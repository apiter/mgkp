define("libs/min/domparserinone.min.js", function(require, module, exports) {
    var entityMap = {
            lt: "<",
            gt: ">",
            amp: "&",
            quot: '"',
            apos: "'",
            Agrave: "À",
            Aacute: "Á",
            Acirc: "Â",
            Atilde: "Ã",
            Auml: "Ä",
            Aring: "Å",
            AElig: "Æ",
            Ccedil: "Ç",
            Egrave: "È",
            Eacute: "É",
            Ecirc: "Ê",
            Euml: "Ë",
            Igrave: "Ì",
            Iacute: "Í",
            Icirc: "Î",
            Iuml: "Ï",
            ETH: "Ð",
            Ntilde: "Ñ",
            Ograve: "Ò",
            Oacute: "Ó",
            Ocirc: "Ô",
            Otilde: "Õ",
            Ouml: "Ö",
            Oslash: "Ø",
            Ugrave: "Ù",
            Uacute: "Ú",
            Ucirc: "Û",
            Uuml: "Ü",
            Yacute: "Ý",
            THORN: "Þ",
            szlig: "ß",
            agrave: "à",
            aacute: "á",
            acirc: "â",
            atilde: "ã",
            auml: "ä",
            aring: "å",
            aelig: "æ",
            ccedil: "ç",
            egrave: "è",
            eacute: "é",
            ecirc: "ê",
            euml: "ë",
            igrave: "ì",
            iacute: "í",
            icirc: "î",
            iuml: "ï",
            eth: "ð",
            ntilde: "ñ",
            ograve: "ò",
            oacute: "ó",
            ocirc: "ô",
            otilde: "õ",
            ouml: "ö",
            oslash: "ø",
            ugrave: "ù",
            uacute: "ú",
            ucirc: "û",
            uuml: "ü",
            yacute: "ý",
            thorn: "þ",
            yuml: "ÿ",
            nbsp: " ",
            iexcl: "¡",
            cent: "¢",
            pound: "£",
            curren: "¤",
            yen: "¥",
            brvbar: "¦",
            sect: "§",
            uml: "¨",
            copy: "©",
            ordf: "ª",
            laquo: "«",
            not: "¬",
            shy: "­­",
            reg: "®",
            macr: "¯",
            deg: "°",
            plusmn: "±",
            sup2: "²",
            sup3: "³",
            acute: "´",
            micro: "µ",
            para: "¶",
            middot: "·",
            cedil: "¸",
            sup1: "¹",
            ordm: "º",
            raquo: "»",
            frac14: "¼",
            frac12: "½",
            frac34: "¾",
            iquest: "¿",
            times: "×",
            divide: "÷",
            forall: "∀",
            part: "∂",
            exist: "∃",
            empty: "∅",
            nabla: "∇",
            isin: "∈",
            notin: "∉",
            ni: "∋",
            prod: "∏",
            sum: "∑",
            minus: "−",
            lowast: "∗",
            radic: "√",
            prop: "∝",
            infin: "∞",
            ang: "∠",
            and: "∧",
            or: "∨",
            cap: "∩",
            cup: "∪",
            int: "∫",
            there4: "∴",
            sim: "∼",
            cong: "≅",
            asymp: "≈",
            ne: "≠",
            equiv: "≡",
            le: "≤",
            ge: "≥",
            sub: "⊂",
            sup: "⊃",
            nsub: "⊄",
            sube: "⊆",
            supe: "⊇",
            oplus: "⊕",
            otimes: "⊗",
            perp: "⊥",
            sdot: "⋅",
            Alpha: "Α",
            Beta: "Β",
            Gamma: "Γ",
            Delta: "Δ",
            Epsilon: "Ε",
            Zeta: "Ζ",
            Eta: "Η",
            Theta: "Θ",
            Iota: "Ι",
            Kappa: "Κ",
            Lambda: "Λ",
            Mu: "Μ",
            Nu: "Ν",
            Xi: "Ξ",
            Omicron: "Ο",
            Pi: "Π",
            Rho: "Ρ",
            Sigma: "Σ",
            Tau: "Τ",
            Upsilon: "Υ",
            Phi: "Φ",
            Chi: "Χ",
            Psi: "Ψ",
            Omega: "Ω",
            alpha: "α",
            beta: "β",
            gamma: "γ",
            delta: "δ",
            epsilon: "ε",
            zeta: "ζ",
            eta: "η",
            theta: "θ",
            iota: "ι",
            kappa: "κ",
            lambda: "λ",
            mu: "μ",
            nu: "ν",
            xi: "ξ",
            omicron: "ο",
            pi: "π",
            rho: "ρ",
            sigmaf: "ς",
            sigma: "σ",
            tau: "τ",
            upsilon: "υ",
            phi: "φ",
            chi: "χ",
            psi: "ψ",
            omega: "ω",
            thetasym: "ϑ",
            upsih: "ϒ",
            piv: "ϖ",
            OElig: "Œ",
            oelig: "œ",
            Scaron: "Š",
            scaron: "š",
            Yuml: "Ÿ",
            fnof: "ƒ",
            circ: "ˆ",
            tilde: "˜",
            ensp: " ",
            emsp: " ",
            thinsp: " ",
            zwnj: "‌",
            zwj: "‍",
            lrm: "‎",
            rlm: "‏",
            ndash: "–",
            mdash: "—",
            lsquo: "‘",
            rsquo: "’",
            sbquo: "‚",
            ldquo: "“",
            rdquo: "”",
            bdquo: "„",
            dagger: "†",
            Dagger: "‡",
            bull: "•",
            hellip: "…",
            permil: "‰",
            prime: "′",
            Prime: "″",
            lsaquo: "‹",
            rsaquo: "›",
            oline: "‾",
            euro: "€",
            trade: "™",
            larr: "←",
            uarr: "↑",
            rarr: "→",
            darr: "↓",
            harr: "↔",
            crarr: "↵",
            lceil: "⌈",
            rceil: "⌉",
            lfloor: "⌊",
            rfloor: "⌋",
            loz: "◊",
            spades: "♠",
            clubs: "♣",
            hearts: "♥",
            diams: "♦"
        },
        nameStartChar = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/,
        nameChar = new RegExp("[\\-\\.0-9" + nameStartChar.source.slice(1, -1) + "\\u00B7\\u0300-\\u036F\\u203F-\\u2040]"),
        tagNamePattern = new RegExp("^" + nameStartChar.source + nameChar.source + "*(?::" + nameStartChar.source + nameChar.source + "*)?$"),
        S_TAG = 0,
        S_ATTR = 1,
        S_ATTR_SPACE = 2,
        S_EQ = 3,
        S_ATTR_NOQUOT_VALUE = 4,
        S_ATTR_END = 5,
        S_TAG_SPACE = 6,
        S_TAG_CLOSE = 7,
        SaxO = {};

    function XMLReader() {}

    function parse(e, n, r, i, o) {
        function entityReplacer(e) {
            var n = e.slice(1, -1);
            return n in r ? r[n] : "#" === n.charAt(0) ? function(e) {
                if (e > 65535) {
                    var n = 55296 + ((e -= 65536) >> 10),
                        r = 56320 + (1023 & e);
                    return String.fromCharCode(n, r)
                }
                return String.fromCharCode(e)
            }(parseInt(n.substr(1).replace("x", "0x"))) : (o.error("entity not found:" + e), e)
        }

        function appendText(n) {
            if (n > p) {
                var r = e.substring(p, n).replace(/&#?\w+;/g, entityReplacer);
                u && position(p), i.characters(r, 0, n - p), p = n
            }
        }

        function position(n, r) {
            for (; n >= s && (r = c.exec(e));) a = r.index, s = a + r[0].length, u.lineNumber++;
            u.columnNumber = n - a + 1
        }
        for (var a = 0, s = 0, c = /.*(?:\r\n?|\n)|.*$/g, u = i.locator, l = [{
                currentNSMap: n
            }], d = {}, p = 0;;) {
            try {
                var m = e.indexOf("<", p);
                if (m < 0) {
                    if (!e.substr(p).match(/^\s*$/)) {
                        var N = i.doc,
                            E = N.createTextNode(e.substr(p));
                        N.appendChild(E), i.currentElement = E
                    }
                    return
                }
                switch (m > p && appendText(m), e.charAt(m + 1)) {
                    case "/":
                        var h = e.indexOf(">", m + 3),
                            f = e.substring(m + 2, h),
                            _ = l.pop();
                        h < 0 ? (f = e.substring(m + 2).replace(/[\s<].*/, ""), o.error("end tag name: " + f + " is not complete:" + _.tagName), h = m + 1 + f.length) : f.match(/\s</) && (f = f.replace(/[\s<].*/, ""), o.error("end tag name: " + f + " maybe not complete"), h = m + 1 + f.length);
                        var T = _.localNSMap,
                            g = _.tagName == f;
                        if (g || _.tagName && _.tagName.toLowerCase() == f.toLowerCase()) {
                            if (i.endElement(_.uri, _.localName, f), T)
                                for (var D in T) i.endPrefixMapping(D);
                            g || o.fatalError("end tag name: " + f + " is not match the current start tagName:" + _.tagName)
                        } else l.push(_);
                        h++;
                        break;
                    case "?":
                        u && position(m), h = parseInstruction(e, m, i);
                        break;
                    case "!":
                        u && position(m), h = parseDCC(e, m, i, o);
                        break;
                    default:
                        u && position(m);
                        var S = new ElementAttributes,
                            A = l[l.length - 1].currentNSMap,
                            v = (h = parseElementStartPart(e, m, S, A, entityReplacer, o), S.length);
                        if (!S.closed && fixSelfClosed(e, h, S.tagName, d) && (S.closed = !0, r.nbsp || o.warning("unclosed xml attribute")), u && v) {
                            for (var C = copyLocator(u, {}), O = 0; O < v; O++) {
                                var x = S[O];
                                position(x.offset), x.locator = copyLocator(u, {})
                            }
                            i.locator = C, SaxO.appendElement(S, i, A) && l.push(S), i.locator = u
                        } else SaxO.appendElement(S, i, A) && l.push(S);
                        "http://www.w3.org/1999/xhtml" !== S.uri || S.closed ? h++ : h = parseHtmlSpecialContent(e, h, S.tagName, entityReplacer, i)
                }
            } catch (e) {
                o.error("element parse error: " + e), h = -1
            }
            h > p ? p = h : appendText(Math.max(m, p) + 1)
        }
    }

    function copyLocator(e, n) {
        return n.lineNumber = e.lineNumber, n.columnNumber = e.columnNumber, n
    }

    function parseElementStartPart(e, n, r, i, o, a) {
        for (var s, c = ++n, u = S_TAG;;) {
            var l = e.charAt(c);
            switch (l) {
                case "=":
                    if (u === S_ATTR) s = e.slice(n, c), u = S_EQ;
                    else {
                        if (u !== S_ATTR_SPACE) throw new Error("attribute equal must after attrName");
                        u = S_EQ
                    }
                    break;
                case "'":
                case '"':
                    if (u === S_EQ || u === S_ATTR) {
                        if (u === S_ATTR && (a.warning('attribute value must after "="'), s = e.slice(n, c)), n = c + 1, !((c = e.indexOf(l, n)) > 0)) throw new Error("attribute value no end '" + l + "' match");
                        d = e.slice(n, c).replace(/&#?\w+;/g, o), r.add(s, d, n - 1), u = S_ATTR_END
                    } else {
                        if (u != S_ATTR_NOQUOT_VALUE) throw new Error('attribute value must after "="');
                        d = e.slice(n, c).replace(/&#?\w+;/g, o), r.add(s, d, n), a.warning('attribute "' + s + '" missed start quot(' + l + ")!!"), n = c + 1, u = S_ATTR_END
                    }
                    break;
                case "/":
                    switch (u) {
                        case S_TAG:
                            r.setTagName(e.slice(n, c));
                        case S_ATTR_END:
                        case S_TAG_SPACE:
                        case S_TAG_CLOSE:
                            u = S_TAG_CLOSE, r.closed = !0;
                        case S_ATTR_NOQUOT_VALUE:
                        case S_ATTR:
                        case S_ATTR_SPACE:
                            break;
                        default:
                            throw new Error("attribute invalid close char('/')")
                    }
                    break;
                case "":
                    return a.error("unexpected end of input"), u == S_TAG && r.setTagName(e.slice(n, c)), c;
                case ">":
                    switch (u) {
                        case S_TAG:
                            r.setTagName(e.slice(n, c));
                        case S_ATTR_END:
                        case S_TAG_SPACE:
                        case S_TAG_CLOSE:
                            break;
                        case S_ATTR_NOQUOT_VALUE:
                        case S_ATTR:
                            "/" === (d = e.slice(n, c)).slice(-1) && (r.closed = !0, d = d.slice(0, -1));
                        case S_ATTR_SPACE:
                            u === S_ATTR_SPACE && (d = s), u == S_ATTR_NOQUOT_VALUE ? (a.warning('attribute "' + d + '" missed quot(")!!'), r.add(s, d.replace(/&#?\w+;/g, o), n)) : ("http://www.w3.org/1999/xhtml" === i[""] && d.match(/^(?:disabled|checked|selected)$/i) || a.warning('attribute "' + d + '" missed value!! "' + d + '" instead!!'), r.add(d, d, n));
                            break;
                        case S_EQ:
                            throw new Error("attribute value missed!!")
                    }
                    return c;
                case "":
                    l = " ";
                default:
                    if (l <= " ") switch (u) {
                        case S_TAG:
                            r.setTagName(e.slice(n, c)), u = S_TAG_SPACE;
                            break;
                        case S_ATTR:
                            s = e.slice(n, c), u = S_ATTR_SPACE;
                            break;
                        case S_ATTR_NOQUOT_VALUE:
                            var d = e.slice(n, c).replace(/&#?\w+;/g, o);
                            a.warning('attribute "' + d + '" missed quot(")!!'), r.add(s, d, n);
                        case S_ATTR_END:
                            u = S_TAG_SPACE
                    } else switch (u) {
                        case S_ATTR_SPACE:
                            r.tagName;
                            "http://www.w3.org/1999/xhtml" === i[""] && s.match(/^(?:disabled|checked|selected)$/i) || a.warning('attribute "' + s + '" missed value!! "' + s + '" instead2!!'), r.add(s, s, n), n = c, u = S_ATTR;
                            break;
                        case S_ATTR_END:
                            a.warning('attribute space is required"' + s + '"!!');
                        case S_TAG_SPACE:
                            u = S_ATTR, n = c;
                            break;
                        case S_EQ:
                            u = S_ATTR_NOQUOT_VALUE, n = c;
                            break;
                        case S_TAG_CLOSE:
                            throw new Error("elements closed character '/' and '>' must be connected to")
                    }
            }
            c++
        }
    }

    function parseHtmlSpecialContent(e, n, r, i, o) {
        if (/^(?:script|textarea)$/i.test(r)) {
            var a = e.indexOf("</" + r + ">", n),
                s = e.substring(n + 1, a);
            if (/[&<]/.test(s)) return /^script$/i.test(r) ? (o.characters(s, 0, s.length), a) : (s = s.replace(/&#?\w+;/g, i), o.characters(s, 0, s.length), a)
        }
        return n + 1
    }

    function fixSelfClosed(e, n, r, i) {
        var o = i[r];
        return null == o && ((o = e.lastIndexOf("</" + r + ">")) < n && (o = e.lastIndexOf("</" + r)), i[r] = o), o < n
    }

    function _copy(e, n) {
        for (var r in e) n[r] = e[r]
    }

    function parseDCC(e, n, r, i) {
        if ("-" === e.charAt(n + 2)) return "-" === e.charAt(n + 3) ? (o = e.indexOf("--\x3e", n + 4)) > n ? (r.comment(e, n + 4, o - n - 4), o + 3) : (i.error("Unclosed comment"), -1) : -1;
        if ("CDATA[" == e.substr(n + 3, 6)) {
            var o = e.indexOf("]]>", n + 9);
            return r.startCDATA(), r.characters(e, n + 9, o - n - 9), r.endCDATA(), o + 3
        }
        var a = split(e, n),
            s = a.length;
        if (s > 1 && /!doctype/i.test(a[0][0])) {
            var c = a[1][0],
                u = s > 3 && /^public$/i.test(a[2][0]) && a[3][0],
                l = s > 4 && a[4][0],
                d = a[s - 1];
            return r.startDTD(c, u && u.replace(/^(['"])(.*?)\1$/, "$2"), l && l.replace(/^(['"])(.*?)\1$/, "$2")), r.endDTD(), d.index + d[0].length
        }
        return -1
    }

    function parseInstruction(e, n, r) {
        var i = e.indexOf("?>", n);
        if (i) {
            var o = e.substring(n, i).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);
            if (o) {
                o[0].length;
                return r.processingInstruction(o[1], o[2]), i + 2
            }
            return -1
        }
        return -1
    }

    function ElementAttributes(e) {}

    function split(e, n) {
        var r, i = [],
            o = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;
        for (o.lastIndex = n, o.exec(e); r = o.exec(e);)
            if (i.push(r), r[1]) return i
    }

    function copy(e, n) {
        for (var r in e) n[r] = e[r]
    }

    function _extends(e, n) {
        var r = e.prototype;
        if (!(r instanceof n)) {
            function t() {}
            t.prototype = n.prototype, copy(r, t = new t), e.prototype = r = t
        }
        r.constructor != e && ("function" != typeof e && console.error("unknow Class:" + e), r.constructor = e)
    }
    XMLReader.prototype = {
        parse: function(e, n, r) {
            var i = this.domBuilder;
            i.startDocument(), _copy(n, n = {}), parse(e, n, r, i, this.errorHandler), i.endDocument()
        }
    }, SaxO.appendElement = function(e, n, r) {
        for (var i = e.tagName, o = null, a = e.length; a--;) {
            var s = e[a],
                c = s.qName,
                u = s.value;
            if ((m = c.indexOf(":")) > 0) var l = s.prefix = c.slice(0, m),
                d = c.slice(m + 1),
                p = "xmlns" === l && d;
            else d = c, l = null, p = "xmlns" === c && "";
            s.localName = d, !1 !== p && (null == o && (o = {}, _copy(r, r = {})), r[p] = o[p] = u, s.uri = "http://www.w3.org/2000/xmlns/", n.startPrefixMapping(p, u))
        }
        for (a = e.length; a--;) {
            (l = (s = e[a]).prefix) && ("xml" === l && (s.uri = "http://www.w3.org/XML/1998/namespace"), "xmlns" !== l && (s.uri = r[l || ""]))
        }
        var m;
        (m = i.indexOf(":")) > 0 ? (l = e.prefix = i.slice(0, m), d = e.localName = i.slice(m + 1)) : (l = null, d = e.localName = i);
        var N = e.uri = r[l || ""];
        if (n.startElement(N, d, i, e), !e.closed) return e.currentNSMap = r, e.localNSMap = o, !0;
        if (n.endElement(N, d, i), o)
            for (l in o) n.endPrefixMapping(l)
    }, ElementAttributes.prototype = {
        setTagName: function(e) {
            if (!tagNamePattern.test(e)) throw new Error("invalid tagName:" + e);
            this.tagName = e
        },
        add: function(e, n, r) {
            if (!tagNamePattern.test(e)) throw new Error("invalid attribute:" + e);
            this[this.length++] = {
                qName: e,
                value: n,
                offset: r
            }
        },
        length: 0,
        getLocalName: function(e) {
            return this[e].localName
        },
        getLocator: function(e) {
            return this[e].locator
        },
        getQName: function(e) {
            return this[e].qName
        },
        getURI: function(e) {
            return this[e].uri
        },
        getValue: function(e) {
            return this[e].value
        }
    };
    var htmlns = "http://www.w3.org/1999/xhtml",
        NodeType = {},
        ELEMENT_NODE = NodeType.ELEMENT_NODE = 1,
        ATTRIBUTE_NODE = NodeType.ATTRIBUTE_NODE = 2,
        TEXT_NODE = NodeType.TEXT_NODE = 3,
        CDATA_SECTION_NODE = NodeType.CDATA_SECTION_NODE = 4,
        ENTITY_REFERENCE_NODE = NodeType.ENTITY_REFERENCE_NODE = 5,
        ENTITY_NODE = NodeType.ENTITY_NODE = 6,
        PROCESSING_INSTRUCTION_NODE = NodeType.PROCESSING_INSTRUCTION_NODE = 7,
        COMMENT_NODE = NodeType.COMMENT_NODE = 8,
        DOCUMENT_NODE = NodeType.DOCUMENT_NODE = 9,
        DOCUMENT_TYPE_NODE = NodeType.DOCUMENT_TYPE_NODE = 10,
        DOCUMENT_FRAGMENT_NODE = NodeType.DOCUMENT_FRAGMENT_NODE = 11,
        NOTATION_NODE = NodeType.NOTATION_NODE = 12,
        ExceptionCode = {},
        ExceptionMessage = {},
        INDEX_SIZE_ERR = ExceptionCode.INDEX_SIZE_ERR = (ExceptionMessage[1] = "Index size error", 1),
        DOMSTRING_SIZE_ERR = ExceptionCode.DOMSTRING_SIZE_ERR = (ExceptionMessage[2] = "DOMString size error", 2),
        HIERARCHY_REQUEST_ERR = ExceptionCode.HIERARCHY_REQUEST_ERR = (ExceptionMessage[3] = "Hierarchy request error", 3),
        WRONG_DOCUMENT_ERR = ExceptionCode.WRONG_DOCUMENT_ERR = (ExceptionMessage[4] = "Wrong document", 4),
        INVALID_CHARACTER_ERR = ExceptionCode.INVALID_CHARACTER_ERR = (ExceptionMessage[5] = "Invalid character", 5),
        NO_DATA_ALLOWED_ERR = ExceptionCode.NO_DATA_ALLOWED_ERR = (ExceptionMessage[6] = "No data allowed", 6),
        NO_MODIFICATION_ALLOWED_ERR = ExceptionCode.NO_MODIFICATION_ALLOWED_ERR = (ExceptionMessage[7] = "No modification allowed", 7),
        NOT_FOUND_ERR = ExceptionCode.NOT_FOUND_ERR = (ExceptionMessage[8] = "Not found", 8),
        NOT_SUPPORTED_ERR = ExceptionCode.NOT_SUPPORTED_ERR = (ExceptionMessage[9] = "Not supported", 9),
        INUSE_ATTRIBUTE_ERR = ExceptionCode.INUSE_ATTRIBUTE_ERR = (ExceptionMessage[10] = "Attribute in use", 10),
        INVALID_STATE_ERR = ExceptionCode.INVALID_STATE_ERR = (ExceptionMessage[11] = "Invalid state", 11),
        SYNTAX_ERR = ExceptionCode.SYNTAX_ERR = (ExceptionMessage[12] = "Syntax error", 12),
        INVALID_MODIFICATION_ERR = ExceptionCode.INVALID_MODIFICATION_ERR = (ExceptionMessage[13] = "Invalid modification", 13),
        NAMESPACE_ERR = ExceptionCode.NAMESPACE_ERR = (ExceptionMessage[14] = "Invalid namespace", 14),
        INVALID_ACCESS_ERR = ExceptionCode.INVALID_ACCESS_ERR = (ExceptionMessage[15] = "Invalid access", 15);

    function DOMException(e, n) {
        if (n instanceof Error) var r = n;
        else r = this, Error.call(this, ExceptionMessage[e]), this.message = ExceptionMessage[e], Error.captureStackTrace && Error.captureStackTrace(this, DOMException);
        return r.code = e, n && (this.message = this.message + ": " + n), r
    }

    function NodeList() {}

    function LiveNodeList(e, n) {
        this._node = e, this._refresh = n, _updateLiveList(this)
    }

    function _updateLiveList(e) {
        var n = e._node._inc || e._node.ownerDocument._inc;
        if (e._inc != n) {
            var r = e._refresh(e._node);
            __set__(e, "length", r.length), copy(r, e), e._inc = n
        }
    }

    function NamedNodeMap() {}

    function _findNodeIndex(e, n) {
        for (var r = e.length; r--;)
            if (e[r] === n) return r
    }

    function _addNamedNode(e, n, r, i) {
        if (i ? n[_findNodeIndex(n, i)] = r : n[n.length++] = r, e) {
            r.ownerElement = e;
            var o = e.ownerDocument;
            o && (i && _onRemoveAttribute(o, e, i), _onAddAttribute(o, e, r))
        }
    }

    function _removeNamedNode(e, n, r) {
        var i = _findNodeIndex(n, r);
        if (!(i >= 0)) throw DOMException(NOT_FOUND_ERR, new Error(e.tagName + "@" + r));
        for (var o = n.length - 1; i < o;) n[i] = n[++i];
        if (n.length = o, e) {
            var a = e.ownerDocument;
            a && (_onRemoveAttribute(a, e, r), r.ownerElement = null)
        }
    }

    function DOMImplementation(e) {
        if (this._features = {}, e)
            for (var n in e) this._features = e[n]
    }

    function Node() {}

    function _xmlEncoder(e) {
        return ("<" == e ? "&lt;" : ">" == e && "&gt;") || "&" == e && "&amp;" || '"' == e && "&quot;" || "&#" + e.charCodeAt() + ";"
    }

    function _visitNode(e, n) {
        if (n(e)) return !0;
        if (e = e.firstChild)
            do {
                if (_visitNode(e, n)) return !0
            } while (e = e.nextSibling)
    }

    function Document() {}

    function _onAddAttribute(e, n, r) {
        e && e._inc++, "http://www.w3.org/2000/xmlns/" == r.namespaceURI && (n._nsMap[r.prefix ? r.localName : ""] = r.value)
    }

    function _onRemoveAttribute(e, n, r, i) {
        e && e._inc++, "http://www.w3.org/2000/xmlns/" == r.namespaceURI && delete n._nsMap[r.prefix ? r.localName : ""]
    }

    function _onUpdateChild(e, n, r) {
        if (e && e._inc) {
            e._inc++;
            var i = n.childNodes;
            if (r) i[i.length++] = r;
            else {
                for (var o = n.firstChild, a = 0; o;) i[a++] = o, o = o.nextSibling;
                i.length = a
            }
        }
    }

    function _removeChild(e, n) {
        var r = n.previousSibling,
            i = n.nextSibling;
        return r ? r.nextSibling = i : e.firstChild = i, i ? i.previousSibling = r : e.lastChild = r, _onUpdateChild(e.ownerDocument, e), n
    }

    function _insertBefore(e, n, r) {
        var i = n.parentNode;
        if (i && i.removeChild(n), n.nodeType === DOCUMENT_FRAGMENT_NODE) {
            var o = n.firstChild;
            if (null == o) return n;
            var a = n.lastChild
        } else o = a = n;
        var s = r ? r.previousSibling : e.lastChild;
        o.previousSibling = s, a.nextSibling = r, s ? s.nextSibling = o : e.firstChild = o, null == r ? e.lastChild = a : r.previousSibling = a;
        do {
            o.parentNode = e
        } while (o !== a && (o = o.nextSibling));
        return _onUpdateChild(e.ownerDocument || e, e), n.nodeType == DOCUMENT_FRAGMENT_NODE && (n.firstChild = n.lastChild = null), n
    }

    function _appendSingleChild(e, n) {
        var r = n.parentNode;
        if (r) {
            var i = e.lastChild;
            r.removeChild(n);
            i = e.lastChild
        }
        i = e.lastChild;
        return n.parentNode = e, n.previousSibling = i, n.nextSibling = null, i ? i.nextSibling = n : e.firstChild = n, e.lastChild = n, _onUpdateChild(e.ownerDocument, e, n), n
    }

    function Element() {
        this._nsMap = {}
    }

    function Attr() {}

    function CharacterData() {}

    function Text() {}

    function Comment() {}

    function CDATASection() {}

    function DocumentType() {}

    function Notation() {}

    function Entity() {}

    function EntityReference() {}

    function DocumentFragment() {}

    function ProcessingInstruction() {}

    function XMLSerializer() {}

    function nodeSerializeToString(e, n) {
        var r = [],
            i = 9 == this.nodeType && this.documentElement || this,
            o = i.prefix,
            a = i.namespaceURI;
        if (a && null == o && null == (o = i.lookupPrefix(a))) var s = [{
            namespace: a,
            prefix: null
        }];
        return serializeToString(this, r, e, n, s), r.join("")
    }

    function needNamespaceDefine(e, n, r) {
        var i = e.prefix || "",
            o = e.namespaceURI;
        if (!i && !o) return !1;
        if ("xml" === i && "http://www.w3.org/XML/1998/namespace" === o || "http://www.w3.org/2000/xmlns/" == o) return !1;
        for (var a = r.length; a--;) {
            var s = r[a];
            if (s.prefix == i) return s.namespace != o
        }
        return !0
    }

    function serializeToString(e, n, r, i, o) {
        if (i) {
            if (!(e = i(e))) return;
            if ("string" == typeof e) return void n.push(e)
        }
        switch (e.nodeType) {
            case ELEMENT_NODE:
                o || (o = []);
                o.length;
                var a = e.attributes,
                    s = a.length,
                    c = e.firstChild,
                    u = e.tagName;
                r = htmlns === e.namespaceURI || r, n.push("<", u);
                for (var l = 0; l < s; l++) {
                    "xmlns" == (d = a.item(l)).prefix ? o.push({
                        prefix: d.localName,
                        namespace: d.value
                    }) : "xmlns" == d.nodeName && o.push({
                        prefix: "",
                        namespace: d.value
                    })
                }
                for (l = 0; l < s; l++) {
                    var d;
                    if (needNamespaceDefine(d = a.item(l), r, o)) {
                        var p = d.prefix || "",
                            m = d.namespaceURI,
                            N = p ? " xmlns:" + p : " xmlns";
                        n.push(N, '="', m, '"'), o.push({
                            prefix: p,
                            namespace: m
                        })
                    }
                    serializeToString(d, n, r, i, o)
                }
                if (needNamespaceDefine(e, r, o)) {
                    p = e.prefix || "", m = e.namespaceURI, N = p ? " xmlns:" + p : " xmlns";
                    n.push(N, '="', m, '"'), o.push({
                        prefix: p,
                        namespace: m
                    })
                }
                if (c || r && !/^(?:meta|link|img|br|hr|input)$/i.test(u)) {
                    if (n.push(">"), r && /^script$/i.test(u))
                        for (; c;) c.data ? n.push(c.data) : serializeToString(c, n, r, i, o), c = c.nextSibling;
                    else
                        for (; c;) serializeToString(c, n, r, i, o), c = c.nextSibling;
                    n.push("</", u, ">")
                } else n.push("/>");
                return;
            case DOCUMENT_NODE:
            case DOCUMENT_FRAGMENT_NODE:
                for (c = e.firstChild; c;) serializeToString(c, n, r, i, o), c = c.nextSibling;
                return;
            case ATTRIBUTE_NODE:
                return n.push(" ", e.name, '="', e.value.replace(/[<&"]/g, _xmlEncoder), '"');
            case TEXT_NODE:
                return n.push(e.data.replace(/[<&]/g, _xmlEncoder));
            case CDATA_SECTION_NODE:
                return n.push("<![CDATA[", e.data, "]]>");
            case COMMENT_NODE:
                return n.push("\x3c!--", e.data, "--\x3e");
            case DOCUMENT_TYPE_NODE:
                var E = e.publicId,
                    h = e.systemId;
                if (n.push("<!DOCTYPE ", e.name), E) n.push(' PUBLIC "', E), h && "." != h && n.push('" "', h), n.push('">');
                else if (h && "." != h) n.push(' SYSTEM "', h, '">');
                else {
                    var f = e.internalSubset;
                    f && n.push(" [", f, "]"), n.push(">")
                }
                return;
            case PROCESSING_INSTRUCTION_NODE:
                return n.push("<?", e.target, " ", e.data, "?>");
            case ENTITY_REFERENCE_NODE:
                return n.push("&", e.nodeName, ";");
            default:
                n.push("??", e.nodeName)
        }
    }

    function importNode(e, n, r) {
        var i;
        switch (n.nodeType) {
            case ELEMENT_NODE:
                (i = n.cloneNode(!1)).ownerDocument = e;
            case DOCUMENT_FRAGMENT_NODE:
                break;
            case ATTRIBUTE_NODE:
                r = !0
        }
        if (i || (i = n.cloneNode(!1)), i.ownerDocument = e, i.parentNode = null, r)
            for (var o = n.firstChild; o;) i.appendChild(importNode(e, o, r)), o = o.nextSibling;
        return i
    }

    function cloneNode(e, n, r) {
        var i = new n.constructor;
        for (var o in n) {
            var a = n[o];
            "object" != typeof a && a != i[o] && (i[o] = a)
        }
        switch (n.childNodes && (i.childNodes = new NodeList), i.ownerDocument = e, i.nodeType) {
            case ELEMENT_NODE:
                var s = n.attributes,
                    c = i.attributes = new NamedNodeMap,
                    u = s.length;
                c._ownerElement = i;
                for (var l = 0; l < u; l++) i.setAttributeNode(cloneNode(e, s.item(l), !0));
                break;
            case ATTRIBUTE_NODE:
                r = !0
        }
        if (r)
            for (var d = n.firstChild; d;) i.appendChild(cloneNode(e, d, r)), d = d.nextSibling;
        return i
    }

    function __set__(e, n, r) {
        e[n] = r
    }
    DOMException.prototype = Error.prototype, copy(ExceptionCode, DOMException), NodeList.prototype = {
        length: 0,
        item: function(e) {
            return this[e] || null
        },
        toString: function(e, n) {
            for (var r = [], i = 0; i < this.length; i++) serializeToString(this[i], r, e, n);
            return r.join("")
        }
    }, LiveNodeList.prototype.item = function(e) {
        return _updateLiveList(this), this[e]
    }, _extends(LiveNodeList, NodeList), NamedNodeMap.prototype = {
        length: 0,
        item: NodeList.prototype.item,
        getNamedItem: function(e) {
            for (var n = this.length; n--;) {
                var r = this[n];
                if (r.nodeName == e) return r
            }
        },
        setNamedItem: function(e) {
            var n = e.ownerElement;
            if (n && n != this._ownerElement) throw new DOMException(INUSE_ATTRIBUTE_ERR);
            var r = this.getNamedItem(e.nodeName);
            return _addNamedNode(this._ownerElement, this, e, r), r
        },
        setNamedItemNS: function(e) {
            var n, r = e.ownerElement;
            if (r && r != this._ownerElement) throw new DOMException(INUSE_ATTRIBUTE_ERR);
            return n = this.getNamedItemNS(e.namespaceURI, e.localName), _addNamedNode(this._ownerElement, this, e, n), n
        },
        removeNamedItem: function(e) {
            var n = this.getNamedItem(e);
            return _removeNamedNode(this._ownerElement, this, n), n
        },
        removeNamedItemNS: function(e, n) {
            var r = this.getNamedItemNS(e, n);
            return _removeNamedNode(this._ownerElement, this, r), r
        },
        getNamedItemNS: function(e, n) {
            for (var r = this.length; r--;) {
                var i = this[r];
                if (i.localName == n && i.namespaceURI == e) return i
            }
            return null
        }
    }, DOMImplementation.prototype = {
        hasFeature: function(e, n) {
            var r = this._features[e.toLowerCase()];
            return !(!r || n && !(n in r))
        },
        createDocument: function(e, n, r) {
            var i = new Document;
            if (i.implementation = this, i.childNodes = new NodeList, i.doctype = r, r && i.appendChild(r), n) {
                var o = i.createElementNS(e, n);
                i.appendChild(o)
            }
            return i
        },
        createDocumentType: function(e, n, r) {
            var i = new DocumentType;
            return i.name = e, i.nodeName = e, i.publicId = n, i.systemId = r, i
        }
    }, Node.prototype = {
        firstChild: null,
        lastChild: null,
        previousSibling: null,
        nextSibling: null,
        attributes: null,
        parentNode: null,
        childNodes: null,
        ownerDocument: null,
        nodeValue: null,
        namespaceURI: null,
        prefix: null,
        localName: null,
        insertBefore: function(e, n) {
            return _insertBefore(this, e, n)
        },
        replaceChild: function(e, n) {
            this.insertBefore(e, n), n && this.removeChild(n)
        },
        removeChild: function(e) {
            return _removeChild(this, e)
        },
        appendChild: function(e) {
            return this.insertBefore(e, null)
        },
        hasChildNodes: function() {
            return null != this.firstChild
        },
        cloneNode: function(e) {
            return cloneNode(this.ownerDocument || this, this, e)
        },
        normalize: function() {
            for (var e = this.firstChild; e;) {
                var n = e.nextSibling;
                n && n.nodeType == TEXT_NODE && e.nodeType == TEXT_NODE ? (this.removeChild(n), e.appendData(n.data)) : (e.normalize(), e = n)
            }
        },
        isSupported: function(e, n) {
            return this.ownerDocument.implementation.hasFeature(e, n)
        },
        hasAttributes: function() {
            return this.attributes.length > 0
        },
        lookupPrefix: function(e) {
            for (var n = this; n;) {
                var r = n._nsMap;
                if (r)
                    for (var i in r)
                        if (r[i] == e) return i;
                n = n.nodeType == ATTRIBUTE_NODE ? n.ownerDocument : n.parentNode
            }
            return null
        },
        lookupNamespaceURI: function(e) {
            for (var n = this; n;) {
                var r = n._nsMap;
                if (r && e in r) return r[e];
                n = n.nodeType == ATTRIBUTE_NODE ? n.ownerDocument : n.parentNode
            }
            return null
        },
        isDefaultNamespace: function(e) {
            return null == this.lookupPrefix(e)
        }
    }, copy(NodeType, Node), copy(NodeType, Node.prototype), Document.prototype = {
        nodeName: "#document",
        nodeType: DOCUMENT_NODE,
        doctype: null,
        documentElement: null,
        _inc: 1,
        insertBefore: function(e, n) {
            if (e.nodeType == DOCUMENT_FRAGMENT_NODE) {
                for (var r = e.firstChild; r;) {
                    var i = r.nextSibling;
                    this.insertBefore(r, n), r = i
                }
                return e
            }
            return null == this.documentElement && e.nodeType == ELEMENT_NODE && (this.documentElement = e), _insertBefore(this, e, n), e.ownerDocument = this, e
        },
        removeChild: function(e) {
            return this.documentElement == e && (this.documentElement = null), _removeChild(this, e)
        },
        importNode: function(e, n) {
            return importNode(this, e, n)
        },
        getElementById: function(e) {
            var n = null;
            return _visitNode(this.documentElement, (function(r) {
                if (r.nodeType == ELEMENT_NODE && r.getAttribute("id") == e) return n = r, !0
            })), n
        },
        createElement: function(e) {
            var n = new Element;
            return n.ownerDocument = this, n.nodeName = e, n.tagName = e, n.childNodes = new NodeList, (n.attributes = new NamedNodeMap)._ownerElement = n, n
        },
        createDocumentFragment: function() {
            var e = new DocumentFragment;
            return e.ownerDocument = this, e.childNodes = new NodeList, e
        },
        createTextNode: function(e) {
            var n = new Text;
            return n.ownerDocument = this, n.appendData(e), n
        },
        createComment: function(e) {
            var n = new Comment;
            return n.ownerDocument = this, n.appendData(e), n
        },
        createCDATASection: function(e) {
            var n = new CDATASection;
            return n.ownerDocument = this, n.appendData(e), n
        },
        createProcessingInstruction: function(e, n) {
            var r = new ProcessingInstruction;
            return r.ownerDocument = this, r.tagName = r.target = e, r.nodeValue = r.data = n, r
        },
        createAttribute: function(e) {
            var n = new Attr;
            return n.ownerDocument = this, n.name = e, n.nodeName = e, n.localName = e, n.specified = !0, n
        },
        createEntityReference: function(e) {
            var n = new EntityReference;
            return n.ownerDocument = this, n.nodeName = e, n
        },
        createElementNS: function(e, n) {
            var r = new Element,
                i = n.split(":"),
                o = r.attributes = new NamedNodeMap;
            return r.childNodes = new NodeList, r.ownerDocument = this, r.nodeName = n, r.tagName = n, r.namespaceURI = e, 2 == i.length ? (r.prefix = i[0], r.localName = i[1]) : r.localName = n, o._ownerElement = r, r
        },
        createAttributeNS: function(e, n) {
            var r = new Attr,
                i = n.split(":");
            return r.ownerDocument = this, r.nodeName = n, r.name = n, r.namespaceURI = e, r.specified = !0, 2 == i.length ? (r.prefix = i[0], r.localName = i[1]) : r.localName = n, r
        }
    }, _extends(Document, Node), Element.prototype = {
        nodeType: ELEMENT_NODE,
        hasAttribute: function(e) {
            return null != this.getAttributeNode(e)
        },
        getAttribute: function(e) {
            var n = this.getAttributeNode(e);
            return n && n.value || ""
        },
        getAttributeNode: function(e) {
            return this.attributes.getNamedItem(e)
        },
        setAttribute: function(e, n) {
            var r = this.ownerDocument.createAttribute(e);
            r.value = r.nodeValue = "" + n, this.setAttributeNode(r)
        },
        removeAttribute: function(e) {
            var n = this.getAttributeNode(e);
            n && this.removeAttributeNode(n)
        },
        appendChild: function(e) {
            return e.nodeType === DOCUMENT_FRAGMENT_NODE ? this.insertBefore(e, null) : _appendSingleChild(this, e)
        },
        setAttributeNode: function(e) {
            return this.attributes.setNamedItem(e)
        },
        setAttributeNodeNS: function(e) {
            return this.attributes.setNamedItemNS(e)
        },
        removeAttributeNode: function(e) {
            return this.attributes.removeNamedItem(e.nodeName)
        },
        removeAttributeNS: function(e, n) {
            var r = this.getAttributeNodeNS(e, n);
            r && this.removeAttributeNode(r)
        },
        hasAttributeNS: function(e, n) {
            return null != this.getAttributeNodeNS(e, n)
        },
        getAttributeNS: function(e, n) {
            var r = this.getAttributeNodeNS(e, n);
            return r && r.value || ""
        },
        setAttributeNS: function(e, n, r) {
            var i = this.ownerDocument.createAttributeNS(e, n);
            i.value = i.nodeValue = "" + r, this.setAttributeNode(i)
        },
        getAttributeNodeNS: function(e, n) {
            return this.attributes.getNamedItemNS(e, n)
        },
        getElementsByTagName: function(e) {
            return new LiveNodeList(this, (function(n) {
                var r = [];
                return _visitNode(n, (function(i) {
                    i === n || i.nodeType != ELEMENT_NODE || "*" !== e && i.tagName != e || r.push(i)
                })), r
            }))
        },
        getElementsByTagNameNS: function(e, n) {
            return new LiveNodeList(this, (function(r) {
                var i = [];
                return _visitNode(r, (function(o) {
                    o === r || o.nodeType !== ELEMENT_NODE || "*" !== e && o.namespaceURI !== e || "*" !== n && o.localName != n || i.push(o)
                })), i
            }))
        }
    }, Document.prototype.getElementsByTagName = Element.prototype.getElementsByTagName, Document.prototype.getElementsByTagNameNS = Element.prototype.getElementsByTagNameNS, _extends(Element, Node), Attr.prototype.nodeType = ATTRIBUTE_NODE, _extends(Attr, Node), CharacterData.prototype = {
        data: "",
        substringData: function(e, n) {
            return this.data.substring(e, e + n)
        },
        appendData: function(e) {
            e = this.data + e, this.nodeValue = this.data = e, this.length = e.length
        },
        insertData: function(e, n) {
            this.replaceData(e, 0, n)
        },
        appendChild: function(e) {
            throw new Error(ExceptionMessage[HIERARCHY_REQUEST_ERR])
        },
        deleteData: function(e, n) {
            this.replaceData(e, n, "")
        },
        replaceData: function(e, n, r) {
            r = this.data.substring(0, e) + r + this.data.substring(e + n), this.nodeValue = this.data = r, this.length = r.length
        }
    }, _extends(CharacterData, Node), Text.prototype = {
        nodeName: "#text",
        nodeType: TEXT_NODE,
        splitText: function(e) {
            var n = this.data,
                r = n.substring(e);
            n = n.substring(0, e), this.data = this.nodeValue = n, this.length = n.length;
            var i = this.ownerDocument.createTextNode(r);
            return this.parentNode && this.parentNode.insertBefore(i, this.nextSibling), i
        }
    }, _extends(Text, CharacterData), Comment.prototype = {
        nodeName: "#comment",
        nodeType: COMMENT_NODE
    }, _extends(Comment, CharacterData), CDATASection.prototype = {
        nodeName: "#cdata-section",
        nodeType: CDATA_SECTION_NODE
    }, _extends(CDATASection, CharacterData), DocumentType.prototype.nodeType = DOCUMENT_TYPE_NODE, _extends(DocumentType, Node), Notation.prototype.nodeType = NOTATION_NODE, _extends(Notation, Node), Entity.prototype.nodeType = ENTITY_NODE, _extends(Entity, Node), EntityReference.prototype.nodeType = ENTITY_REFERENCE_NODE, _extends(EntityReference, Node), DocumentFragment.prototype.nodeName = "#document-fragment", DocumentFragment.prototype.nodeType = DOCUMENT_FRAGMENT_NODE, _extends(DocumentFragment, Node), ProcessingInstruction.prototype.nodeType = PROCESSING_INSTRUCTION_NODE, _extends(ProcessingInstruction, Node), XMLSerializer.prototype.serializeToString = function(e, n, r) {
        return nodeSerializeToString.call(e, n, r)
    }, Node.prototype.toString = nodeSerializeToString;
    try {
        if (Object.defineProperty) {
            function getTextContent(e) {
                switch (e.nodeType) {
                    case ELEMENT_NODE:
                    case DOCUMENT_FRAGMENT_NODE:
                        var n = [];
                        for (e = e.firstChild; e;) 7 !== e.nodeType && 8 !== e.nodeType && n.push(getTextContent(e)), e = e.nextSibling;
                        return n.join("");
                    default:
                        return e.nodeValue
                }
            }
            Object.defineProperty(LiveNodeList.prototype, "length", {get: function() {
                    return _updateLiveList(this), this.$$length
                }
            }), Object.defineProperty(Node.prototype, "textContent", {get: function() {
                    return getTextContent(this)
                },
                set: function(e) {
                    switch (this.nodeType) {
                        case ELEMENT_NODE:
                        case DOCUMENT_FRAGMENT_NODE:
                            for (; this.firstChild;) this.removeChild(this.firstChild);
                            (e || String(e)) && this.appendChild(this.ownerDocument.createTextNode(e));
                            break;
                        default:
                            this.data = e, this.value = e, this.nodeValue = e
                    }
                }
            }), __set__ = function(e, n, r) {
                e["$$" + n] = r
            }
        }
    } catch (e) {}

    function DOMParser(e) {
        this.options = e || {
            locator: {}
        }
    }

    function buildErrorHandler(e, n, r) {
        if (!e) {
            if (n instanceof DOMHandler) return n;
            e = n
        }
        var i = {},
            o = e instanceof Function;

        function build(n) {
            var a = e[n];
            !a && o && (a = 2 == e.length ? function(r) {
                e(n, r)
            } : e), i[n] = a && function(e) {
                a("[xmldom " + n + "]\t" + e + _locator(r))
            } || function() {}
        }
        return r = r || {}, build("warning"), build("error"), build("fatalError"), i
    }

    function DOMHandler() {
        this.cdata = !1
    }

    function position(e, n) {
        n.lineNumber = e.lineNumber, n.columnNumber = e.columnNumber
    }

    function _locator(e) {
        if (e) return "\n@" + (e.systemId || "") + "#[line:" + e.lineNumber + ",col:" + e.columnNumber + "]"
    }

    function _toString(e, n, r) {
        return "string" == typeof e ? e.substr(n, r) : e.length >= n + r || n ? new java.lang.String(e, n, r) + "" : e
    }

    function appendElement(e, n) {
        e.currentElement ? e.currentElement.appendChild(n) : e.doc.appendChild(n)
    }
    DOMParser.prototype.parseFromString = function(e, n) {
        var r = this.options,
            i = new XMLReader,
            o = r.domBuilder || new DOMHandler,
            a = r.errorHandler,
            s = r.locator,
            c = r.xmlns || {},
            u = /\/x?html?$/.test(n),
            l = u ? htmlEntity.entityMap : {
                lt: "<",
                gt: ">",
                amp: "&",
                quot: '"',
                apos: "'"
            };
        return s && o.setDocumentLocator(s), i.errorHandler = buildErrorHandler(a, o, s), i.domBuilder = r.domBuilder || o, u && (c[""] = "http://www.w3.org/1999/xhtml"), c.xml = c.xml || "http://www.w3.org/XML/1998/namespace", e ? i.parse(e, c, l) : i.errorHandler.error("invalid doc source"), o.doc
    }, DOMHandler.prototype = {
        startDocument: function() {
            this.doc = (new DOMImplementation).createDocument(null, null, null), this.locator && (this.doc.documentURI = this.locator.systemId)
        },
        startElement: function(e, n, r, i) {
            var o = this.doc,
                a = o.createElementNS(e, r || n),
                s = i.length;
            appendElement(this, a), this.currentElement = a, this.locator && position(this.locator, a);
            for (var c = 0; c < s; c++) {
                e = i.getURI(c);
                var u = i.getValue(c),
                    l = (r = i.getQName(c), o.createAttributeNS(e, r));
                this.locator && position(i.getLocator(c), l), l.value = l.nodeValue = u, a.setAttributeNode(l)
            }
        },
        endElement: function(e, n, r) {
            var i = this.currentElement;
            i.tagName;
            this.currentElement = i.parentNode
        },
        startPrefixMapping: function(e, n) {},
        endPrefixMapping: function(e) {},
        processingInstruction: function(e, n) {
            var r = this.doc.createProcessingInstruction(e, n);
            this.locator && position(this.locator, r), appendElement(this, r)
        },
        ignorableWhitespace: function(e, n, r) {},
        characters: function(e, n, r) {
            if (e = _toString.apply(this, arguments)) {
                if (this.cdata) var i = this.doc.createCDATASection(e);
                else i = this.doc.createTextNode(e);
                this.currentElement ? this.currentElement.appendChild(i) : /^\s*$/.test(e) && this.doc.appendChild(i), this.locator && position(this.locator, i)
            }
        },
        skippedEntity: function(e) {},
        endDocument: function() {
            this.doc.normalize()
        },
        setDocumentLocator: function(e) {
            (this.locator = e) && (e.lineNumber = 0)
        },
        comment: function(e, n, r) {
            e = _toString.apply(this, arguments);
            var i = this.doc.createComment(e);
            this.locator && position(this.locator, i), appendElement(this, i)
        },
        startCDATA: function() {
            this.cdata = !0
        },
        endCDATA: function() {
            this.cdata = !1
        },
        startDTD: function(e, n, r) {
            var i = this.doc.implementation;
            if (i && i.createDocumentType) {
                var o = i.createDocumentType(e, n, r);
                this.locator && position(this.locator, o), appendElement(this, o)
            }
        },
        warning: function(e) {
            console.warn("[xmldom warning]\t" + e, _locator(this.locator))
        },
        error: function(e) {
            console.error("[xmldom error]\t" + e, _locator(this.locator))
        },
        fatalError: function(e) {
            throw console.error("[xmldom fatalError]\t" + e, _locator(this.locator)), e
        }
    }, "endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g, (function(e) {
        DOMHandler.prototype[e] = function() {
            return null
        }
    }));
    var htmlEntity = {};
    htmlEntity.entityMap = entityMap, window.Parser = {
        DOMParser: DOMParser
    };
});
define("libs/min/fx.d2.min.js", function(require, module, exports) {
    window.pako = function r(t, e, a) {
        function h(u, f) {
            if (!e[u]) {
                if (!t[u]) {
                    var g = "function" == typeof require && require;
                    if (!f && g) return g(u, !0);
                    if (n) return n(u, !0);
                    var _ = new Error("Cannot find module '" + u + "'");
                    throw _.code = "MODULE_NOT_FOUND", _
                }
                var p = e[u] = {
                    exports: {}
                };
                t[u][0].call(p.exports, (function(e) {
                    return h(t[u][1][e] || e)
                }), p, p.exports, r, t, e, a)
            }
            return e[u].exports
        }
        for (var n = "function" == typeof require && require, u = 0; u < a.length; u++) h(a[u]);
        return h
    }({
        1: [function(t, e, a) {
            "use strict";
            var n = t("./zlib/deflate"),
                u = t("./utils/common"),
                f = t("./utils/strings"),
                g = t("./zlib/messages"),
                _ = t("./zlib/zstream"),
                p = Object.prototype.toString;

            function c(t) {
                if (!(this instanceof c)) return new c(t);
                this.options = u.assign({
                    level: -1,
                    method: 8,
                    chunkSize: 16384,
                    windowBits: 15,
                    memLevel: 8,
                    strategy: 0,
                    to: ""
                }, t || {});
                var e = this.options;
                e.raw && 0 < e.windowBits ? e.windowBits = -e.windowBits : e.gzip && 0 < e.windowBits && e.windowBits < 16 && (e.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new _, this.strm.avail_out = 0;
                var a = n.deflateInit2(this.strm, e.level, e.method, e.windowBits, e.memLevel, e.strategy);
                if (0 !== a) throw new Error(g[a]);
                if (e.header && n.deflateSetHeader(this.strm, e.header), e.dictionary) {
                    var y;
                    if (y = "string" == typeof e.dictionary ? f.string2buf(e.dictionary) : "[object ArrayBuffer]" === p.call(e.dictionary) ? new Uint8Array(e.dictionary) : e.dictionary, 0 !== (a = n.deflateSetDictionary(this.strm, y))) throw new Error(g[a]);
                    this._dict_set = !0
                }
            }

            function i(t, e) {
                var a = new c(e);
                if (a.push(t, !0), a.err) throw a.msg || g[a.err];
                return a.result
            }
            c.prototype.push = function(t, e) {
                var a, g, _ = this.strm,
                    y = this.options.chunkSize;
                if (this.ended) return !1;
                g = e === ~~e ? e : !0 === e ? 4 : 0, "string" == typeof t ? _.input = f.string2buf(t) : "[object ArrayBuffer]" === p.call(t) ? _.input = new Uint8Array(t) : _.input = t, _.next_in = 0, _.avail_in = _.input.length;
                do {
                    if (0 === _.avail_out && (_.output = new u.Buf8(y), _.next_out = 0, _.avail_out = y), 1 !== (a = n.deflate(_, g)) && 0 !== a) return this.onEnd(a), !(this.ended = !0);
                    0 !== _.avail_out && (0 !== _.avail_in || 4 !== g && 2 !== g) || ("string" === this.options.to ? this.onData(f.buf2binstring(u.shrinkBuf(_.output, _.next_out))) : this.onData(u.shrinkBuf(_.output, _.next_out)))
                } while ((0 < _.avail_in || 0 === _.avail_out) && 1 !== a);
                return 4 === g ? (a = n.deflateEnd(this.strm), this.onEnd(a), this.ended = !0, 0 === a) : 2 !== g || (this.onEnd(0), !(_.avail_out = 0))
            }, c.prototype.onData = function(t) {
                this.chunks.push(t)
            }, c.prototype.onEnd = function(t) {
                0 === t && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = u.flattenChunks(this.chunks)), this.chunks = [], this.err = t, this.msg = this.strm.msg
            }, a.Deflate = c, a.deflate = i, a.deflateRaw = function(t, e) {
                return (e = e || {}).raw = !0, i(t, e)
            }, a.gzip = function(t, e) {
                return (e = e || {}).gzip = !0, i(t, e)
            }
        }, {
            "./utils/common": 3,
            "./utils/strings": 4,
            "./zlib/deflate": 8,
            "./zlib/messages": 13,
            "./zlib/zstream": 15
        }],
        2: [function(t, e, a) {
            "use strict";
            var n = t("./zlib/inflate"),
                u = t("./utils/common"),
                f = t("./utils/strings"),
                g = t("./zlib/constants"),
                _ = t("./zlib/messages"),
                p = t("./zlib/zstream"),
                y = t("./zlib/gzheader"),
                m = Object.prototype.toString;

            function s(t) {
                if (!(this instanceof s)) return new s(t);
                this.options = u.assign({
                    chunkSize: 16384,
                    windowBits: 0,
                    to: ""
                }, t || {});
                var e = this.options;
                e.raw && 0 <= e.windowBits && e.windowBits < 16 && (e.windowBits = -e.windowBits, 0 === e.windowBits && (e.windowBits = -15)), !(0 <= e.windowBits && e.windowBits < 16) || t && t.windowBits || (e.windowBits += 32), 15 < e.windowBits && e.windowBits < 48 && 0 == (15 & e.windowBits) && (e.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new p, this.strm.avail_out = 0;
                var a = n.inflateInit2(this.strm, e.windowBits);
                if (a !== g.Z_OK) throw new Error(_[a]);
                this.header = new y, n.inflateGetHeader(this.strm, this.header)
            }

            function o(t, e) {
                var a = new s(e);
                if (a.push(t, !0), a.err) throw a.msg || _[a.err];
                return a.result
            }
            s.prototype.push = function(t, e) {
                var a, _, p, y, b, w, x = this.strm,
                    v = this.options.chunkSize,
                    S = this.options.dictionary,
                    E = !1;
                if (this.ended) return !1;
                _ = e === ~~e ? e : !0 === e ? g.Z_FINISH : g.Z_NO_FLUSH, "string" == typeof t ? x.input = f.binstring2buf(t) : "[object ArrayBuffer]" === m.call(t) ? x.input = new Uint8Array(t) : x.input = t, x.next_in = 0, x.avail_in = x.input.length;
                do {
                    if (0 === x.avail_out && (x.output = new u.Buf8(v), x.next_out = 0, x.avail_out = v), (a = n.inflate(x, g.Z_NO_FLUSH)) === g.Z_NEED_DICT && S && (w = "string" == typeof S ? f.string2buf(S) : "[object ArrayBuffer]" === m.call(S) ? new Uint8Array(S) : S, a = n.inflateSetDictionary(this.strm, w)), a === g.Z_BUF_ERROR && !0 === E && (a = g.Z_OK, E = !1), a !== g.Z_STREAM_END && a !== g.Z_OK) return this.onEnd(a), !(this.ended = !0);
                    x.next_out && (0 !== x.avail_out && a !== g.Z_STREAM_END && (0 !== x.avail_in || _ !== g.Z_FINISH && _ !== g.Z_SYNC_FLUSH) || ("string" === this.options.to ? (p = f.utf8border(x.output, x.next_out), y = x.next_out - p, b = f.buf2string(x.output, p), x.next_out = y, x.avail_out = v - y, y && u.arraySet(x.output, x.output, p, y, 0), this.onData(b)) : this.onData(u.shrinkBuf(x.output, x.next_out)))), 0 === x.avail_in && 0 === x.avail_out && (E = !0)
                } while ((0 < x.avail_in || 0 === x.avail_out) && a !== g.Z_STREAM_END);
                return a === g.Z_STREAM_END && (_ = g.Z_FINISH), _ === g.Z_FINISH ? (a = n.inflateEnd(this.strm), this.onEnd(a), this.ended = !0, a === g.Z_OK) : _ !== g.Z_SYNC_FLUSH || (this.onEnd(g.Z_OK), !(x.avail_out = 0))
            }, s.prototype.onData = function(t) {
                this.chunks.push(t)
            }, s.prototype.onEnd = function(t) {
                t === g.Z_OK && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = u.flattenChunks(this.chunks)), this.chunks = [], this.err = t, this.msg = this.strm.msg
            }, a.Inflate = s, a.inflate = o, a.inflateRaw = function(t, e) {
                return (e = e || {}).raw = !0, o(t, e)
            }, a.ungzip = o
        }, {
            "./utils/common": 3,
            "./utils/strings": 4,
            "./zlib/constants": 6,
            "./zlib/gzheader": 9,
            "./zlib/inflate": 11,
            "./zlib/messages": 13,
            "./zlib/zstream": 15
        }],
        3: [function(t, e, a) {
            "use strict";
            var n = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Int32Array;
            a.assign = function(t) {
                for (var e, a, n = Array.prototype.slice.call(arguments, 1); n.length;) {
                    var u = n.shift();
                    if (u) {
                        if ("object" != typeof u) throw new TypeError(u + "must be non-object");
                        for (var f in u) e = u, a = f, Object.prototype.hasOwnProperty.call(e, a) && (t[f] = u[f])
                    }
                }
                return t
            }, a.shrinkBuf = function(t, e) {
                return t.length === e ? t : t.subarray ? t.subarray(0, e) : (t.length = e, t)
            };
            var u = {
                    arraySet: function(t, e, a, n, u) {
                        if (e.subarray && t.subarray) t.set(e.subarray(a, a + n), u);
                        else
                            for (var f = 0; f < n; f++) t[u + f] = e[a + f]
                    },
                    flattenChunks: function(t) {
                        var e, a, n, u, f, g;
                        for (e = n = 0, a = t.length; e < a; e++) n += t[e].length;
                        for (g = new Uint8Array(n), e = u = 0, a = t.length; e < a; e++) f = t[e], g.set(f, u), u += f.length;
                        return g
                    }
                },
                f = {
                    arraySet: function(t, e, a, n, u) {
                        for (var f = 0; f < n; f++) t[u + f] = e[a + f]
                    },
                    flattenChunks: function(t) {
                        return [].concat.apply([], t)
                    }
                };
            a.setTyped = function(t) {
                t ? (a.Buf8 = Uint8Array, a.Buf16 = Uint16Array, a.Buf32 = Int32Array, a.assign(a, u)) : (a.Buf8 = Array, a.Buf16 = Array, a.Buf32 = Array, a.assign(a, f))
            }, a.setTyped(n)
        }, {}],
        4: [function(t, e, a) {
            "use strict";
            var n = t("./common"),
                u = !0,
                f = !0;
            try {
                String.fromCharCode.apply(null, [0])
            } catch (t) {
                u = !1
            }
            try {
                String.fromCharCode.apply(null, new Uint8Array(1))
            } catch (t) {
                f = !1
            }
            for (var g = new n.Buf8(256), _ = 0; _ < 256; _++) g[_] = 252 <= _ ? 6 : 248 <= _ ? 5 : 240 <= _ ? 4 : 224 <= _ ? 3 : 192 <= _ ? 2 : 1;

            function d(t, e) {
                if (e < 65534 && (t.subarray && f || !t.subarray && u)) return String.fromCharCode.apply(null, n.shrinkBuf(t, e));
                for (var a = "", g = 0; g < e; g++) a += String.fromCharCode(t[g]);
                return a
            }
            g[254] = g[254] = 1, a.string2buf = function(t) {
                var e, a, u, f, g, _ = t.length,
                    p = 0;
                for (f = 0; f < _; f++) 55296 == (64512 & (a = t.charCodeAt(f))) && f + 1 < _ && 56320 == (64512 & (u = t.charCodeAt(f + 1))) && (a = 65536 + (a - 55296 << 10) + (u - 56320), f++), p += a < 128 ? 1 : a < 2048 ? 2 : a < 65536 ? 3 : 4;
                for (e = new n.Buf8(p), f = g = 0; g < p; f++) 55296 == (64512 & (a = t.charCodeAt(f))) && f + 1 < _ && 56320 == (64512 & (u = t.charCodeAt(f + 1))) && (a = 65536 + (a - 55296 << 10) + (u - 56320), f++), e[g++] = a < 128 ? a : (e[g++] = a < 2048 ? 192 | a >>> 6 : (e[g++] = a < 65536 ? 224 | a >>> 12 : (e[g++] = 240 | a >>> 18, 128 | a >>> 12 & 63), 128 | a >>> 6 & 63), 128 | 63 & a);
                return e
            }, a.buf2binstring = function(t) {
                return d(t, t.length)
            }, a.binstring2buf = function(t) {
                for (var e = new n.Buf8(t.length), a = 0, u = e.length; a < u; a++) e[a] = t.charCodeAt(a);
                return e
            }, a.buf2string = function(t, e) {
                var a, n, u, f, _ = e || t.length,
                    p = new Array(2 * _);
                for (a = n = 0; a < _;)
                    if ((u = t[a++]) < 128) p[n++] = u;
                    else if (4 < (f = g[u])) p[n++] = 65533, a += f - 1;
                else {
                    for (u &= 2 === f ? 31 : 3 === f ? 15 : 7; 1 < f && a < _;) u = u << 6 | 63 & t[a++], f--;
                    p[n++] = 1 < f ? 65533 : u < 65536 ? u : (u -= 65536, p[n++] = 55296 | u >> 10 & 1023, 56320 | 1023 & u)
                }
                return d(p, n)
            }, a.utf8border = function(t, e) {
                var a;
                for ((e = e || t.length) > t.length && (e = t.length), a = e - 1; 0 <= a && 128 == (192 & t[a]);) a--;
                return a < 0 || 0 === a ? e : a + g[t[a]] > e ? a : e
            }
        }, {
            "./common": 3
        }],
        5: [function(t, e, a) {
            "use strict";
            e.exports = function(t, e, a, n) {
                for (var u = 65535 & t | 0, f = t >>> 16 & 65535 | 0, g = 0; 0 !== a;) {
                    for (a -= g = 2e3 < a ? 2e3 : a; f = f + (u = u + e[n++] | 0) | 0, --g;);
                    u %= 65521, f %= 65521
                }
                return u | f << 16 | 0
            }
        }, {}],
        6: [function(t, e, a) {
            "use strict";
            e.exports = {
                Z_NO_FLUSH: 0,
                Z_PARTIAL_FLUSH: 1,
                Z_SYNC_FLUSH: 2,
                Z_FULL_FLUSH: 3,
                Z_FINISH: 4,
                Z_BLOCK: 5,
                Z_TREES: 6,
                Z_OK: 0,
                Z_STREAM_END: 1,
                Z_NEED_DICT: 2,
                Z_ERRNO: -1,
                Z_STREAM_ERROR: -2,
                Z_DATA_ERROR: -3,
                Z_BUF_ERROR: -5,
                Z_NO_COMPRESSION: 0,
                Z_BEST_SPEED: 1,
                Z_BEST_COMPRESSION: 9,
                Z_DEFAULT_COMPRESSION: -1,
                Z_FILTERED: 1,
                Z_HUFFMAN_ONLY: 2,
                Z_RLE: 3,
                Z_FIXED: 4,
                Z_DEFAULT_STRATEGY: 0,
                Z_BINARY: 0,
                Z_TEXT: 1,
                Z_UNKNOWN: 2,
                Z_DEFLATED: 8
            }
        }, {}],
        7: [function(t, e, a) {
            "use strict";
            var n = function() {
                for (var t, e = [], a = 0; a < 256; a++) {
                    t = a;
                    for (var n = 0; n < 8; n++) t = 1 & t ? 3988292384 ^ t >>> 1 : t >>> 1;
                    e[a] = t
                }
                return e
            }();
            e.exports = function(t, e, a, u) {
                var f = n,
                    g = u + a;
                t ^= -1;
                for (var _ = u; _ < g; _++) t = t >>> 8 ^ f[255 & (t ^ e[_])];
                return -1 ^ t
            }
        }, {}],
        8: [function(t, e, a) {
            "use strict";
            var n, u = t("../utils/common"),
                f = t("./trees"),
                g = t("./adler32"),
                _ = t("./crc32"),
                p = t("./messages"),
                y = -2,
                m = 258,
                b = 262,
                w = 113;

            function N(t, e) {
                return t.msg = p[e], e
            }

            function O(t) {
                return (t << 1) - (4 < t ? 9 : 0)
            }

            function D(t) {
                for (var e = t.length; 0 <= --e;) t[e] = 0
            }

            function I(t) {
                var e = t.state,
                    a = e.pending;
                a > t.avail_out && (a = t.avail_out), 0 !== a && (u.arraySet(t.output, e.pending_buf, e.pending_out, a, t.next_out), t.next_out += a, e.pending_out += a, t.total_out += a, t.avail_out -= a, e.pending -= a, 0 === e.pending && (e.pending_out = 0))
            }

            function U(t, e) {
                f._tr_flush_block(t, 0 <= t.block_start ? t.block_start : -1, t.strstart - t.block_start, e), t.block_start = t.strstart, I(t.strm)
            }

            function T(t, e) {
                t.pending_buf[t.pending++] = e
            }

            function F(t, e) {
                t.pending_buf[t.pending++] = e >>> 8 & 255, t.pending_buf[t.pending++] = 255 & e
            }

            function L(t, e) {
                var a, n, u = t.max_chain_length,
                    f = t.strstart,
                    g = t.prev_length,
                    _ = t.nice_match,
                    p = t.strstart > t.w_size - b ? t.strstart - (t.w_size - b) : 0,
                    y = t.window,
                    w = t.w_mask,
                    x = t.prev,
                    v = t.strstart + m,
                    S = y[f + g - 1],
                    E = y[f + g];
                t.prev_length >= t.good_match && (u >>= 2), _ > t.lookahead && (_ = t.lookahead);
                do {
                    if (y[(a = e) + g] === E && y[a + g - 1] === S && y[a] === y[f] && y[++a] === y[f + 1]) {
                        f += 2, a++;
                        do {} while (y[++f] === y[++a] && y[++f] === y[++a] && y[++f] === y[++a] && y[++f] === y[++a] && y[++f] === y[++a] && y[++f] === y[++a] && y[++f] === y[++a] && y[++f] === y[++a] && f < v);
                        if (n = m - (v - f), f = v - m, g < n) {
                            if (t.match_start = e, _ <= (g = n)) break;
                            S = y[f + g - 1], E = y[f + g]
                        }
                    }
                } while ((e = x[e & w]) > p && 0 != --u);
                return g <= t.lookahead ? g : t.lookahead
            }

            function H(t) {
                var e, a, n, f, p, y, m, w, x, v, S = t.w_size;
                do {
                    if (f = t.window_size - t.lookahead - t.strstart, t.strstart >= S + (S - b)) {
                        for (u.arraySet(t.window, t.window, S, S, 0), t.match_start -= S, t.strstart -= S, t.block_start -= S, e = a = t.hash_size; n = t.head[--e], t.head[e] = S <= n ? n - S : 0, --a;);
                        for (e = a = S; n = t.prev[--e], t.prev[e] = S <= n ? n - S : 0, --a;);
                        f += S
                    }
                    if (0 === t.strm.avail_in) break;
                    if (y = t.strm, m = t.window, w = t.strstart + t.lookahead, v = void 0, (x = f) < (v = y.avail_in) && (v = x), a = 0 === v ? 0 : (y.avail_in -= v, u.arraySet(m, y.input, y.next_in, v, w), 1 === y.state.wrap ? y.adler = g(y.adler, m, v, w) : 2 === y.state.wrap && (y.adler = _(y.adler, m, v, w)), y.next_in += v, y.total_in += v, v), t.lookahead += a, t.lookahead + t.insert >= 3)
                        for (p = t.strstart - t.insert, t.ins_h = t.window[p], t.ins_h = (t.ins_h << t.hash_shift ^ t.window[p + 1]) & t.hash_mask; t.insert && (t.ins_h = (t.ins_h << t.hash_shift ^ t.window[p + 3 - 1]) & t.hash_mask, t.prev[p & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = p, p++, t.insert--, !(t.lookahead + t.insert < 3)););
                } while (t.lookahead < b && 0 !== t.strm.avail_in)
            }

            function j(t, e) {
                for (var a, n;;) {
                    if (t.lookahead < b) {
                        if (H(t), t.lookahead < b && 0 === e) return 1;
                        if (0 === t.lookahead) break
                    }
                    if (a = 0, t.lookahead >= 3 && (t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + 3 - 1]) & t.hash_mask, a = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart), 0 !== a && t.strstart - a <= t.w_size - b && (t.match_length = L(t, a)), t.match_length >= 3)
                        if (n = f._tr_tally(t, t.strstart - t.match_start, t.match_length - 3), t.lookahead -= t.match_length, t.match_length <= t.max_lazy_match && t.lookahead >= 3) {
                            for (t.match_length--; t.strstart++, t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + 3 - 1]) & t.hash_mask, a = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart, 0 != --t.match_length;);
                            t.strstart++
                        } else t.strstart += t.match_length, t.match_length = 0, t.ins_h = t.window[t.strstart], t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + 1]) & t.hash_mask;
                    else n = f._tr_tally(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++;
                    if (n && (U(t, !1), 0 === t.strm.avail_out)) return 1
                }
                return t.insert = t.strstart < 2 ? t.strstart : 2, 4 === e ? (U(t, !0), 0 === t.strm.avail_out ? 3 : 4) : t.last_lit && (U(t, !1), 0 === t.strm.avail_out) ? 1 : 2
            }

            function K(t, e) {
                for (var a, n, u;;) {
                    if (t.lookahead < b) {
                        if (H(t), t.lookahead < b && 0 === e) return 1;
                        if (0 === t.lookahead) break
                    }
                    if (a = 0, t.lookahead >= 3 && (t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + 3 - 1]) & t.hash_mask, a = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart), t.prev_length = t.match_length, t.prev_match = t.match_start, t.match_length = 2, 0 !== a && t.prev_length < t.max_lazy_match && t.strstart - a <= t.w_size - b && (t.match_length = L(t, a), t.match_length <= 5 && (1 === t.strategy || 3 === t.match_length && 4096 < t.strstart - t.match_start) && (t.match_length = 2)), t.prev_length >= 3 && t.match_length <= t.prev_length) {
                        for (u = t.strstart + t.lookahead - 3, n = f._tr_tally(t, t.strstart - 1 - t.prev_match, t.prev_length - 3), t.lookahead -= t.prev_length - 1, t.prev_length -= 2; ++t.strstart <= u && (t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + 3 - 1]) & t.hash_mask, a = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart), 0 != --t.prev_length;);
                        if (t.match_available = 0, t.match_length = 2, t.strstart++, n && (U(t, !1), 0 === t.strm.avail_out)) return 1
                    } else if (t.match_available) {
                        if ((n = f._tr_tally(t, 0, t.window[t.strstart - 1])) && U(t, !1), t.strstart++, t.lookahead--, 0 === t.strm.avail_out) return 1
                    } else t.match_available = 1, t.strstart++, t.lookahead--
                }
                return t.match_available && (n = f._tr_tally(t, 0, t.window[t.strstart - 1]), t.match_available = 0), t.insert = t.strstart < 2 ? t.strstart : 2, 4 === e ? (U(t, !0), 0 === t.strm.avail_out ? 3 : 4) : t.last_lit && (U(t, !1), 0 === t.strm.avail_out) ? 1 : 2
            }

            function M(t, e, a, n, u) {
                this.good_length = t, this.max_lazy = e, this.nice_length = a, this.max_chain = n, this.func = u
            }

            function P() {
                this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = 8, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new u.Buf16(1146), this.dyn_dtree = new u.Buf16(122), this.bl_tree = new u.Buf16(78), D(this.dyn_ltree), D(this.dyn_dtree), D(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new u.Buf16(16), this.heap = new u.Buf16(573), D(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new u.Buf16(573), D(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0
            }

            function Y(t) {
                var e;
                return t && t.state ? (t.total_in = t.total_out = 0, t.data_type = 2, (e = t.state).pending = 0, e.pending_out = 0, e.wrap < 0 && (e.wrap = -e.wrap), e.status = e.wrap ? 42 : w, t.adler = 2 === e.wrap ? 0 : 1, e.last_flush = 0, f._tr_init(e), 0) : N(t, y)
            }

            function q(t) {
                var e, a = Y(t);
                return 0 === a && ((e = t.state).window_size = 2 * e.w_size, D(e.head), e.max_lazy_match = n[e.level].max_lazy, e.good_match = n[e.level].good_length, e.nice_match = n[e.level].nice_length, e.max_chain_length = n[e.level].max_chain, e.strstart = 0, e.block_start = 0, e.lookahead = 0, e.insert = 0, e.match_length = e.prev_length = 2, e.match_available = 0, e.ins_h = 0), a
            }

            function G(t, e, a, n, f, g) {
                if (!t) return y;
                var _ = 1;
                if (-1 === e && (e = 6), n < 0 ? (_ = 0, n = -n) : 15 < n && (_ = 2, n -= 16), f < 1 || 9 < f || 8 !== a || n < 8 || 15 < n || e < 0 || 9 < e || g < 0 || 4 < g) return N(t, y);
                8 === n && (n = 9);
                var p = new P;
                return (t.state = p).strm = t, p.wrap = _, p.gzhead = null, p.w_bits = n, p.w_size = 1 << p.w_bits, p.w_mask = p.w_size - 1, p.hash_bits = f + 7, p.hash_size = 1 << p.hash_bits, p.hash_mask = p.hash_size - 1, p.hash_shift = ~~((p.hash_bits + 3 - 1) / 3), p.window = new u.Buf8(2 * p.w_size), p.head = new u.Buf16(p.hash_size), p.prev = new u.Buf16(p.w_size), p.lit_bufsize = 1 << f + 6, p.pending_buf_size = 4 * p.lit_bufsize, p.pending_buf = new u.Buf8(p.pending_buf_size), p.d_buf = 1 * p.lit_bufsize, p.l_buf = 3 * p.lit_bufsize, p.level = e, p.strategy = g, p.method = a, q(t)
            }
            n = [new M(0, 0, 0, 0, (function(t, e) {
                var a = 65535;
                for (a > t.pending_buf_size - 5 && (a = t.pending_buf_size - 5);;) {
                    if (t.lookahead <= 1) {
                        if (H(t), 0 === t.lookahead && 0 === e) return 1;
                        if (0 === t.lookahead) break
                    }
                    t.strstart += t.lookahead, t.lookahead = 0;
                    var n = t.block_start + a;
                    if ((0 === t.strstart || t.strstart >= n) && (t.lookahead = t.strstart - n, t.strstart = n, U(t, !1), 0 === t.strm.avail_out)) return 1;
                    if (t.strstart - t.block_start >= t.w_size - b && (U(t, !1), 0 === t.strm.avail_out)) return 1
                }
                return t.insert = 0, 4 === e ? (U(t, !0), 0 === t.strm.avail_out ? 3 : 4) : (t.strstart > t.block_start && (U(t, !1), t.strm.avail_out), 1)
            })), new M(4, 4, 8, 4, j), new M(4, 5, 16, 8, j), new M(4, 6, 32, 32, j), new M(4, 4, 16, 16, K), new M(8, 16, 32, 32, K), new M(8, 16, 128, 128, K), new M(8, 32, 128, 256, K), new M(32, 128, 258, 1024, K), new M(32, 258, 258, 4096, K)], a.deflateInit = function(t, e) {
                return G(t, e, 8, 15, 8, 0)
            }, a.deflateInit2 = G, a.deflateReset = q, a.deflateResetKeep = Y, a.deflateSetHeader = function(t, e) {
                return t && t.state ? 2 !== t.state.wrap ? y : (t.state.gzhead = e, 0) : y
            }, a.deflate = function(t, e) {
                var a, u, g, p;
                if (!t || !t.state || 5 < e || e < 0) return t ? N(t, y) : y;
                if (u = t.state, !t.output || !t.input && 0 !== t.avail_in || 666 === u.status && 4 !== e) return N(t, 0 === t.avail_out ? -5 : y);
                if (u.strm = t, a = u.last_flush, u.last_flush = e, 42 === u.status)
                    if (2 === u.wrap) t.adler = 0, T(u, 31), T(u, 139), T(u, 8), u.gzhead ? (T(u, (u.gzhead.text ? 1 : 0) + (u.gzhead.hcrc ? 2 : 0) + (u.gzhead.extra ? 4 : 0) + (u.gzhead.name ? 8 : 0) + (u.gzhead.comment ? 16 : 0)), T(u, 255 & u.gzhead.time), T(u, u.gzhead.time >> 8 & 255), T(u, u.gzhead.time >> 16 & 255), T(u, u.gzhead.time >> 24 & 255), T(u, 9 === u.level ? 2 : 2 <= u.strategy || u.level < 2 ? 4 : 0), T(u, 255 & u.gzhead.os), u.gzhead.extra && u.gzhead.extra.length && (T(u, 255 & u.gzhead.extra.length), T(u, u.gzhead.extra.length >> 8 & 255)), u.gzhead.hcrc && (t.adler = _(t.adler, u.pending_buf, u.pending, 0)), u.gzindex = 0, u.status = 69) : (T(u, 0), T(u, 0), T(u, 0), T(u, 0), T(u, 0), T(u, 9 === u.level ? 2 : 2 <= u.strategy || u.level < 2 ? 4 : 0), T(u, 3), u.status = w);
                    else {
                        var b = 8 + (u.w_bits - 8 << 4) << 8;
                        b |= (2 <= u.strategy || u.level < 2 ? 0 : u.level < 6 ? 1 : 6 === u.level ? 2 : 3) << 6, 0 !== u.strstart && (b |= 32), b += 31 - b % 31, u.status = w, F(u, b), 0 !== u.strstart && (F(u, t.adler >>> 16), F(u, 65535 & t.adler)), t.adler = 1
                    }
                if (69 === u.status)
                    if (u.gzhead.extra) {
                        for (g = u.pending; u.gzindex < (65535 & u.gzhead.extra.length) && (u.pending !== u.pending_buf_size || (u.gzhead.hcrc && u.pending > g && (t.adler = _(t.adler, u.pending_buf, u.pending - g, g)), I(t), g = u.pending, u.pending !== u.pending_buf_size));) T(u, 255 & u.gzhead.extra[u.gzindex]), u.gzindex++;
                        u.gzhead.hcrc && u.pending > g && (t.adler = _(t.adler, u.pending_buf, u.pending - g, g)), u.gzindex === u.gzhead.extra.length && (u.gzindex = 0, u.status = 73)
                    } else u.status = 73;
                if (73 === u.status)
                    if (u.gzhead.name) {
                        g = u.pending;
                        do {
                            if (u.pending === u.pending_buf_size && (u.gzhead.hcrc && u.pending > g && (t.adler = _(t.adler, u.pending_buf, u.pending - g, g)), I(t), g = u.pending, u.pending === u.pending_buf_size)) {
                                p = 1;
                                break
                            }
                            T(u, p = u.gzindex < u.gzhead.name.length ? 255 & u.gzhead.name.charCodeAt(u.gzindex++) : 0)
                        } while (0 !== p);
                        u.gzhead.hcrc && u.pending > g && (t.adler = _(t.adler, u.pending_buf, u.pending - g, g)), 0 === p && (u.gzindex = 0, u.status = 91)
                    } else u.status = 91;
                if (91 === u.status)
                    if (u.gzhead.comment) {
                        g = u.pending;
                        do {
                            if (u.pending === u.pending_buf_size && (u.gzhead.hcrc && u.pending > g && (t.adler = _(t.adler, u.pending_buf, u.pending - g, g)), I(t), g = u.pending, u.pending === u.pending_buf_size)) {
                                p = 1;
                                break
                            }
                            T(u, p = u.gzindex < u.gzhead.comment.length ? 255 & u.gzhead.comment.charCodeAt(u.gzindex++) : 0)
                        } while (0 !== p);
                        u.gzhead.hcrc && u.pending > g && (t.adler = _(t.adler, u.pending_buf, u.pending - g, g)), 0 === p && (u.status = 103)
                    } else u.status = 103;
                if (103 === u.status && (u.gzhead.hcrc ? (u.pending + 2 > u.pending_buf_size && I(t), u.pending + 2 <= u.pending_buf_size && (T(u, 255 & t.adler), T(u, t.adler >> 8 & 255), t.adler = 0, u.status = w)) : u.status = w), 0 !== u.pending) {
                    if (I(t), 0 === t.avail_out) return u.last_flush = -1, 0
                } else if (0 === t.avail_in && O(e) <= O(a) && 4 !== e) return N(t, -5);
                if (666 === u.status && 0 !== t.avail_in) return N(t, -5);
                if (0 !== t.avail_in || 0 !== u.lookahead || 0 !== e && 666 !== u.status) {
                    var x = 2 === u.strategy ? function(t, e) {
                        for (var a;;) {
                            if (0 === t.lookahead && (H(t), 0 === t.lookahead)) {
                                if (0 === e) return 1;
                                break
                            }
                            if (t.match_length = 0, a = f._tr_tally(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++, a && (U(t, !1), 0 === t.strm.avail_out)) return 1
                        }
                        return t.insert = 0, 4 === e ? (U(t, !0), 0 === t.strm.avail_out ? 3 : 4) : t.last_lit && (U(t, !1), 0 === t.strm.avail_out) ? 1 : 2
                    }(u, e) : 3 === u.strategy ? function(t, e) {
                        for (var a, n, u, g, _ = t.window;;) {
                            if (t.lookahead <= m) {
                                if (H(t), t.lookahead <= m && 0 === e) return 1;
                                if (0 === t.lookahead) break
                            }
                            if (t.match_length = 0, t.lookahead >= 3 && 0 < t.strstart && (n = _[u = t.strstart - 1]) === _[++u] && n === _[++u] && n === _[++u]) {
                                g = t.strstart + m;
                                do {} while (n === _[++u] && n === _[++u] && n === _[++u] && n === _[++u] && n === _[++u] && n === _[++u] && n === _[++u] && n === _[++u] && u < g);
                                t.match_length = m - (g - u), t.match_length > t.lookahead && (t.match_length = t.lookahead)
                            }
                            if (t.match_length >= 3 ? (a = f._tr_tally(t, 1, t.match_length - 3), t.lookahead -= t.match_length, t.strstart += t.match_length, t.match_length = 0) : (a = f._tr_tally(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++), a && (U(t, !1), 0 === t.strm.avail_out)) return 1
                        }
                        return t.insert = 0, 4 === e ? (U(t, !0), 0 === t.strm.avail_out ? 3 : 4) : t.last_lit && (U(t, !1), 0 === t.strm.avail_out) ? 1 : 2
                    }(u, e) : n[u.level].func(u, e);
                    if (3 !== x && 4 !== x || (u.status = 666), 1 === x || 3 === x) return 0 === t.avail_out && (u.last_flush = -1), 0;
                    if (2 === x && (1 === e ? f._tr_align(u) : 5 !== e && (f._tr_stored_block(u, 0, 0, !1), 3 === e && (D(u.head), 0 === u.lookahead && (u.strstart = 0, u.block_start = 0, u.insert = 0))), I(t), 0 === t.avail_out)) return u.last_flush = -1, 0
                }
                return 4 !== e ? 0 : u.wrap <= 0 ? 1 : (2 === u.wrap ? (T(u, 255 & t.adler), T(u, t.adler >> 8 & 255), T(u, t.adler >> 16 & 255), T(u, t.adler >> 24 & 255), T(u, 255 & t.total_in), T(u, t.total_in >> 8 & 255), T(u, t.total_in >> 16 & 255), T(u, t.total_in >> 24 & 255)) : (F(u, t.adler >>> 16), F(u, 65535 & t.adler)), I(t), 0 < u.wrap && (u.wrap = -u.wrap), 0 !== u.pending ? 0 : 1)
            }, a.deflateEnd = function(t) {
                var e;
                return t && t.state ? 42 !== (e = t.state.status) && 69 !== e && 73 !== e && 91 !== e && 103 !== e && e !== w && 666 !== e ? N(t, y) : (t.state = null, e === w ? N(t, -3) : 0) : y
            }, a.deflateSetDictionary = function(t, e) {
                var a, n, f, _, p, m, b, w, x = e.length;
                if (!t || !t.state) return y;
                if (2 === (_ = (a = t.state).wrap) || 1 === _ && 42 !== a.status || a.lookahead) return y;
                for (1 === _ && (t.adler = g(t.adler, e, x, 0)), a.wrap = 0, x >= a.w_size && (0 === _ && (D(a.head), a.strstart = 0, a.block_start = 0, a.insert = 0), w = new u.Buf8(a.w_size), u.arraySet(w, e, x - a.w_size, a.w_size, 0), e = w, x = a.w_size), p = t.avail_in, m = t.next_in, b = t.input, t.avail_in = x, t.next_in = 0, t.input = e, H(a); a.lookahead >= 3;) {
                    for (n = a.strstart, f = a.lookahead - 2; a.ins_h = (a.ins_h << a.hash_shift ^ a.window[n + 3 - 1]) & a.hash_mask, a.prev[n & a.w_mask] = a.head[a.ins_h], a.head[a.ins_h] = n, n++, --f;);
                    a.strstart = n, a.lookahead = 2, H(a)
                }
                return a.strstart += a.lookahead, a.block_start = a.strstart, a.insert = a.lookahead, a.lookahead = 0, a.match_length = a.prev_length = 2, a.match_available = 0, t.next_in = m, t.input = b, t.avail_in = p, a.wrap = _, 0
            }, a.deflateInfo = "pako deflate (from Nodeca project)"
        }, {
            "../utils/common": 3,
            "./adler32": 5,
            "./crc32": 7,
            "./messages": 13,
            "./trees": 14
        }],
        9: [function(t, e, a) {
            "use strict";
            e.exports = function() {
                this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1
            }
        }, {}],
        10: [function(t, e, a) {
            "use strict";
            e.exports = function(t, e) {
                var a, n, u, f, g, _, p, y, m, b, w, x, v, S, E, C, A, k, B, R, z, V, Z, $, J;
                a = t.state, n = t.next_in, $ = t.input, u = n + (t.avail_in - 5), f = t.next_out, J = t.output, g = f - (e - t.avail_out), _ = f + (t.avail_out - 257), p = a.dmax, y = a.wsize, m = a.whave, b = a.wnext, w = a.window, x = a.hold, v = a.bits, S = a.lencode, E = a.distcode, C = (1 << a.lenbits) - 1, A = (1 << a.distbits) - 1;
                t: do {
                    v < 15 && (x += $[n++] << v, v += 8, x += $[n++] << v, v += 8), k = S[x & C];
                    e: for (;;) {
                        if (x >>>= B = k >>> 24, v -= B, 0 == (B = k >>> 16 & 255)) J[f++] = 65535 & k;
                        else {
                            if (!(16 & B)) {
                                if (0 == (64 & B)) {
                                    k = S[(65535 & k) + (x & (1 << B) - 1)];
                                    continue e
                                }
                                if (32 & B) {
                                    a.mode = 12;
                                    break t
                                }
                                t.msg = "invalid literal/length code", a.mode = 30;
                                break t
                            }
                            R = 65535 & k, (B &= 15) && (v < B && (x += $[n++] << v, v += 8), R += x & (1 << B) - 1, x >>>= B, v -= B), v < 15 && (x += $[n++] << v, v += 8, x += $[n++] << v, v += 8), k = E[x & A];
                            i: for (;;) {
                                if (x >>>= B = k >>> 24, v -= B, !(16 & (B = k >>> 16 & 255))) {
                                    if (0 == (64 & B)) {
                                        k = E[(65535 & k) + (x & (1 << B) - 1)];
                                        continue i
                                    }
                                    t.msg = "invalid distance code", a.mode = 30;
                                    break t
                                }
                                if (z = 65535 & k, v < (B &= 15) && (x += $[n++] << v, (v += 8) < B && (x += $[n++] << v, v += 8)), p < (z += x & (1 << B) - 1)) {
                                    t.msg = "invalid distance too far back", a.mode = 30;
                                    break t
                                }
                                if (x >>>= B, v -= B, (B = f - g) < z) {
                                    if (m < (B = z - B) && a.sane) {
                                        t.msg = "invalid distance too far back", a.mode = 30;
                                        break t
                                    }
                                    if (Z = w, (V = 0) === b) {
                                        if (V += y - B, B < R) {
                                            for (R -= B; J[f++] = w[V++], --B;);
                                            V = f - z, Z = J
                                        }
                                    } else if (b < B) {
                                        if (V += y + b - B, (B -= b) < R) {
                                            for (R -= B; J[f++] = w[V++], --B;);
                                            if (V = 0, b < R) {
                                                for (R -= B = b; J[f++] = w[V++], --B;);
                                                V = f - z, Z = J
                                            }
                                        }
                                    } else if (V += b - B, B < R) {
                                        for (R -= B; J[f++] = w[V++], --B;);
                                        V = f - z, Z = J
                                    }
                                    for (; 2 < R;) J[f++] = Z[V++], J[f++] = Z[V++], J[f++] = Z[V++], R -= 3;
                                    R && (J[f++] = Z[V++], 1 < R && (J[f++] = Z[V++]))
                                } else {
                                    for (V = f - z; J[f++] = J[V++], J[f++] = J[V++], J[f++] = J[V++], 2 < (R -= 3););
                                    R && (J[f++] = J[V++], 1 < R && (J[f++] = J[V++]))
                                }
                                break
                            }
                        }
                        break
                    }
                } while (n < u && f < _);
                n -= R = v >> 3, x &= (1 << (v -= R << 3)) - 1, t.next_in = n, t.next_out = f, t.avail_in = n < u ? u - n + 5 : 5 - (n - u), t.avail_out = f < _ ? _ - f + 257 : 257 - (f - _), a.hold = x, a.bits = v
            }
        }, {}],
        11: [function(t, e, a) {
            "use strict";
            var n = t("../utils/common"),
                u = t("./adler32"),
                f = t("./crc32"),
                g = t("./inffast"),
                _ = t("./inftrees"),
                p = -2;

            function L(t) {
                return (t >>> 24 & 255) + (t >>> 8 & 65280) + ((65280 & t) << 8) + ((255 & t) << 24)
            }

            function r() {
                this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new n.Buf16(320), this.work = new n.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0
            }

            function s(t) {
                var e;
                return t && t.state ? (e = t.state, t.total_in = t.total_out = e.total = 0, t.msg = "", e.wrap && (t.adler = 1 & e.wrap), e.mode = 1, e.last = 0, e.havedict = 0, e.dmax = 32768, e.head = null, e.hold = 0, e.bits = 0, e.lencode = e.lendyn = new n.Buf32(852), e.distcode = e.distdyn = new n.Buf32(592), e.sane = 1, e.back = -1, 0) : p
            }

            function o(t) {
                var e;
                return t && t.state ? ((e = t.state).wsize = 0, e.whave = 0, e.wnext = 0, s(t)) : p
            }

            function l(t, e) {
                var a, n;
                return t && t.state ? (n = t.state, e < 0 ? (a = 0, e = -e) : (a = 1 + (e >> 4), e < 48 && (e &= 15)), e && (e < 8 || 15 < e) ? p : (null !== n.window && n.wbits !== e && (n.window = null), n.wrap = a, n.wbits = e, o(t))) : p
            }

            function h(t, e) {
                var a, n;
                return t ? (n = new r, (t.state = n).window = null, 0 !== (a = l(t, e)) && (t.state = null), a) : p
            }
            var y, m, b = !0;

            function H(t) {
                if (b) {
                    var e;
                    for (y = new n.Buf32(512), m = new n.Buf32(32), e = 0; e < 144;) t.lens[e++] = 8;
                    for (; e < 256;) t.lens[e++] = 9;
                    for (; e < 280;) t.lens[e++] = 7;
                    for (; e < 288;) t.lens[e++] = 8;
                    for (_(1, t.lens, 0, 288, y, 0, t.work, {
                            bits: 9
                        }), e = 0; e < 32;) t.lens[e++] = 5;
                    _(2, t.lens, 0, 32, m, 0, t.work, {
                        bits: 5
                    }), b = !1
                }
                t.lencode = y, t.lenbits = 9, t.distcode = m, t.distbits = 5
            }

            function j(t, e, a, u) {
                var f, g = t.state;
                return null === g.window && (g.wsize = 1 << g.wbits, g.wnext = 0, g.whave = 0, g.window = new n.Buf8(g.wsize)), u >= g.wsize ? (n.arraySet(g.window, e, a - g.wsize, g.wsize, 0), g.wnext = 0, g.whave = g.wsize) : (u < (f = g.wsize - g.wnext) && (f = u), n.arraySet(g.window, e, a - u, f, g.wnext), (u -= f) ? (n.arraySet(g.window, e, a - u, u, 0), g.wnext = u, g.whave = g.wsize) : (g.wnext += f, g.wnext === g.wsize && (g.wnext = 0), g.whave < g.wsize && (g.whave += f))), 0
            }
            a.inflateReset = o, a.inflateReset2 = l, a.inflateResetKeep = s, a.inflateInit = function(t) {
                return h(t, 15)
            }, a.inflateInit2 = h, a.inflate = function(t, e) {
                var a, y, m, b, w, x, v, S, E, C, A, k, B, R, z, V, Z, $, J, tt, et, it, st, at, nt = 0,
                    rt = new n.Buf8(4),
                    ot = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
                if (!t || !t.state || !t.output || !t.input && 0 !== t.avail_in) return p;
                12 === (a = t.state).mode && (a.mode = 13), w = t.next_out, m = t.output, v = t.avail_out, b = t.next_in, y = t.input, x = t.avail_in, S = a.hold, E = a.bits, C = x, A = v, it = 0;
                t: for (;;) switch (a.mode) {
                    case 1:
                        if (0 === a.wrap) {
                            a.mode = 13;
                            break
                        }
                        for (; E < 16;) {
                            if (0 === x) break t;
                            x--, S += y[b++] << E, E += 8
                        }
                        if (2 & a.wrap && 35615 === S) {
                            rt[a.check = 0] = 255 & S, rt[1] = S >>> 8 & 255, a.check = f(a.check, rt, 2, 0), E = S = 0, a.mode = 2;
                            break
                        }
                        if (a.flags = 0, a.head && (a.head.done = !1), !(1 & a.wrap) || (((255 & S) << 8) + (S >> 8)) % 31) {
                            t.msg = "incorrect header check", a.mode = 30;
                            break
                        }
                        if (8 != (15 & S)) {
                            t.msg = "unknown compression method", a.mode = 30;
                            break
                        }
                        if (E -= 4, et = 8 + (15 & (S >>>= 4)), 0 === a.wbits) a.wbits = et;
                        else if (et > a.wbits) {
                            t.msg = "invalid window size", a.mode = 30;
                            break
                        }
                        a.dmax = 1 << et, t.adler = a.check = 1, a.mode = 512 & S ? 10 : 12, E = S = 0;
                        break;
                    case 2:
                        for (; E < 16;) {
                            if (0 === x) break t;
                            x--, S += y[b++] << E, E += 8
                        }
                        if (a.flags = S, 8 != (255 & a.flags)) {
                            t.msg = "unknown compression method", a.mode = 30;
                            break
                        }
                        if (57344 & a.flags) {
                            t.msg = "unknown header flags set", a.mode = 30;
                            break
                        }
                        a.head && (a.head.text = S >> 8 & 1), 512 & a.flags && (rt[0] = 255 & S, rt[1] = S >>> 8 & 255, a.check = f(a.check, rt, 2, 0)), E = S = 0, a.mode = 3;
                    case 3:
                        for (; E < 32;) {
                            if (0 === x) break t;
                            x--, S += y[b++] << E, E += 8
                        }
                        a.head && (a.head.time = S), 512 & a.flags && (rt[0] = 255 & S, rt[1] = S >>> 8 & 255, rt[2] = S >>> 16 & 255, rt[3] = S >>> 24 & 255, a.check = f(a.check, rt, 4, 0)), E = S = 0, a.mode = 4;
                    case 4:
                        for (; E < 16;) {
                            if (0 === x) break t;
                            x--, S += y[b++] << E, E += 8
                        }
                        a.head && (a.head.xflags = 255 & S, a.head.os = S >> 8), 512 & a.flags && (rt[0] = 255 & S, rt[1] = S >>> 8 & 255, a.check = f(a.check, rt, 2, 0)), E = S = 0, a.mode = 5;
                    case 5:
                        if (1024 & a.flags) {
                            for (; E < 16;) {
                                if (0 === x) break t;
                                x--, S += y[b++] << E, E += 8
                            }
                            a.length = S, a.head && (a.head.extra_len = S), 512 & a.flags && (rt[0] = 255 & S, rt[1] = S >>> 8 & 255, a.check = f(a.check, rt, 2, 0)), E = S = 0
                        } else a.head && (a.head.extra = null);
                        a.mode = 6;
                    case 6:
                        if (1024 & a.flags && (x < (k = a.length) && (k = x), k && (a.head && (et = a.head.extra_len - a.length, a.head.extra || (a.head.extra = new Array(a.head.extra_len)), n.arraySet(a.head.extra, y, b, k, et)), 512 & a.flags && (a.check = f(a.check, y, k, b)), x -= k, b += k, a.length -= k), a.length)) break t;
                        a.length = 0, a.mode = 7;
                    case 7:
                        if (2048 & a.flags) {
                            if (0 === x) break t;
                            for (k = 0; et = y[b + k++], a.head && et && a.length < 65536 && (a.head.name += String.fromCharCode(et)), et && k < x;);
                            if (512 & a.flags && (a.check = f(a.check, y, k, b)), x -= k, b += k, et) break t
                        } else a.head && (a.head.name = null);
                        a.length = 0, a.mode = 8;
                    case 8:
                        if (4096 & a.flags) {
                            if (0 === x) break t;
                            for (k = 0; et = y[b + k++], a.head && et && a.length < 65536 && (a.head.comment += String.fromCharCode(et)), et && k < x;);
                            if (512 & a.flags && (a.check = f(a.check, y, k, b)), x -= k, b += k, et) break t
                        } else a.head && (a.head.comment = null);
                        a.mode = 9;
                    case 9:
                        if (512 & a.flags) {
                            for (; E < 16;) {
                                if (0 === x) break t;
                                x--, S += y[b++] << E, E += 8
                            }
                            if (S !== (65535 & a.check)) {
                                t.msg = "header crc mismatch", a.mode = 30;
                                break
                            }
                            E = S = 0
                        }
                        a.head && (a.head.hcrc = a.flags >> 9 & 1, a.head.done = !0), t.adler = a.check = 0, a.mode = 12;
                        break;
                    case 10:
                        for (; E < 32;) {
                            if (0 === x) break t;
                            x--, S += y[b++] << E, E += 8
                        }
                        t.adler = a.check = L(S), E = S = 0, a.mode = 11;
                    case 11:
                        if (0 === a.havedict) return t.next_out = w, t.avail_out = v, t.next_in = b, t.avail_in = x, a.hold = S, a.bits = E, 2;
                        t.adler = a.check = 1, a.mode = 12;
                    case 12:
                        if (5 === e || 6 === e) break t;
                    case 13:
                        if (a.last) {
                            S >>>= 7 & E, E -= 7 & E, a.mode = 27;
                            break
                        }
                        for (; E < 3;) {
                            if (0 === x) break t;
                            x--, S += y[b++] << E, E += 8
                        }
                        switch (a.last = 1 & S, E -= 1, 3 & (S >>>= 1)) {
                            case 0:
                                a.mode = 14;
                                break;
                            case 1:
                                if (H(a), a.mode = 20, 6 !== e) break;
                                S >>>= 2, E -= 2;
                                break t;
                            case 2:
                                a.mode = 17;
                                break;
                            case 3:
                                t.msg = "invalid block type", a.mode = 30
                        }
                        S >>>= 2, E -= 2;
                        break;
                    case 14:
                        for (S >>>= 7 & E, E -= 7 & E; E < 32;) {
                            if (0 === x) break t;
                            x--, S += y[b++] << E, E += 8
                        }
                        if ((65535 & S) != (S >>> 16 ^ 65535)) {
                            t.msg = "invalid stored block lengths", a.mode = 30;
                            break
                        }
                        if (a.length = 65535 & S, E = S = 0, a.mode = 15, 6 === e) break t;
                    case 15:
                        a.mode = 16;
                    case 16:
                        if (k = a.length) {
                            if (x < k && (k = x), v < k && (k = v), 0 === k) break t;
                            n.arraySet(m, y, b, k, w), x -= k, b += k, v -= k, w += k, a.length -= k;
                            break
                        }
                        a.mode = 12;
                        break;
                    case 17:
                        for (; E < 14;) {
                            if (0 === x) break t;
                            x--, S += y[b++] << E, E += 8
                        }
                        if (a.nlen = 257 + (31 & S), S >>>= 5, E -= 5, a.ndist = 1 + (31 & S), S >>>= 5, E -= 5, a.ncode = 4 + (15 & S), S >>>= 4, E -= 4, 286 < a.nlen || 30 < a.ndist) {
                            t.msg = "too many length or distance symbols", a.mode = 30;
                            break
                        }
                        a.have = 0, a.mode = 18;
                    case 18:
                        for (; a.have < a.ncode;) {
                            for (; E < 3;) {
                                if (0 === x) break t;
                                x--, S += y[b++] << E, E += 8
                            }
                            a.lens[ot[a.have++]] = 7 & S, S >>>= 3, E -= 3
                        }
                        for (; a.have < 19;) a.lens[ot[a.have++]] = 0;
                        if (a.lencode = a.lendyn, a.lenbits = 7, st = {
                                bits: a.lenbits
                            }, it = _(0, a.lens, 0, 19, a.lencode, 0, a.work, st), a.lenbits = st.bits, it) {
                            t.msg = "invalid code lengths set", a.mode = 30;
                            break
                        }
                        a.have = 0, a.mode = 19;
                    case 19:
                        for (; a.have < a.nlen + a.ndist;) {
                            for (; V = (nt = a.lencode[S & (1 << a.lenbits) - 1]) >>> 16 & 255, Z = 65535 & nt, !((z = nt >>> 24) <= E);) {
                                if (0 === x) break t;
                                x--, S += y[b++] << E, E += 8
                            }
                            if (Z < 16) S >>>= z, E -= z, a.lens[a.have++] = Z;
                            else {
                                if (16 === Z) {
                                    for (at = z + 2; E < at;) {
                                        if (0 === x) break t;
                                        x--, S += y[b++] << E, E += 8
                                    }
                                    if (S >>>= z, E -= z, 0 === a.have) {
                                        t.msg = "invalid bit length repeat", a.mode = 30;
                                        break
                                    }
                                    et = a.lens[a.have - 1], k = 3 + (3 & S), S >>>= 2, E -= 2
                                } else if (17 === Z) {
                                    for (at = z + 3; E < at;) {
                                        if (0 === x) break t;
                                        x--, S += y[b++] << E, E += 8
                                    }
                                    E -= z, et = 0, k = 3 + (7 & (S >>>= z)), S >>>= 3, E -= 3
                                } else {
                                    for (at = z + 7; E < at;) {
                                        if (0 === x) break t;
                                        x--, S += y[b++] << E, E += 8
                                    }
                                    E -= z, et = 0, k = 11 + (127 & (S >>>= z)), S >>>= 7, E -= 7
                                }
                                if (a.have + k > a.nlen + a.ndist) {
                                    t.msg = "invalid bit length repeat", a.mode = 30;
                                    break
                                }
                                for (; k--;) a.lens[a.have++] = et
                            }
                        }
                        if (30 === a.mode) break;
                        if (0 === a.lens[256]) {
                            t.msg = "invalid code -- missing end-of-block", a.mode = 30;
                            break
                        }
                        if (a.lenbits = 9, st = {
                                bits: a.lenbits
                            }, it = _(1, a.lens, 0, a.nlen, a.lencode, 0, a.work, st), a.lenbits = st.bits, it) {
                            t.msg = "invalid literal/lengths set", a.mode = 30;
                            break
                        }
                        if (a.distbits = 6, a.distcode = a.distdyn, st = {
                                bits: a.distbits
                            }, it = _(2, a.lens, a.nlen, a.ndist, a.distcode, 0, a.work, st), a.distbits = st.bits, it) {
                            t.msg = "invalid distances set", a.mode = 30;
                            break
                        }
                        if (a.mode = 20, 6 === e) break t;
                    case 20:
                        a.mode = 21;
                    case 21:
                        if (6 <= x && 258 <= v) {
                            t.next_out = w, t.avail_out = v, t.next_in = b, t.avail_in = x, a.hold = S, a.bits = E, g(t, A), w = t.next_out, m = t.output, v = t.avail_out, b = t.next_in, y = t.input, x = t.avail_in, S = a.hold, E = a.bits, 12 === a.mode && (a.back = -1);
                            break
                        }
                        for (a.back = 0; V = (nt = a.lencode[S & (1 << a.lenbits) - 1]) >>> 16 & 255, Z = 65535 & nt, !((z = nt >>> 24) <= E);) {
                            if (0 === x) break t;
                            x--, S += y[b++] << E, E += 8
                        }
                        if (V && 0 == (240 & V)) {
                            for ($ = z, J = V, tt = Z; V = (nt = a.lencode[tt + ((S & (1 << $ + J) - 1) >> $)]) >>> 16 & 255, Z = 65535 & nt, !($ + (z = nt >>> 24) <= E);) {
                                if (0 === x) break t;
                                x--, S += y[b++] << E, E += 8
                            }
                            S >>>= $, E -= $, a.back += $
                        }
                        if (S >>>= z, E -= z, a.back += z, a.length = Z, 0 === V) {
                            a.mode = 26;
                            break
                        }
                        if (32 & V) {
                            a.back = -1, a.mode = 12;
                            break
                        }
                        if (64 & V) {
                            t.msg = "invalid literal/length code", a.mode = 30;
                            break
                        }
                        a.extra = 15 & V, a.mode = 22;
                    case 22:
                        if (a.extra) {
                            for (at = a.extra; E < at;) {
                                if (0 === x) break t;
                                x--, S += y[b++] << E, E += 8
                            }
                            a.length += S & (1 << a.extra) - 1, S >>>= a.extra, E -= a.extra, a.back += a.extra
                        }
                        a.was = a.length, a.mode = 23;
                    case 23:
                        for (; V = (nt = a.distcode[S & (1 << a.distbits) - 1]) >>> 16 & 255, Z = 65535 & nt, !((z = nt >>> 24) <= E);) {
                            if (0 === x) break t;
                            x--, S += y[b++] << E, E += 8
                        }
                        if (0 == (240 & V)) {
                            for ($ = z, J = V, tt = Z; V = (nt = a.distcode[tt + ((S & (1 << $ + J) - 1) >> $)]) >>> 16 & 255, Z = 65535 & nt, !($ + (z = nt >>> 24) <= E);) {
                                if (0 === x) break t;
                                x--, S += y[b++] << E, E += 8
                            }
                            S >>>= $, E -= $, a.back += $
                        }
                        if (S >>>= z, E -= z, a.back += z, 64 & V) {
                            t.msg = "invalid distance code", a.mode = 30;
                            break
                        }
                        a.offset = Z, a.extra = 15 & V, a.mode = 24;
                    case 24:
                        if (a.extra) {
                            for (at = a.extra; E < at;) {
                                if (0 === x) break t;
                                x--, S += y[b++] << E, E += 8
                            }
                            a.offset += S & (1 << a.extra) - 1, S >>>= a.extra, E -= a.extra, a.back += a.extra
                        }
                        if (a.offset > a.dmax) {
                            t.msg = "invalid distance too far back", a.mode = 30;
                            break
                        }
                        a.mode = 25;
                    case 25:
                        if (0 === v) break t;
                        if (k = A - v, a.offset > k) {
                            if ((k = a.offset - k) > a.whave && a.sane) {
                                t.msg = "invalid distance too far back", a.mode = 30;
                                break
                            }
                            B = k > a.wnext ? (k -= a.wnext, a.wsize - k) : a.wnext - k, k > a.length && (k = a.length), R = a.window
                        } else R = m, B = w - a.offset, k = a.length;
                        for (v < k && (k = v), v -= k, a.length -= k; m[w++] = R[B++], --k;);
                        0 === a.length && (a.mode = 21);
                        break;
                    case 26:
                        if (0 === v) break t;
                        m[w++] = a.length, v--, a.mode = 21;
                        break;
                    case 27:
                        if (a.wrap) {
                            for (; E < 32;) {
                                if (0 === x) break t;
                                x--, S |= y[b++] << E, E += 8
                            }
                            if (A -= v, t.total_out += A, a.total += A, A && (t.adler = a.check = a.flags ? f(a.check, m, A, w - A) : u(a.check, m, A, w - A)), A = v, (a.flags ? S : L(S)) !== a.check) {
                                t.msg = "incorrect data check", a.mode = 30;
                                break
                            }
                            E = S = 0
                        }
                        a.mode = 28;
                    case 28:
                        if (a.wrap && a.flags) {
                            for (; E < 32;) {
                                if (0 === x) break t;
                                x--, S += y[b++] << E, E += 8
                            }
                            if (S !== (4294967295 & a.total)) {
                                t.msg = "incorrect length check", a.mode = 30;
                                break
                            }
                            E = S = 0
                        }
                        a.mode = 29;
                    case 29:
                        it = 1;
                        break t;
                    case 30:
                        it = -3;
                        break t;
                    case 31:
                        return -4;
                    default:
                        return p
                }
                return t.next_out = w, t.avail_out = v, t.next_in = b, t.avail_in = x, a.hold = S, a.bits = E, (a.wsize || A !== t.avail_out && a.mode < 30 && (a.mode < 27 || 4 !== e)) && j(t, t.output, t.next_out, A - t.avail_out) ? (a.mode = 31, -4) : (C -= t.avail_in, A -= t.avail_out, t.total_in += C, t.total_out += A, a.total += A, a.wrap && A && (t.adler = a.check = a.flags ? f(a.check, m, A, t.next_out - A) : u(a.check, m, A, t.next_out - A)), t.data_type = a.bits + (a.last ? 64 : 0) + (12 === a.mode ? 128 : 0) + (20 === a.mode || 15 === a.mode ? 256 : 0), (0 === C && 0 === A || 4 === e) && 0 === it && (it = -5), it)
            }, a.inflateEnd = function(t) {
                if (!t || !t.state) return p;
                var e = t.state;
                return e.window && (e.window = null), t.state = null, 0
            }, a.inflateGetHeader = function(t, e) {
                var a;
                return t && t.state ? 0 == (2 & (a = t.state).wrap) ? p : ((a.head = e).done = !1, 0) : p
            }, a.inflateSetDictionary = function(t, e) {
                var a, n = e.length;
                return t && t.state ? 0 !== (a = t.state).wrap && 11 !== a.mode ? p : 11 === a.mode && u(1, e, n, 0) !== a.check ? -3 : j(t, e, n, n) ? (a.mode = 31, -4) : (a.havedict = 1, 0) : p
            }, a.inflateInfo = "pako inflate (from Nodeca project)"
        }, {
            "../utils/common": 3,
            "./adler32": 5,
            "./crc32": 7,
            "./inffast": 10,
            "./inftrees": 12
        }],
        12: [function(t, e, a) {
            "use strict";
            var n = t("../utils/common"),
                u = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0],
                f = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78],
                g = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0],
                _ = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
            e.exports = function(t, e, a, p, y, m, b, w) {
                var x, v, S, E, C, A, k, B, R, z = w.bits,
                    V = 0,
                    Z = 0,
                    $ = 0,
                    J = 0,
                    tt = 0,
                    et = 0,
                    it = 0,
                    st = 0,
                    at = 0,
                    nt = 0,
                    rt = null,
                    ot = 0,
                    lt = new n.Buf16(16),
                    ht = new n.Buf16(16),
                    ct = null,
                    ut = 0;
                for (V = 0; V <= 15; V++) lt[V] = 0;
                for (Z = 0; Z < p; Z++) lt[e[a + Z]] ++;
                for (tt = z, J = 15; 1 <= J && 0 === lt[J]; J--);
                if (J < tt && (tt = J), 0 === J) return y[m++] = 20971520, y[m++] = 20971520, w.bits = 1, 0;
                for ($ = 1; $ < J && 0 === lt[$]; $++);
                for (tt < $ && (tt = $), V = st = 1; V <= 15; V++)
                    if (st <<= 1, (st -= lt[V]) < 0) return -1;
                if (0 < st && (0 === t || 1 !== J)) return -1;
                for (ht[1] = 0, V = 1; V < 15; V++) ht[V + 1] = ht[V] + lt[V];
                for (Z = 0; Z < p; Z++) 0 !== e[a + Z] && (b[ht[e[a + Z]] ++] = Z);
                if (A = 0 === t ? (rt = ct = b, 19) : 1 === t ? (rt = u, ot -= 257, ct = f, ut -= 257, 256) : (rt = g, ct = _, -1), V = $, C = m, it = Z = nt = 0, S = -1, E = (at = 1 << (et = tt)) - 1, 1 === t && 852 < at || 2 === t && 592 < at) return 1;
                for (;;) {
                    for (k = V - it, R = b[Z] < A ? (B = 0, b[Z]) : b[Z] > A ? (B = ct[ut + b[Z]], rt[ot + b[Z]]) : (B = 96, 0), x = 1 << V - it, $ = v = 1 << et; y[C + (nt >> it) + (v -= x)] = k << 24 | B << 16 | R | 0, 0 !== v;);
                    for (x = 1 << V - 1; nt & x;) x >>= 1;
                    if (0 !== x ? (nt &= x - 1, nt += x) : nt = 0, Z++, 0 == --lt[V]) {
                        if (V === J) break;
                        V = e[a + b[Z]]
                    }
                    if (tt < V && (nt & E) !== S) {
                        for (0 === it && (it = tt), C += $, st = 1 << (et = V - it); et + it < J && !((st -= lt[et + it]) <= 0);) et++, st <<= 1;
                        if (at += 1 << et, 1 === t && 852 < at || 2 === t && 592 < at) return 1;
                        y[S = nt & E] = tt << 24 | et << 16 | C - m | 0
                    }
                }
                return 0 !== nt && (y[C + nt] = V - it << 24 | 64 << 16 | 0), w.bits = tt, 0
            }
        }, {
            "../utils/common": 3
        }],
        13: [function(t, e, a) {
            "use strict";
            e.exports = {
                2: "need dictionary",
                1: "stream end",
                0: "",
                "-1": "file error",
                "-2": "stream error",
                "-3": "data error",
                "-4": "insufficient memory",
                "-5": "buffer error",
                "-6": "incompatible version"
            }
        }, {}],
        14: [function(t, e, a) {
            "use strict";
            var n = t("../utils/common");

            function i(t) {
                for (var e = t.length; 0 <= --e;) t[e] = 0
            }
            var u = 256,
                f = 286,
                g = 30,
                _ = 15,
                p = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0],
                y = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13],
                m = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7],
                b = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],
                w = new Array(576);
            i(w);
            var x = new Array(60);
            i(x);
            var v = new Array(512);
            i(v);
            var S = new Array(256);
            i(S);
            var E = new Array(29);
            i(E);
            var C, A, k, B = new Array(g);

            function I(t, e, a, n, u) {
                this.static_tree = t, this.extra_bits = e, this.extra_base = a, this.elems = n, this.max_length = u, this.has_stree = t && t.length
            }

            function r(t, e) {
                this.dyn_tree = t, this.max_code = 0, this.stat_desc = e
            }

            function U(t) {
                return t < 256 ? v[t] : v[256 + (t >>> 7)]
            }

            function T(t, e) {
                t.pending_buf[t.pending++] = 255 & e, t.pending_buf[t.pending++] = e >>> 8 & 255
            }

            function F(t, e, a) {
                t.bi_valid > 16 - a ? (t.bi_buf |= e << t.bi_valid & 65535, T(t, t.bi_buf), t.bi_buf = e >> 16 - t.bi_valid, t.bi_valid += a - 16) : (t.bi_buf |= e << t.bi_valid & 65535, t.bi_valid += a)
            }

            function L(t, e, a) {
                F(t, a[2 * e], a[2 * e + 1])
            }

            function H(t, e) {
                for (var a = 0; a |= 1 & t, t >>>= 1, a <<= 1, 0 < --e;);
                return a >>> 1
            }

            function j(t, e, a) {
                var n, u, f = new Array(16),
                    g = 0;
                for (n = 1; n <= _; n++) f[n] = g = g + a[n - 1] << 1;
                for (u = 0; u <= e; u++) {
                    var p = t[2 * u + 1];
                    0 !== p && (t[2 * u] = H(f[p] ++, p))
                }
            }

            function K(t) {
                var e;
                for (e = 0; e < f; e++) t.dyn_ltree[2 * e] = 0;
                for (e = 0; e < g; e++) t.dyn_dtree[2 * e] = 0;
                for (e = 0; e < 19; e++) t.bl_tree[2 * e] = 0;
                t.dyn_ltree[512] = 1, t.opt_len = t.static_len = 0, t.last_lit = t.matches = 0
            }

            function M(t) {
                8 < t.bi_valid ? T(t, t.bi_buf) : 0 < t.bi_valid && (t.pending_buf[t.pending++] = t.bi_buf), t.bi_buf = 0, t.bi_valid = 0
            }

            function P(t, e, a, n) {
                var u = 2 * e,
                    f = 2 * a;
                return t[u] < t[f] || t[u] === t[f] && n[e] <= n[a]
            }

            function Y(t, e, a) {
                for (var n = t.heap[a], u = a << 1; u <= t.heap_len && (u < t.heap_len && P(e, t.heap[u + 1], t.heap[u], t.depth) && u++, !P(e, n, t.heap[u], t.depth));) t.heap[a] = t.heap[u], a = u, u <<= 1;
                t.heap[a] = n
            }

            function q(t, e, a) {
                var n, f, g, _, m = 0;
                if (0 !== t.last_lit)
                    for (; n = t.pending_buf[t.d_buf + 2 * m] << 8 | t.pending_buf[t.d_buf + 2 * m + 1], f = t.pending_buf[t.l_buf + m], m++, 0 === n ? L(t, f, e) : (L(t, (g = S[f]) + u + 1, e), 0 !== (_ = p[g]) && F(t, f -= E[g], _), L(t, g = U(--n), a), 0 !== (_ = y[g]) && F(t, n -= B[g], _)), m < t.last_lit;);
                L(t, 256, e)
            }

            function G(t, e) {
                var a, n, u, f = e.dyn_tree,
                    g = e.stat_desc.static_tree,
                    p = e.stat_desc.has_stree,
                    y = e.stat_desc.elems,
                    m = -1;
                for (t.heap_len = 0, t.heap_max = 573, a = 0; a < y; a++) 0 !== f[2 * a] ? (t.heap[++t.heap_len] = m = a, t.depth[a] = 0) : f[2 * a + 1] = 0;
                for (; t.heap_len < 2;) f[2 * (u = t.heap[++t.heap_len] = m < 2 ? ++m : 0)] = 1, t.depth[u] = 0, t.opt_len--, p && (t.static_len -= g[2 * u + 1]);
                for (e.max_code = m, a = t.heap_len >> 1; 1 <= a; a--) Y(t, f, a);
                for (u = y; a = t.heap[1], t.heap[1] = t.heap[t.heap_len--], Y(t, f, 1), n = t.heap[1], t.heap[--t.heap_max] = a, t.heap[--t.heap_max] = n, f[2 * u] = f[2 * a] + f[2 * n], t.depth[u] = (t.depth[a] >= t.depth[n] ? t.depth[a] : t.depth[n]) + 1, f[2 * a + 1] = f[2 * n + 1] = u, t.heap[1] = u++, Y(t, f, 1), 2 <= t.heap_len;);
                t.heap[--t.heap_max] = t.heap[1],
                    function(t, e) {
                        var a, n, u, f, g, p, y = e.dyn_tree,
                            m = e.max_code,
                            b = e.stat_desc.static_tree,
                            w = e.stat_desc.has_stree,
                            x = e.stat_desc.extra_bits,
                            v = e.stat_desc.extra_base,
                            S = e.stat_desc.max_length,
                            E = 0;
                        for (f = 0; f <= _; f++) t.bl_count[f] = 0;
                        for (y[2 * t.heap[t.heap_max] + 1] = 0, a = t.heap_max + 1; a < 573; a++) S < (f = y[2 * y[2 * (n = t.heap[a]) + 1] + 1] + 1) && (f = S, E++), y[2 * n + 1] = f, m < n || (t.bl_count[f] ++, g = 0, v <= n && (g = x[n - v]), p = y[2 * n], t.opt_len += p * (f + g), w && (t.static_len += p * (b[2 * n + 1] + g)));
                        if (0 !== E) {
                            do {
                                for (f = S - 1; 0 === t.bl_count[f];) f--;
                                t.bl_count[f] --, t.bl_count[f + 1] += 2, t.bl_count[S] --, E -= 2
                            } while (0 < E);
                            for (f = S; 0 !== f; f--)
                                for (n = t.bl_count[f]; 0 !== n;) m < (u = t.heap[--a]) || (y[2 * u + 1] !== f && (t.opt_len += (f - y[2 * u + 1]) * y[2 * u], y[2 * u + 1] = f), n--)
                        }
                    }(t, e), j(f, m, t.bl_count)
            }

            function X(t, e, a) {
                var n, u, f = -1,
                    g = e[1],
                    _ = 0,
                    p = 7,
                    y = 4;
                for (0 === g && (p = 138, y = 3), e[2 * (a + 1) + 1] = 65535, n = 0; n <= a; n++) u = g, g = e[2 * (n + 1) + 1], ++_ < p && u === g || (_ < y ? t.bl_tree[2 * u] += _ : 0 !== u ? (u !== f && t.bl_tree[2 * u] ++, t.bl_tree[32] ++) : _ <= 10 ? t.bl_tree[34] ++ : t.bl_tree[36] ++, f = u, y = (_ = 0) === g ? (p = 138, 3) : u === g ? (p = 6, 3) : (p = 7, 4))
            }

            function W(t, e, a) {
                var n, u, f = -1,
                    g = e[1],
                    _ = 0,
                    p = 7,
                    y = 4;
                for (0 === g && (p = 138, y = 3), n = 0; n <= a; n++)
                    if (u = g, g = e[2 * (n + 1) + 1], !(++_ < p && u === g)) {
                        if (_ < y)
                            for (; L(t, u, t.bl_tree), 0 != --_;);
                        else 0 !== u ? (u !== f && (L(t, u, t.bl_tree), _--), L(t, 16, t.bl_tree), F(t, _ - 3, 2)) : _ <= 10 ? (L(t, 17, t.bl_tree), F(t, _ - 3, 3)) : (L(t, 18, t.bl_tree), F(t, _ - 11, 7));
                        f = u, y = (_ = 0) === g ? (p = 138, 3) : u === g ? (p = 6, 3) : (p = 7, 4)
                    }
            }
            i(B);
            var R = !1;

            function Q(t, e, a, u) {
                var f, g, _;
                F(t, 0 + (u ? 1 : 0), 3), g = e, _ = a, M(f = t), T(f, _), T(f, ~_), n.arraySet(f.pending_buf, f.window, g, _, f.pending), f.pending += _
            }
            a._tr_init = function(t) {
                R || (function() {
                    var t, e, a, n, u, b = new Array(16);
                    for (n = a = 0; n < 28; n++)
                        for (E[n] = a, t = 0; t < 1 << p[n]; t++) S[a++] = n;
                    for (S[a - 1] = n, n = u = 0; n < 16; n++)
                        for (B[n] = u, t = 0; t < 1 << y[n]; t++) v[u++] = n;
                    for (u >>= 7; n < g; n++)
                        for (B[n] = u << 7, t = 0; t < 1 << y[n] - 7; t++) v[256 + u++] = n;
                    for (e = 0; e <= _; e++) b[e] = 0;
                    for (t = 0; t <= 143;) w[2 * t + 1] = 8, t++, b[8] ++;
                    for (; t <= 255;) w[2 * t + 1] = 9, t++, b[9] ++;
                    for (; t <= 279;) w[2 * t + 1] = 7, t++, b[7] ++;
                    for (; t <= 287;) w[2 * t + 1] = 8, t++, b[8] ++;
                    for (j(w, 287, b), t = 0; t < g; t++) x[2 * t + 1] = 5, x[2 * t] = H(t, 5);
                    C = new I(w, p, 257, f, _), A = new I(x, y, 0, g, _), k = new I(new Array(0), m, 0, 19, 7)
                }(), R = !0), t.l_desc = new r(t.dyn_ltree, C), t.d_desc = new r(t.dyn_dtree, A), t.bl_desc = new r(t.bl_tree, k), t.bi_buf = 0, t.bi_valid = 0, K(t)
            }, a._tr_stored_block = Q, a._tr_flush_block = function(t, e, a, n) {
                var f, g, _ = 0;
                0 < t.level ? (2 === t.strm.data_type && (t.strm.data_type = function(t) {
                    var e, a = 4093624447;
                    for (e = 0; e <= 31; e++, a >>>= 1)
                        if (1 & a && 0 !== t.dyn_ltree[2 * e]) return 0;
                    if (0 !== t.dyn_ltree[18] || 0 !== t.dyn_ltree[20] || 0 !== t.dyn_ltree[26]) return 1;
                    for (e = 32; e < u; e++)
                        if (0 !== t.dyn_ltree[2 * e]) return 1;
                    return 0
                }(t)), G(t, t.l_desc), G(t, t.d_desc), _ = function(t) {
                    var e;
                    for (X(t, t.dyn_ltree, t.l_desc.max_code), X(t, t.dyn_dtree, t.d_desc.max_code), G(t, t.bl_desc), e = 18; 3 <= e && 0 === t.bl_tree[2 * b[e] + 1]; e--);
                    return t.opt_len += 3 * (e + 1) + 5 + 5 + 4, e
                }(t), f = t.opt_len + 3 + 7 >>> 3, (g = t.static_len + 3 + 7 >>> 3) <= f && (f = g)) : f = g = a + 5, a + 4 <= f && -1 !== e ? Q(t, e, a, n) : 4 === t.strategy || g === f ? (F(t, 2 + (n ? 1 : 0), 3), q(t, w, x)) : (F(t, 4 + (n ? 1 : 0), 3), function(t, e, a, n) {
                    var u;
                    for (F(t, e - 257, 5), F(t, a - 1, 5), F(t, n - 4, 4), u = 0; u < n; u++) F(t, t.bl_tree[2 * b[u] + 1], 3);
                    W(t, t.dyn_ltree, e - 1), W(t, t.dyn_dtree, a - 1)
                }(t, t.l_desc.max_code + 1, t.d_desc.max_code + 1, _ + 1), q(t, t.dyn_ltree, t.dyn_dtree)), K(t), n && M(t)
            }, a._tr_tally = function(t, e, a) {
                return t.pending_buf[t.d_buf + 2 * t.last_lit] = e >>> 8 & 255, t.pending_buf[t.d_buf + 2 * t.last_lit + 1] = 255 & e, t.pending_buf[t.l_buf + t.last_lit] = 255 & a, t.last_lit++, 0 === e ? t.dyn_ltree[2 * a] ++ : (t.matches++, e--, t.dyn_ltree[2 * (S[a] + u + 1)] ++, t.dyn_dtree[2 * U(e)] ++), t.last_lit === t.lit_bufsize - 1
            }, a._tr_align = function(t) {
                var e;
                F(t, 2, 3), L(t, 256, w), 16 === (e = t).bi_valid ? (T(e, e.bi_buf), e.bi_buf = 0, e.bi_valid = 0) : 8 <= e.bi_valid && (e.pending_buf[e.pending++] = 255 & e.bi_buf, e.bi_buf >>= 8, e.bi_valid -= 8)
            }
        }, {
            "../utils/common": 3
        }],
        15: [function(t, e, a) {
            "use strict";
            e.exports = function() {
                this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0
            }
        }, {}],
        "/": [function(t, e, a) {
            "use strict";
            var n = {};
            (0, t("./lib/utils/common").assign)(n, t("./lib/deflate"), t("./lib/inflate"), t("./lib/zlib/constants")), e.exports = n
        }, {
            "./lib/deflate": 1,
            "./lib/inflate": 2,
            "./lib/utils/common": 3,
            "./lib/zlib/constants": 6
        }]
    }, {}, [])("/"), window.fx = function(t) {
        "use strict";
        class e {
            constructor(t = 0, e = 0) {
                this.x = t, this.y = e
            }
            setValue(t, e) {
                return this.x = t, this.y = e, this
            }
            static scale(t, e, a) {
                a.x = t.x * e, a.y = t.y * e
            }
            fromArray(t, e = 0) {
                return this.x = t[e + 0], this.y = t[e + 1], this
            }
            toArray(t, e = 0) {
                t[e + 0] = this.x, t[e + 1] = this.y
            }
            cloneTo(t) {
                var e = t;
                e.x = this.x, e.y = this.y
            }
            from(t) {
                return this.x = t.x, this.y = t.y, this
            }
            isZero() {
                return this.lengthSqr() < 1e-6
            }
            distance(t) {
                let e = this.x - t.x,
                    a = this.y - t.y;
                return Math.sqrt(e * e + a * a)
            }
            distanceSq(t) {
                let e = this.x - t.x,
                    a = this.y - t.y;
                return e * e + a * a
            }
            sub(t) {
                return this.x -= t.x, this.y -= t.y, this
            }
            subOut(t) {
                let a = new e;
                return a.x = this.x - t.x, a.y = this.y - t.y, a
            }
            scale(t, a = !1) {
                let n = a ? new e(this.x, this.y) : this;
                return n.x *= t, n.y *= t, this
            }
            mul(t, a) {
                return (a = a || new e).x = this.x * t, a.y = this.y * t, a
            }
            fuzzyEquals(t, e) {
                return this.x - e <= t.x && t.x <= this.x + e && this.y - e <= t.y && t.y <= this.y + e
            }
            dot(t) {
                return this.x * t.x + this.y * t.y
            }
            cross(t) {
                return this.x * t.y - this.y * t.x
            }
            len() {
                return Math.sqrt(this.x * this.x + this.y * this.y)
            }
            lengthSqr() {
                return this.x * this.x + this.y * this.y
            }
            magSqr() {
                return this.lengthSqr()
            }
            normalize(t = 1) {
                let e = this.x,
                    a = this.y,
                    n = e * e + a * a;
                return n > 0 && (n = t / Math.sqrt(n), this.x = e * n, this.y = a * n), this
            }
            add(t) {
                return this.x += t.x, this.y += t.y, this
            }
            angle(t) {
                var e = this.magSqr(),
                    a = t.magSqr();
                if (0 === e || 0 === a) return console.warn("Can't get angle between zero vector"), 0;
                var n = this.dot(t) / Math.sqrt(e * a);
                return n = Math.clamp(n, -1, 1), Math.acos(n)
            }
            signAngle(t) {
                var e = this.angle(t);
                return this.cross(t) < 0 ? -e : e
            }
            rotate(t) {
                if (!t) return this;
                let e = this.x,
                    a = this.y;
                return this.x = e * Math.cos(t) - a * Math.sin(t), this.y = a * Math.cos(t) + e * Math.sin(t), this
            }
            static dot(t, e) {
                return t.x * e.x + t.y * e.y
            }
            static normalize(t, e) {
                var a = t.x,
                    n = t.y,
                    u = a * a + n * n;
                u > 0 && (u = 1 / Math.sqrt(u), e.x = a * u, e.y = n * u)
            }
            static scalarLength(t) {
                var e = t.x,
                    a = t.y;
                return Math.sqrt(e * e + a * a)
            }
            clone() {
                var t = new e;
                return this.cloneTo(t), t
            }
            forNativeElement(t = null) {
                t ? (this.elements = t, this.elements[0] = this.x, this.elements[1] = this.y) : this.elements = new Float32Array([this.x, this.y]), e.rewriteNumProperty(this, "x", 0), e.rewriteNumProperty(this, "y", 1)
            }
            static rewriteNumProperty(t, e, a) {
                Object.defineProperty(t, e, {get: function() {
                        return this.elements[a]
                    },
                    set: function(t) {
                        this.elements[a] = t
                    },
                    configurable: !0
                })
            }
            static lerp(t, e, a, n) {
                var u = t.x,
                    f = t.y;
                n.x = u + a * (e.x - u), n.y = f + a * (e.y - f)
            }
            lerp(t, a, n) {
                return n = n || new e, e.lerp(this, t, a, n), n
            }
            equal(t, e = 1e-6) {
                return Math.abs(this.x - t.x) < e && Math.abs(this.y - t.y) < e
            }
        }
        e.ZERO = new e(0, 0), e.ONE = new e(1, 1);
        class a {
            constructor(t = 0, e = 0, a = 0) {
                this.x = t, this.y = e, this.z = a
            }
            static distance(t, e) {
                var a = t.x - e.x,
                    n = t.y - e.y,
                    u = t.z - e.z;
                return Math.sqrt(a * a + n * n + u * u)
            }
            static min(t, e, a) {
                a.x = Math.min(t.x, e.x), a.y = Math.min(t.y, e.y), a.z = Math.min(t.z, e.z)
            }
            static max(t, e, a) {
                a.x = Math.max(t.x, e.x), a.y = Math.max(t.y, e.y), a.z = Math.max(t.z, e.z)
            }
            static add(t, e, a) {
                a.x = t.x + e.x, a.y = t.y + e.y, a.z = t.z + e.z
            }
            static subtract(t, e, a) {
                a.x = t.x - e.x, a.y = t.y - e.y, a.z = t.z - e.z
            }
            static cross(t, e, a) {
                var n = t.x,
                    u = t.y,
                    f = t.z,
                    g = e.x,
                    _ = e.y,
                    p = e.z;
                a.x = u * p - f * _, a.y = f * g - n * p, a.z = n * _ - u * g
            }
            static dot(t, e) {
                return t.x * e.x + t.y * e.y + t.z * e.z
            }
            static scalarLength(t) {
                var e = t.x,
                    a = t.y,
                    n = t.z;
                return Math.sqrt(e * e + a * a + n * n)
            }
            static scalarLengthSquared(t) {
                var e = t.x,
                    a = t.y,
                    n = t.z;
                return e * e + a * a + n * n
            }
            static normalize(t, e) {
                var a = t.x,
                    n = t.y,
                    u = t.z,
                    f = a * a + n * n + u * u;
                f > 0 && (f = 1 / Math.sqrt(f), e.x = a * f, e.y = n * f, e.z = u * f)
            }
            static multiply(t, e, a) {
                a.x = t.x * e.x, a.y = t.y * e.y, a.z = t.z * e.z
            }
            static scale(t, e, a) {
                a.x = t.x * e, a.y = t.y * e, a.z = t.z * e
            }
            static lerp(t, e, a, n) {
                var u = t.x,
                    f = t.y,
                    g = t.z;
                n.x = u + a * (e.x - u), n.y = f + a * (e.y - f), n.z = g + a * (e.z - g)
            }
            static Clamp(t, e, a, n) {
                var u = t.x,
                    f = t.y,
                    g = t.z,
                    _ = e.x,
                    p = e.y,
                    y = e.z,
                    m = a.x,
                    b = a.y,
                    w = a.z;
                u = (u = u > m ? m : u) < _ ? _ : u, f = (f = f > b ? b : f) < p ? p : f, g = (g = g > w ? w : g) < y ? y : g, n.x = u, n.y = f, n.z = g
            }
            normalize(t = 1) {
                let e = this.x,
                    a = this.y,
                    n = e * e + a * a;
                return n > 0 && (n = t / Math.sqrt(n), this.x = e * n, this.y = a * n), this
            }
            setValue(t, e, a) {
                this.x = t, this.y = e, this.z = a
            }
        }
        a.ZERO = new a(0, 0, 0), a.ONE = new a(1, 1, 1), a.UnitX = new a(1, 0, 0), a.UnitY = new a(0, 1, 0), a.UnitZ = new a(0, 0, 1);
        class n {
            constructor(t = 0, e = 0, a = 0, n = 0) {
                this.x = t, this.y = e, this.z = a, this.w = n
            }
        }
        const u = {
            x: .3,
            y: .59,
            z: .11
        };
        class f {
            static isGetterSetter(t, e) {
                let a = Object.getOwnPropertyDescriptor(t, e) || {};
                return a.get || a.set
            }
            static isNumber(t) {
                return !isNaN(t) && ("number" == typeof t || t instanceof Number)
            }
            static isStrNumber(t) {
                return Number.isFinite(+t)
            }
            static isString(t) {
                return "string" == typeof t || t instanceof String
            }
            static isFunction(t) {
                return t && "function" == typeof t
            }
            static isFunctionEx(t, e) {
                return "function" == typeof t[e]
            }
            static isObject(t) {
                return t && "object" == typeof t && !1 === Array.isArray(t)
            }
            static isBool(t) {
                return "boolean" == typeof t
            }
            static getDeepFunctions(t) {
                if (t && t !== Object.prototype) {
                    let e = Object.getOwnPropertyNames(t).filter((e => this.isGetterSetter(t, e) || this.isFunctionEx(t, e))),
                        a = this.getDeepFunctions(Object.getPrototypeOf(t));
                    return a && (e = e.concat(a)), e
                }
            }
            static getUniqueDeepFunctions(t) {
                return Array.from(new Set(this.getDeepFunctions(t)))
            }
            static getUserFunctions(t) {
                let e = this.getUniqueDeepFunctions(t);
                return e = e.filter((t => "constructor" !== t && !~t.indexOf("__"))), e
            }
            static enableLog() {
                Laya.Log.enable();
                let t = console.log;
                console.log = function(e) {
                    Laya.Log.print(e), t(e)
                }
            }
            static profile(t) {
                if (!t) throw Error("profile key is unexpected !!!");
                this.profileMap[t] = Laya.Browser.now()
            }
            static profileEnd(t, e = 0) {
                if (!t) throw Error("profile key is unexpected !!!");
                if (this.profileMap[t]) {
                    let a = Laya.Browser.now() - this.profileMap[t];
                    return delete this.profileMap[t], a > e && console.log("%c################ %s: %sms", "color:#00aa00", t, a), a
                }
                return 0
            }
            static isEmpty(t) {
                for (const e in t) return !1;
                return !0
            }
            static getGID() {
                return Laya.Utils.getGID()
            }
            static isOnMiniGame() {
                if (Laya.isWXPlayable) return !0;
                let t = window.sdk.Sdk;
                return !!window.biliMiniGame || (t.isOnToutiao() || t.isOnWeiXin() || t.isOnQQ() || t.isOnOppo() || t.isOnBaidu() || t.isOnVivo() || t.isOnKuaiShou() || t.isOnXiaoMi() || t.isOnHuaWei() || t.isOnALIPAY())
            }
            static isOnPC() {
                if (Laya.isWXPlayable) return !1;
                let t = Laya.Browser,
                    e = t._window || window,
                    a = t.userAgent || e.navigator.userAgent,
                    n = e.location.href;
                return -1 != a.indexOf("Windows") && !n.includes("http")
            }
            static isOnNativeAndroid() {
                if (!window.conchConfig) return !1;
                return "Conch-android" == window.conchConfig.getOS()
            }
            static isOnNativeIos() {
                if (!window.conchConfig) return !1;
                return "Conch-ios" == window.conchConfig.getOS()
            }
            static isOnIOS() {
                if (this.isOnNativeIos()) return !0;
                let t = Laya.Browser,
                    e = t._window || window;
                return !!(t.userAgent || e.navigator.userAgent).match(/\(i[^;]+;( U;)? CPU.+Mac OS X/)
            }
            static isQMP() {
                if (void 0 !== this.sIsQMP) return this.sIsQMP;
                let t = !1,
                    e = Laya.Browser.clientWidth,
                    a = Laya.Browser.clientHeight;
                if (console.log("isQMP userAgent:", Laya.Browser.window.navigator.userAgent, e, a), Laya.Browser.onAndroid) t = Laya.stage.scaleMode == Laya.Stage.SCREEN_VERTICAL ? a / e > 2 : e / a > 2;
                else {
                    let n = /iPhone/gi.test(Laya.Browser.window.navigator.userAgent) && 375 == Math.min(a, e) && 812 == Math.max(a, e),
                        u = 414 == Math.min(a, e) && 896 == Math.max(a, e),
                        f = Laya.MiniAdpter,
                        g = Laya.BMiniAdapter;
                    (Laya.Browser.onMiniGame && !Laya.Browser.onAndroid && -1 != f.systemInfo.model.indexOf("iPhone X") || Laya.Browser.onBDMiniGame && !Laya.Browser.onAndroid && -1 != g.systemInfo.model.indexOf("iPhone X") || n || u) && (t = !0)
                }
                return console.log("isQMP = ", t), this.sIsQMP = t, t
            }
            static isNotchScreenDevice() {
                if (void 0 !== this.sNotchScreen) return this.sNotchScreen;
                let t = null;
                if (Laya.isWXPlayable) window.wx && (t = wx.getSystemInfoSync());
                else {
                    t = Laya.ClassUtils.getRegClass("Sdk").instance.getSystemInfo()
                }
                let e = Laya.LocalStorage.getItem("testNotch");
                if (this.isOnPC() && e && (t.model = "iPhone X"), t && t.model) {
                    for (let e of this.NotchScreenCfg) {
                        if (-1 != t.model.indexOf(e.model)) {
                            this.sNotchScreen = e;
                            break
                        }
                        let a = e.model.replace(/\s/g, "");
                        if (-1 != t.model.indexOf(a)) {
                            this.sNotchScreen = e;
                            break
                        }
                    }
                    if (!this.sNotchScreen)
                        if (t.safeArea) {
                            if (Laya.stage.scaleMode == Laya.Stage.SCREEN_VERTICAL || Laya.stage.scaleMode == Laya.Stage.SCALE_FIXED_AUTO && Laya.stage.screenMode == Laya.Stage.SCREEN_VERTICAL) {
                                let e = t.safeArea.top || 0;
                                if (e > 20) {
                                    let a = Math.max(t.screenHeight - t.safeArea.bottom, 0);
                                    this.sNotchScreen = {
                                        model: t.model,
                                        notchTop: e,
                                        notchBottom: a
                                    }
                                }
                            } else {
                                let e = t.safeArea.left || 0;
                                if (e > 20) {
                                    let a = Math.max(t.screenWidth - t.safeArea.right, 0);
                                    this.sNotchScreen = {
                                        model: t.model,
                                        notchTop: e,
                                        notchBottom: a
                                    }
                                }
                            }
                            this.sNotchScreen || (this.sNotchScreen = null)
                        } else {
                            if (Laya.stage.scaleMode == Laya.Stage.SCREEN_VERTICAL || Laya.stage.scaleMode == Laya.Stage.SCALE_FIXED_AUTO && Laya.stage.screenMode == Laya.Stage.SCREEN_VERTICAL) {
                                let e = null;
                                Laya.isWXPlayable ? window.wx && wx.getMenuButtonBoundingClientRect && (e = wx.getMenuButtonBoundingClientRect()) : e = window.sdk.Sdk.instance.getMenuButtonBoundingClientRect(), e && e.top > 20 ? this.sNotchScreen = {
                                    model: t.model,
                                    notchTop: e.top,
                                    notchBottom: 20
                                } : this.sNotchScreen = null
                            }!this.sNotchScreen && this.isQMP() && (this.sNotchScreen = {
                                model: t.model,
                                notchTop: 30,
                                notchBottom: 20
                            })
                        }
                }
                return this.sNotchScreen ? console.log("isNotchScreenDevice: ", JSON.stringify(this.sNotchScreen)) : console.log("isNotchScreenDevice: false"), this.sNotchScreen
            }
            static randomArray(t) {
                if (!t || 0 == t.length) return t;
                let e = t.length;
                for (; e;) {
                    let a = Math.floor(Math.random() * e--);
                    [t[a], t[e]] = [t[e], t[a]]
                }
                return t
            }
            static randomArrayEx(t) {
                if (!t || 0 == t.length) return [];
                let e = (t = t.slice()).length;
                for (; e;) {
                    let a = Math.floor(Math.random() * e--);
                    [t[a], t[e]] = [t[e], t[a]]
                }
                return t
            }
            static diffArray(t, e, a = !1) {
                return t && 0 != t.length ? e && 0 != e.length ? a ? t.filter((t => !e.includes(t))).concat(e.filter((e => !t.includes(e)))) : t.filter((t => !e.includes(t))) : t.concat([]) : e.concat([])
            }
            static randomInArray(t) {
                if (!t || 0 == t.length) return null;
                return t[Math.floor(Math.random() * t.length)]
            }
            static randomInArrayEx(t, e) {
                if (!t || 0 == t.length) return null;
                let a = this.copyArray(t);
                if (this.randomArray(a), e <= a.length) return a.slice(0, Math.min(e, a.length)); {
                    let n = e - a.length,
                        u = 0;
                    for (; n--;) a.push(t[u]), u++, u %= t.length;
                    return this.randomArray(a), a
                }
            }
            static showTips(t, e = 2, a, n = "#ffffff") {
                let u = new Laya.Label;
                u.fontSize = 30, u.color = n, u.centerX = 0, u.centerY = 0, u.bold = !0, u.stroke = 5, u.strokeColor = "#000000", u.text = t;
                let f = u.width + 50,
                    g = u.height + 30,
                    _ = new Laya.Box;
                _.zOrder = 1e4, _.width = f, _.height = g, a ? (_.x = a.x, _.y = a.y) : (_.x = Laya.stage.width - _.width >> 1, _.y = 300), Laya.stage.addChild(_);
                let p = new Laya.Image("res/img_tips.png");
                p.sizeGrid = "25,27,30,26", p.width = f, p.height = g, p.alpha = .5, _.addChild(p), _.addChild(u), Laya.Tween.from(_, {
                    y: 400,
                    alpha: 0
                }, 200, null, Laya.Handler.create(this, (() => {
                    Laya.Tween.to(_, {
                        y: 200,
                        alpha: 0
                    }, 200, null, Laya.Handler.create(this, (() => {
                        _.destroy()
                    })), 1e3 * e, !0, !0)
                })))
            }
            static adaptNode(t, e, a, n = !0, u) {
                const adaptFunc = function(f, g) {
                    if (u) {
                        let u = e / f,
                            _ = a / g,
                            p = n ? Math.max(u, _) : Math.min(u, _);
                        t.scaleX = t.scaleY = p
                    } else {
                        let u = f / g,
                            _ = u * a,
                            p = e / u;
                        n ? _ * a > e * p ? (f = _, g = a) : (f = e, g = p) : _ * a < e * p ? (f = _, g = a) : (f = e, g = p), t.width = f, t.height = g
                    }
                };
                if (t instanceof Laya.Image && "img_bg" != t.name) {
                    if (t._RegisterLoaded) return;
                    t._RegisterLoaded = !0, t.on(Laya.Event.LOADED, this, (() => {
                        t.destroyed || t._bitmap && t._bitmap._source && (t.width = t._bitmap._source.width, t.height = t._bitmap._source.height, adaptFunc(t.width, t.height))
                    }))
                } else adaptFunc(t.width, t.height)
            }
            static getClassName(t) {
                return t.__proto__.constructor.name
            }
            static checkClick(t = 300) {
                let e = Laya.Browser.now();
                return e - this.lastClickTime <= t ? (this.lastClickTime = e, !0) : (this.lastClickTime = e, !1)
            }
            static rgbToHsb(t, e, a) {
                let n, u, f;
                t /= 255, e /= 255, a /= 255;
                let g = Math.min(t, e, a),
                    _ = f = Math.max(t, e, a),
                    p = _ - g;
                if (_ == g) n = 0;
                else {
                    switch (_) {
                        case t:
                            n = (e - a) / p + (e < a ? 6 : 0);
                            break;
                        case e:
                            n = 2 + (a - t) / p;
                            break;
                        case a:
                            n = 4 + (t - e) / p
                    }
                    n = Math.round(60 * n) - 180
                }
                return u = 0 == _ ? 0 : 1 - g / _, u = Math.round(200 * u) - 100, f = Math.round(200 * f) - 100, [n, u, f]
            }
            static hsbToRgb(t, e, a) {
                let n = (e + 100) / 200,
                    u = (a + 100) / 200,
                    f = t + 180,
                    g = 0,
                    _ = 0,
                    p = 0,
                    y = parseInt((f / 60 % 6).toString()),
                    m = f / 60 - y,
                    b = u * (1 - n),
                    w = u * (1 - m * n),
                    x = u * (1 - (1 - m) * n);
                switch (y) {
                    case 0:
                        g = u, _ = x, p = b;
                        break;
                    case 1:
                        g = w, _ = u, p = b;
                        break;
                    case 2:
                        g = b, _ = u, p = x;
                        break;
                    case 3:
                        g = b, _ = w, p = u;
                        break;
                    case 4:
                        g = x, _ = b, p = u;
                        break;
                    case 5:
                        g = u, _ = b, p = w
                }
                return g = parseInt((255 * g).toString()), _ = parseInt((255 * _).toString()), p = parseInt((255 * p).toString()), [g, _, p]
            }
            static copyArray(t) {
                if (!t) return t;
                let e = new Array;
                return Laya.Utils.copyArray(e, t)
            }
            static cloneArray(t) {
                if (!t) return t;
                let e = new Array;
                for (let a = 0; a < t.length; a++) {
                    let n = t[a];
                    e[a] = n instanceof Array ? this.cloneArray(n) : n instanceof Object ? this.cloneDeep(n) : n
                }
                return e
            }
            static clone(t) {
                let e = {},
                    a = Object.getOwnPropertyNames(t);
                for (let n of a) e[n] = t[n];
                return e
            }
            static cloneDeep(t) {
                if (!t) return;
                if (this.isString(t) || this.isNumber(t)) return t;
                let e = t instanceof Array ? [] : {},
                    a = Object.getOwnPropertyNames(t);
                for (let n of a) {
                    let a = t[n];
                    e[n] = a instanceof Array ? this.copyArray(a) : a instanceof Object ? this.cloneDeep(a) : a
                }
                return e
            }
            static getFileExt(t) {
                return Laya.Utils.getFileExtension(t)
            }
            static getGlobalBounds(t, e) {
                let a = t.getBounds();
                a = a.clone();
                let n = new Laya.Point(a.x, a.y);
                return n = t.parent.localToGlobal(n), e ? (n = e.globalToLocal(n), a.setTo(n.x, n.y, a.width, a.height)) : a.setTo(n.x, n.y, a.width, a.height), a
            }
            static getIntRandom(t, e) {
                return Math.floor(Math.random() * (e - t + 1) + t)
            }
            static getIntRandomEx(t, e) {
                return Math.floor(Math.randomEx() * (e - t + 1) + t)
            }
            static getNumberRandom(t, e) {
                return Math.random() * (e - t) + t
            }
            static getNumberRandomEx(t, e) {
                return Math.randomEx() * (e - t) + t
            }
            static getSignRandom() {
                return 0 == this.getIntRandom(0, 1) ? -1 : 1
            }
            static formatNumber(t, e = 0) {
                if (this.isNumber(t)) {
                    let a = t.toFixed(e);
                    return a = a.split("").reverse().join("").replace(/(\d{3})/g, "$1,").replace(/\,$/, "").split("").reverse().join(""), a
                }
                return (t = 0).toFixed(e)
            }
            static formatString(t, e) {
                let a = e;
                if ("object" != typeof a) {
                    a = {};
                    for (let t in arguments) "0" !== t && (a[Number(t) - 1] = arguments[t])
                }
                for (let e in a) {
                    let f = a[e];
                    n = e, u = f, t = t.replace(new RegExp("\\{" + n + "\\}", "gm"), u)
                }
                var n, u;
                return t
            }
            static checkPowerOf2(t) {
                return 0 == (t &= t - 1)
            }
            static getIndex2N(t) {
                if (1 == t) return 0;
                if (this.checkPowerOf2(t)) {
                    let e = 1;
                    for (; t;) {
                        if (1 == t || 2 == t) return e;
                        t % 2 == 0 && (t >>= 1, e += 1)
                    }
                }
                return -1
            }
            static getIndexN(t, e) {
                let a = t;
                for (let n = 0; n < e; ++n) a *= t;
                return a
            }
            static roundNumber(t, e) {
                let a = Math.pow(10, e);
                return Math.round(t * a) / a
            }
            static showBorder(t, e = !0, a, n) {
                let u = t;
                if (!e) return void(u.__border && (Laya.timer.clearAll(u), u.__border.removeSelf(), u.__border = null));
                if (u.__border) return;
                let f = new Laya.Sprite;
                u.__border = f, Laya.stage.addChild(f), Laya.timer.loop(50, u, (function() {
                    let e = fx.Utils.getGlobalBounds(t, n);
                    f.graphics.clear(), a = a || "#ff0000", f.graphics.drawRect(e.x, e.y, e.width, e.height, null, a, 2)
                })), t.once(Laya.Event.REMOVED, this, (() => {
                    this.showBorder(t, !1)
                }))
            }
            static showRect(t, e, a = !0, n) {
                let u = e;
                if (!a) return void(u.__border && (Laya.timer.clearAll(u), u.__border.removeSelf(), u.__border = null));
                if (u.__border) return;
                let f = new Laya.Sprite;
                u.__border = f, e.addChild(f), f.graphics.clear(), n = n || "#ff0000", f.graphics.drawRect(t.x, t.y, t.width, t.height, null, n, 2), e.once(Laya.Event.REMOVED, this, (() => {
                    this.showRect(t, e, !1)
                }))
            }
            static showRedDot(t, a) {
                let n, u;
                if (t instanceof Laya.Point || t instanceof e ? (n = Laya.stage, u = t) : (n = t, a ? u = new Laya.Point(a.x, a.y) : (u = new Laya.Point(n.x, n.y), u = n.fromParentPoint(u))), n.__reddot) return;
                let f = new Laya.Sprite;
                f.scale(1 / n.scaleX, 1 / n.scaleY), f.x = u.x, f.y = u.y, n.addChild(f), f.graphics.clear(), f.graphics.drawCircle(0, 0, 5, "#ff0000", "#ff0000", 2), n.__reddot = f, n.once(Laya.Event.REMOVED, this, (function() {
                    n.__reddot = void 0, f.removeSelf()
                }))
            }
            static pathInfo(t) {
                let e = "",
                    a = "",
                    n = "",
                    u = "",
                    f = "",
                    g = "",
                    _ = t;
                if (t) {
                    _ = t.replace("\\", "/");
                    let p = t.match(/((^.+)\/)((\w+)(\.(\w+)))/i);
                    p && p.length > 1 ? (e = p[1], a = p[2], n = p[3], u = p[4], f = p[5], g = p[6]) : u = t
                }
                return {
                    dir: e,
                    dirname: a,
                    file: n,
                    filename: u,
                    ext: f,
                    extname: g,
                    full: _
                }
            }
            static createAnim(t, e) {
                let a = new Laya.Animation;
                return a.loadAnimation(t, Laya.Handler.create(this, (function() {
                    !a.destroyed && e && e.runWith(a)
                }))), a
            }
            static playAnim(t, e, a, n, u) {
                t.play(a, n, u), e && (n ? t.on(Laya.Event.COMPLETE, e.caller, (function() {
                    e.run()
                })) : t.once(Laya.Event.COMPLETE, e.caller, (function() {
                    e.run()
                })))
            }
            static getAnimSize(t, e) {
                if (t.isPlaying) {
                    let a = t.getSelfBounds();
                    e.runWith(a)
                } else {
                    t.play();
                    let func = function() {
                        t.gotoAndStop(0);
                        let a = t.getSelfBounds();
                        e.runWith(a)
                    };
                    t.once(Laya.Event.REMOVED, this, (() => {
                        Laya.timer.clear(this, func)
                    })), Laya.timer.frameOnce(1, this, func)
                }
            }
            static createAni(t) {
                let e = new Laya.Animation;
                return t.parent.addChild(e), e.pos(t.pos.x, t.pos.y, !0), e.offAll(), e.on(Laya.Event.LABEL, t.lbCaller, t.lbCb), e.on(Laya.Event.COMPLETE, t.completeCaller, t.completeCb), e
            }
            static playAni(t, e, a, n, u, f, g, _) {
                t && t.loadAnimation(e, Laya.Handler.create(this, (() => {
                    t.visible = !0, t.play(n, u, a), f && g && g.apply(f, _)
                })))
            }
            static recoverAni(t) {
                t && (t.offAll(), t.loop = !1, t.removeSelf())
            }
            static getLength(t) {
                return Object.keys(t).length
            }
            static randomByRate(t) {
                return t > 1 && (t *= .01), Math.random() > 1 - t
            }
            static applyMixins(t, e, a) {
                t.prototype && e.forEach((e => {
                    Object.getOwnPropertyNames(e.prototype).forEach((n => {
                        "constructor" != n && (t.prototype[n] = e.prototype[n], t._super = a)
                    }))
                }))
            }
            static super(t) {
                let e = this.getModule(t);
                return e._super || e.__super || e.__proto__
            }
            static getModule(t) {
                return t.__proto__.constructor
            }
            static getNumberZeroAmount(t) {
                if (null == t || isNaN(t)) return console.log("非法参数"), [0, 0];
                let e = 0;
                for (;;) {
                    let a = t / 1e3;
                    if (a < 1) break;
                    t = a, e += 1
                }
                return [t = 0 !== e ? Number(t.toFixed(2)) : Math.floor(t), 3 * e]
            }
            static getStringZeroAmount(t) {
                if (null == t || "string" != typeof t) return console.log("非法参数"), [0, 0];
                let e = t.indexOf("."),
                    a = 0,
                    n = 0,
                    u = (t = t.slice(0, e)).length;
                n = Math.floor(u / 3), a = u % 3, 0 == a && (a = 3, n -= 1);
                let f = Number(t.slice(a, a + 2));
                return f = Number(t.slice(a + 2, a + 3)) >= 5 ? f + 1 : f, [Number(t.slice(0, a) + "." + f), 3 * n]
            }
            static formatNumberWithUnits(t) {
                let [e, a] = f.getFormatNumberWithUnitsInfo(t);
                return e + a
            }
            static getFormatNumberWithUnitsInfo(t, e) {
                let [a, n] = [null, null];
                "number" == typeof t ? [a, n] = f.getNumberZeroAmount(t) : "string" == typeof t && ([a, n] = f.getStringZeroAmount(t));
                let u = "" + n,
                    g = null;
                return g = null != e ? e[u] : f.numberUnit[u], null == g && (g = ""), [a, g]
            }
            static takeOneByWeight(t, e) {
                let a = [];
                if (e) {
                    let n = t,
                        u = e;
                    if (n.length !== u.length) return void console.log("对象数组和权重数组长度不匹配!!!");
                    for (let t = 0; t < n.length; ++t) {
                        let e = n[t],
                            f = u[t];
                        a.push({
                            o: e,
                            weight: f
                        })
                    }
                } else a = t;
                if (!a) return void console.log("带权数组为空!!!");
                let n = 0,
                    u = [];
                for (let t = 0; t < a.length; ++t) {
                    let e = a[t].weight;
                    null != e && (n += e, u.push({
                        prob: e,
                        index: t,
                        ele: a[t]
                    }))
                }
                let g = null,
                    _ = 0,
                    p = f.getIntRandom(1, n),
                    y = 0;
                for (let t = 0; t < u.length; ++t)
                    if (y += u[t].prob, p <= y) {
                        g = u[t].ele, _ = u[t].index;
                        break
                    }
                return [_, g]
            }
            static takeSomeByWeight(t, e, a) {
                let n = [];
                if (a) {
                    let t = e,
                        u = a;
                    if (t.length !== u.length) return void console.log("对象数组和权重数组长度不匹配!!!");
                    for (let e = 0; e < t.length; ++e) {
                        let a = t[e],
                            f = u[e];
                        n.push({
                            o: a,
                            weight: f
                        })
                    }
                } else n = e;
                if (null == n) return void console.log("带权数组为空!!!");
                let u = [],
                    g = n.slice();
                for (let e = 0; e < t; ++e) {
                    let [t, e] = f.takeOneByWeight(g);
                    g.splice(t, 1), u.push([t, e])
                }
                return u
            }
            static getUIFrameAnimation(t, e) {
                return t[e]
            }
            static getDefaultUIFrameAnimation(t) {
                let e = t._aniList;
                if (e && e.length > 0) return e[0]
            }
            static getAnimationActionName(t) {
                return t._actionName
            }
            static getAnimationUrl(t) {
                return t._url
            }
            static timestampToTime(t, e) {
                e ? !e.separator && (e.separator = ["h ", "m ", "s"]) : e = {
                    separator: ["h ", "m ", "s"],
                    isAlign: !1
                };
                let a = t / 1e3,
                    n = Math.floor(a / 3600),
                    u = "";
                n >= 0 && (u = n < 10 && e.isAlign ? "0" + n + e.separator[0] : n + e.separator[0]);
                let f = Math.floor(a % 3600 / 60),
                    g = "";
                f >= 0 && (g = f < 10 && e.isAlign ? "0" + f + e.separator[1] : f + e.separator[1]);
                let _ = Math.floor(a % 60),
                    p = "";
                return _ >= 0 && (p = _ < 10 && e.isAlign ? "0" + _ + e.separator[2] : _ + e.separator[2]), u + g + p
            }
            static timestampToMS(t, e) {
                e ? !e.separator && (e.separator = ["m ", "s"]) : e = {
                    separator: ["m ", "s"],
                    isAlign: !1
                };
                let a = t / 1e3,
                    n = Math.floor(a % 3600 / 60),
                    u = "";
                n >= 0 && (u = n < 10 && e.isAlign ? "0" + n + e.separator[0] : n + e.separator[0]);
                let f = Math.floor(a % 60),
                    g = "";
                return f >= 0 && (g = f < 10 && e.isAlign ? "0" + f : f + "", e.separator[1] && (g += e.separator[1])), u + g
            }
            static timestampToHM(t, e) {
                e ? !e.separator && (e.separator = ["h ", "m"]) : e = {
                    separator: ["h ", "m"],
                    isAlign: !1
                };
                let a = t / 1e3,
                    n = Math.floor(a / 3600),
                    u = "";
                n >= 0 && (u = n < 10 && e.isAlign ? "0" + n + e.separator[0] : n + e.separator[0]);
                let f = Math.floor(a % 3600 / 60),
                    g = "";
                return f >= 0 && (g = f < 10 && e.isAlign ? "0" + f + e.separator[1] : f + e.separator[1]), u + g
            }
            static countdown(t, e, a) {
                const clear = function() {
                        e.clearTimer(e, tick)
                    },
                    tick = () => {
                        t = Math.max(t - 1e3, 0), a.call(e, t), t <= 0 && (clear(), e.off(Laya.Event.REMOVED, this, clear))
                    };
                e.once(Laya.Event.REMOVED, this, clear), e.timerLoop(1e3, e, tick)
            }
            static getDayInYear(t) {
                let e = t || new Date,
                    a = new Date(e.getFullYear().toString()).getTime(),
                    n = e.getTime();
                return Math.ceil((n - a) / 864e5)
            }
            static initRelativeDate(t) {
                f.relativeDate = t, f.localLaunchDate = new Date
            }
            static getDate() {
                return f.relativeDate || new Date
            }
            static getTime() {
                if (f.relativeDate) {
                    let t = (new Date).getTime() - f.localLaunchDate.getTime();
                    return f.relativeDate.getTime() + t
                }
                return (new Date).getTime()
            }
            static getCurDayStartTime() {
                let t = this.getDate().toLocaleDateString();
                return new Date(t).getTime()
            }
            static getCurEndStartTime() {
                return this.getCurDayStartTime() + 864e5 - 1
            }
            static getYearWeek() {
                let t = new Date,
                    e = t.getDay();
                0 == e && (e = 7);
                let a = new Date(t.getFullYear(), 0, 1),
                    n = a.getDay();
                0 == n && (n = 7);
                let u = Math.round((t.getTime() - a.getTime() + 864e5 * (n - e)) / 864e5);
                return {
                    year: t.getFullYear(),
                    week: Math.ceil(u / 7) + 1
                }
            }
            static isToday(t) {
                let e;
                e = "string" == typeof t ? new Date(t) : t;
                let a = new Date;
                return e >= new Date(a.getFullYear(), a.getMonth(), a.getDate())
            }
            static assign(t, e, a = !0, n = !0) {
                let u = a ? Object.keys(t) : Object.keys(e);
                return e instanceof Array && u.pop(), this.assignFrom(t, e, u, n)
            }
            static assignFrom(t, e, a, n) {
                let u = [];
                for (let f of a) null == e[f] || e[f] == t[f] || !n && null != t[f] || (t[f] = e[f], u.push(f));
                return u
            }
            static stringformat(t, e) {
                return this.formatString(t, e)
            }
            static binarySearch(t, e, a = 1) {
                let n = 0,
                    u = t.length - 1;
                for (; n <= u;) {
                    let f = Math.floor((n + u) / 2),
                        g = Math.min(f + a, u),
                        _ = e(t[f], t[g], f);
                    if (0 == _) return f;
                    _ > 0 ? n = f : u = f
                }
                return -1
            }
            static resetAnchor(t, e, a) {
                if (e < 0 || e > 1 || a < 0 || a > 1 || 0 == t.scaleX || 0 == t.scaleY) return;
                let n, u, f = t.anchorX,
                    g = t.anchorY;
                if (e == f && a == g) return n = f * t.width, u = g * t.height, void t.pivot(n, u);
                !f && t.pivotX && !g && t.pivotY && (f = t.pivotX / t.width, g = t.pivotY / t.height), f = f || 0, g = g || 0, n = (e - f) * t.width, u = (a - g) * t.height, t.anchorX = e, t.anchorY = a, t.pivot(n, u), n *= t.scaleX, u *= t.scaleY, t.x += n, t.y += u
            }
            static resetPivot(t, e, a) {
                let n = t.pivotX,
                    u = t.pivotY,
                    f = e / t.width,
                    g = a / t.height,
                    _ = n / t.width,
                    p = u / t.height,
                    y = (f - _) * t.width * t.scaleX,
                    m = (g - p) * t.height * t.scaleY;
                t.pivot(e, a), t.x += y, t.y += m
            }
            static generatePicture(t, e, a, n, u) {
                e = e || 0, a = a || 0, n = n || t.width, u = u || t.height;
                let g = t.drawToCanvas(n, u, e, a).toBase64("image/png", .9);
                g = g.substring(g.indexOf("base64") + 7);
                let _ = `${Laya.MiniFileMgr.fileNativeDir}/tmp_qrcode.png`;
                Laya.MiniFileMgr.fs.writeFile({
                    filePath: _,
                    data: g,
                    encoding: "base64",
                    success: t => {
                        wx.saveImageToPhotosAlbum({
                            filePath: _,
                            success: t => {
                                f.showTips("成功")
                            },
                            fail: t => {
                                f.showTips("失败")
                            }
                        })
                    },
                    fail: t => {
                        f.showTips("保存失败")
                    }
                })
            }
            static renderToTexture(t, e, a, n = 0, u = 0, f) {
                let g;
                if (e = e || t.width, a = a || t.height, Laya.stage.addChild(t), f) {
                    g = f;
                    let _ = t.drawToTexture(e, a, n, u, f.bitmap);
                    g.bitmap = _
                } else g = t.drawToTexture(e, a, n, u), Laya.CallLater.I.callLater(this, (() => {
                    g.bitmap.lock = !1, g.destroy()
                }));
                return Laya.stage.removeChild(t), g
            }
            static mixturePicture(t, e) {
                if (!window.wx) return;
                let a = t.width,
                    n = t.height,
                    u = t.drawToCanvas(a, n, 0, 0).toBase64("image/png", .9);
                u = u.substring(u.indexOf("base64") + 7);
                let f = `${Laya.MiniFileMgr.fileNativeDir}/tmp_qrcode.png`;
                Laya.MiniFileMgr.fs.writeFile({
                    filePath: f,
                    data: u,
                    encoding: "base64",
                    success: t => {
                        console.log(f), e(f)
                    },
                    fail: t => {}
                })
            }
            static deltaDays(t, e) {
                let a = (e - t) / 1e3;
                return Math.floor(a / 86400)
            }
            static equal(t, e, a = 1e-6) {
                return Math.abs(t - e) < a
            }
            static str2Boolean(t) {
                if ("string" != typeof t) return !1;
                let e = t.toLowerCase();
                return "false" !== e && "" !== e
            }
            static str2Number(t) {
                let e = 0;
                for (let a = 0; a < t.length; a++) {
                    let n = t.charCodeAt(a);
                    n <<= a, e += n
                }
                return e
            }
            static getFrameDelta(t) {
                let e = .001 * Laya.timer.delta;
                return t && (e = Math.min(e, t)), e
            }
            static createPrefabs(t, e = 1) {
                let a = [];
                if (!Laya.loader.getRes(t)) throw `需要先加载${t}才可以创建`;
                for (let n = 0; n < e; ++n) a.push(this.createPrefab(t));
                return a
            }
            static createPrefab(t, e) {
                if (!e) {
                    let e = Laya.loader.getRes(t);
                    if (e instanceof Laya.Prefab) return e.create(); {
                        let t = e;
                        return e = new Laya.Prefab, e.json = t, e.create()
                    }
                }
                Laya.loader.load(t, Laya.Handler.create(this, (() => {
                    if (e.caller.destroyed) return;
                    let a, n = Laya.loader.getRes(t);
                    if (n instanceof Laya.Prefab) a = n.create();
                    else {
                        let t = n;
                        n = new Laya.Prefab, n.json = t, a = n.create()
                    }
                    e.runWith(a)
                })))
            }
            static getEnumArray(t) {
                let e = 0,
                    a = [];
                for (; t[e];) a.push(t[e]), e++;
                return a
            }
            static getEnumKeyMap(t) {
                let e = this.getEnumArray(t),
                    a = {};
                for (const n of e) null != t[n] && (a[n] = n);
                return a
            }
            static MeterToKilometer(t) {
                if (t < 1e4) return t + "m";
                return (t / 1e3).toFixed(1) + "km"
            }
            static getCirclePoint(t, a, n) {
                let u = Math.rad(n),
                    f = t.x + Math.sin(u) * a,
                    g = t.y - Math.cos(u) * a;
                return new e(f, g)
            }
            static compareVersion(t, e) {
                let a = t;
                if (!a || !a.split) return 0;
                let n = e;
                if (!n || !n.split) return 0;
                let u = a.split("."),
                    f = n.split(".");
                const g = Math.max(u.length, f.length);
                for (; u.length < g;) u.push("0");
                for (; f.length < g;) f.push("0");
                for (let t = 0; t < g; t++) {
                    const e = parseInt(u[t]),
                        a = parseInt(f[t]);
                    if (e > a) return 1;
                    if (e < a) return -1
                }
                return 0
            }
            static compatibleVersion(t, e) {
                return f.compareVersion(t, e) >= 0
            }
            static defineProperty(t, e, a, n = "_") {
                if (!Object.getOwnPropertyDescriptor(t, e)) {
                    let u = n + e;
                    delete t[e], t.hasOwnProperty(u) || null == a || (t[u] = a), Object.defineProperty(t, e, {set: function(t) {
                            this[u] != t && (this[u] = t)
                        },
                        get: function() {
                            return this[u]
                        },
                        configurable: !0
                    })
                }
            }
            static definePropertyEx(t, e, a) {
                Object.getOwnPropertyDescriptor(t, e) ? console.warn(`already defined property: ${e} !`) : (delete t[e], Object.defineProperty(t, e, {
                    value: a.value,
                    enumerable: a.enumerable,
                    writable: a.writable,
                    configurable: a.configurable
                }))
            }
            static warpObjectGetterSetter(t, e) {
                let a = t;
                for (const n in t)
                    if (t.hasOwnProperty(n)) {
                        let u = a[n];
                        delete a[n], u instanceof Object ? Object.defineProperty(t, n, {get: function() {
                                return a["_" + n]
                            },
                            set: function(t) {
                                a["_" + n] = t, e && e.call(a, n)
                            },
                            enumerable: !1,
                            configurable: !0
                        }) : Object.defineProperty(t, n, {get: function() {
                                return a["_" + n]
                            },
                            set: function(t) {
                                t !== a["_" + n] && (a["_" + n] = t, e && e.call(a, n))
                            },
                            enumerable: !1,
                            configurable: !0
                        }), a["_" + n] = u, e && e.call(a, n)
                    }
            }
            static warpObjectGetterSetterAppend(t, e, a) {
                let n = t;
                for (const u of e) {
                    let e = n[u];
                    delete n[u], e instanceof Object ? Object.defineProperty(t, u, {get: function() {
                            return n["_" + u]
                        },
                        set: function(t) {
                            n["_" + u] = t, a && a.call(n, u)
                        },
                        enumerable: !1,
                        configurable: !0
                    }) : Object.defineProperty(t, u, {get: function() {
                            return n["_" + u]
                        },
                        set: function(t) {
                            t !== n["_" + u] && (n["_" + u] = t, a && a.call(n, u))
                        },
                        enumerable: !1,
                        configurable: !0
                    }), n["_" + u] = e, a && a.call(n, u)
                }
            }
            static warpObjectGetterSetterPrefix(t, e, a) {
                let n = t;
                const proc = (a, u, f) => {
                    let g = n[a];
                    delete n[a], g instanceof Object ? Object.defineProperty(t, a, {get: function() {
                            return u ? u.call(n) : n["_" + a]
                        },
                        set: function(t) {
                            f ? f.call(n, t) : n["_" + a] = t, e && e.call(n, a)
                        },
                        enumerable: !1,
                        configurable: !0
                    }) : Object.defineProperty(t, a, {get: function() {
                            return u ? u.call(n) : n["_" + a]
                        },
                        set: function(t) {
                            if (f) f.call(n, t);
                            else {
                                if (t === n["_" + a]) return;
                                n["_" + a] = t
                            }
                            e && e.call(n, a)
                        },
                        enumerable: !1,
                        configurable: !0
                    }), f ? f.call(n, g) : n["_" + a] = g, e && e.call(n, a)
                };
                let u = this.getUserFunctions(t);
                for (; t && t != Object.prototype;) {
                    a = a || Object.getOwnPropertyNames(t);
                    for (const e of a)
                        if (this.isGetterSetter(t, e) || this.isFunctionEx(t, e)) {
                            if (u.includes(e) && this.isGetterSetter(t, e)) {
                                let a = Object.getOwnPropertyDescriptor(t, e),
                                    n = a.get,
                                    u = a.set;
                                proc(e, n, u)
                            }
                        } else n != t || u.find((t => e.includes(t))) || proc(e);
                    t = Object.getPrototypeOf(t)
                }
            }
            static getUIComponetRoot(t) {
                if (!t.scene) return;
                let e = t.scene.getModuleUrlName();
                if (e) return e;
                let a = t.scene;
                for (; a.parent && (a = a.parent, !a.getModuleUrlName || (e = a.getModuleUrlName(), !e)););
                return e
            }
            static asyncProcess(t, e, a = 30) {
                const clearFunc = () => {
                        Laya.timer.clear(this, loopFunc), t.off(Laya.Event.REMOVED, this, clearFunc)
                    },
                    loopFunc = () => {
                        for (;;) {
                            if (Laya.stage.getTimeFromFrameStart() >= a) return;
                            if (e.run()) return void clearFunc()
                        }
                    };
                Laya.timer.frameLoop(1, this, loopFunc), t.once(Laya.Event.REMOVED, this, clearFunc)
            }
            static bindVarByName(t, e) {
                let a = e ? e.getChildren() : t.getChildren(),
                    n = t;
                for (const e of a) {
                    let a = e.name;
                    if (a) {
                        if (n[a]) throw Error("bindVarByName failed, already exist !!!");
                        n[a] = e
                    }
                    e.numChildren > 0 && this.bindVarByName(t, e)
                }
            }
            static bindScriptVarByName(t, e) {
                let a, n = Object.getOwnPropertyNames(t);
                if (n && n.length) {
                    e || (e = t.owner), a = e.getChildren();
                    for (const e of a) {
                        let a = e.name;
                        a && -1 !== n.indexOf(a) && (t[a] = e), e.numChildren > 0 && this.bindScriptVarByName(t, e)
                    }
                }
            }
            static clearUIComponentPositionInfo(t) {
                t && (t.x = t.y = t.left = t.right = t.top = t.bottom = t.centerX = t.centerY = void 0)
            }
            static getHashCode(t, e) {
                e || (t = t.toLowerCase());
                let a, n, u = 1315423911;
                for (a = t.length - 1; a >= 0; a--) n = t.charCodeAt(a), u ^= (u << 5) + n + (u >> 2);
                return 2147483647 & u
            }
            static createUUID() {
                let t = [],
                    e = "0123456789abcdef";
                for (let a = 0; a < 36; a++) t[a] = e.substr(Math.floor(16 * Math.random()), 1);
                return t[14] = "4", t[19] = e.substr(3 & t[19] | 8, 1), t[8] = t[13] = t[18] = t[23] = "-", t.join("")
            }
            static createUUIDEx(t, e) {
                var a, n, u = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split(""),
                    f = [];
                if (e = e || u.length, t)
                    for (a = 0; a < t; a++) f[a] = u[0 | Math.random() * e];
                else
                    for (f[8] = f[13] = f[18] = f[23] = "-", f[14] = "4", a = 0; a < 36; a++) f[a] || (n = 0 | 16 * Math.random(), f[a] = u[19 == a ? 3 & n | 8 : n]);
                return f.join("")
            }
            static remap(t, e, a, n, u) {
                return n + (t - e) / (a - e) * (u - n)
            }
            static colorHexTo3I(t) {
                if ("#" != t.charAt(0)) return new a;
                t = t.substr(1);
                let e = parseInt(t, 16);
                return new a((16711680 & e) >> 16, (65280 & e) >> 8, 255 & e)
            }
            static colorHexTo3F(t) {
                if ("#" != t.charAt(0)) return new a;
                t = t.substr(1);
                let e = parseInt(t, 16);
                return new a(((16711680 & e) >> 16) / 255, ((65280 & e) >> 8) / 255, (255 & e) / 255)
            }
            static colorHexTo4I(t) {
                if ("#" != t.charAt(0)) return new n;
                t = t.substr(1);
                let e = parseInt(t, 16);
                return new n((16711680 & e) >> 16, (65280 & e) >> 8, 255 & e, 255)
            }
            static colorHexTo4F(t) {
                if ("#" != t.charAt(0)) return new n;
                t = t.substr(1);
                let e = parseInt(t, 16);
                return new n(((16711680 & e) >> 16) / 255, ((65280 & e) >> 8) / 255, (255 & e) / 255, 1)
            }
            static getRandomColor4F() {
                let t = fx.Utils.getNumberRandom(0, 1),
                    e = fx.Utils.getNumberRandom(0, 1),
                    a = fx.Utils.getNumberRandom(0, 1);
                return new n(t, e, a, 1)
            }
            static getRandomColor3F() {
                let t = fx.Utils.getNumberRandom(0, 1),
                    e = fx.Utils.getNumberRandom(0, 1),
                    n = fx.Utils.getNumberRandom(0, 1);
                return new a(t, e, n)
            }
            static color3Fto3I(t) {
                return new a(255 * t.x, 255 * t.y, 255 * t.z)
            }
            static color3Ito3F(t) {
                return new a(t.x / 255, t.y / 255, t.z / 255)
            }
            static color3Fto4F(t) {
                return new n(t.x, t.y, t.z, 1)
            }
            static color4Fto3F(t) {
                return new a(t.x, t.y, t.z)
            }
            static color4Fto3I(t) {
                return new a(255 * t.x, 255 * t.y, 255 * t.z)
            }
            static color3Ito4F(t) {
                return new n(t.x / 255, t.y / 255, t.z / 255, 1)
            }
            static getColorLumin3F(t) {
                return a.dot(t, u)
            }
            static getColorLumin3I(t) {
                let e = this.color3Ito3F(t);
                return this.getColorLumin3F(e)
            }
            static setColorLumin3F(t, e) {
                let n = this.getColorLumin3F(t);
                return a.scale(t, e / n, t), a.Clamp(t, a.ZERO, a.ONE, t), t
            }
            static getColorLumin4F(t) {
                return a.dot(t, u)
            }
            static setColorLumin4F(t, e) {
                let a = this.color4Fto3F(t);
                return a = this.setColorLumin3F(a, e), t.setValue(a.x, a.y, a.z, t.w), t
            }
            static getRandomColorString() {
                let t = fx.Utils.getIntRandom(0, 255),
                    e = fx.Utils.getIntRandom(0, 255),
                    a = fx.Utils.getIntRandom(0, 255);
                return this.getHexColorStringI(t, e, a)
            }
            static getHexColorStringF(t, e, a) {
                return t = Math.floor(255 * t), e = Math.floor(255 * e), a = Math.floor(255 * a), this.getHexColorStringI(t, e, a)
            }
            static getHexColorStringI(t, e, a) {
                let n = (t << 16) + (e << 8) + a;
                return Laya.Utils.toHexColor(n)
            }
            static setTimerSpeed(t) {
                Laya.startTimer.speed = t, Laya.physicsTimer.speed = t, Laya.updateTimer.speed = t, Laya.lateTimer.speed = t, Laya.timer.speed = t
            }
            static clearUnusedRes(t) {
                let e = Laya.URL.formatURL(t),
                    a = Laya.Loader.getAtlas(e);
                if (a)
                    for (let t = 0, e = a.length; t < e; t++) {
                        let e = a[t],
                            n = Laya.Loader.getRes(e);
                        if (n && n._referenceCount > 0) return
                    }
                let n = Laya.Loader.textureMap[e];
                n && n._referenceCount > 0 || Laya.loader.clearRes(t)
            }
            static recurisNode(t, e, a = !1) {
                if (a) {
                    const anonymous = function(t) {
                        let a = t.getChildren();
                        for (const t of a) {
                            let e = anonymous(t);
                            if (!1 === e) return e;
                            if (-1 === e) break
                        }
                        return e(t)
                    };
                    anonymous(t)
                } else {
                    let a = [];
                    for (a.push(t); a.length > 0;) {
                        let t = a.shift(),
                            n = e(t);
                        if (!1 === n) return n;
                        if (-1 === n) continue;
                        let u = t.getChildren();
                        for (const t of u) a.push(t)
                    }
                }
            }
            static randomPointInRect(t, a = 1, n) {
                let u, f, g = 2 * a,
                    _ = !1;
                t.forEach((t => {
                    if (u = t, !u.__grid) {
                        let e = Math.ceil(t.width / g),
                            a = Math.ceil(t.height / g);
                        u.__grid = [];
                        for (let t = 0; t < e; t++) u.__grid[t] = new Array(a).fill(0);
                        _ = !0
                    }
                })), _ && n && n.length > 0 && this.occupyPointsInRects(t, n), fx.Utils.randomArray(t);
                let p = t.length;
                for (; p-- && (f = t[p], u = f, "full" == u.__grid);); - 1 == p && console.warn("randomPointInRect: 已占满！请缩小radius或者减少数量！");
                let y, m, b = new e(f.x, f.y),
                    w = new e(f.right, f.bottom),
                    x = u.__grid,
                    v = x.length,
                    S = x[0].length,
                    E = v * S;
                for (; E--;) {
                    y = fx.Utils.getNumberRandomEx(b.x, w.x), m = fx.Utils.getNumberRandomEx(b.y, w.y);
                    let t = w.x - b.x,
                        e = w.y - b.y,
                        n = Math.min(Math.floor((y - b.x) / t * v), v - 1),
                        u = Math.min(Math.floor((m - b.y) / e * S), S - 1);
                    if (0 == x[n][u]) {
                        x[n][u] = 1, y = (n + 1) / v * t + b.x - a, m = (u + 1) / S * e + b.y - a;
                        break
                    }
                }
                return -1 == E && (u.__grid = "full"), new e(y, m)
            }
            static occupyPointsInRects(t, a) {
                let n, u, f = t.length;
                for (; f--;) {
                    n = t[f], u = n;
                    let g = u.__grid;
                    if (g && "full" != g) {
                        let t = new e(n.x, n.y),
                            u = new e(n.right, n.bottom),
                            f = g.length,
                            _ = g[0].length;
                        for (let e = a.length - 1; e >= 0; --e) {
                            let n = a[e],
                                p = e;
                            if (n.x >= t.x && n.x <= u.x && n.y >= t.y && n.y <= u.y) {
                                let e = u.x - t.x,
                                    y = u.y - t.y,
                                    m = Math.min(Math.floor((n.x - t.x) / e * f), f - 1),
                                    b = Math.min(Math.floor((n.y - t.y) / y * _), _ - 1);
                                0 == g[m][b] && (g[m][b] = 1, a.splice(p, 1))
                            }
                        }
                    }
                    if (0 == a.length) break
                } - 1 == f && console.warn("occupyPointsInBounds 失败！不在范围内? 已占满? 没有创建格子?")
            }
            static randomPointInCircle(t, a = 1, n) {
                let u, f = 2 * a,
                    g = new e,
                    _ = !1;
                t.forEach((t => {
                    if (!t.__grid) {
                        let n = 2 * t.radius,
                            u = Math.ceil(n / f),
                            p = new e;
                        p.x = t.center.x - t.radius, p.y = t.center.y - t.radius;
                        let y = new e;
                        y.x = t.center.x + t.radius, y.y = t.center.y + t.radius, t.__min = p, t.__max = y;
                        let m = t.__grid = [];
                        for (let e = 0; e < u; e++) {
                            m[e] = new Array(u);
                            for (let f = 0; f < u; f++) {
                                let _ = (e + 1) / u * n + p.x - a,
                                    y = (f + 1) / u * n + p.y - a;
                                g.setValue(_, y);
                                let b = Math.pow(t.radius + .01, 2);
                                g.distanceSq(t.center) > b ? m[e][f] = 1 : m[e][f] = 0
                            }
                        }
                        _ = !0
                    }
                })), _ && n && n.length > 0 && this.occupyPointsInCircles(t, n), fx.Utils.randomArray(t);
                let p = t.length;
                for (; p-- && (u = t[p], "full" == u.__grid);); - 1 == p && console.warn("randomPointInCircles: 已占满！请缩小radius或者减少数量！");
                let y, m, b = u.__min,
                    w = u.__max,
                    x = u.__grid,
                    v = x.length,
                    S = x[0].length,
                    E = v * S;
                for (; E--;) {
                    y = fx.Utils.getNumberRandomEx(b.x, w.x), m = fx.Utils.getNumberRandomEx(b.y, w.y);
                    let t = w.x - b.x,
                        e = Math.min(Math.floor((y - b.x) / t * v), v - 1),
                        n = Math.min(Math.floor((m - b.y) / t * S), S - 1);
                    if (0 == x[e][n]) {
                        x[e][n] = 1, y = (e + 1) / v * t + b.x - a, m = (n + 1) / S * t + b.y - a;
                        break
                    }
                }
                return -1 == E && (u.__grid = "full"), new e(y, m)
            }
            static occupyPointsInCircles(t, e) {
                let a, n = t.length;
                for (; n--;) {
                    a = t[n];
                    let u = a.__grid;
                    if (u && "full" != u) {
                        let t = a.__min,
                            n = a.__max,
                            f = u.length;
                        for (let g = e.length - 1; g >= 0; --g) {
                            let _ = e[g],
                                p = g,
                                y = a.radius * a.radius;
                            if (_.distanceSq(a.center) <= y) {
                                let a = n.x - t.x,
                                    g = Math.min(Math.floor((_.x - t.x) / a * f), f - 1),
                                    y = Math.min(Math.floor((_.y - t.y) / a * f), f - 1);
                                0 == u[g][y] && (u[g][y] = 1, e.splice(p, 1))
                            }
                        }
                    }
                    if (0 == e.length) break
                } - 1 == n && console.warn("occupyPointsInCircles 失败！不在范围内? 已占满? 没有创建格子?")
            }
            static calcBezierPoint2D(t, a) {
                t = Math.clamp(t, 0, 1);
                const factorial = function(t) {
                    return t <= 1 ? 1 : t * factorial(t - 1)
                };
                let n = new e,
                    u = a.length - 1;
                return a.forEach(((e, a) => {
                    a ? (n.x += factorial(u) / factorial(a) / factorial(u - a) * e.x * Math.pow(1 - t, u - a) * Math.pow(t, a), n.y += factorial(u) / factorial(a) / factorial(u - a) * e.y * Math.pow(1 - t, u - a) * Math.pow(t, a)) : (n.x += e.x * Math.pow(1 - t, u - a) * Math.pow(t, a), n.y += e.y * Math.pow(1 - t, u - a) * Math.pow(t, a))
                })), n
            }
            static union(t) {
                let e = [];
                for (const a of t) e.includes(a) || e.push(a);
                return e
            }
        }
        f.NotchScreenCfg = [{
            model: "PAAM00",
            notchTop: 80,
            notchBottom: 10
        }, {
            model: "PAAT00",
            notchTop: 80,
            notchBottom: 10
        }, {
            model: "PACM00",
            notchTop: 80,
            notchBottom: 10
        }, {
            model: "PACT00",
            notchTop: 80,
            notchBottom: 10
        }, {
            model: "CPH1831",
            notchTop: 80,
            notchBottom: 10
        }, {
            model: "CPH1833",
            notchTop: 80,
            notchBottom: 10
        }, {
            model: "PBCM10",
            notchTop: 80,
            notchBottom: 10
        }, {
            model: "V1732A",
            notchTop: 36,
            notchBottom: 10
        }, {
            model: "V1934A",
            notchTop: 46,
            notchBottom: 0
        }, {
            model: "V2047A",
            notchTop: 31,
            notchBottom: 0
        }, {
            model: "V2056A",
            notchTop: 36,
            notchBottom: 10
        }, {
            model: "VOG-AL10",
            notchTop: 36,
            notchBottom: 10
        }, {
            model: "SEA-AL10",
            notchTop: 30,
            notchBottom: 0
        }, {
            model: "PBEM00",
            notchTop: 30,
            notchBottom: 0
        }, {
            model: "iPhone X",
            notchTop: 44,
            notchBottom: 30
        }, {
            model: "iPhone 11",
            notchTop: 64,
            notchBottom: 30
        }, {
            model: "iPhone 12",
            notchTop: 64,
            notchBottom: 30
        }, {
            model: "iPhone 13",
            notchTop: 64,
            notchBottom: 30
        }, {
            model: "iPhone 14",
            notchTop: 64,
            notchBottom: 30
        }, {
            model: "iPhone 15",
            notchTop: 64,
            notchBottom: 30
        }, {
            model: "iPhone 15 Pro",
            notchTop: 54,
            notchBottom: 34
        }, {
            model: "iPhone 15 Pro Max",
            notchTop: 54,
            notchBottom: 34
        }, {
            model: "iPhone 16",
            notchTop: 54,
            notchBottom: 34
        }, {
            model: "iPhone 16 Pro",
            notchTop: 54,
            notchBottom: 34
        }, {
            model: "SPN-AL00",
            notchTop: 2,
            notchBottom: 2
        }, {
            model: "HUAWEI CET-AL00",
            notchTop: 38,
            notchBottom: 0
        }, {
            model: "HUAWEI ALT-AL10",
            notchTop: 38,
            notchBottom: 0
        }], f.profileMap = {}, f.lastClickTime = 0, f.numberUnit = {
            3: "K",
            6: "M",
            9: "B",
            12: "T",
            15: "aa",
            18: "bb",
            21: "cc",
            24: "dd",
            27: "ee",
            30: "ff",
            33: "gg",
            36: "hh",
            39: "ii",
            42: "jj",
            45: "kk",
            48: "ll",
            51: "mm",
            54: "nn",
            57: "oo",
            60: "pp",
            63: "qq",
            66: "rr",
            69: "ss",
            72: "tt",
            75: "uu",
            78: "vv",
            81: "ww",
            84: "xx",
            87: "yy",
            90: "zz",
            93: "Aa",
            96: "Bb",
            99: "Cc",
            102: "Dd",
            105: "Ee",
            108: "Ff",
            111: "Gg",
            114: "Hh",
            117: "Ii",
            120: "Jj",
            123: "Kk",
            126: "Ll",
            129: "Mm",
            132: "Nn",
            135: "Oo",
            138: "Pp",
            141: "Qq",
            144: "Rr",
            147: "Ss",
            150: "Tt",
            153: "Uu",
            156: "Vv",
            159: "Ww",
            162: "Xx",
            165: "Yy",
            168: "Zz",
            171: "AA",
            174: "BB",
            177: "CC",
            180: "DD",
            183: "EE",
            186: "FF",
            189: "GG",
            192: "HH",
            195: "II",
            198: "JJ",
            201: "KK",
            204: "LL",
            207: "MM",
            210: "NN",
            213: "OO",
            216: "PP",
            219: "QQ",
            222: "RR",
            225: "SS",
            228: "TT",
            231: "UU",
            234: "VV",
            237: "WW",
            240: "XX",
            243: "YY",
            246: "ZZ"
        }, f.relativeDate = void 0, f.localLaunchDate = void 0;
        class g {
            constructor(t, e) {
                this.parallelCount = 0, this.actions = t || [], this.isRepeat = e, this.pActionIdx = 0, this._curTweens = []
            }
            get actions() {
                return this._actions
            }
            set actions(t) {
                this._actions = t
            }
            get isRepeat() {
                return this._isRepeat
            }
            set isRepeat(t) {
                this._isRepeat = t
            }
            get pActionIdx() {
                return this._pActionIdx
            }
            set pActionIdx(t) {
                this._pActionIdx = t
            }
            run(t) {
                if (this._curTweens = [], !this.actions || 0 === this.actions.length) return;
                if (this.pActionIdx >= this.actions.length) {
                    if (!this.isRepeat) return void(this._curTween = null);
                    this.pActionIdx = 0
                }
                let e = this.actions[this.pActionIdx];
                if (t) {
                    if (t.destroyed) return void(this._curTween = null);
                    e.target = t
                }
                let a = !0;
                if (e.parallels && e.parallels.length > 0) {
                    this._recoverProps = {}, a = !1, this.curParallels = e.parallels.concat(e);
                    for (const t of e.parallels) t.target = e.target, this._run(t, !1)
                }
                this._run(e, a)
            }
            _run(t, e = !0) {
                if (t && t.t && t.target && t.props && f.isNumber(t.duration)) {
                    if (!t.props.isRecover && e && (this._recoverProps = {}), t.recoverKeys)
                        for (const e of t.recoverKeys) this.addRecover(e, t.target[e]);
                    let a = this;
                    if ("update" == t.t) {
                        let e = {},
                            n = "";
                        for (const e in t.props) {
                            n = e;
                            break
                        }
                        t.target[n] = 0, t.init && t.init(t.target), e[n] = 1, e.update = new Laya.Handler(this, (() => {
                            t.update(t.target, t.target[n])
                        }));
                        let u = Laya.Tween.to(t.target, e, t.duration, t.ease, Laya.Handler.create(this, (t => {
                            this.removeCurTween(u);
                            let e = a.curParallels;
                            e && e.length > 0 ? (e.splice(e.indexOf(t), 1), 0 == e.length && a.runNext(t)) : a.runNext(t)
                        }), [t]), void 0, void 0, !1);
                        this._curTween = u, this._curTweens.push(this._curTween)
                    } else if ("delay" == t.t) {
                        t.target._fx_sequenceDelayTime = 0;
                        let e = t.props,
                            n = Laya.Tween.to(t.target, e, t.duration, t.ease, Laya.Handler.create(this, (t => {
                                this.removeCurTween(n);
                                let e = a.curParallels;
                                e && e.length > 0 ? (e.splice(e.indexOf(t), 1), 0 == e.length && a.runNext(t)) : a.runNext(t)
                            }), [t]), void 0, void 0, !1);
                        this._curTween = n, this._curTweens.push(this._curTween)
                    } else if ("to" === t.t) {
                        let e = t.props;
                        "function" == typeof e && (e = e(t.target));
                        let n = Laya.Tween.to(t.target, e, t.duration, t.ease, Laya.Handler.create(this, (function(...t) {
                            this.removeCurTween(n);
                            let [e] = t, u = a.curParallels;
                            u && u.length > 0 ? (u.splice(u.indexOf(e), 1), 0 == u.length && a.runNext(e)) : a.runNext(e)
                        }), [t]), t.delay, void 0, !1);
                        this._curTween = n, this._curTweens.push(this._curTween)
                    } else if ("from" === t.t) {
                        let e = t.props;
                        "function" == typeof e && (e = e(t.target));
                        let n = Laya.Tween.from(t.target, e, t.duration, t.ease, Laya.Handler.create(this, (function(...t) {
                            this.removeCurTween(n);
                            let [e] = t, u = a.curParallels;
                            u && u.length > 0 ? (u.splice(u.indexOf(e), 1), 0 == u.length && a.runNext(e)) : a.runNext(e)
                        }), [t]), t.delay, void 0, !1);
                        this._curTween = n, this._curTweens.push(this._curTween)
                    } else if ("set" == t.t) {
                        let e = t.props;
                        "function" == typeof e && (e = e(t.target));
                        for (const a in e) t.target[a] = e[a];
                        let n = a.curParallels;
                        n && n.length > 0 ? (n.splice(n.indexOf(t), 1), 0 == n.length && a.runNext(t)) : a.runNext(t)
                    } else if (t.props.exec) {
                        let e = t.props.exec;
                        if (e instanceof Laya.Handler) {
                            let a = e.once;
                            e.runWith(t.target), a && (t.props.exec = null)
                        } else e(t.target);
                        let n = a.curParallels;
                        n && n.length > 0 ? (n.splice(n.indexOf(t), 1), 0 == n.length && a.runNext(t)) : this.runNext(t)
                    }
                } else {
                    let e = this.curParallels;
                    e && e.length > 0 && (e.splice(e.indexOf(t), 1), 0 == e.length && this.runNext(t))
                }
            }
            runNext(t) {
                t && t.complete && t.complete.call(t.complete, t.completeCaller, t.completeArgs), this.pActionIdx = this.pActionIdx + 1;
                let e = t && t.target;
                this.run(e)
            }
            removeCurTween(t) {
                let e = this._curTweens.indexOf(t); - 1 != e && this._curTweens.splice(e, 1)
            }
            getCurTween() {
                return this._curTween
            }
            addRecover(t, e) {
                this._recoverProps[t] || (this._recoverProps[t] = e)
            }
            pushAction(t) {
                if (this.parallelCount > 0) {
                    this.parallelCount--;
                    let e = this.actions[this.actions.length - 1];
                    e && e.parallels ? e.parallels.push(t) : (t.parallels = [], this.actions.push(t))
                } else this.actions.push(t)
            }
            pause() {
                for (const t of this._curTweens) t.pause()
            }
            resume() {
                for (const t of this._curTweens) t.resume()
            }
            parallel(t) {
                return this.parallelCount = t, this
            }
            to(t, e, a) {
                let n = {
                    t: "to",
                    target: null,
                    props: t,
                    duration: e,
                    ease: a
                };
                return this.pushAction(n), this
            }
            delay(t) {
                let e = {
                    t: "delay",
                    target: null,
                    props: {
                        _fx_sequenceDelayTime: 1
                    },
                    duration: t
                };
                return this.pushAction(e), this
            }
            hide() {
                let t = {
                    t: "exec",
                    target: null,
                    props: {
                        exec: null
                    },
                    duration: 0,
                    recoverKeys: ["visible"]
                };
                return t.props.exec = t => {
                    t.visible = !1
                }, this.pushAction(t), this
            }
            show() {
                let t = {
                    t: "exec",
                    target: null,
                    props: {
                        exec: null
                    },
                    duration: 0,
                    recoverKeys: ["visible"]
                };
                return t.props.exec = t => {
                    t.visible = !0
                }, this.pushAction(t), this
            }
            setProp(t) {
                let e = {
                    t: "set",
                    target: null,
                    props: t,
                    duration: 0
                };
                return e.props.exec = t => {}, this.pushAction(e), this
            }
            recover() {
                let t = {
                    t: "exec",
                    target: null,
                    props: {
                        exec: null,
                        isRecover: !0
                    },
                    duration: 0
                };
                return t.props.exec = t => {
                    for (var e in this._recoverProps) this._recoverProps.hasOwnProperty(e) && (t[e] = this._recoverProps[e]);
                    this._recoverProps = {}
                }, this.pushAction(t), this
            }
            removeNode(t) {
                let e = {
                    t: "exec",
                    target: null,
                    props: {
                        exec: null
                    },
                    duration: 0
                };
                return e.props.exec = e => {
                    t ? e.destroy() : e.removeSelf()
                }, this.pushAction(e), this
            }
            scaleIn(t, e, a) {
                let n = {
                    t: "from",
                    target: null,
                    props: {
                        scaleX: t,
                        scaleY: t
                    },
                    duration: e,
                    recoverKeys: ["scaleX", "scaleY"],
                    ease: a
                };
                return this.pushAction(n), this
            }
            scaleOut(t, e, a) {
                let n = {
                    t: "to",
                    target: null,
                    props: {
                        scaleX: t,
                        scaleY: t
                    },
                    duration: e,
                    recoverKeys: ["scaleX", "scaleY"],
                    ease: a
                };
                return this.pushAction(n), this
            }
            scaleOut2(t, e, a, n) {
                let u = {
                    t: "to",
                    target: null,
                    props: {
                        scaleX: t,
                        scaleY: e
                    },
                    duration: a,
                    recoverKeys: ["scaleX", "scaleY"],
                    ease: n
                };
                return this.pushAction(u), this
            }
            up(t, e, a) {
                let n = {
                    t: "to",
                    target: null,
                    props: function(e) {
                        return {
                            y: e.y - t
                        }
                    },
                    duration: e,
                    recoverKeys: ["y"],
                    ease: a
                };
                return this.pushAction(n), this
            }
            down(t, e, a) {
                let n = {
                    t: "to",
                    target: null,
                    props: function(e) {
                        return {
                            y: e.y + t
                        }
                    },
                    duration: e,
                    recoverKeys: ["y"],
                    ease: a
                };
                return this.pushAction(n), this
            }
            fadeIn(t, e) {
                let a = {
                    t: "to",
                    target: null,
                    props: function(t) {
                        return t.alpha = 0, {
                            alpha: 1
                        }
                    },
                    duration: t,
                    recoverKeys: ["alpha"],
                    ease: e
                };
                return this.pushAction(a), this
            }
            fadeOut(t, e) {
                let a = {
                    t: "to",
                    target: null,
                    props: {
                        alpha: 0
                    },
                    duration: t,
                    recoverKeys: ["alpha"],
                    ease: e
                };
                return this.pushAction(a), this
            }
            fadeTo(t, e, a) {
                let n = {
                    t: "to",
                    target: null,
                    props: {
                        alpha: t
                    },
                    duration: e,
                    recoverKeys: ["alpha"],
                    ease: a
                };
                return this.pushAction(n), this
            }
            pos(t, e, a, n) {
                let u = {
                    t: "to",
                    target: null,
                    props: function(a) {
                        return a.centerX = a.centerY = void 0, a.left = a.right = a.top = a.bottom = void 0, {
                            x: t,
                            y: e
                        }
                    },
                    duration: a,
                    recoverKeys: ["x", "y", "centerX", "centerY", "left", "right", "top", "bottom"],
                    ease: n
                };
                return 0 == a && (u.t = "exec", u.recoverKeys = null, u.ease = null, u.props = {}, u.props.exec = a => {
                    a.centerX = a.centerY = void 0, a.left = a.right = a.top = a.bottom = void 0, a.pos(t, e)
                }), this.pushAction(u), this
            }
            follow(t, a, n = 4, u, f, g = 9999999999) {
                let _ = {
                    t: "to",
                    target: null,
                    props: function(f) {
                        f.centerX = f.centerY = void 0, f.left = f.right = f.top = f.bottom = void 0;
                        let g = new e,
                            _ = u ? u.x : 0,
                            p = u ? u.y : 0;
                        return {
                            update: new Laya.Handler(this, ((e, u) => {
                                g.x = t.x + _ - f.x, g.y = t.y + p - f.y;
                                let y = g.len();
                                y <= n ? e._duration = 0 : (g.normalize(Math.min(y, a * (.05 + u))), f.x += g.x, f.y += g.y)
                            }))
                        }
                    },
                    ease: f,
                    duration: g,
                    recoverKeys: ["x", "y", "centerX", "centerY", "left", "right", "top", "bottom"]
                };
                return this.pushAction(_), this
            }
            move(t, e, a, n) {
                let u = {
                    t: "to",
                    target: null,
                    props: function(a) {
                        return a.centerX = a.centerY = void 0, a.left = a.right = a.top = a.bottom = void 0, {
                            x: a.x + t,
                            y: a.y + e
                        }
                    },
                    duration: a,
                    recoverKeys: ["x", "y", "centerX", "centerY", "left", "right", "top", "bottom"],
                    ease: n
                };
                return this.pushAction(u), this
            }
            rotate(t, e, a) {
                let n = {
                    t: "to",
                    target: null,
                    props: {
                        rotation: t
                    },
                    duration: e,
                    recoverKeys: ["rotation"],
                    ease: a
                };
                return this.pushAction(n), this
            }
            exec(t) {
                let e = {
                    t: "exec",
                    target: null,
                    props: {
                        exec: t
                    },
                    duration: 0
                };
                return this.pushAction(e), this
            }
            circle(t, e, a, n) {
                let u = {
                    t: "to",
                    target: null,
                    props: function(t) {
                        let n = t.globalToLocal(e, !0);
                        return f.resetPivot(t, n.x, n.y), {
                            rotation: a
                        }
                    },
                    duration: t,
                    recoverKeys: ["rotation", "pivotX", "pivotY"],
                    ease: n
                };
                return this.pushAction(u), this
            }
            blink(t, e, a) {
                let n = {
                    t: "update",
                    target: null,
                    props: {
                        _fx_sequenceBlink: 1
                    },
                    ease: a,
                    duration: t,
                    update: (t, a) => {
                        if (a >= 1) return void(t.alpha = 1);
                        let n = 1 / e,
                            u = Math.floor(a / (n / 2)) % 2 == 1 ? 1 : 0;
                        t.alpha = u
                    }
                };
                return this.pushAction(n), this
            }
            color(t, e, a, n) {
                let u = fx.Utils.colorHexTo4F(e),
                    f = fx.Utils.colorHexTo4F(a),
                    g = {
                        t: "update",
                        target: null,
                        props: {
                            _fx_sequenceColor: 1
                        },
                        ease: n,
                        duration: t,
                        update: (t, e) => {
                            let a = u.x + (f.x - u.x) * e,
                                n = u.y + (f.y - u.y) * e,
                                g = u.z + (f.z - u.z) * e,
                                _ = fx.Utils.getHexColorStringF(a, n, g);
                            t.filterColor(_)
                        }
                    };
                return this.pushAction(g), this
            }
            jumpTo(t, a, n) {
                if (t.length <= 2) throw Error("must have 3 points");
                let u, g = {
                    t: "update",
                    target: null,
                    props: {
                        _fx_sequenceJumpTo: 1
                    },
                    ease: n,
                    duration: a,
                    init: t => {
                        u = new e(t.x, t.y)
                    },
                    update: (e, a) => {
                        let n = f.calcBezierPoint2D(a, t);
                        e.pos(n.x, n.y, !0)
                    }
                };
                return this.pushAction(g), this
            }
            moveToTarget(t, a, n, u) {
                let f, g = {
                    t: "update",
                    target: null,
                    props: {
                        _fx_sequenceMoveToTarget: 1
                    },
                    ease: u,
                    duration: a,
                    init: t => {
                        f = new e(t.x, t.y)
                    },
                    update: (e, a) => {
                        let u = new Laya.Point(t.x + n.x, t.y + n.y);
                        if (t.parent.localToGlobal(u), e.parent.globalToLocal(u), a >= 1) return void e.pos(u.x, u.y);
                        let g = f.x + (u.x - f.x) * a,
                            _ = f.y + (u.y - f.y) * a;
                        e.pos(g, _)
                    }
                };
                return this.pushAction(g), this
            }
            throwTo(t, e, a, n) {
                let u = (e.x - t.x) / a,
                    f = (e.y - t.y + .5 * n * u * u) / u,
                    g = {
                        t: "update",
                        target: null,
                        props: {
                            _fx_sequenceThrowTo: 1
                        },
                        duration: 1e3 * u,
                        update: (g, _) => {
                            let p, y;
                            p = t.x < e.x ? t.x + _ * u * a : t.x - _ * u * a, y = t.y + (f * (_ * u) - .5 * n * (_ * u) * (_ * u)), _ >= 1 && (p = e.x, y = e.y), g.pos(p, y)
                        }
                    };
                return this.pushAction(g), this
            }
            brightness(t, e, a, n) {
                let u = {
                    t: "update",
                    target: null,
                    props: {
                        _fx_sequenceBrightness: 1
                    },
                    ease: n,
                    duration: a,
                    update: (a, n) => {
                        let u = t + (e - t) * n,
                            f = new Laya.ColorFilter;
                        f.adjustColor(u, u, 0, 0), a.filters = [f]
                    }
                };
                return this.pushAction(u), this
            }
            bezierTo(t, e, a, n) {
                let u = {
                    t: "update",
                    target: null,
                    props: {
                        _fx_sequenceBezierTo: 1
                    },
                    duration: 1e3 * t,
                    update: (t, u) => {
                        let f = fx.Effect.getBezierPoint(u, e, a, n);
                        t.pos(f.x, f.y)
                    }
                };
                return this.pushAction(u), this
            }
        }
        var _, p, y;
        t.BTStatus = void 0, (_ = t.BTStatus || (t.BTStatus = {}))[_.SUCCESS = 1] = "SUCCESS", _[_.FAILURE = 2] = "FAILURE", _[_.RUNNING = 3] = "RUNNING", t.EPolicy = void 0, (p = t.EPolicy || (t.EPolicy = {}))[p.RequireOne = 0] = "RequireOne", p[p.RequireAll = 1] = "RequireAll", t.BTCategory = void 0, (y = t.BTCategory || (t.BTCategory = {})).COMPOSITE = "composite", y.DECORATOR = "decorator", y.ACTION = "action", y.CONDITION = "condition";
        const m = {},
            b = {},
            w = {},
            x = {};
        class XBTBaseNode {
            constructor({
                category: t = "",
                name: e = "",
                title: a = "",
                description: n = "",
                properties: u
            }) {
                this.id = f.createUUID(), this.category = t, this.name = e, this.title = a || e, this.description = n, this.properties = u || {}
            }
            static register(e, a) {
                let n = this;
                switch (n.bt_category = a, n.bt_name = e, a) {
                    case t.BTCategory.COMPOSITE:
                        b[e] = n;
                        break;
                    case t.BTCategory.DECORATOR:
                        m[e] = n;
                        break;
                    case t.BTCategory.ACTION:
                        w[e] = n;
                        break;
                    case t.BTCategory.CONDITION:
                        x[e] = n;
                        break;
                    default:
                        throw Error("not found node category !")
                }
            }
            _execute(e) {
                this._enter(e), e.blackboard.get("isOpen", e.tree.id, this.id) || this._open(e);
                let a = this._tick(e);
                return a !== t.BTStatus.RUNNING && this._close(e), this._exit(e), a
            }
            _enter(t) {
                t._enterNode(this), this.enter(t)
            }
            _open(t) {
                t._openNode(this), t.blackboard.set("isOpen", !0, t.tree.id, this.id), this.open(t)
            }
            _tick(t) {
                return t._tickNode(this), this.tick(t)
            }
            _close(t) {
                t._closeNode(this), t.blackboard.set("isOpen", !1, t.tree.id, this.id), this.close(t)
            }
            _exit(t) {
                t._exitNode(this), this.exit(t)
            }
            enter(t) {}
            open(t) {}
            tick(t) {
                throw Error("BTBaseNode tick not implement !")
            }
            close(t) {}
            exit(t) {}
            bindout(...t) {
                return this.out = t, this
            }
            output(t, e) {
                if (this.out)
                    for (const a of this.out) a.properties[t] = e
            }
            takeOut(t) {
                let e = this.properties[t];
                return this.properties[t] = void 0, e
            }
        }
        class S extends XBTBaseNode {
            constructor({
                name: e = "Action",
                title: a = "",
                properties: n
            }) {
                super({
                    category: t.BTCategory.ACTION,
                    name: e,
                    title: a,
                    properties: n
                })
            }
        }
        class E {
            constructor() {
                this.tree = null, this.debug = null, this.target = null, this.blackboard = null, this._openNodes = [], this._nodeCount = 0
            }
            _enterNode(t) {
                this._nodeCount++, this._openNodes.push(t)
            }
            _openNode(t) {}
            _tickNode(t) {}
            _closeNode(t) {
                this._openNodes.pop()
            }
            _exitNode(t) {}
        }
        class C extends XBTBaseNode {
            constructor({
                child: e = null,
                name: a = "Decorator",
                title: n = "",
                properties: u
            } = {}) {
                super({
                    category: t.BTCategory.DECORATOR,
                    name: a,
                    title: n,
                    properties: u
                }), this.child = e
            }
            add(t) {
                this.child = t
            }
        }
        class A extends XBTBaseNode {
            constructor({
                children: e = [],
                name: a = "Composite",
                title: n = "",
                properties: u
            }) {
                super({
                    category: t.BTCategory.COMPOSITE,
                    name: a,
                    title: n,
                    properties: u
                }), this.children = e.slice(0)
            }
            add(t) {
                this.children.push(t)
            }
        }
        const k = "1.6.130";
        var B = Laya.Color,
            R = Laya.Dialog,
            z = Laya.EventDispatcher;
        const V = {
            E_APP_ON_PAUSE: "$ONPAUSE",
            E_APP_ON_RESUME: "$ONRESUME",
            E_PANEL_OPENCLOSE: "$PANEL_OPENCLOSE",
            E_SOUND_PLAY_OK: "$SOUND_PLAY_OK",
            E_UI_ADAPTED: "UI_ADAPTED",
            E_PROP_CHANGED: "$USER_PROP_CHANGED",
            E_PHYSICS_COLLISION: "PHYSICS_COLLISION_ENTER",
            E_PHYSICS_COLLISION_EXIT: "PHYSICS_COLLISION_EXIT",
            E_MATERIAL_LOADED: "MATERIAL_LOAD_COMPLETE",
            E_ANIM_STATE_CHENGED: "$ANIM_STATE_CHENGE",
            E_ANIM_EVENT: "$ANIM_EVENT_TRIGGER",
            E_SERVER_CFG_COMPLETE: "E_SERVER_CFG_COMPLETE",
            E_ON_USER_SAVED: "$E_ON_USER_SAVED",
            E_UI_RES_LOAD_START: "$E_UI_RES_LOAD_START",
            E_UI_RES_LOAD_COMPLETE: "$E_UI_RES_LOAD_COMPLETE"
        };
        var Z;
        t.BaseCode = void 0, (Z = t.BaseCode || (t.BaseCode = {}))[Z.PANEL_OPEN = 0] = "PANEL_OPEN", Z[Z.PANEL_CLOSE = 1] = "PANEL_CLOSE", Z[Z.VIEW_OPEN = 2] = "VIEW_OPEN", Z[Z.VIEW_CLOSE = 3] = "VIEW_CLOSE", Z[Z.SCENE_CHANGE = 4] = "SCENE_CHANGE", Z[Z.SOUND_MUSIC_PLAY_OK = 5] = "SOUND_MUSIC_PLAY_OK", Z[Z.SOUND_FX_PLAY_OK = 6] = "SOUND_FX_PLAY_OK", Z[Z.HTTP_INTERFACE_UNDEFINED = 7] = "HTTP_INTERFACE_UNDEFINED", Z[Z.E_ANIM_START = 8] = "E_ANIM_START", Z[Z.E_ANIM_STOP = 9] = "E_ANIM_STOP", Z[Z.E_ANIM_ABORT = 10] = "E_ANIM_ABORT";
        const $ = window.Physics;
        var J;
        t.Gender = void 0, (J = t.Gender || (t.Gender = {}))[J.Male = 0] = "Male", J[J.Female = 1] = "Female";
        var tt;
        t.PlatformType = void 0, (tt = t.PlatformType || (t.PlatformType = {})).PC = "pc", tt.WEB = "web", tt.WEIXIN = "wx", tt.BAIDU = "swan", tt.VIVO = "vivo", tt.TT = "toutiao", tt.MEIZU = "meizu", tt.OPPO = "oppo", tt.NATIVE_XIAOMI = "native_xiaomi", tt.NATIVE_TAPTAP = "native_taptap", tt.QQ = "qq", tt.QTT = "qtt", tt.FTNN = "4399", tt.FTNNBOX = "4399box", tt.NATIVE_ANDROID = "native_android", tt.NATIVE_IOS = "native_ios", tt.KUAISHOU = "kuaishou", tt.HUAWEI = "huawei", tt.UC = "uc", tt.NATIVE_233 = "native_233", tt.TTFF = "2345", tt.CHUANYIN = "chuanyin", tt.NATIVE_KXHZ = "native_kxhz", tt.NATIVE_MMY = "native_mmy", tt.NATIVE_VIVO = "native_vivo", tt.NATIVE_OPPO = "native_oppo", tt.NATIVE_XINGTU = "native_xingtu", tt.NATIVE_MEIZU = "native_meizu", tt.NATIVE_TOPON = "native_topon", tt.NATIVE_HUAWEI = "native_huawei", tt.NATIVE_4399 = "native_4399", tt.NATIVE_GP = "native_googleplay", tt.XIAOMI = "xiaomi", tt.ALIPAY = "alipay", tt.RONGYAO = "rongyao", tt.MINI360 = "mini360", tt.YOUGUBT = "ygbt", tt.MT = "meituan";
        class et {
            constructor(t, e) {
                this._width = t, this._height = e
            }
            get width() {
                return this._width
            }
            set width(t) {
                this._width = t
            }
            get height() {
                return this._height
            }
            set height(t) {
                this._height = t
            }
        }
        class it {
            static init() {
                let t = Laya.Browser.now();
                Math.seedEx = function(e) {
                    t = e
                }, Math.randomEx = function() {
                    t = (9301 * t + 49297) % 233280;
                    let e = t / 233280;
                    return e = Math.floor(1e4 * e) / 1e4, e
                }, Math.clamp = function(t, e, a) {
                    if (e > a) {
                        let t = e;
                        e = a, a = t
                    }
                    return t > a ? a : t < e ? e : t
                }, Math.rad = function(t) {
                    return t * (Math.PI / 180)
                }, Math.deg = function(t) {
                    return t * (180 / Math.PI)
                }, Math.sign = function(t) {
                    return +(t > 0) - +(t < 0) || +t
                }, Math.lerp = function(t, e, a) {
                    return a = Math.clamp(a, 0, 1), Laya.MathUtil.lerp(t, e, a)
                }, Laya.Node.prototype.findChildByName = function(t) {
                    let e = t.split("/"),
                        a = this,
                        n = null;
                    for (const t of e) {
                        if (n = a.getChildByName(t), !n) return null;
                        a = n
                    }
                    return n
                }, Laya.Node.prototype.getChildBySubName = function(t) {
                    let e = this._children;
                    for (const a of e)
                        if (-1 != a.name.indexOf(t)) return a
                }, Laya.Node.prototype.seekChildByName = function(t) {
                    if (!t) return;
                    let e = this._children;
                    for (const a of e)
                        if (a.name == t) return a;
                    for (const a of e) {
                        let e = a.seekChildByName(t);
                        if (e) return e
                    }
                }, Laya.Node.prototype.seekChildBySubName = function(t) {
                    if (!t) return;
                    let e = this._children;
                    for (const a of e)
                        if (-1 != a.name.indexOf(t)) return a;
                    for (const a of e) {
                        let e = a.seekChildBySubName(t);
                        if (e) return e
                    }
                }, Laya.Node.prototype.seekChildrenByName = function(t) {
                    let e = [];
                    const anonymous = function(a) {
                        a.name == t && e.push(a);
                        let n = a.getChildren();
                        for (const t of n) anonymous(t)
                    };
                    let a = this.getChildren();
                    for (const t of a) anonymous(t);
                    return e
                }, Laya.Node.prototype.seekChildrenBySubName = function(t) {
                    let e = [];
                    const anonymous = function(a) {
                        -1 != a.name.indexOf(t) && e.push(a);
                        let n = a.getChildren();
                        for (const t of n) anonymous(t)
                    };
                    let a = this.getChildren();
                    for (const t of a) anonymous(t);
                    return e
                }, Laya.Node.prototype.getAllComponents = function() {
                    return this._components
                }, Laya.Node.prototype.destroyAllComponents = function() {
                    let t = this.getAllComponents();
                    for (let e = t.length - 1; e >= 0; e--) {
                        t[e].destroy()
                    }
                }, Laya.Node.prototype.getChildren = function() {
                    return this._children.concat()
                }, Laya.Node.prototype.getChildrenBySubName = function(t) {
                    let e = this._children,
                        a = [];
                    return e.forEach((e => {
                        -1 != e.name.indexOf(t) && a.push(e)
                    })), a
                }, Laya.Label.prototype.fitWidth = function(t = !0) {
                    let e = this,
                        a = e.text,
                        n = `${e.fontSize}px ${e.font}`,
                        u = Laya.Browser.measureText(a, n).width;
                    if (isNaN(e.width) || u <= e.width) return;
                    let f = t ? "..." : "";
                    for (; u > e.width;) a = a.substr(0, a.length - 1), u = Laya.Browser.measureText(a + f, n).width;
                    e.text = a + f
                }, Laya.Box.prototype.reverse = function(t) {
                    let e, a, n, u = this;
                    if (0 != u.numChildren) {
                        t ? (e = "x", n = "anchorX", a = "width") : (e = "y", n = "anchorY", a = "height");
                        for (let t = 0; t < u.numChildren; t++) {
                            let f = this._children[t];
                            f instanceof Laya.Component && (f[n] = 1 - (isNaN(f[n]) ? 0 : f[n])), f[e] = u[a] - f[e]
                        }
                    }
                }, Laya.Box.prototype.verticalLayout = function(t, e = !0, a = 0) {
                    if (0 == this.numChildren) return;
                    let n = this;
                    n.top = n.left = n.right = n.bottom = void 0;
                    let u = 0,
                        f = 0,
                        g = 0,
                        _ = ["centerX", "left", "right"][a];
                    this._children.forEach((e => {
                        let a = e,
                            n = e.layoutGap || 0;
                        a instanceof Laya.UIComponent && (a.top = a.bottom = a.centerY = void 0, a[_] = 0, a.anchorY = 0), a.y = f, g = f + a.displayHeight, f = g + t + n, u = Math.max(u, a.displayWidth)
                    })), n.size(u, g), e || n.reverse(!1)
                }, Laya.Box.prototype.horizontalLayout = function(t, e = !0, a = 0) {
                    if (0 == this.numChildren) return;
                    let n = this;
                    n.top = n.left = n.right = n.bottom = void 0;
                    let u = 0,
                        f = 0,
                        g = 0,
                        _ = ["centerY", "top", "bottom"][a];
                    this._children.forEach((e => {
                        let a = e.layoutGap || 0,
                            n = e;
                        n instanceof Laya.UIComponent && (n.left = n.right = n.centerX = void 0, n[_] = 0, n.anchorX = 0), n.x = f, u = f + n.displayWidth, f = u + t + a, g = Math.max(g, n.displayHeight)
                    })), n.size(u, g), e || n.reverse(!0)
                }, Laya.Box.prototype.tileLayout = function(t, e, a, n, u = !1) {
                    if (t < 1 || e < 1 || a.width < 0 || a.height < 0) return console.log("Invalid parameter"), !1;
                    if (0 == this.numChildren) return console.log("No Children"), !1;
                    if (this.numChildren > t * e) return console.log("row or col Not enough"), !1;
                    let f = this;
                    f.top = f.left = f.right = f.bottom = void 0, f.width = e * (n.width + 2 * a.width), f.height = t * (n.height + 2 * a.height);
                    for (let t = 0; t < this._children.length; ++t) {
                        let f = this._children[t];
                        f instanceof Laya.UIComponent && (f.left = f.right = f.top = f.bottom = void 0, f.anchorX = f.anchorY = .5), u && (f.width = n.width, f.height = n.height);
                        let g = t % e,
                            _ = Math.floor(t / e);
                        f.x = g * (f.width + 2 * a.width) + a.width + f.width / 2, f.y = _ * (f.height + 2 * a.height) + a.height + f.height / 2
                    }
                    return !0
                }, Laya.Sprite.prototype.onPressed = function(t, e, a, n = !0, u, f = 100) {
                    let g = this;

                    function onPressed(a) {
                        g.__pressed = !0, null != u ? u > 0 ? Laya.timer.loop(u, t, e, [a]) : Laya.timer.frameLoop(1, t, e, [a]) : e.call(t, [a])
                    }

                    function onMouseDown(t) {
                        Laya.timer.once(f, g, onPressed, [t])
                    }

                    function interupt() {
                        Laya.timer.clear(g, onPressed), Laya.timer.clear(t, e), g.__pressed && a && a.call(t)
                    }

                    function onMouseUp() {
                        interupt(), Laya.timer.callLater(g, (() => {
                            g.__pressed = !1
                        }))
                    }
                    g.__pressed = !1, g.on(Laya.Event.MOUSE_DOWN, g, onMouseDown), n && g.onMoved(g, interupt), g.on(Laya.Event.MOUSE_UP, g, onMouseUp), g.on(Laya.Event.MOUSE_OUT, g, onMouseUp), g.offPressed = function() {
                        Laya.timer.clear(g, onPressed), Laya.timer.clear(t, e), g.off(Laya.Event.MOUSE_DOWN, g, onMouseDown), g.off(Laya.Event.MOUSE_UP, g, onMouseUp), g.__pressed = !1
                    }
                }, Laya.Sprite.prototype.offPressed = function() {}, Laya.Sprite.prototype.isPressed = function() {
                    return this.__pressed
                }, Laya.Sprite.prototype.onMoved = function(t, e, a = 0, ...n) {
                    let u, f = this,
                        g = new Laya.Point,
                        _ = !1;

                    function onMouseDown(t) {
                        _ || (g.x = t.stageX, g.y = t.stageY, _ = !0, u = t.touchId)
                    }

                    function onMouseMove(f) {
                        _ && u == f.touchId && g.distance(f.stageX, f.stageY) > a && e.call(t, f, g, ...n)
                    }

                    function onMouseUp() {
                        _ = !1, u = null
                    }
                    f.on(Laya.Event.MOUSE_DOWN, f, onMouseDown), f.on(Laya.Event.MOUSE_MOVE, f, onMouseMove), f.on(Laya.Event.MOUSE_UP, f, onMouseUp), f.offMoved = function() {
                        f.off(Laya.Event.MOUSE_DOWN, f, onMouseDown), f.off(Laya.Event.MOUSE_MOVE, f, onMouseMove), f.off(Laya.Event.MOUSE_UP, f, onMouseUp)
                    }
                }, Laya.Sprite.prototype.offMoved = function() {}, Laya.Sprite.prototype.filterColor = function(t) {
                    let e = fx.Utils.colorHexTo4F(t),
                        a = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0];
                    a[0] = e.x, a[6] = e.y, a[12] = e.z, a[18] = e.w, this.filters = [new Laya.ColorFilter(a)]
                }, Laya.Scene.prototype.showSomething = function() {
                    this.onPressed(this, (() => {
                        let t = "&#33879;&#20316;&#26435;&#24402;&#25104;&#37117;&#21019;&#19990;&#26041;&#33311;&#31185;&#25216;&#26377;&#38480;&#20844;&#21496;&#25152;&#26377;";
                        t = t.replace(/&#[0-9]+;/g, (t => String.fromCodePoint(parseInt(`${t.replace("&#","").replace(";","")}`))));
                        let e = new Laya.Text;
                        e.text = t, e.font = "Arial", e.color = "#ffffff", e.fontSize = 30, e.x = 300, e.y = 50, this.addChild(e)
                    }), null, !0, null, 1e4)
                }, Laya.Bone && (Laya.Bone.prototype.mount = function(t, e) {
                    let a = this,
                        n = this._sprite;
                    return e && (this._update = a.update, a.update = a.updateEx, this._hUpdate = e), n ? (n.addChild(t), !0) : (this._sprite = t, !1)
                }, Laya.Bone.prototype.updateEx = function(t) {
                    this._update(t), this._hUpdate.runWith(this)
                }, Laya.Bone.prototype.unmount = function(t) {
                    this._sprite == t && (this._sprite = null), t.removeSelf();
                    let e = this;
                    this._hUpdate && (this._sprite && 0 != this._sprite.numChildren || (e.update = this._update, this._hUpdate = null, this._update = null))
                }), Laya.EventDispatcher.prototype.offAllNot = function(t) {
                    let e = this._events;
                    if (!e) return this;
                    if (t && t.length > 0)
                        for (let a in e) - 1 == t.indexOf(a) && (this._recoverHandlers(e[a]), delete e[a]);
                    return this
                }, Laya.EventDispatcher.prototype.priorityReverse = function(t, e = 1) {
                    let a = this._events;
                    if (!a) return;
                    let n = a[t];
                    if (n && n.length && n.length > 1 && e > 0) {
                        e = Math.min(e, Math.floor(.5 * n.length));
                        let t = n.splice(n.length - e, e);
                        for (const e of t) n.unshift(e)
                    }
                }, Laya.EventDispatcher.prototype.onAndEvent = function(t, e, a, n, u) {
                    return this.on(t, e, a, n), this.event(t, u), this
                }, Laya.Dialog.prototype.open = function(t = !0, e = null, a = null) {
                    this._dealDragArea(), this._param = e, a ? (this._dialogManager = a, this._dialogManager.open(this, t, this.isShowEffect), this._dialogManager.lock(!1), this.on(Laya.Event.DESTORYED, Laya.stage, (() => {
                        a.destroy()
                    }))) : (Laya.Dialog.manager.open(this, t, this.isShowEffect), Laya.Dialog.manager.lock(!1))
                }, Laya.Dialog.prototype.close = function(t = null) {
                    this.closeType = t, (this._dialogManager || Laya.Dialog.manager).close(this)
                }, Laya.Script.prototype.getComponent = function(t) {
                    return this.owner.getComponent(t)
                };
                let findChildComponent = function(t, e) {
                        for (let a = 0; a < t.length; ++a) {
                            let n = t[a],
                                u = n.getComponent(e);
                            if (u) return u;
                            if (n._children && n._children.length > 0 && (u = findChildComponent(n._children, e), u)) return u
                        }
                        return null
                    },
                    findChildComponents = function(t, e, a) {
                        for (let n = 0; n < t.length; ++n) {
                            let u = t[n],
                                f = u.getComponents(e);
                            f && (a = a.concat(f)), u._children && u._children.length > 0 && (a = findChildComponents(u._children, e, a))
                        }
                        return a
                    };
                Laya.Script.prototype.getComponentInChildren = function(t) {
                    return findChildComponent(this.owner._children, t)
                }, Laya.Script.prototype.getComponentsInChildren = function(t) {
                    let e = this.owner.getComponents(t) || [];
                    return e = findChildComponents(this.owner._children, t, e), e
                }, Laya.Script.prototype.addComponent = function(t) {
                    return this.owner.addComponent(t)
                }, Laya.Node.prototype.getComponentInChildren = function(t) {
                    return findChildComponent(this._children, t)
                }, Laya.Node.prototype.getComponentsInChildren = function(t) {
                    let e = this.getComponents(t) || [];
                    return e = findChildComponents(this._children, t, e), e
                }, window.Laya3D ? fx.BaseExtend3D.init() : Laya.Size = et
            }
        }
        class st {
            constructor() {
                this.mData = {}
            }
            static get instance() {
                return this._instance || (this._instance = new st), this._instance
            }
            load(t) {
                let e = this;
                Laya.loader.load("json/list.txt", new Laya.Handler(this, (function(...a) {
                    if (!a.pop()) return void t.run();
                    let n = Laya.loader.getRes("json/list.txt").replace(/\r\n/g, "\n").split("\n");
                    n.pop();
                    let u = [];
                    if (n.forEach((t => {
                            var e = t.substr(t.indexOf("json")); - 1 == t.indexOf(".txt") && u.push(e.replace("\\", "/"))
                        })), !u.length) return void t.run();
                    let g = u[0];
                    1 == u.length && g.includes("bundle.json") ? Laya.loader.load(g, new Laya.Handler(this, (function(e) {
                        if (!e) throw new Error("load cfg json failed!");
                        for (const t in e) this.mData[t] = e[t];
                        t.run()
                    })), null, Laya.Loader.JSON) : Laya.loader.load(u, new Laya.Handler(this, (function(...a) {
                        a.pop() && (a.forEach((t => {
                            let a = f.pathInfo(t).filename,
                                n = Laya.loader.getRes(t);
                            n = e.parseBuf(n), this.mData[a] = JSON.parse(n)
                        })), t.run())
                    }), u), null, Laya.Loader.BUFFER)
                })))
            }
            get(t, e, a) {
                return null == this.mData[t] ? null : null == e && null == a ? this.mData[t] : null == this.mData[t][e] ? null : null == a ? this.mData[t][e] : this.mData[t][e][a]
            }
            getConstant(t) {
                return this.get("constant", t)
            }
            getStr(t) {
                return this.get("lang_ch", t)
            }
            parseBuf(t) {
                if ("string" != typeof t) {
                    var e = new Laya.Byte(t),
                        a = e.getCustomString(1);
                    if ("{" == a || "[" == a) e.pos = 0, t = e.getUTFBytes(e.length);
                    else {
                        const e = window.pako;
                        t = decodeURIComponent(e.inflate(t, {
                            to: "string"
                        }))
                    }
                }
                return t
            }
            loadJson(t, e) {
                t && Laya.loader.load(t, Laya.Handler.create(this, (a => {
                    let n = this.mData[t] = JSON.parse(this.parseBuf(a));
                    e && e.runWith(n)
                })), null, Laya.Loader.BUFFER)
            }
        }
        class at extends z {
            constructor() {
                super(), this.m_listenerMap = {}
            }
            static get I() {
                return this._instance || (this._instance = new at), this._instance
            }
            find(t, e, a) {
                for (let n = 0; n < a.length; n++) {
                    let u = a[n];
                    if (t == u.type && e == u.cb) return n
                }
                return -1
            }
            findAll(t, e) {
                let a = [];
                for (let n = 0; n < e.length; n++) {
                    t == e[n].type && a.push(n)
                }
                return a
            }
            on(t, e, a, n) {
                let u = super.on(t, e, a, n);
                e.$_GID || (e.$_GID = Laya.Utils.getGID());
                let f = this.m_listenerMap[e.$_GID];
                return f ? -1 == this.find(t, a, f) ? f.push({
                    type: t,
                    cb: a
                }) : console.log(!1, `${t} listener already added!!!`) : (f = new Array, f.push({
                    type: t,
                    cb: a
                }), this.m_listenerMap[e.$_GID] = f), u
            }
            once(t, e, a, n) {
                let u = super.once(t, e, a, n);
                e.$_GID || (e.$_GID = Laya.Utils.getGID());
                let f = this.m_listenerMap[e.$_GID];
                return f ? -1 == this.find(t, a, f) ? f.push({
                    type: t,
                    cb: a
                }) : console.log(!1, `${t} listener already added!!!`) : (f = new Array, f.push({
                    type: t,
                    cb: a
                }), this.m_listenerMap[e.$_GID] = f), u
            }
            off(t, e, a, n) {
                if (e.$_GID) {
                    let n = this.m_listenerMap[e.$_GID];
                    if (n) {
                        let e = this.find(t, a, n); - 1 != e && n.splice(e, 1)
                    }
                }
                return super.off(t, e, a, n)
            }
            offAllCaller(t) {
                let e = t.$_GID;
                if (e) {
                    let a = this.m_listenerMap[e];
                    if (a) {
                        for (let e of a) super.off(e.type, t, e.cb);
                        delete this.m_listenerMap[e]
                    }
                }
                return super.offAllCaller(t)
            }
            offAll(t) {
                if (t)
                    for (let e in this.m_listenerMap) {
                        let a = this.m_listenerMap[e],
                            n = this.findAll(t, a);
                        for (let t of n) a.splice(t, 1)
                    } else this.m_listenerMap = {};
                return super.offAll(t)
            }
            event(t, e) {
                return super.event(t, e)
            }
        }
        class nt extends Laya.EventDispatcher {
            constructor() {
                super()
            }
            static superFunc(t, e) {
                if (t instanceof nt) return Laya.EventDispatcher.prototype[e].bind(t);
                return f.super(t).prototype[e].bind(t)
            }
            hasListener(t) {
                return "$" == t.charAt(0) ? at.I.hasListener(t) : nt.superFunc(this, "hasListener")(t)
            }
            event(t, e) {
                return "$" == t.charAt(0) ? at.I.event(t, e) : nt.superFunc(this, "event")(t, e)
            }
            on(t, e, a, n) {
                return "$" == t.charAt(0) ? at.I.on(t, e, a, n) : nt.superFunc(this, "on")(t, e, a, n)
            }
            once(t, e, a, n) {
                return "$" == t.charAt(0) ? at.I.once(t, e, a, n) : nt.superFunc(this, "once")(t, e, a, n)
            }
            off(t, e, a, n) {
                return "$" == t.charAt(0) ? at.I.off(t, e, a, n) : nt.superFunc(this, "off")(t, e, a, n)
            }
            offAllCaller(t) {
                return at.I.offAllCaller(t), nt.superFunc(this, "offAllCaller")(t)
            }
            offAll(t) {
                return t ? "$" == t.charAt(0) ? at.I.offAll(t) : nt.superFunc(this, "offAll")(t) : this.offAllCaller(this)
            }
        }
        class rt extends Laya.Scene {
            constructor() {
                super(), this.once(Laya.Event.ADDED, this, this.addToStage), this.once(Laya.Event.REMOVED, this, this.removeFromStage), this.views = []
            }
            get curView() {
                return this._curView
            }
            set curView(t) {
                this._curView = t
            }
            createDialogManager(t) {
                let e = new Laya.DialogManager;
                return e.zOrder = 0, e.popupEffect = t => {
                    t.scale(1, 1), t._effectTween = Laya.Tween.from(t, {
                        x: Laya.stage.width / 2,
                        y: Laya.stage.height / 2,
                        scaleX: 0,
                        scaleY: 0
                    }, 300, Laya.Ease.backOut, Laya.Handler.create(e, e.doOpen, [t]), 0, !1, !1)
                }, e.closeEffect = t => {
                    t._effectTween = Laya.Tween.to(t, {
                        x: Laya.stage.width / 2,
                        y: Laya.stage.height / 2,
                        scaleX: 0,
                        scaleY: 0
                    }, 300, Laya.Ease.strongOut, Laya.Handler.create(e, e.doClose, [t]), 0, !1, !1)
                }, e.popupEffectHandler = new Laya.Handler(this, e.popupEffect), e.closeEffectHandler = new Laya.Handler(this, e.closeEffect), t instanceof Laya.Node ? t.addChild(e) : this.addChild(e), e
            }
            removeView(t) {
                if (t)
                    if (this._curView == t) {
                        if (this.views.length > 1) throw Error("please use SceneManager.popView instead !!!");
                        this.views.length = 0, this._curView = null
                    } else {
                        let e = this.views.indexOf(t); - 1 != e && this.views.splice(e, 1)
                    }
            }
            pushView(t) {
                if (t) {
                    -1 == this.views.indexOf(t) && (this.views.push(t), this.addChild(t), t.on(Laya.Event.REMOVED, this, this.removeView, [t]))
                }
                if (this.views.length > 1) {
                    this.lastView = this.views[this.views.length - 2]
                } else {
                    this.lastView = null
                }
            }
            popView() {
                let t = this.views.pop();
                if (t && t.removeSelf(), this.views.length > 1) {
                    this.lastView = this.views[this.views.length - 2]
                } else {
                    this.lastView = null
                }
            }
            closeView(t) {
                let e = this.views.indexOf(t);
                if (-1 != e && (this.views.splice(e, 1), t.removeSelf()), this.views.length > 1) {
                    this.lastView = this.views[this.views.length - 2]
                } else {
                    this.lastView = null
                }
            }
            static getRes(...t) {
                return null
            }
            enter(...t) {
                console.log(f.getClassName(this) + " enter!"), this.onEnter(...t)
            }
            exit() {
                console.log(f.getClassName(this) + " exit!"), this.onExit()
            }
            actived() {
                console.log(f.getClassName(this) + " actived!"), this.onActive()
            }
            deactived() {
                console.log(f.getClassName(this) + " deactived!"), this.onDeactive()
            }
            onAdd() {}
            onRemove() {}
            onEnter(...t) {}
            onExit() {}
            onActive() {}
            onDeactive() {}
            onStart() {}
            close(t) {
                this.closeType = t, super.close(t)
            }
            removeSelf() {
                if (!this.closeType) throw Error("BaseScene can not removeSelf, use SceneManager.changeScene instead!");
                return super.removeSelf()
            }
            addToStage() {
                this.size(Laya.stage.width, Laya.stage.height), this.onAdd(), this.onStart !== rt.prototype.onStart && Laya.startTimer.callLater(this, this.onStart)
            }
            removeFromStage() {
                this.offAll(), this.timer.clearAll(this), this.onRemove()
            }
            loadScene(t) {
                this.url = t, this.frameOnce(1, this, super.loadScene, [t])
            }
            getModuleRegName() {
                let t = f.getModule(this),
                    e = Laya.ClassUtils._classMap;
                for (const a in e)
                    if (e.hasOwnProperty(a) && e[a] == t) return a;
                return null
            }
            getModuleUrlName() {
                let t = "";
                if (this.url) {
                    let e = this.url.indexOf("/"); - 1 !== e && (t = this.url.substring(e + 1))
                }
                return t
            }
        }
        f.applyMixins(rt, [nt], Laya.Scene), Laya.ClassUtils.regClass("Scene", rt);
        class ot extends Laya.View {
            constructor(...t) {
                super(), this.lastPos = new e, this.lastStamp = 0, this._count = 0, this.$_GID = Laya.Utils.getGID(), this.isAdapt = !1, this.once(Laya.Event.ADDED, this, this.addToStage), this.once(Laya.Event.REMOVED, this, this.removeFromStage), this.on(Laya.Event.MOUSE_DOWN, this, this.mouseDown), this.on(Laya.Event.CLICK, this, this.clicked)
            }
            createDialogManager() {
                let t = new Laya.DialogManager;
                return t.zOrder = 0, t.popupEffect = e => {
                    e.scale(1, 1), e._effectTween = Laya.Tween.from(e, {
                        x: Laya.stage.width / 2,
                        y: Laya.stage.height / 2,
                        scaleX: 0,
                        scaleY: 0
                    }, 300, Laya.Ease.backOut, Laya.Handler.create(t, t.doOpen, [e]), 0, !1, !1)
                }, t.closeEffect = e => {
                    e._effectTween = Laya.Tween.to(e, {
                        x: Laya.stage.width / 2,
                        y: Laya.stage.height / 2,
                        scaleX: 0,
                        scaleY: 0
                    }, 300, Laya.Ease.strongOut, Laya.Handler.create(t, t.doClose, [e]), 0, !1, !1)
                }, t.popupEffectHandler = new Laya.Handler(this, t.popupEffect), t.closeEffectHandler = new Laya.Handler(this, t.closeEffect), this.addChild(t), t
            }
            getGID() {
                return this.$_GID
            }
            isAdapted() {
                return this.isAdapt
            }
            static getRes(...t) {
                return null
            }
            enter(...t) {
                console.log(f.getClassName(this) + " enter!"), this.onEnter(...t)
            }
            exit() {
                console.log(f.getClassName(this) + " exit!"), this.onExit()
            }
            actived() {
                console.log(f.getClassName(this) + " actived!"), this.onActive()
            }
            deactived() {
                console.log(f.getClassName(this) + " deactived!"), this.onDeactive()
            }
            onAdd() {}
            onRemove() {}
            onEnter(...t) {}
            onExit() {}
            onActive() {}
            onDeactive() {}
            onStart() {}
            onMouseDown(t) {
                return this.mouseThrough
            }
            onClicked(t) {
                return this.mouseThrough
            }
            onLayout(t) {}
            getBgComp() {
                return this.getChildByName("img_bg")
            }
            disableAdapt() {
                this.isAdapt = null
            }
            mouseDown(t) {
                !1 === this.onMouseDown(t) && t.stopPropagation()
            }
            clicked(t) {
                !1 === this.onClicked(t) && t.stopPropagation()
            }
            adaptScreen(t) {
                if (null === this.isAdapt) return;
                if (this.isAdapt) return void this.onLayout();
                if ((t = t || this.getBaseViewParent(this.parent)) && 0 == t.isAdapted()) return void t.once(V.E_UI_ADAPTED, this, this.adaptScreen);
                this.isAdapt = !0, this.left = this.top = this.bottom = this.right = this.centerX = this.centerY = void 0;
                let e = Laya.stage.width,
                    a = Laya.stage.height;
                t && (e = t.width, a = t.height);
                let n = !1;
                this._width == e && this._height == a || (this.size(0, 0), this.pos(0, 0), this.width = e, this.height = a, n = !0);
                let u = this.getBgComp(),
                    g = f.isNotchScreenDevice();
                if (u && (u.x = u.y = u.anchorX = u.anchorY = 0, this.origSize ? u.size(this.origSize.width, this.origSize.height) : this.origSize = new Laya.Size(u.width, u.height), g ? (u.mouseEnabled = !0, f.adaptNode(u, Laya.stage.width, Laya.stage.height, !0)) : f.adaptNode(u, e, a, !0)), g) {
                    this.hitTestPrior = !1;
                    let f, _, p, y = g.notchTop,
                        m = 0;
                    Laya.stage.screenMode == Laya.Stage.SCREEN_VERTICAL ? (f = "y", _ = "centerY", p = "height", m = a) : (f = "x", _ = "centerX", p = "width", m = e), t && t.isAdapted() ? u && (g.exceed = .5 * Math.abs(m - u[p]), u.centerX = u.centerY = 0, u.centerX = u.centerY = void 0, u[f] = .5 * (Laya.stage[p] - u[p]) - y) : (this[f] += y, this[p] -= y + g.notchBottom, u && (g.exceed = .5 * Math.abs(m - u[p]), u.centerX = u.centerY = 0, u.centerX = u.centerY = void 0, u[f] = .5 * (Laya.stage[p] - u[p]) - y), n = !0)
                } else u && (u.centerX = 0, u.centerY = 0, u.centerX = u.centerY = void 0);
                this.event(V.E_UI_ADAPTED, this), n ? this.once(Laya.Event.RESIZE, this, this.onLayout, [g]) : this.onLayout(g)
            }
            getBaseViewParent(t) {
                return !t || t instanceof rt ? null : t instanceof ot ? t : this.getBaseViewParent(t.parent)
            }
            addToStage() {
                let t = this.getBgComp();
                t && t instanceof Laya.Image ? (t.left = t.right = t.top = t.bottom = t.centerX = t.centerY = void 0, t.source ? (!t.width && (t.width = t.source.width), !t.height && (t.height = t.source.height), this.adaptScreen()) : (t.width = t.height = void 0, t.once(Laya.Event.LOADED, this, this.adaptScreen))) : this.adaptScreen(), this.onAdd(), this.onStart !== ot.prototype.onStart && Laya.startTimer.callLater(this, this.onStart)
            }
            removeFromStage() {
                this.offAll(), this.timer.clearAll(this), this.onRemove()
            }
            removeSelf(t = !0) {
                if (Laya.ClassUtils.getClass("SceneManager").isInUIStack(this)) throw Error("already in ui stack, please use SceneManager to remove self !!!");
                return t ? this.destroy() : super.removeSelf(), this
            }
            loadScene(t) {
                this.url = t, this.frameOnce(1, this, super.loadScene, [t])
            }
            getModuleRegName() {
                let t = f.getModule(this),
                    e = Laya.ClassUtils._classMap;
                for (const a in e)
                    if (e.hasOwnProperty(a) && e[a] == t) return a;
                return null
            }
            getModuleUrlName() {
                let t = "";
                if (this.url) {
                    let e = this.url.indexOf("/"); - 1 !== e && (t = this.url.substring(e + 1))
                }
                return t
            }
        }
        f.applyMixins(ot, [nt], Laya.View), Laya.ClassUtils.regClass("View", ot);
        class lt extends Laya.Dialog {
            constructor(...t) {
                super(), this.lastPos = new e, this.lastStamp = 0, this._count = 0, this.$_GID = Laya.Utils.getGID(), this.once(Laya.Event.ADDED, this, this.addToStage), this.once(Laya.Event.REMOVED, this, this.removeFromStage), this.on(Laya.Event.MOUSE_DOWN, this, this.mouseDown), this.on(Laya.Event.CLICK, this, this.clicked)
            }
            getGID() {
                return this.$_GID
            }
            static getRes(...t) {
                return null
            }
            refreshMaskLayer() {
                let t = Laya.Dialog.manager.maskLayer;
                t.graphics.clear(!0), null == this.bgColor ? t.graphics.drawRect(0, 0, t.width, t.height, UIConfig.popupBgColor) : t.graphics.drawRect(0, 0, t.width, t.height, this.bgColor), null == this.bgAlpha ? t.alpha = UIConfig.popupBgAlpha : t.alpha = this.bgAlpha, this.isModal && this.mouseThrough ? t.mouseEnabled = !1 : t.mouseEnabled = !0
            }
            actived() {
                this.refreshMaskLayer(), console.log(f.getClassName(this) + " actived!"), this.onActive()
            }
            deactived() {
                console.log(f.getClassName(this) + " deactived!"), this.onDeactive()
            }
            onAdd() {}
            onRemove() {}
            onEnter(...t) {}
            onExit() {}
            onActive(...t) {}
            onDeactive() {}
            onStart() {}
            onMouseDown(t) {
                return this.mouseThrough
            }
            onClicked(t) {
                return this.mouseThrough
            }
            onOpened(t) {
                this.onEnter(...t)
            }
            close(t) {
                if (!this.closeEffPlay)
                    if ("closeOnSide" == t) {
                        if (this.isModal) return;
                        let t = null == this.autoDestroyAtClosed || this.autoDestroyAtClosed;
                        Laya.ClassUtils.getClass("SceneManager").closePanel(this, {
                            autoDestroy: t
                        }), this.isShowEffect && null != this.closeEffect && (this.closeEffPlay = !0)
                    } else super.close(t)
            }
            onClosed() {
                this.closeEffPlay = !1, this.onExit()
            }
            mouseDown(t) {
                !1 === this.onMouseDown(t) && t.stopPropagation()
            }
            clicked(t) {
                !1 === this.onClicked(t) && t.stopPropagation()
            }
            removeSelf() {
                if ("closePanel" != this.closeType) throw new Error("BaseDialog can not removeSelf, use SceneManager.closePanel instead!");
                return super.removeSelf()
            }
            addToStage() {
                this.refreshMaskLayer(), this.onAdd(), this.onStart !== lt.prototype.onStart && Laya.startTimer.callLater(this, this.onStart)
            }
            removeFromStage() {
                this.offAll(), this.timer.clearAll(this), this.onRemove()
            }
            loadScene(t) {
                this.url = t, this.frameOnce(1, this, super.loadScene, [t])
            }
            getModuleRegName() {
                let t = f.getModule(this),
                    e = Laya.ClassUtils._classMap;
                for (const a in e)
                    if (e.hasOwnProperty(a) && e[a] == t) return a;
                return null
            }
            getModuleUrlName() {
                let t = "";
                if (this.url) {
                    let e = this.url.indexOf("/"); - 1 !== e && (t = this.url.substring(e + 1))
                }
                return t
            }
        }
        f.applyMixins(lt, [nt], Laya.Dialog), Laya.ClassUtils.regClass("Dialog", lt);
        class ht {
            constructor() {
                this.audioContexts = [], this.curAudioIndex = 0, this.refCount = 0
            }
        }
        class ct {
            constructor() {
                this.musicVolume = 1, this.init(), at.I.on(V.E_APP_ON_PAUSE, this, this.deactive), at.I.on(V.E_APP_ON_RESUME, this, this.active);
                let t = Laya.ClassUtils.getRegClass("Sdk");
                t && t.instance.onAudioInterruption(this.deactive.bind(this), this.active.bind(this)), this.soundCfg = st.instance.get("soundCfg");
                let e = {},
                    a = !1;
                for (const t in this.soundCfg) {
                    let n = this.soundCfg[t];
                    "string" == typeof n && (a = !0, e[t] = {
                        id: t,
                        content: n,
                        volume: 1,
                        interval: 0
                    })
                }
                a && (this.soundCfg = e), this.lastPlayTimes = {}
            }
            static get instance() {
                return this._instance || (this._instance = new ct), this._instance
            }
            getAudioPoolInst() {
                return Laya.Browser.onWeiXin ? window.wx : Laya.Browser.onHWMiniGame || Laya.Browser.onQGMiniGame || Laya.Browser.onVVMiniGame ? window.qg : window.my && window.my.createInnerAudioContext ? window.my : void 0
            }
            init(t = !0) {
                if (this.soundFxEnable = !0, this.musicEnable = !0, this.playing = !1, t) {
                    let t = Laya.LocalStorage.getItem("soundFxEnable"),
                        e = Laya.LocalStorage.getItem("musicEnable");
                    "false" == t && (this.soundFxEnable = !1), "false" == e && (this.musicEnable = !1)
                }
                this.saveLocal = t, this.getAudioPoolInst() && (this.defaultPool = new ht, this.defaultPool.useWebAudioImplement = !0, this.addInnerAudioContextCnt(10), this.bindContexts = {})
            }
            addInnerAudioContextCnt(t) {
                let e = this.defaultPool.audioContexts.length - 1,
                    a = this.getAudioPoolInst();
                for (let n = e; n < t; n++) this.defaultPool.audioContexts.push(a.createInnerAudioContext({
                    useWebAudioImplement: !0
                }))
            }
            canSaveLoacl(t) {
                this.saveLocal = t
            }
            createAudioContxtPool(t, e = !0) {
                let a = this.getAudioPoolInst();
                if (a) {
                    if (t <= 0) return;
                    t = Math.min(t, this.defaultPool.audioContexts.length);
                    let u = new ht;
                    u.useWebAudioImplement = e;
                    for (var n = 0; n < t; n++) e ? u.audioContexts.push(this.defaultPool.audioContexts.pop()) : u.audioContexts.push(a.createInnerAudioContext({
                        useWebAudioImplement: !1
                    }));
                    return u
                }
            }
            bindSoundCtx(t, e) {
                if (this.getAudioPoolInst()) {
                    this.bindContexts[t] && this.unbindSoundCtx(t), e.refCount++, this.bindContexts[t] = e
                }
            }
            bindSoundCtxById(t, e) {
                t && this.soundCfg && this.soundCfg[t] && this.bindSoundCtx(this.soundCfg[t].content, e)
            }
            unbindSoundCtx(t) {
                if (this.getAudioPoolInst()) {
                    let e = this.bindContexts[t];
                    if (e) {
                        if (e.refCount--, 0 == e.refCount)
                            for (let t of e.audioContexts) e.useWebAudioImplement ? this.defaultPool.audioContexts.push(t) : t.destroy();
                        delete this.bindContexts[t]
                    }
                }
            }
            unbindSoundCtxById(t) {
                t && this.soundCfg && this.soundCfg[t] && this.unbindSoundCtx(this.soundCfg[t].content)
            }
            unbindAll() {
                if (this.getAudioPoolInst())
                    for (let t in this.bindContexts) this.unbindSoundCtx(t)
            }
            playSound(t, e = 1, a = 0, n = 1, u = 0) {
                if (this.soundFxEnable && t) {
                    if (!this.checkInterval(t, u)) return;
                    n || (n = 1), a > 0 ? Laya.timer.once(a, this, this._playSound, [t, e, n]) : this._playSound(t, e, n)
                }
            }
            playSoundById(t, e = 1, a = 0, n, u) {
                if (t && this.soundCfg && this.soundCfg[t]) {
                    let f = this.soundCfg[t].content;
                    !n && (n = this.soundCfg[t].volume), !u && (u = this.soundCfg[t].interval), f && this.playSound(f, e, a, n, u)
                }
            }
            _playSound(t, e, a) {
                if (this.getAudioPoolInst()) {
                    let e = this.bindContexts[t];
                    e || (e = this.defaultPool);
                    let n = e.curAudioIndex;
                    e.curAudioIndex++;
                    let u = e.audioContexts;
                    n %= u.length;
                    let f = u[n],
                        g = Laya.loader.getRes(t);
                    if (g) {
                        let t = g.readyUrl;
                        Laya.MiniFileMgr.readFile(t, void 0, Laya.Handler.create(this, (function() {
                            f.src = t, f.play(), a < 1 && (f.volume = a)
                        })))
                    } else Laya.loader.load(t, new Laya.Handler(this, (t => {
                        if (!t || !t.readyUrl) return;
                        let e = t.readyUrl;
                        Laya.MiniFileMgr.readFile(e, void 0, Laya.Handler.create(this, (function() {
                            f.src = e, f.play(), a < 1 && (f.volume = a)
                        })))
                    })))
                } else Laya.SoundManager.playSound(t, e), a < 1 && Laya.SoundManager.setSoundVolume(a, t)
            }
            stopAll() {
                Laya.SoundManager.stopAll()
            }
            stopAllSound() {
                this.stopSoundFx()
            }
            stopSoundFx(t) {
                if (Laya.timer.clearAll(this), t ? Laya.SoundManager.stopSound(t) : Laya.SoundManager.stopAllSound(), this.getAudioPoolInst())
                    if (t) {
                        for (let e of this.defaultPool.audioContexts)
                            if (e.src == t) {
                                e.stop();
                                break
                            }
                    } else {
                        for (let t of this.defaultPool.audioContexts) t.stop();
                        this.defaultPool.curAudioIndex = 0
                    }
            }
            stopSoundById(t) {
                if (t && this.soundCfg) {
                    let e = this.soundCfg[t].content;
                    e && this.stopSoundFx(e)
                }
            }
            toggleSoundFx(t, e) {
                return this.soundFxEnable = !this.soundFxEnable, void 0 !== t && (this.soundFxEnable = !!t), this.soundFxEnable || this.stopSoundFx(), (e = void 0 !== e ? e : this.saveLocal) && Laya.LocalStorage.setItem("soundFxEnable", String(this.soundFxEnable)), this.soundFxEnable
            }
            getToggleSoundFxStatus() {
                return this.soundFxEnable
            }
            playMusic(t, e = 0, a) {
                this.musicEnable && t ? (this.musicLoop = e, this.resumeMusic(), a && (this.setMusicVolume(a), this.musicVolume = a), this.musicUrl != t ? (this.playing && this.stopMusic(), Laya.loader.clearRes(this.musicUrl), this.musicUrl = t, this.playing = !0, Laya.loader.load(t, Laya.Handler.create(this, this.onMusicLoaded))) : this.playing || (this.musicUrl = t, this.playing = !0, this.onMusicLoaded())) : t && (this.musicLoop = e, this.musicUrl = t)
            }
            playMusicById(t, e = 0, a) {
                if (t && this.soundCfg) {
                    let n = this.soundCfg[t].content;
                    n && (this.musicId = t, a || (a = this.soundCfg[t].volume), this.playMusic(n, e, a))
                }
            }
            getMusicId() {
                return this.musicId
            }
            onMusicLoaded() {
                this.playing && (console.log("SoundManager playMusic..."), Laya.SoundManager.playMusic(this.musicUrl, this.musicLoop, Laya.Handler.create(this, this.onMusicComplete)))
            }
            stopMusic() {
                console.log("SoundManager stopMusic..."), Laya.SoundManager.stopMusic(), this.playing = !1
            }
            pauseMusic() {
                console.log("SoundManager pauseMusic..."), this.pause || (Laya.SoundManager.musicMuted = !0, this.pause = !0)
            }
            resumeMusic() {
                console.log("SoundManager resumeMusic..."), this.pause && (Laya.SoundManager.musicMuted = !1, this.pause = !1)
            }
            toggleMusic(t) {
                return this.musicEnable = !this.musicEnable, void 0 !== t && (this.musicEnable = !!t), this.musicEnable ? this.playMusic(this.musicUrl, this.musicLoop) : this.stopMusic(), this.saveLocal && Laya.LocalStorage.setItem("musicEnable", String(this.musicEnable)), this.musicEnable
            }
            getToggleMusicStatus() {
                return this.musicEnable
            }
            toggleAll(t) {
                return this.toggleMusic(t), this.toggleSoundFx(t), this.musicEnable && this.soundFxEnable
            }
            isPlayingMusic() {
                return this.playing
            }
            setMusicVolume(t = 1) {
                t < 0 || t > 1 || (console.log("SoundManager setMusicVolume:", t), this.musicVolume = t, Laya.SoundManager.setMusicVolume(t))
            }
            setSoundFxVolume(t = 1, e) {
                t < 0 || t > 1 || Laya.SoundManager.setSoundVolume(t, e)
            }
            setSoundVolumeById(t, e = 1) {
                if (t && this.soundCfg) {
                    let a = this.soundCfg[t].content;
                    a && this.setSoundFxVolume(e, a)
                }
            }
            onSoundFxComplete(t) {}
            onMusicComplete() {
                at.I.event(V.E_SOUND_PLAY_OK, {
                    code: t.BaseCode.SOUND_MUSIC_PLAY_OK
                })
            }
            active() {
                console.log("SoundManager active..."), this.musicEnable && !this.pause && (Laya.SoundManager.musicMuted = !1)
            }
            deactive() {
                console.log("SoundManager deactive..."), this.musicEnable && !this.pause && (Laya.SoundManager.musicMuted = !0)
            }
            checkInterval(t, e) {
                if (!e || e < 0) return !0;
                let a = this.lastPlayTimes[t] || 0,
                    n = Date.now();
                return n - a > e && (this.lastPlayTimes[t] = n, !0)
            }
        }
        class ut {
            static toneLight(t, e) {
                let a = new Laya.ColorFilter;
                a.adjustBrightness(e), t.filters = [a]
            }
            static multiplyColor(t, e) {
                if (e) {
                    let a;
                    if (a = "string" == typeof e ? f.colorHexTo3F(e) : e, t.filters && t.filters.length > 0) {
                        let e = t.filters[0]._mat;
                        e[0] = a.x / 255, e[6] = a.y / 255, e[12] = a.z / 255
                    } else {
                        let e = [a.x / 255, 0, 0, 0, 0, 0, a.y / 255, 0, 0, 0, 0, 0, a.z / 255, 0, 0, 0, 0, 0, 1, 0],
                            n = new Laya.ColorFilter(e);
                        t.filters = [n]
                    }
                } else t.filters = void 0
            }
            static setColor(t, e) {
                if (e) {
                    let a, n;
                    a = "string" == typeof e ? e : f.getHexColorStringI(e.x, e.y, e.z), t.filters && t.filters.length > 0 ? n = t.filters[0] : (n = new Laya.ColorFilter, t.filters = [n]), n.setColor(a)
                } else t.filters = void 0
            }
            static setColorGrayRGB(t, e) {
                if (e) {
                    let a = f.getColorLumin3I(e),
                        n = new Laya.ColorFilter;
                    n.gray(), n.adjustBrightness(a), t.filters = [n]
                } else t.filters = void 0
            }
            static rotationHue(t) {
                let e = [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0],
                    a = Math.cos(Math.rad(t)),
                    n = Math.sin(Math.rad(t));
                e[0] = a + (1 - a) / 3, e[1] = 1 / 3 * (1 - a) - Math.sqrt(1 / 3) * n, e[2] = 1 / 3 * (1 - a) + Math.sqrt(1 / 3) * n, e[5] = 1 / 3 * (1 - a) + Math.sqrt(1 / 3) * n, e[6] = a + 1 / 3 * (1 - a), e[7] = 1 / 3 * (1 - a) - Math.sqrt(1 / 3) * n, e[10] = 1 / 3 * (1 - a) - Math.sqrt(1 / 3) * n, e[11] = 1 / 3 * (1 - a) + Math.sqrt(1 / 3) * n, e[12] = a + 1 / 3 * (1 - a);
                let u = new Laya.ColorFilter;
                return u.setByMatrix(e), u
            }
            static glow(t, e, a = 0) {
                let n = new Laya.GlowFilter(e, 10, a, a);
                t.filters = [n]
            }
            static splashEff(t, e, a = !1, n = 100) {
                let u, f = t;
                f.__splashEff ? (u = f.__splashEff.o, Laya.Tween.clearTween(u), t.filters = void 0) : (u = {
                    factor: n
                }, f.__splashEff = {
                    o: u
                }), u.factor = n;
                let g = new Laya.Handler(this, (function() {
                        ut.toneLight(t, u.factor)
                    })),
                    anifunc = function() {
                        Laya.Tween.from(u, {
                            factor: 0,
                            update: g
                        }, e >> 1, null, Laya.Handler.create(this, (function() {
                            Laya.Tween.to(u, {
                                factor: 0,
                                update: g
                            }, e >> 1, null, Laya.Handler.create(this, (function() {
                                if (u.factor = n, a) return anifunc()
                            })))
                        })))
                    };
                t.once(Laya.Event.REMOVED, t, this.stopSplashEff), anifunc()
            }
            static stopSplashEff(t) {
                let e = t || this;
                if (e.__splashEff) {
                    t = e;
                    let a = e.__splashEff.o;
                    Laya.Tween.clearTween(a), t.filters = void 0, e.__splashEff = null
                }
            }
            static shake(t, e, a) {
                let n, u = t;
                u.__shakeEff ? (Laya.Tween.clear(u.__shakeEff.tween), n = u.__shakeEff.o, t.x = u.__shakeEff.o.x, t.y = u.__shakeEff.o.y) : (n = new Laya.Point(t.x, t.y), u.__shakeEff = {
                    o: n
                }), u.__shakeEff.tween = Laya.Tween.to(t, {
                    update: new Laya.Handler(this, (function() {
                        let e = -a + 2 * a * Math.random(),
                            u = -a + 2 * a * Math.random();
                        t.x = n.x + e, t.y = n.y + u
                    }))
                }, e, null, Laya.Handler.create(this, (function() {
                    t.x = n.x, t.y = n.y, u.__shakeEff = null
                }))), t.once(Laya.Event.REMOVED, this, this.stopShake, [t])
            }
            static stopShake(t) {
                let e, a = t;
                a.__shakeEff && (Laya.Tween.clear(a.__shakeEff.tween), e = a.__shakeEff.o, t.x = a.__shakeEff.o.x, t.y = a.__shakeEff.o.y, a.__shakeEff = null)
            }
            static breathEff(t, e, a, n = !0) {
                let u, f = t;
                f.__breathEff ? (Laya.Tween.clear(f.__breathEff.tween), u = f.__breathEff.o, t.scaleX = f.__breathEff.o.x, t.scaleY = f.__breathEff.o.y) : (u = new Laya.Point(t.scaleX, t.scaleY), f.__breathEff = {
                    o: u
                });
                let anifunc = function() {
                    f.__breathEff.tween = Laya.Tween.to(t, {
                        scaleX: a * u.x,
                        scaleY: a * u.y
                    }, e >> 1, null, Laya.Handler.create(this, (function() {
                        f.__breathEff.tween = Laya.Tween.to(t, {
                            scaleX: u.x,
                            scaleY: u.y
                        }, e >> 1, null, Laya.Handler.create(this, (function() {
                            n ? anifunc() : ut.stopBreathEff(f)
                        })))
                    })))
                };
                anifunc(), t.once(Laya.Event.REMOVED, this, this.stopBreathEff, [f])
            }
            static stopBreathEff(t) {
                let e = t;
                e.__breathEff && (Laya.Tween.clear(e.__breathEff.tween), t.scaleX = e.__breathEff.o.x, t.scaleY = e.__breathEff.o.y, e.__breathEff = null)
            }
            static cd(t, e, a, n, u) {
                let g = t,
                    _ = t.width >> 1,
                    p = t.height >> 1;
                u = u || Math.max(_, p);
                let y = -90,
                    m = 270;
                if (g.__cdEff) {
                    Laya.Tween.clear(g.__cdEff.tween), g.__cdEff.o.graphics.drawPie(_, p, _, y, m, "#000000"), g.__cdEff.angle = y
                } else {
                    let e = new Laya.Sprite;
                    e.setSelfBounds(new Laya.Rectangle(0, 0, t.width, t.height)), e.alpha = .8, n ? t.mask = e : t.addChild(e), e.graphics.drawPie(_, p, u, y, m, "#000000"), g.__cdEff = {
                        o: e,
                        angle: y
                    }
                }
                return g.__cdEff.tween = Laya.Tween.to(g.__cdEff, {
                    angle: m,
                    update: new Laya.Handler(this, (function() {
                        let t = g.__cdEff.o,
                            e = g.__cdEff.angle;
                        0 == f.equal(e, y, 1) && (y = e, t.graphics.clear(), t.graphics.drawPie(_, p, u, e, m, "#000000"))
                    }))
                }, e, null, Laya.Handler.create(this, (function() {
                    g.__cdEff.o.destroy(), n && (t.mask = null), g.__cdEff = null, a && a.run()
                }))), t.once(Laya.Event.REMOVED, this, this.stopCDEff, [t]), g.__cdEff.tween
            }
            static getCDEffTween(t) {
                if (t.__cdEff) return t.__cdEff.tween
            }
            static stopCDEff(t) {
                if (t.__cdEff) {
                    Laya.Tween.clear(t.__cdEff.tween), t.__cdEff.o.destroy(), t.mask = null, t.__cdEff = null
                }
            }
            static splashScreen(t, e, a = 1, n) {
                let u, f = Laya.stage;
                f.__splashScreenEff ? (Laya.Tween.clear(f.__splashScreenEff.tween), u = f.__splashScreenEff.o) : (u = new Laya.Sprite, u.graphics.drawRect(0, 0, Laya.stage.width, Laya.stage.height, t), Laya.stage.addChild(u), f.__splashScreenEff = {
                    o: u
                }), u.alpha = 0, f.__splashScreenEff.tween = Laya.Tween.to(u, {
                    alpha: a
                }, e >> 1, null, Laya.Handler.create(this, (() => {
                    n && n.run(), f.__splashScreenEff.tween = Laya.Tween.to(u, {
                        alpha: 0
                    }, e >> 1, null, Laya.Handler.create(this, (() => {
                        u.removeSelf(), f.__splashScreenEff = null
                    })))
                })))
            }
            static shadeScreen(t, e, a = 1, n) {
                let u, f = Laya.stage;
                f.__splashScreenEff ? (Laya.Tween.clear(f.__splashScreenEff.tween), u = f.__splashScreenEff.o) : (u = new Laya.Sprite, u.graphics.drawRect(0, 0, Laya.stage.width, Laya.stage.height, t), Laya.stage.addChild(u), f.__splashScreenEff = {
                    o: u
                }), u.alpha = 0, f.__splashScreenEff.tween = Laya.Tween.to(u, {
                    alpha: a
                }, e >> 1, null, Laya.Handler.create(this, (() => {
                    u.destroy(), f.__splashScreenEff = null, n && n.run()
                })))
            }
            static shadeUIComponet(t, e, a) {
                e = e || "#ffffffff";
                let n = !1;
                if (t.name && a && -1 !== a.indexOf(t.name) && (n = !0), !n && (t instanceof Laya.Image || t instanceof Laya.Sprite || t instanceof Laya.Label)) {
                    let a = parseInt(e.substring(1, 3), 16) / 255,
                        n = parseInt(e.substring(3, 5), 16) / 255,
                        u = parseInt(e.substring(5, 7), 16) / 255,
                        f = parseInt(e.substring(7), 16) / 255;
                    t.filters = [new Laya.ColorFilter([a, 0, 0, 0, 0, 0, n, 0, 0, 0, 0, 0, u, 0, 0, 0, 0, 0, f, 0])]
                }
                for (let n = 0; n < t.numChildren; ++n) ut.shadeUIComponet(t.getChildAt(n), e, a)
            }
            static ghostEff(t, e, a) {}
            static jellyQEff(t, e, a = 1) {
                let n = 10 * a || 10,
                    u = {
                        scx: t.scaleX,
                        scy: t.scaleY
                    },
                    f = t;
                if (f._jellyQEff) {
                    if (!f._jellyQEff.complete) return;
                    f._jellyQEff.curTime = 0, f._jellyQEff.complete = !1
                } else f._jellyQEff = {
                    tween: null,
                    curTime: 0,
                    complete: !1
                };
                let g = new Laya.Handler(this, (function() {
                    let e = f._jellyQEff.curTime,
                        a = .1 * Math.exp(-.04 * e) * Math.cos(Math.PI / n * e);
                    f._jellyQEff.curTime += Math.PI / (n / 2), t.scaleX = u.scx + a, t.scaleY = u.scy + a
                }));
                Laya.Tween.to(f, {
                    update: g
                }, 300, null, Laya.Handler.create(this, (() => {
                    t.scaleX = u.scx, t.scaleY = u.scy, f._jellyQEff.complete = !0, e && e.run()
                }), [f]))
            }
            static btnScaleEff(t, e = {
                x: .88,
                y: .88
            }) {
                let a = t;
                if (a.__btnScaleEff) return;
                let n = {
                    scx: t.scaleX,
                    scy: t.scaleY,
                    fixed: !1
                };
                a.__btnScaleEff = n, t.on(Laya.Event.MOUSE_DOWN, this, (a => {
                    if (t instanceof Laya.UIComponent && (t.anchorX > 0 || t.anchorY > 0) && (t.left = t.right = t.bottom = t.top = void 0), !t.hitArea && (e.x < n.scx || e.y < n.scy)) {
                        n.fixed = !0;
                        let a = t.width + 2 * (1 - e.x) * t.width,
                            u = t.height + 2 * (1 - e.y) * t.height;
                        t.hitArea = new Laya.Rectangle((e.x - n.scx) * t.width, (e.y - n.scy) * t.height, a, u)
                    }
                    t.scale(n.scx * e.x, n.scy * e.y)
                })), t.on(Laya.Event.MOUSE_OUT, this, (e => {
                    t.scale(n.scx, n.scy), n.fixed && (t.hitArea = null)
                })), t.on(Laya.Event.MOUSE_UP, this, (e => {
                    t.scale(n.scx, n.scy), n.fixed && (t.hitArea = null)
                }))
            }
            static jumpEff(t, e = 7, a = 1e3, n = !0) {
                let u = {
                        ox: t.x,
                        oy: t.y
                    },
                    f = t;
                f._eff ? Laya.Tween.clear(f._eff.tween) : (f._eff = {}, f._eff.tween = new Laya.Tween);
                let effFun = function() {
                    f._eff.tween.to(t, {
                        y: u.oy + e
                    }, 500, null, Laya.Handler.create(this, (() => {
                        f._eff.tween.to(t, {
                            y: u.oy
                        }, 500, null, Laya.Handler.create(this, (() => {
                            n && (effFun(), t.y = u.oy)
                        })))
                    })))
                };
                effFun()
            }
            static scaleEff(t, e, a) {
                let n = {
                        ox: t.scaleX,
                        oy: t.scaleY
                    },
                    u = t;
                u.__scaleEff ? (Laya.Tween.clear(u.__scaleEff.tween), n.ox = u.__scaleEff.ox, n.oy = u.__scaleEff.oy, t.scaleX = n.ox, t.scaleY = n.oy) : u.__scaleEff = n, u.__scaleEff.tween = Laya.Tween.to(t, {
                    scaleX: n.ox + e,
                    scaleY: n.oy + e
                }, a >> 1, null, Laya.Handler.create(this, (() => {
                    Laya.Tween.to(t, {
                        scaleX: n.ox,
                        scaleY: n.oy
                    }, a >> 1, null, Laya.Handler.create(this, (() => {
                        u.__scaleEff = null
                    })))
                })))
            }
            static jetEff(t, e = !0, a, n = 0, u = 8) {
                let g = new Laya.Box,
                    _ = Math.PI / 40;
                for (let e = 0; e < u; ++e) {
                    let a = new Laya.Image;
                    a.skin = t, a.name = "img" + e, g.addChild(a);
                    let n = 100 * e,
                        u = 150;
                    e % 2 == 0 ? Laya.timer.once(n, null, (function(t) {
                        let e = t,
                            a = .1 * f.getIntRandom(0, 2) * u;
                        e._eff = {
                            curX: 0,
                            a: u + a * (0 == f.getIntRandom(0, 1) ? -1 : 1),
                            x: 0,
                            xdelta: f.getIntRandom(0, 3)
                        };
                        let n = new Laya.Handler(this, (function(t) {
                            let e = t._eff.a,
                                a = t._eff.curX,
                                n = -e * Math.sin(a);
                            t.x = t._eff.x, t.y = n, t._eff.curX = a + _, t._eff.x += t._eff.xdelta
                        }), [e]);
                        Laya.Tween.to(t, {
                            update: n
                        }, 40 * 16.67)
                    }), [a]) : Laya.timer.once(n, null, (function(t) {
                        let e = t,
                            a = .01 * f.getIntRandom(0, 2) * u;
                        e._eff = {
                            curX: 0,
                            a: u + a * (0 == f.getIntRandom(0, 1) ? -1 : 1),
                            x: 0,
                            xdelta: f.getIntRandom(0, 3)
                        };
                        let n = new Laya.Handler(this, (function(t) {
                            let e = t._eff.a,
                                a = t._eff.curX,
                                n = -e * Math.sin(-a);
                            t.x = t._eff.x, t.y = n, t._eff.curX = a - _, t._eff.x -= t._eff.xdelta
                        }), [e]);
                        Laya.Tween.to(t, {
                            update: n
                        }, 40 * 16.67)
                    }), [a])
                }
                return Laya.timer.once(700 + 40 * 16.67, null, (function(t) {
                    Laya.Tween.to(t, {
                        alpha: n
                    }, 300, null, Laya.Handler.create(null, (function(t) {
                        e && t.removeSelf(), a && a.run()
                    }), [t]))
                }), [g]), g
            }
            static scale_up_fade(t, e, a = 2, n = 200, u = 300, f = 50, _ = 1, p = 500, y = 0, m = 500) {
                return a *= t.scaleX, _ *= t.scaleX, (new g).scaleIn(a, n).delay(u).parallel(2).up(f, p).scaleOut(_, p).delay(y).fadeOut(m).delay(m).recover().exec(e).run(t)
            }
            static up_fade(t, e, a = 50, n = 500) {
                return (new g).up(a, n).fadeOut(n).delay(n).recover().exec(e).run(t)
            }
            static move_fade(t, e, a, n = 500) {
                return (new g).parallel(2).move(e.x, e.y, n).fadeOut(n).delay(n).recover().exec(a).run(t)
            }
            static fade_InOut(t, e, a = 1, n = 0, u) {
                let f = t;
                f.__fadeInOutEff ? Laya.Tween.clear(f.__fadeInOutEff.tween) : f.__fadeInOutEff = {
                    alpha: t.alpha
                };
                let anifunc = function() {
                    f.__fadeInOutEff.tween = Laya.Tween.to(t, {
                        alpha: n
                    }, e >> 1, null, Laya.Handler.create(this, (() => {
                        f.__fadeInOutEff.tween = Laya.Tween.to(t, {
                            alpha: a
                        }, e >> 1, null, Laya.Handler.create(this, (() => {
                            u ? anifunc() : this.stopFadeInOutEff(t)
                        })))
                    })))
                };
                anifunc(), t.once(Laya.Event.REMOVED, this, this.stopFadeInOutEff, [t])
            }
            static stopFadeInOutEff(t) {
                let e = t;
                e.__fadeInOutEff && (t.alpha = e.__fadeInOutEff.alpha, Laya.Tween.clear(e.__fadeInOutEff.tween), e.__fadeInOutEff = null, t.off(Laya.Event.REMOVED, this, this.stopFadeInOutEff))
            }
            static splashColor(t, e, a = -1, n = "#000000", u = "#ffffff", f) {
                let g, _ = t;
                _.__splashColor ? (g = _.__splashColor.o, g.clearAll(t), t.filters = void 0) : (g = new Laya.Timer, _.__splashColor = {
                    o: g,
                    c: t.filters
                });
                let anifunc = function() {
                    g.once(e >> 1, t, (() => {
                        t.color = u, g.once(e >> 1, t, (() => {
                            t.color = n, -1 == a ? anifunc() : (a -= 1) <= 0 ? (ut.stopSplashColor(t), f && f()) : anifunc()
                        }))
                    }))
                };
                t.once(Laya.Event.REMOVED, t, this.stopSplashColor), t.color = n, anifunc()
            }
            static stopSplashColor(t) {
                let e = t || this;
                if (e.__splashColor) {
                    let a = e.__splashColor.o;
                    a && a.clearAll(t), t.filters = e.__splashColor.c, e.__splashColor = null
                }
            }
            static getPropEffect(t, e, a, n) {
                Laya.MouseManager.enabled = !1;
                let u = "res/sound/gold_action_start",
                    g = "res/sound/gold_action_end",
                    _ = Laya.ClassUtils.getRegClass("Sdk"),
                    p = _.isOnNativeAndroid(),
                    y = _.isOnNativeIos();
                p || y ? (u += ".wav", g += ".wav") : (u += ".mp3", g += ".mp3");
                let m, b, w, x, v = [{
                    x: -300,
                    y: -150
                }, {
                    x: 0,
                    y: -150
                }, {
                    x: 300,
                    y: -150
                }];
                n && n.iconCtrl && (m = n.iconCtrl.scaleX, b = n.iconCtrl.scaleY), t instanceof Laya.Sprite ? w = t.localToGlobal(new Laya.Point(t.width / 2, t.height / 2)) : t instanceof Laya.Point && (w = t), e instanceof Laya.Sprite ? x = e.localToGlobal(new Laya.Point(e.width / 2, e.height / 2)) : e instanceof Laya.Point && (x = e);
                let S = [];
                for (let t = 0; t < 3; t++)
                    for (let e = 0; e < 15; e++) {
                        let a = Laya.Pool.getItemByClass("goldImage", Laya.Image);
                        a.source = Laya.loader.getRes("res/img_coins.png"), a.anchorX = a.anchorY = .5, a.size(70, 70), a.pos(w.x, w.y, !0), a.zOrder = 1e3, Laya.stage.addChild(a);
                        let n = {
                                x: v[t].x + f.getIntRandom(-150, 150),
                                y: v[t].y + f.getIntRandom(-50, 50)
                            },
                            u = {
                                image: a,
                                counts: 0,
                                point: [w, new Laya.Point(w.x + n.x, w.y + n.y), x],
                                runSign: !1
                            };
                        S.push(u), Laya.timer.once(15 * e, this, (function(t) {
                            S[t].runSign = !0
                        }), [15 * t + e])
                    }
                ct.instance.playSound(u);
                let playSound = function() {
                    ct.instance.playSound(u)
                };
                Laya.timer.loop(50, Laya.stage, playSound), Laya.timer.once(200, Laya.stage, (function() {
                    Laya.timer.clear(Laya.stage, playSound)
                }));
                let updataFuc = function(t) {
                    for (let e = 0; e < S.length; e++) {
                        const u = S[e];
                        if (u && u.runSign) {
                            let _ = t * u.counts,
                                p = ut.getBezierPoint(_, u.point[0], u.point[1], u.point[2]);
                            if (u.image.pos(p.x, p.y), _ >= 1) {
                                if (u.image.removeSelf(), Laya.Pool.recover("goldImage", u.image), S[e] = void 0, e == S.length - 1) Laya.timer.clear(Laya.stage, updataFuc), n && n.iconCtrl ? Laya.timer.once(150, this, (function(t) {
                                    n.iconCtrl && (Laya.Tween.clearAll(n.iconCtrl), Laya.Tween.to(n.iconCtrl, {
                                        scaleX: m,
                                        scaleY: b
                                    }, 100, null, Laya.Handler.create(this, (function(t) {
                                        t && t.run(), Laya.timer.once(100, this, (function() {
                                            Laya.MouseManager.enabled = !0
                                        }))
                                    }), [t])))
                                }), [a]) : (a && a.run(), Laya.timer.once(100, this, (function() {
                                    Laya.MouseManager.enabled = !0
                                })));
                                else if (0 == e && (ct.instance.playSound(g), n && n.iconCtrl && (n.iconCtrl.anchorX = n.iconCtrl.anchorY = .5, ut.propQEffect(n.iconCtrl)), n && n.callbackFirst && n.callbackFirst.run(), n && n.coinsLabelCtrl && n.addCoinsNum)) {
                                    let t = Number(n.coinsLabelCtrl.text);
                                    if (n.isScienceount) {
                                        if (!n.ownCoinsNum) return;
                                        t = n.ownCoinsNum
                                    }
                                    t = t > 0 ? t : 0;
                                    for (let e = 0; e < 10; e++) {
                                        let a = (e + 1) * (n.addCoinsNum / 10) + t;
                                        Laya.timer.once(25 * e, this, (t => {
                                            n.isScienceount ? n.coinsLabelCtrl.text = f.formatNumberWithUnits(Math.floor(t)) + "" : n.coinsLabelCtrl.text = Math.floor(t) + ""
                                        }), [a])
                                    }
                                }
                            } else S[e].counts += 70
                        }
                    }
                };
                Laya.timer.frameLoop(1, Laya.stage, updataFuc, [3e-4])
            }
            static getPropEffectEx(t, e, a, n) {
                Laya.MouseManager.enabled = !1;
                let u, g, _, p, y = [{
                    x: -300,
                    y: -150
                }, {
                    x: 0,
                    y: -150
                }, {
                    x: 300,
                    y: -150
                }];
                n && n.iconCtrl && (u = n.iconCtrl.scaleX, g = n.iconCtrl.scaleY), t instanceof Laya.Sprite ? _ = t.localToGlobal(new Laya.Point(t.width / 2, t.height / 2)) : t instanceof Laya.Point && (_ = t), e instanceof Laya.Sprite ? p = e.localToGlobal(new Laya.Point(e.width / 2, e.height / 2)) : e instanceof Laya.Point && (p = e);
                let m = [];
                for (let t = 0; t < 3; t++)
                    for (let e = 0; e < 15; e++) {
                        let a = Laya.Pool.getItemByClass("goldImage", Laya.Image);
                        a.source = Laya.loader.getRes("res/img_coins.png"), a.anchorX = a.anchorY = .5, a.size(70, 70), a.pos(_.x, _.y, !0), a.zOrder = 1e3, Laya.stage.addChild(a);
                        let n = {
                                x: y[t].x + f.getIntRandom(-150, 150),
                                y: y[t].y + f.getIntRandom(-50, 50)
                            },
                            u = {
                                image: a,
                                counts: 0,
                                point: [_, new Laya.Point(_.x + n.x, _.y + n.y), p],
                                runSign: !1
                            };
                        m.push(u), Laya.timer.once(15 * e, this, (function(t) {
                            m[t].runSign = !0
                        }), [15 * t + e])
                    }
                ct.instance.playSoundById(101);
                let playSound = function() {
                    ct.instance.playSoundById(101)
                };
                Laya.timer.loop(50, Laya.stage, playSound), Laya.timer.once(200, Laya.stage, (function() {
                    Laya.timer.clear(Laya.stage, playSound)
                }));
                let updataFuc = function(t) {
                    for (let e = 0; e < m.length; e++) {
                        const _ = m[e];
                        if (_ && _.runSign) {
                            let p = t * _.counts,
                                y = ut.getBezierPoint(p, _.point[0], _.point[1], _.point[2]);
                            if (_.image.pos(y.x, y.y), p >= 1) {
                                if (_.image.removeSelf(), Laya.Pool.recover("goldImage", _.image), m[e] = void 0, e == m.length - 1) Laya.timer.clear(Laya.stage, updataFuc), n && n.iconCtrl ? Laya.timer.once(150, this, (function(t) {
                                    n.iconCtrl && (Laya.Tween.clearAll(n.iconCtrl), Laya.Tween.to(n.iconCtrl, {
                                        scaleX: u,
                                        scaleY: g
                                    }, 100, null, Laya.Handler.create(this, (function(t) {
                                        t && t.run(), Laya.timer.once(100, this, (function() {
                                            Laya.MouseManager.enabled = !0
                                        }))
                                    }), [t])))
                                }), [a]) : (a && a.run(), Laya.timer.once(100, this, (function() {
                                    Laya.MouseManager.enabled = !0
                                })));
                                else if (0 == e && (ct.instance.playSoundById(102), n && n.iconCtrl && (n.iconCtrl.anchorX = n.iconCtrl.anchorY = .5, ut.propQEffect(n.iconCtrl)), n && n.callbackFirst && n.callbackFirst.run(), n && n.coinsLabelCtrl && n.addCoinsNum)) {
                                    let t = Number(n.coinsLabelCtrl.text);
                                    if (n.isScienceount) {
                                        if (!n.ownCoinsNum) return;
                                        t = n.ownCoinsNum
                                    }
                                    t = t > 0 ? t : 0;
                                    for (let e = 0; e < 10; e++) {
                                        let a = (e + 1) * (n.addCoinsNum / 10) + t;
                                        Laya.timer.once(25 * e, this, (t => {
                                            n.isScienceount ? n.coinsLabelCtrl.text = f.formatNumberWithUnits(Math.floor(t)) + "" : n.coinsLabelCtrl.text = Math.floor(t) + ""
                                        }), [a])
                                    }
                                }
                            } else m[e].counts += 70
                        }
                    }
                };
                Laya.timer.frameLoop(1, Laya.stage, updataFuc, [3e-4])
            }
            static consumePropEffect(t, e, a, n) {
                for (let a = 0; a < 3; a++)
                    for (let a = 0; a < 5; a++) Laya.timer.once(50 * a, this, (function() {
                        let a = Laya.Pool.getItemByClass("goldImage", Laya.Image);
                        a.source = Laya.loader.getRes(t), a.anchorX = .5, a.anchorY = .5, a.size(35, 35), a.pos(e.x, e.y, !0), a.zOrder = 1e3, Laya.stage.addChild(a), Laya.Tween.to(a, {
                            x: e.x + f.getIntRandom(-100, 100),
                            y: e.y + f.getIntRandom(-100, 100)
                        }, 400, null, Laya.Handler.create(this, (function(t) {
                            t.removeSelf(), Laya.Pool.recover("goldImage", t), n && n.run()
                        }), [a]))
                    }));
                let u = new Laya.Label;
                u.text = `-${a}`, u.anchorX = u.anchorY = .5, u.fontSize = 45, u.pos(e.x, e.y), u.zOrder = 1001, u.color = "#f8f3d3", u.stroke = 3, u.strokeColor = "#000000", Laya.stage.addChild(u), Laya.Tween.to(u, {
                    x: e.x,
                    y: e.y - 100
                }, 500, null, Laya.Handler.create(this, (function(t) {
                    t.removeSelf(), t.destroy()
                }), [u]))
            }
            static propQEffect(t) {
                let e = t.scaleX;
                t.scaleY;
                new g([{
                    t: "to",
                    target: t,
                    props: {
                        scaleX: 1.25 * e,
                        scaleY: .75 * e
                    },
                    duration: 50,
                    ease: null
                }, {
                    t: "to",
                    target: t,
                    props: {
                        scaleX: .75 * e,
                        scaleY: 1.25 * e
                    },
                    duration: 50,
                    ease: null
                }], !0).run()
            }
            static getBezierPoint(t, e, a, n) {
                let u = 1 - t;
                return {
                    x: u * u * e.x + 2 * t * u * a.x + t * t * n.x,
                    y: u * u * e.y + 2 * t * u * a.y + t * t * n.y
                }
            }
            static glowBreath(t, e) {
                if (!t.scene) return void console.log("该控件无所属场景!!!");
                e ? (!e.color && (e.color = "#ffffff"), !e.blur && (e.blur = 1), !e.offX && (e.offX = 0), !e.offY && (e.offY = 0)) : e = {
                    color: "#fffffff",
                    blur: 1
                };
                let a = 0,
                    n = e.blur,
                    u = !0;
                t.scene.timer.loop(100, t.scene, (() => {
                    if (u) {
                        if (a++, a > n) return void(u = !1)
                    } else if (a--, a < 0) return void(u = !0);
                    t.filters = [], t.filters = [new Laya.GlowFilter(e.color, a, e.offX, e.offY)]
                }))
            }
            static shakeCamrea(t, e = 10) {
                if (!t) return;
                let a, n = t.viewport;
                t.__mViewportTween && t.__mViewportTween instanceof Laya.Tween ? (a = t.__mViewportTween, a.complete(), a.clear()) : (a = new Laya.Tween, t.__mViewportTween = a);
                let u = new Laya.Point(n.x, n.y);
                a.to(n, {
                    update: new Laya.Handler(this, (() => {
                        let a = -e + 2 * e * Math.random(),
                            f = -e + 2 * e * Math.random();
                        n.x = u.x + a, n.y = u.y + f, t.viewport = n
                    }))
                }, 200, null, Laya.Handler.create(this, (() => {
                    n.x = u.x, n.y = u.y, t.viewport = n
                }))), t.once(Laya.Event.REMOVED, null, (() => {
                    a.clear(), delete t.__mViewportTween
                }))
            }
            static stopShakeCamrea(t) {
                if (!t) return;
                let e;
                t.__mViewportTween && t.__mViewportTween instanceof Laya.Tween && (e = t.__mViewportTween, e.complete(), e.clear(), delete t.__mViewportTween)
            }
            static loopRotate(t, e) {
                t.__loopRotateTween && this.stopLoopRotate(t);
                let a = {
                        value: 0
                    },
                    n = 360 / Math.abs(e),
                    u = new Laya.Handler(this, (() => {
                        let a = e * Laya.timer.delta / 1e3;
                        t.rotation += a
                    })),
                    exec = () => {
                        t.__loopRotateTween = Laya.Tween.to(a, {
                            value: 360,
                            update: u
                        }, 1e3 * n, null, new Laya.Handler(this, (() => {
                            exec()
                        })))
                    };
                exec(), t.on(Laya.Event.REMOVED, this, this.stopLoopRotate, [t])
            }
            static stopLoopRotate(t) {
                if (t.__loopRotateTween) {
                    t.__loopRotateTween.clear(), delete t.__loopRotateTween
                }
            }
        }
        class dt {
            static getSceneUrl(t) {
                return t
            }
            static destroy(t, e) {
                if (t && (t.autoDestroyAtClosed = !0, t.destroyed || t.close("closeByDestroy"), e && !Laya.isWXPlayable)) {
                    let e = t,
                        a = e.__loadedResMap;
                    if (a) {
                        for (const t of a) t.destroyed || t._removeReference();
                        e.__loadedResMap = void 0
                    }
                    Laya.Scene.gc()
                }
            }
            static uiChanged(t, e) {
                if (e) {
                    if (this.uiStack[this.uiStack.length - 1] == t) {
                        t.actived();
                        let e = this.uiStack[this.uiStack.length - 2];
                        e && e.deactived()
                    } else t.deactived()
                } else if (t) {
                    if (this.uiStack[this.uiStack.length - 1] == t) {
                        this.uiStack.pop(), t.deactived();
                        let e = this.uiStack[this.uiStack.length - 1];
                        e && e.actived()
                    } else {
                        let e = this.uiStack.indexOf(t); - 1 != e && (this.uiStack.splice(e, 1), t.deactived())
                    }
                }
            }
            static processRes(t) {
                Laya.loader.clearRes3d && Laya.loader.clearRes3d();
                let e = [],
                    a = [];
                for (const n of t) - 1 != ["ls", "lh"].indexOf(Laya.Utils.getFileExtension(n)) ? (Laya.loader.setGroup(n, "3DRES_GROUP"), e.push(n)) : a.push(n);
                return [e, a]
            }
            static changeScene(t, e, a) {
                let onLoadFail = function() {
                    console.error("--------------onLoadFail----------"), dt.cur_url_module = void 0, Laya.MouseManager.enabled = !0, fx.EventCenter.I.event("OnSceneLoadFail", t)
                };
                if (this.cur_url_module == t) return;
                this.cur_url_module = t;
                let n, u = dt;
                e && (n = e.userArgs, null != e.from && (n ? n.unshift(e.from) : n = [e.from])), n = n || [], Laya.MouseManager.enabled = !1, fx.EventCenter.I.event(V.E_UI_RES_LOAD_START);
                let listener = function(t) {
                    fx.EventCenter.I.event(V.E_UI_RES_LOAD_COMPLETE);
                    for (let t = u.uiStack.length - 1; t >= 0; --t) {
                        let e = u.uiStack[t];
                        e instanceof lt && (e.isShowEffect = !1, dt.closePanel(e))
                    }
                    let f = e && e.effectFunc;
                    if (f ? (t.open(!1), f.call(u, u.curScene, (() => {
                            u.curScene.exit()
                        }), t, (() => {
                            Laya.MouseManager.enabled = !0, u.cur_url_module = void 0, u.uiStack.push(t), t.enter(n), u.uiChanged(u.curScene, !1), u.uiChanged(t, !0), u.destroy(u.curScene, !0), u.curScene = t
                        }))) : (u.curScene && u.curScene.exit(), Laya.MouseManager.enabled = !0, u.cur_url_module = void 0, u.uiChanged(u.curScene, !1), t.open(!0), u.uiStack.push(t), t.enter(n), u.uiChanged(t, !0), u.destroy(u.curScene, !0), u.curScene = t), a && a.runWith(t), !Laya.isWXPlayable) {
                        Laya.ClassUtils.getRegClass("Sdk").instance.sendEvent("面板", {
                            "打开": t.getModuleUrlName()
                        })
                    }
                };
                if ("string" == typeof t) {
                    let e = t;
                    e = this.getSceneUrl(e), rt.load(e, Laya.Handler.create(u, listener))
                } else {
                    let e = t,
                        a = 1,
                        f = new e(...n),
                        g = e.getRes(...n);
                    if (g && g.length > 0) {
                        let [t, e] = this.processRes(g);
                        t.length > 0 && (a++, Laya.loader.create(t, Laya.Handler.create(u, (t => {
                            t ? (a--, 0 == a && listener(f)) : onLoadFail()
                        })))), e.length > 0 && (a++, Laya.loader.load(e, Laya.Handler.create(u, (t => {
                            if (t) {
                                for (const t of e) {
                                    let e = Laya.loader.getRes(t);
                                    if (e && 0 == e._referenceCount) {
                                        e._addReference();
                                        let t = f;
                                        t.__loadedResMap || (t.__loadedResMap = []), t.__loadedResMap.push(e)
                                    }
                                }
                                a--, 0 == a && listener(f)
                            } else onLoadFail()
                        }))))
                    }
                    f.once("onViewCreated", u, (() => {
                        a--, 0 == a && listener(f)
                    }))
                }
            }
            static changeView(e, a, n) {
                let u, g = dt;
                a && (u = a.userArgs, null != a.from && (u ? u.unshift(a.from) : u = [a.from])), u = u || [], Laya.MouseManager.enabled = !1, fx.EventCenter.I.event(V.E_UI_RES_LOAD_START);
                let listener = function(e) {
                    fx.EventCenter.I.event(V.E_UI_RES_LOAD_COMPLETE);
                    let _ = a && a.effectFunc;
                    g.curScene.pushView(e);
                    let p = g.curScene.curView;
                    _ ? (e.visible = !1, e.once(V.E_UI_ADAPTED, this, (() => {
                        e.visible = !0, _.call(g, p, (() => {
                            p && p.exit()
                        }), e, (() => {
                            Laya.MouseManager.enabled = !0, g.uiStack.push(e), e.enter(u), g.uiChanged(p, !1), g.uiChanged(e, !0), g.destroy(p), g.curScene.curView = e
                        }))
                    }))) : (p && p.exit(), Laya.MouseManager.enabled = !0, g.uiStack.push(e), e.enter(u), g.uiChanged(p, !1), g.uiChanged(e, !0), g.destroy(p), g.curScene.curView = e), n && n.runWith(e);
                    let y = f.getModule(e);
                    at.I.event(V.E_PANEL_OPENCLOSE, {
                        code: t.BaseCode.VIEW_OPEN,
                        name: dt.getModuleName(y),
                        gid: e.getGID()
                    })
                };
                if ("string" == typeof e) {
                    let t = e;
                    t = this.getSceneUrl(t), ot.load(t, Laya.Handler.create(g, listener))
                } else {
                    let t = e,
                        a = t.getRes(...u),
                        n = 1,
                        f = new t(...u);
                    a && a.length > 0 && (n++, Laya.loader.load(a, Laya.Handler.create(g, (() => {
                        n--, 0 == n && listener(f)
                    })))), f.once("onViewCreated", g, (() => {
                        n--, 0 == n && listener(f)
                    }))
                }
            }
            static pushView(e, a, n, u) {
                let g, _ = dt;
                a && (g = a.userArgs, null != a.from && (g ? g.unshift(a.from) : g = [a.from])), g = g || [], Laya.MouseManager.enabled = !1, fx.EventCenter.I.event(V.E_UI_RES_LOAD_START);
                let listener = function(e) {
                    fx.EventCenter.I.event(V.E_UI_RES_LOAD_COMPLETE);
                    let p = a && a.effectFunc;
                    _.curScene.pushView(e);
                    let y = _.curScene.curView;
                    p ? (e.visible = !1, e.once(V.E_UI_ADAPTED, this, (() => {
                        e.visible = !0, p.call(_, y, (() => {
                            y && u && y.exit()
                        }), e, (() => {
                            Laya.MouseManager.enabled = !0, _.uiStack.push(e), e.enter(g), _.uiChanged(e, !0), y && u && (y.visible = !1), _.curScene.curView = e
                        }))
                    }))) : (y && u && (y.exit(), y.visible = !1), Laya.MouseManager.enabled = !0, _.uiStack.push(e), e.enter(g), _.uiChanged(e, !0), _.curScene.curView = e), n && n.runWith(e);
                    let m = f.getModule(e);
                    if (at.I.event(V.E_PANEL_OPENCLOSE, {
                            code: t.BaseCode.VIEW_OPEN,
                            name: dt.getModuleName(m),
                            gid: e.getGID()
                        }), !Laya.isWXPlayable) {
                        Laya.ClassUtils.getRegClass("Sdk").instance.sendEvent("面板", {
                            "打开": e.getModuleUrlName()
                        })
                    }
                };
                if ("string" == typeof e) {
                    let t = e;
                    t = this.getSceneUrl(t), ot.load(t, Laya.Handler.create(_, listener))
                } else {
                    let t = e,
                        a = t.getRes(...g),
                        n = 1,
                        u = new t(...g);
                    if (a && a.length > 0) {
                        let [t, e] = this.processRes(a);
                        t.length > 0 && (n++, Laya.loader.create(t, Laya.Handler.create(_, (() => {
                            n--, 0 == n && listener(u)
                        })))), e.length > 0 && (n++, Laya.loader.load(e, Laya.Handler.create(_, (() => {
                            n--, 0 == n && listener(u)
                        }))))
                    }
                    u.once("onViewCreated", _, (() => {
                        n--, 0 == n && listener(u)
                    }))
                }
            }
            static closeView(e) {
                e.exit();
                let a = this.curScene.lastView;
                a && (a.visible = !0), this.uiChanged(e, !1), this.curScene.curView = a, this.curScene.closeView(e), this.destroy(e);
                let n = f.getModule(e);
                at.I.event(V.E_PANEL_OPENCLOSE, {
                    code: t.BaseCode.VIEW_CLOSE,
                    name: dt.getModuleName(n),
                    gid: e.getGID()
                })
            }
            static popView(e) {
                let a, n = e && e.effectFunc;
                e && (a = e.userArgs, null != e.from && (a ? a.unshift(e.from) : a = [e.from])), a = a || [];
                let u = this.curScene.lastView,
                    g = this.curScene.curView;
                if (!g) return;
                let _ = f.getModule(g);
                Laya.MouseManager.enabled = !1, n ? n.call(this, g, (() => {
                    g.exit()
                }), u, (() => {
                    Laya.MouseManager.enabled = !0, u && (u.enter(a), u.visible = !0), this.uiChanged(g, !1), this.curScene.curView = u, this.curScene.popView(), this.destroy(g)
                })) : (g && g.exit(), Laya.MouseManager.enabled = !0, u && (u.enter(a), u.visible = !0), this.uiChanged(g, !1), this.curScene.curView = u, this.curScene.popView(), this.destroy(g)), at.I.event(V.E_PANEL_OPENCLOSE, {
                    code: t.BaseCode.VIEW_CLOSE,
                    name: dt.getModuleName(_),
                    gid: g.getGID()
                })
            }
            static getModuleByName(t) {
                return Laya.ClassUtils.getRegClass(t)
            }
            static getModuleName(t) {
                let e = Laya.ClassUtils._classMap;
                for (const a in e)
                    if (e.hasOwnProperty(a) && e[a] == t) return a
            }
            static openPanel(e, a, n) {
                let u, g = dt;
                a && (u = a.userArgs, null != a.from && (u ? u.unshift(a.from) : u = [a.from])), u = u || [], Laya.MouseManager.enabled = !1, fx.EventCenter.I.event(V.E_UI_RES_LOAD_START);
                let listener = function(e) {
                    fx.EventCenter.I.event(V.E_UI_RES_LOAD_COMPLETE);
                    let _ = null;
                    a && a.addToScene && (_ = g.curScene.createDialogManager(a.addToScene), e.popupEffect = _.popupEffectHandler, e.closeEffect = _.closeEffectHandler);
                    let p = a && a.effectFunc;
                    if (p) g.uiStack.push(e), e.open(!1, u, _), g.uiChanged(e, !0), p.call(g, null, null, e, (() => {
                        Laya.MouseManager.enabled = !0
                    }));
                    else {
                        let t = a && a.closeOther;
                        null == t && (t = !0), Laya.MouseManager.enabled = !0, g.uiStack.push(e), e.open(t, u, _), g.uiChanged(e, !0)
                    }
                    n && n.runWith(e);
                    let y = f.getModule(e);
                    if (at.I.event(V.E_PANEL_OPENCLOSE, {
                            code: t.BaseCode.PANEL_OPEN,
                            name: dt.getModuleName(y),
                            gid: e.getGID()
                        }), !Laya.isWXPlayable) {
                        Laya.ClassUtils.getRegClass("Sdk").instance.sendEvent("面板", {
                            "打开": e.getModuleUrlName()
                        })
                    }
                };
                if ("string" == typeof e) {
                    let t = e;
                    t = this.getSceneUrl(t), Laya.Dialog.load(t, Laya.Handler.create(this, listener))
                } else if (a && a.isInstance) listener(e);
                else {
                    let t = e,
                        a = t.getRes(...u),
                        n = new t(...u),
                        f = 1;
                    !n.url && (f = 0), a && a.length > 0 && (f++, Laya.loader.load(a, Laya.Handler.create(g, (() => {
                        f--, 0 == f && listener(n)
                    })))), n.once("onViewCreated", g, (() => {
                        f--, 0 == f && listener(n)
                    }))
                }
            }
            static closePanel(e, a) {
                let n = dt,
                    u = f.getModule(e),
                    g = a && a.effectFunc,
                    _ = a && a.autoDestroy;
                null == _ && (_ = !0);
                let p = e.getGID();
                e.once(Laya.Event.REMOVED, this, (() => {
                    e && (e.mouseEnabled = !0), at.I.event(V.E_PANEL_OPENCLOSE, {
                        code: t.BaseCode.PANEL_CLOSE,
                        name: dt.getModuleName(u),
                        gid: p
                    })
                })), g ? (Laya.MouseManager.enabled = !1, g.call(n, e, (() => {
                    Laya.MouseManager.enabled = !0, e.autoDestroyAtClosed = _, e.isShowEffect = !1, e.close("closePanel"), n.uiChanged(e, !1)
                }))) : (e.autoDestroyAtClosed = _, n.uiChanged(e, !1), e.close("closePanel"), e.isShowEffect && (e.mouseEnabled = !1))
            }
            static getCurScene() {
                return this.curScene
            }
            static getCurSceneRgeName() {
                let t = f.getModule(this.curScene);
                if (t) return this.getModuleName(t)
            }
            static getCurViewRgeName() {
                let t = f.getModule(this.curScene.curView);
                if (t) return this.getModuleName(t)
            }
            static getCurDialogRegName() {
                let t = Laya.Dialog.manager,
                    e = t.getChildAt(t.numChildren - 1);
                if (e) return this.getModuleName(f.getModule(e))
            }
            static getCurUIRegName(t = 1) {
                let e = this.uiStack[this.uiStack.length - t];
                if (e) return this.getModuleName(f.getModule(e))
            }
            static isInUIStack(t) {
                return -1 != this.uiStack.indexOf(t)
            }
        }
        dt.uiStack = [], dt.EF_FADE_OUT_BLACK = function(t, e, a, n, u) {
            n.visible = !1, ut.shadeScreen("#000000", t, 1, Laya.Handler.create(this, (() => {
                n.visible = !0, a && a(), u && u()
            })))
        }, dt.EF_FADE_OUT = function(t, e, a, n, u) {
            n.visible = !0, Laya.Tween.to(e, {
                alpha: 0
            }, t, null, Laya.Handler.create(this, (() => {
                e.visible = !1, a && a(), u && u()
            }))), e.alpha = 1, e.zOrder = 1
        }, dt.EF_FADE_INOUT = function(t, e, a, n, u) {
            e.alpha = 1, n.alpha = 0, Laya.Tween.to(e, {
                alpha: 0
            }, t, null), Laya.Tween.to(n, {
                alpha: 1
            }, t, null, Laya.Handler.create(this, (() => {
                a && a(), u && u()
            })))
        }, dt.EF_FADE_IN_OUT = function(t, e, a, n, u) {
            e.alpha = 1, n.alpha = 0, Laya.Tween.to(e, {
                alpha: 0
            }, .5 * t, null, Laya.Handler.create(this, (() => {
                Laya.Tween.to(n, {
                    alpha: 1
                }, .5 * t, null, Laya.Handler.create(this, (() => {
                    a && a(), u && u()
                })))
            })))
        }, dt.EF_QSCALE_IN = function(t, e, a, n) {
            f.resetAnchor(a, .5, .5), Laya.Tween.from(a, {
                scaleX: 0,
                scaleY: 0
            }, 300, Laya.Ease.backOut, Laya.Handler.create(this, (() => {
                e && e(), n && n()
            })))
        }, dt.EF_QSCALE_FADE_IN = function(t, e, a, n) {
            a.alpha = 0, f.resetAnchor(a, .5, .5), Laya.Tween.from(a, {
                scaleX: 0,
                scaleY: 0
            }, 300, Laya.Ease.backOut, Laya.Handler.create(this, (() => {
                e && e(), n && n()
            }))), Laya.Tween.to(a, {
                alpha: 1
            }, 400, null, null)
        }, dt.EF_QSCALE_OUT = function(t, e, a, n) {
            Laya.Tween.to(t, {
                scaleX: 0,
                scaleY: 0
            }, 300, Laya.Ease.strongOut, Laya.Handler.create(t, (() => {
                e && e(), n && n()
            }), [t]))
        }, dt.EF_PANEL = function(t, e, a, n, u) {
            n.alpha = 0, dt.openPanel(t, {
                from: "",
                userArgs: [n, Laya.Handler.create(this, (() => {
                    a && a(), u && u()
                }))]
            })
        }, Laya.ClassUtils.regClass("SceneManager", dt), window.Config3D || (window.Config3D = class {
            constructor() {}
        });
        const ft = {
            enableShadow: !1,
            enableMultiLight: !1,
            enableAntialias: !0,
            enableRetinalCanvas: !0,
            enableHDR: !1
        };
        class gt extends nt {
            constructor() {
                super(), this._initialized = !1
            }
            init(...t) {
                0 == this._initialized && this.onInitOnce.apply(this, t), this.onInit(...t), this._initialized = !0
            }
            get initialized() {
                return this._initialized
            }
            onInit(...t) {}
            onInitOnce(...t) {}
        }
        class _t {
            constructor(t) {
                this.includes = [], this.readySaveProps = [];
                let e = t.getKey(),
                    a = _t.keyMap[e],
                    n = f.getModule(t);
                a && a != n ? console.error(`存储key重复！ ${e}`) : (this.data = t, _t.keyMap[e] = n, this.init(), t.isAutoRecover && this.recover())
            }
            init() {
                let t = this.data,
                    e = this.includes.slice();
                if (0 != this.includes.length || t.getIncludes) {
                    if (t.getIncludes) {
                        let a = t.getIncludes();
                        e = f.diffArray(this.includes, a, !0)
                    }
                } else e = Object.keys(t);
                if (t.getExcludes) {
                    let a = t.getExcludes();
                    for (const t of a) e.splice(e.indexOf(t), 1)
                }
                f.warpObjectGetterSetterAppend(t, e, this.dirty.bind(this)), this.includes = this.includes.concat(e)
            }
            hasStorage() {
                let t = this.data.getKey();
                return !!Laya.LocalStorage.getItem(t)
            }
            getData() {
                return this.data
            }
            recover() {
                let t = this.data.getKey(),
                    e = Laya.LocalStorage.getItem(t);
                if (e) try {
                    let t = e.charAt(0),
                        a = e.charAt(1),
                        n = e;
                    "Z" == t && "L" == a && (n = LZString.decompress(e.substring(2)));
                    let u = JSON.parse(n);
                    return f.assign(this.data, u, !1), !0
                } catch (a) {
                    console.log("LocalStorage.getItem error: ", t, e)
                }
            }
            dirty(t) {
                this.readySaveProps.includes(t) || this.readySaveProps.push(t), this.data.isAutoSave && 1 == this.readySaveProps.length && Laya.CallLater.I.callLater(this, this._save)
            }
            save() {
                this._save()
            }
            _save() {
                let t = [],
                    e = this.data;
                e.getExcludes && (t = e.getExcludes());
                let a = e;
                if (this.includes.length > 0) {
                    a = {};
                    for (const t of this.includes) a[t] = this.data[t]
                }
                let n = JSON.stringify(a, ((e, a) => {
                        if (!t.includes(e)) return a
                    })),
                    u = e.getKey();
                e.isCompress && "undefined" != typeof LZString && (n = "ZL" + LZString.compress(n)), Laya.LocalStorage.setItem(u, n)
            }
            clear() {
                let t = this.data.getKey();
                Laya.LocalStorage.removeItem(t)
            }
        }
        _t.keyMap = {};
        class pt {
            constructor(t) {
                this.autoSave = !0, pt.keyList.includes(t) ? console.error(`存储key重复！ ${t}`) : (this.key = t, pt.keyList.push(t))
            }
            init() {
                let t = this.loadData();
                if (t)
                    for (const e in this)
                        if (this.hasOwnProperty(e)) {
                            let a = t[e];
                            null != a && "" !== a && (this[e] = a)
                        }
            }
            loadData() {
                let t = Laya.LocalStorage.getItem(this.key);
                if (t) {
                    if (t instanceof Object) return t;
                    try {
                        t = JSON.parse(t)
                    } catch (e) {
                        console.log("LocalStorage.getItem error: ", this.key, t)
                    }
                }
                return t
            }
            dirty(t) {
                this.autoSave && Laya.CallLater.I.callLater(this, this._save)
            }
            save() {
                Laya.CallLater.I.callLater(this, this._save)
            }
            _save() {
                let t = ["$_GID", "_autoSave", "_key"],
                    e = JSON.stringify(this, ((e, a) => {
                        for (const a of t)
                            if (e == a) return;
                        return a
                    }));
                Laya.LocalStorage.setItem(this.key, e)
            }
            clear() {
                Laya.LocalStorage.removeItem(this.key)
            }
        }
        pt.keyList = [];
        const yt = window.CryptoJS;
        class mt {
            static getSecret() {
                return this._secret
            }
            static setSecret(t) {
                this._secret || this._secret != t && (this._secret = t, this.key = String(t))
            }
            static decryptAes(t) {
                if (!this.key) throw Error("need secret key !");
                let e = yt.AES.decrypt(t, this.key);
                return JSON.parse(e.toString(yt.enc.Utf8))
            }
            static encryptAes(t) {
                if (!this.key) throw Error("need secret key !");
                return yt.AES.encrypt(JSON.stringify(t), this.key).toString()
            }
            static base64Ciphertext(t) {
                let e = yt.enc.Hex.parse(t);
                return yt.enc.Base64.stringify(e)
            }
        }
        class bt {
            constructor() {
                this.releasePool = [], Laya.timer.frameLoop(1, this, this.update)
            }
            static get instance() {
                return this._instance || (this._instance = new bt), this._instance
            }
            add(t, e = !0, a, n) {
                if (!t) return;
                let u = {
                    node: t,
                    delay: a,
                    destroy: e,
                    group: n
                };
                a && (u.addtime = Laya.Browser.now()), this.releasePool.push(u)
            }
            update() {
                let t = Laya.Browser.now();
                for (let e = this.releasePool.length - 1; e >= 0; e--) {
                    let a = this.releasePool[e];
                    a.delay ? t - a.addtime >= a.delay && this.release(a, e) : this.release(a, e)
                }
            }
            release(t, e) {
                t.destroy ? t.node.destroyed || t.node.destroy() : t.node.removeSelf(), this.releasePool.splice(e, 1)
            }
            releaseByGroup(t) {
                if (t)
                    for (let e = this.releasePool.length - 1; e >= 0; e--) {
                        let a = this.releasePool[e];
                        a.group == t && this.release(a, e)
                    }
            }
        }
        class wt extends Laya.EventDispatcher {
            constructor(t) {
                super();
                let e = new Laya.HttpRequest;
                e.http.timeout = 1e4, e.once(Laya.Event.COMPLETE, this, this.completeHandler), e.once(Laya.Event.ERROR, this, this.errorHandler), e.on(Laya.Event.PROGRESS, this, this.processHandler), this.xhr = e, this.encrypt = t
            }
            send(t, e, a, n, u = "POST") {
                const f = window.pako;
                if (t) {
                    this.once("HTTPRSP", n, a);
                    let g = Laya.LocalStorage.getItem("AUTHTOKEN"),
                        _ = ["Content-Type", "application/x-www-form-urlencoded"];
                    g && (_.push("authorization"), _.push(g));
                    let p = JSON.stringify(e);
                    if (console.log("http >>>>>>>>>>>>>>>>>>> url:" + t + " data:" + p), "GET" == u.toUpperCase()) {
                        let a;
                        for (let t in e) {
                            let n = e[t];
                            "object" == typeof n && (n = JSON.stringify(n)), a = null == a ? t + "=" + encodeURIComponent(n) : a + "&" + t + "=" + encodeURIComponent(n)
                        }
                        this.xhr.send(t + "?" + a, null, u, "json", _)
                    } else _[1] = "application/json", p = this.encrypt ? f.deflate(encodeURIComponent(p), {
                        to: "string"
                    }) : encodeURIComponent(p), p = JSON.stringify({
                        data: p
                    }), this.xhr.send(t, p, u, "json", _)
                }
            }
            registerErrHandler(t, e) {
                this.once("HTTPERR", e, t)
            }
            processHandler(t) {}
            errorHandler(t) {
                console.log("http <<<<<<<<<<<<<<<<<<< error:" + JSON.stringify(t)), this.event("HTTPERR", t)
            }
            completeHandler(e) {
                const a = window.pako;
                let n = e.data;
                if (n) {
                    this.encrypt && (n = a.inflate(n, {
                        to: "string"
                    })), n = decodeURIComponent(n), console.log("http <<<<<<<<<<<<<<<<<<< ok:" + n);
                    try {
                        n = JSON.parse(n)
                    } catch (e) {
                        return void this.event("HTTPERR", {
                            code: t.BaseCode.HTTP_INTERFACE_UNDEFINED
                        })
                    }
                    try {
                        let t = this.xhr.http;
                        if (t.getAllResponseHeaders()) {
                            const e = ["authorization", "Authorization"];
                            for (const a of e) {
                                let e = t.getResponseHeader(a);
                                if (e) {
                                    Laya.LocalStorage.setItem("AUTHTOKEN", e);
                                    break
                                }
                            }
                        }
                    } catch (t) {}
                    this.event("HTTPRSP", n)
                } else console.log("http <<<<<<<<<<<<<<<<<<< ok: null")
            }
        }
        class xt {
            static request(t, e, a, n, u, f, g, _) {
                let p, y = new Laya.HttpRequest;
                if (y.http.timeout = g || 1e4, y.once(Laya.Event.COMPLETE, this, (t => {
                        console.log("HttpManager request complete: ", t), u && f && f.call(u, t)
                    })), y.once(Laya.Event.ERROR, this, (t => {
                        console.log("HttpManager request error: ", t), u && f && f.call(u, t)
                    })), p = "GET" == e ? ["Content-Type", "application/x-www-form-urlencoded"] : ["Content-Type", "application/json"], n && (p[2] = "Authorization", p[3] = n), _ && _.length > 0)
                    for (let t = 0; t < _.length; t += 2) {
                        let e = _[t],
                            a = _[t + 1];
                        void 0 !== e && void 0 !== a && p.push(e, a)
                    }
                "string" != typeof a && (a = JSON.stringify(a)), y.send(t, a, e, "json", p)
            }
        }
        class Lt {
            static get I() {
                return this._instance || (this._instance = new Lt), this._instance
            }
            callback(t, e, a) {
                t && e && e.call(t, a)
            }
            isLogin() {
                return !!this._openID
            }
            getOpenId() {
                return this._openID
            }
            getToken() {
                return this._token
            }
            login(t, e, a) {
                if (this.isLogin()) return void this.callback(e, a, [!0]);
                this._serverUrl = t.serverUrl, this._gameID = t.gameID, this._platform = t.platform;
                let n = this._serverUrl + "/createaccount",
                    u = window.sdk.Sdk.instance.getLoginCode(),
                    f = window.sdk.Sdk.instance.getLoginAnonymousCode(),
                    g = {
                        gameID: this._gameID,
                        platform: this._platform,
                        third: {
                            code: u,
                            anonymous_code: f,
                            openid: "",
                            anonymousOpenid: ""
                        },
                        strict: t.strict
                    };
                t.openid && (g.third.openid = t.openid), t.anonymousOpenid && (g.third.anonymousOpenid = t.anonymousOpenid), xt.request(n, "POST", g, null, this, (t => {
                    t && t.jwt && t.user && t.user.udid ? (this._token = t.jwt, this._openID = t.user.udid, console.log("http 登录成功!", t)) : console.log("http 登录失败!", t), this.callback(e, a, [this.isLogin(), t])
                }), 5e3)
            }
            getStorage(t, e) {
                if (!this._token) return console.log("getStorage 请先登录"), void this.callback(t, e, null);
                let a = this._serverUrl + "/getStorage",
                    n = {
                        gameID: this._gameID,
                        platform: this._platform,
                        openID: this._openID
                    };
                xt.request(a, "POST", n, this._token, t, e, 5e3)
            }
            setStorage(t, e, a) {
                if (!this._token) return console.log("setStorage 请先登录"), void this.callback(e, a, null);
                let n = this._serverUrl + "/setStorage",
                    u = {
                        gameID: this._gameID,
                        platform: this._platform,
                        openID: this._openID,
                        data: t
                    };
                xt.request(n, "POST", u, this._token, e, a)
            }
        }
        const vt = 1e8,
            St = "__TableViewIdx";
        var Et;
        t.TableViewDirection = void 0, (Et = t.TableViewDirection || (t.TableViewDirection = {}))[Et.HORIZONTAL = 0] = "HORIZONTAL", Et[Et.VERTICAL = 1] = "VERTICAL";
        class Tt extends Laya.Panel {
            constructor() {
                super(), this._indices = [], this._cellsUsed = [], this._cellsFreed = [], this._cellsPositions = [], this._direction = t.TableViewDirection.HORIZONTAL, this._isUsedCellsDirty = !1, this._contentSize = new fx.Size(0, 0)
            }
            get contentWidth() {
                return this._contentSize.width
            }
            get contentHeight() {
                return this._contentSize.height
            }
            get direction() {
                return this._direction
            }
            set direction(e) {
                this._direction = e, this.direction == t.TableViewDirection.HORIZONTAL ? this.hScrollBarSkin = "" : this.vScrollBarSkin = ""
            }
            get scrollBar() {
                return this._direction == t.TableViewDirection.HORIZONTAL ? this.hScrollBar : this.vScrollBar
            }
            reloadData() {
                this.scrollBar.changeHandler = new Laya.Handler(this, this._didScroll);
                for (const t of this._cellsUsed) this._cellsFreed.push(t), t.removeSelf();
                this._indices = [], this._cellsUsed = [], this._updateCellPositions(), this._updateContentSize(), this.dataHandler.cellsCount() > 0 && this._didScroll()
            }
            _updateCellPositions() {
                this._cellsPositions = [];
                let e = this.dataHandler.cellsCount();
                if (e > 0) {
                    let a = 0;
                    for (let n = 0; n < e; ++n) {
                        this._cellsPositions[n] = a;
                        let e = this.dataHandler.cellSizeAtIndex(this, n);
                        this.direction == t.TableViewDirection.HORIZONTAL ? a += e.width : a += e.height
                    }
                    this._cellsPositions[e] = a
                }
            }
            _updateContentSize() {
                let e = this.dataHandler.cellsCount();
                if (e > 0) {
                    let a = this._cellsPositions[e];
                    this.direction == t.TableViewDirection.HORIZONTAL ? this._contentSize = new fx.Size(a, this.height) : this._contentSize = new fx.Size(this.width, a), this.refresh()
                }
            }
            _offsetFromIndex(a) {
                return this.direction == t.TableViewDirection.HORIZONTAL ? new e(this._cellsPositions[a], 0) : new e(0, this._cellsPositions[a])
            }
            _indexFromOffset(t) {
                let e = this.dataHandler.cellsCount() - 1,
                    a = this.__indexFromOffset(t);
                return -1 != a && (a = Math.max(0, a), a > e && (a = vt)), a
            }
            __indexFromOffset(t) {
                let e = 0,
                    a = this.dataHandler.cellsCount() - 1,
                    n = t;
                for (; a >= e;) {
                    let t = e + Math.floor((a - e) / 2),
                        u = this._cellsPositions[t],
                        f = this._cellsPositions[t + 1];
                    if (n >= u && n <= f) return t;
                    n < u ? a = t - 1 : e = t + 1
                }
                return e <= 0 ? 0 : -1
            }
            _didScroll() {
                let e = this.dataHandler.cellsCount();
                if (0 == e) return;
                this._isUsedCellsDirty && (this._isUsedCellsDirty = !1, this._cellsUsed.sort(((t, e) => t[St] - e[St])));
                let a = this.scrollBar.value,
                    n = Math.max(e - 1, 0),
                    u = this._indexFromOffset(a);
                u == vt && (u = e - 1), this.direction == t.TableViewDirection.HORIZONTAL ? a += this.width : a += this.height;
                let f = this._indexFromOffset(a);
                if (f == vt && (f = e - 1), -1 == f && 1 == e && (f = u), this._cellsUsed.length > 0) {
                    let t = this._cellsUsed[0],
                        e = t[St];
                    for (; e < u && (this._moveCellOutOfSight(t), this._cellsUsed.length > 0);) t = this._cellsUsed[0], e = t[St]
                }
                if (this._cellsUsed.length > 0) {
                    let t = this._cellsUsed[this._cellsUsed.length - 1],
                        e = t[St];
                    for (; e <= n && e > f && (this._moveCellOutOfSight(t), this._cellsUsed.length > 0);) t = this._cellsUsed[this._cellsUsed.length - 1], e = t[St]
                }
                for (let t = u; t <= f; ++t) this._indices.includes(t) || this.updateCellAtIndex(t)
            }
            _moveCellOutOfSight(t) {
                let e = t[St],
                    a = this._cellsUsed.indexOf(t);
                this._cellsUsed.splice(a, 1), this._cellsFreed.push(t), this._isUsedCellsDirty = !0, a = this._indices.indexOf(e), this._indices.splice(a, 1), t.removeSelf()
            }
            _setIndexForCell(t, e) {
                e.anchorX = e.anchorY = 0;
                let a = this._offsetFromIndex(t);
                e.pos(a.x, a.y), e[St] = t
            }
            _addCellIfNecessary(t) {
                t.parent != this.content && this.addChild(t), this._cellsUsed.push(t), this._indices.push(t[St]), this._isUsedCellsDirty = !0
            }
            cellAtIndex(t) {
                if (this._indices.includes(t))
                    for (const e of this._cellsUsed)
                        if (e[St] == t) return e;
                return null
            }
            updateCellAtIndex(t) {
                if (t == vt) return;
                let e = this.dataHandler.cellsCount();
                if (0 == e || t >= e) return;
                let a = this.cellAtIndex(t);
                a && this._moveCellOutOfSight(a), a = this.dataHandler.tableCellAtIndex(this, t), this._setIndexForCell(t, a), this._addCellIfNecessary(a)
            }
            insertCellAtIndex(t) {
                if (t == vt) return;
                let e = this.dataHandler.cellsCount();
                if (0 == e || t >= e) return;
                let a = 0,
                    n = this.cellAtIndex(t);
                if (n) {
                    a = this._cellsUsed.indexOf(n);
                    for (let t = a; t < this._cellsUsed.length; t++) n = this._cellsUsed[t], this._setIndexForCell(n[St] + 1, n)
                }
                this._updateCellPositions(), this._updateContentSize(), this._didScroll()
            }
            removeCellAtIndex(t) {
                if (t == vt) return;
                let e = this.dataHandler.cellsCount();
                if (0 == e || t >= e) return;
                let a = 0,
                    n = this.cellAtIndex(t);
                if (!n) return;
                a = this._cellsUsed.indexOf(n), this._moveCellOutOfSight(n);
                let u = this._indices.indexOf(t);
                this._indices.splice(u, 1), this._updateCellPositions();
                for (let t = this._cellsUsed.length - 1; t > a; t--) n = this._cellsUsed[t], this._setIndexForCell(n[St] - 1, n)
            }
            dequeueCell() {
                if (0 == this._cellsFreed.length) return null; {
                    let t = this._cellsFreed[0];
                    return this._cellsFreed.splice(0, 1), t
                }
            }
            scrollToTop() {
                this.scrollTo(0, 0)
            }
            scrollToBottom() {
                this.scrollTo(0, this.scrollBar.max)
            }
        }
        class Ct extends Laya.Image {
            constructor(t) {
                super(), this._anisMap = {}, this._interval = 50, t && this.load(t)
            }
            onDestroy() {
                this.clearTimer(this, this._frameLoop)
            }
            load(t) {
                for (const e of t) this._anisMap[e.name] = e;
                return this
            }
            play(t, e, a, n, u, f) {
                !f && this._isPlaying && t == this._curAniName || (this._isPlaying = !0, this._loop = a, this._animation = this._anisMap[t], this._curAniName = t, this._count = this._animation.frames.length, n ? this.interval = n : this._animation.frameRate && (this._interval = 1e3 / this._animation.frameRate), this.activeInHierarchy && (this.clearTimer(this, this._frameLoop), this.timerLoop(this.interval, this, this._frameLoop, null, !0, !0)), this._complete = u, this.index = e || 0)
            }
            _onActiveInScene() {
                super._onActiveInScene(), this.interval > 0 && (this.clearTimer(this, this._frameLoop), this.timerLoop(this.interval, this, this._frameLoop, null, !0, !0))
            }
            gotoAndStop(t, e) {
                this._animation = this._anisMap[t], this._count = this._animation.frames.length, this.index = e, this.stop()
            }
            stop() {
                this._isPlaying = !1, this._curAniName = null, this.clearTimer(this, this._frameLoop)
            }
            pause() {
                this._isPause = !0
            }
            resume() {
                this._isPause = !1
            }
            get isPlaying() {
                return this._isPlaying
            }
            get index() {
                return this._index
            }
            set index(t) {
                this._index = t, this._displayToIndex(t)
            }
            get interval() {
                return this._interval
            }
            set interval(t) {
                this._interval != t && (this._interval = t, this._isPlaying && t > 0 && this.scene && (this.clearTimer(this, this._frameLoop), this.timerLoop(t, this, this._frameLoop, null, !0, !0)))
            }
            _displayToIndex(t) {
                this.skin = this._animation.frames[t]
            }
            _frameLoop() {
                this.destroyed ? this.clearTimer(this, this._frameLoop) : this.visible && this.parent && this._animation && !this._isPause && (this._index++, this._index >= this._count && (this._loop ? this._index = 0 : (this._index = 0, this.stop(), this._complete && this._complete.run())), this.destroyed || (this.index = this._index))
            }
            getCurAniName() {
                return this._curAniName
            }
            hasAni(t) {
                return Boolean(this._anisMap[t])
            }
        }
        class At extends Laya.Sprite {
            constructor(t) {
                super(), this._dir = new a, this._temp = new a, this._tempPoint = new Laya.Point, this._pointSize = 11, this._maxWidth = 40, this._minWidth = 2, this._historySize = 10, this._historyX = [], this._historyY = [], this._startTrail = !1, this._skin = t
            }
            onAwake() {
                this._lastPos = new a(this.x, this.y, 0), this._points = [];
                for (let t = 0; t < this._pointSize; t++) this._points.push(new a(0, 0, 0));
                Laya.loader.load(this._skin, Laya.Handler.create(this, (t => {
                    t && (this._tex = t, this.initCmd(), this.updateVertices())
                }))), this.frameLoop(1, this, this.update)
            }
            onDestroy() {
                this.clearTimer(this, this.update)
            }
            initCmd() {
                this._vertices = new Float32Array(4 * this._pointSize);
                let t = new Float32Array(4 * this._pointSize),
                    e = new Uint16Array(6 * (this._pointSize - 1));
                for (let t = 1; t < this._pointSize; ++t) {
                    let a = 6 * (t - 1),
                        n = 2 * (t - 1);
                    e[a] = n, e[a + 1] = n + 1, e[a + 2] = n + 2, e[a + 3] = n + 2, e[a + 4] = n + 1, e[a + 5] = n + 3
                }
                this._cmd = this.graphics.drawTriangles(this._tex, 0, 0, this._vertices, t, e)
            }
            updateVertices() {
                if (this._points.length <= 1) return;
                let t = 0,
                    e = this._points[0],
                    n = [0];
                for (let u = 1; u < this._points.length; ++u) {
                    let f = this._points[u],
                        g = a.distance(f, e);
                    t += g, e = f, n.push(g)
                }
                let u = 0;
                e = this._points[0], a.subtract(this._points[0], this._points[1], this._dir);
                for (let e = 0; e < this._points.length; ++e) {
                    u += n[e];
                    let f = this._points[e],
                        g = this._minWidth + (this._maxWidth - this._minWidth) * (t - u) / t;
                    a.cross(this._dir, a.UnitZ, this._temp), this._temp.normalize(g / 2);
                    let _ = 4 * e;
                    this._vertices[_] = f.x + this._temp.x, this._vertices[_ + 1] = f.y + this._temp.y, this._vertices[_ + 2] = f.x - this._temp.x, this._vertices[_ + 3] = f.y - this._temp.y, e > 0 && a.subtract(this._points[e - 1], f, this._dir)
                }
            }
            update() {
                if (!this._cmd || !this.visible || !this._startTrail) return;
                this._tempPoint.setTo(0, 0), this.localToGlobal(this._tempPoint), this._historyX.length >= this._historySize && this._historyX.pop(), this._historyX.unshift(this._tempPoint.x), this._historyY.length >= this._historySize && this._historyY.pop(), this._historyY.unshift(this._tempPoint.y);
                let t = 0,
                    e = 0;
                for (var a = 0; a < this._pointSize; a++) {
                    var n = this._points[a];
                    a < this._historyX.length ? (n.x = this._historyX[a] - this._tempPoint.x, n.y = this._historyY[a] - this._tempPoint.y, t = n.x, e = n.y) : (n.x = t, n.y = e)
                }
                this.updateVertices(), this._lastPos.setValue(this._tempPoint.x, this._tempPoint.y, 0)
            }
            start() {
                this._startTrail || (this.visible = !0, this._startTrail = !0, this.update())
            }
            stop() {
                this.visible = !1, this._startTrail = !1;
                for (let t = 0; t < this._points.length; t++) this._points[t].setValue(0, 0, 0);
                this._historyX = [], this._historyY = []
            }
        }
        class Mt {
            constructor(t, e) {
                this.x = 0, this.y = 0, this.x = t, this.y = e
            }
            plus(t) {
                return new Mt(this.x + t.x, this.y + t.y)
            }
            minus(t) {
                return new Mt(this.x - t.x, this.y - t.y)
            }
            multiply(t) {
                return this.x * t.x + this.y * t.y
            }
            scale(t) {
                return new Mt(this.x * t, this.y * t)
            }
            copy(t) {
                return this.x = t.x, this.y = t.y, this
            }
            clone() {
                return new Mt(this.x, this.y)
            }
            substract(t, e) {
                return t.x -= e.x, t.y -= e.y, t
            }
            lengthSqr() {
                return Math.pow(this.x, 2) + Math.pow(this.y, 2)
            }
        }
        class It {}
        class Ot {}
        class kt {
            constructor(t, e) {
                this.key = t, this.value = e
            }
        }
        class Nt {
            static absSq(t) {
                return t.multiply(t)
            }
            static normalize(t) {
                return t.scale(1 / Nt.abs(t))
            }
            static distSqPointLineSegment(t, e, a) {
                let n = a.minus(t),
                    u = e.minus(t),
                    f = n.multiply(u) / Nt.absSq(u);
                return f < 0 ? Nt.absSq(n) : f > 1 ? Nt.absSq(a.minus(e)) : Nt.absSq(a.minus(t.plus(u.scale(f))))
            }
            static sqr(t) {
                return t * t
            }
            static det(t, e) {
                return t.x * e.y - t.y * e.x
            }
            static abs(t) {
                return Math.sqrt(Nt.absSq(t))
            }
            static leftOf(t, e, a) {
                return Nt.det(t.minus(a), e.minus(t))
            }
        }
        Nt.RVO_EPSILON = 1e-5;
        class Pt {
            constructor() {
                this.agentNeighbors_ = [], this.obstaclNeighbors_ = [], this.orcaLines_ = [], this.position_ = new Mt(0, 0), this.prefVelocity_ = new Mt(0, 0), this.velocity_ = new Mt(0, 0), this.id = 0, this.maxNeighbors_ = 0, this.maxSpeed_ = 0, this.neighborDist = 0, this.radius_ = 0, this.timeHorizon = 0, this.timeHorizonObst = 0, this.newVelocity_ = new Mt(0, 0), this.mass = 1
            }
            computeNeighbors(t) {
                this.obstaclNeighbors_.length = 0;
                let e = Math.pow(this.timeHorizonObst * this.maxSpeed_ + this.radius_, 2);
                t.kdTree.computeObstacleNeighbors(this, e), this.agentNeighbors_.length = 0, this.maxNeighbors_ > 0 && (e = Math.pow(this.neighborDist, 2), e = t.kdTree.computeAgentNeighbors(this, e))
            }
            computeNewVelocity(t) {
                this.orcaLines_.length = 0;
                let e = this.orcaLines_,
                    a = 1 / this.timeHorizonObst;
                for (let t = 0; t < this.obstaclNeighbors_.length; ++t) {
                    let n = this.obstaclNeighbors_[t].value,
                        u = n.next,
                        f = n.point.minus(this.position_),
                        g = u.point.minus(this.position_),
                        _ = !1;
                    for (let t = 0; t < e.length; ++t)
                        if (Nt.det(f.scale(a).minus(e[t].point), e[t].direction) - a * this.radius_ >= -Nt.RVO_EPSILON && Nt.det(g.scale(a).minus(e[t].point), e[t].direction) - a * this.radius_ >= -Nt.RVO_EPSILON) {
                            _ = !0;
                            break
                        }
                    if (_) continue;
                    let p, y, m = Nt.absSq(f),
                        b = Nt.absSq(g),
                        w = Nt.sqr(this.radius_),
                        x = u.point.minus(n.point),
                        v = f.scale(-1).multiply(x) / Nt.absSq(x),
                        S = Nt.absSq(f.scale(-1).minus(x.scale(v))),
                        E = new Ot;
                    if (v < 0 && m <= w) {
                        n.convex && (E.point = new Mt(0, 0), E.direction = Nt.normalize(new Mt(-f.y, f.x)), e.push(E));
                        continue
                    }
                    if (v > 1 && b <= w) {
                        u.convex && Nt.det(g, u.direction) >= 0 && (E.point = new Mt(0, 0), E.direction = Nt.normalize(new Mt(-g.y, g.x)), e.push(E));
                        continue
                    }
                    if (v >= 0 && v <= 1 && S <= w) {
                        E.point = new Mt(0, 0), E.direction = n.direction.scale(-1), e.push(E);
                        continue
                    }
                    if (v < 0 && S <= w) {
                        if (!n.convex) continue;
                        u = n;
                        let t = Math.sqrt(m - w);
                        p = new Mt(f.x * t - f.y * this.radius_, f.x * this.radius_ + f.y * t).scale(1 / m), y = new Mt(f.x * t + f.y * this.radius_, -f.x * this.radius_ + f.y * t).scale(1 / m)
                    } else if (v > 1 && S <= w) {
                        if (!u.convex) continue;
                        n = u;
                        let t = Math.sqrt(b - w);
                        p = new Mt(g.x * t - g.y * this.radius_, g.x * this.radius_ + g.y * t).scale(1 / b), y = new Mt(g.x * t + g.y * this.radius_, -g.x * this.radius_ + g.y * t).scale(1 / b)
                    } else {
                        if (n.convex) {
                            let t = Math.sqrt(m - w);
                            p = new Mt(f.x * t - f.y * this.radius_, f.x * this.radius_ + f.y * t).scale(1 / m)
                        } else p = n.direction.scale(-1);
                        if (u.convex) {
                            let t = Math.sqrt(b - w);
                            y = new Mt(g.x * t + g.y * this.radius_, -g.x * this.radius_ + g.y * t).scale(1 / b)
                        } else y = n.direction
                    }
                    let C = n.previous,
                        A = !1,
                        k = !1;
                    n.convex && Nt.det(p, C.direction.scale(-1)) >= 0 && (p = C.direction.scale(-1), A = !0), u.convex && Nt.det(y, u.direction) <= 0 && (y = u.direction, k = !0);
                    let B = n.point.minus(this.position_).scale(a),
                        R = u.point.minus(this.position_).scale(a),
                        z = R.minus(B),
                        V = n == u ? .5 : this.velocity_.minus(B).multiply(z) / Nt.absSq(z),
                        Z = this.velocity_.minus(B).multiply(p),
                        $ = this.velocity_.minus(R).multiply(y);
                    if (V < 0 && Z < 0 || n == u && Z < 0 && $ < 0) {
                        let t = Nt.normalize(this.velocity_.minus(B));
                        E.direction = new Mt(t.y, -t.x), E.point = B.plus(t.scale(this.radius_ * a)), e.push(E);
                        continue
                    }
                    if (V > 1 && $ < 0) {
                        let t = Nt.normalize(this.velocity_.minus(R));
                        E.direction = new Mt(t.y, -t.x), E.point = R.plus(t.scale(this.radius_ * a)), e.push(E);
                        continue
                    }
                    let J = V < 0 || V > 1 || n == u ? 1 / 0 : Nt.absSq(this.velocity_.minus(z.scale(V).plus(B))),
                        tt = Z < 0 ? 1 / 0 : Nt.absSq(this.velocity_.minus(p.scale(Z).plus(B))),
                        et = $ < 0 ? 1 / 0 : Nt.absSq(this.velocity_.minus(y.scale($).plus(R)));
                    if (J <= tt && J <= et) {
                        E.direction = n.direction.scale(-1);
                        let t = new Mt(-E.direction.y, E.direction.x);
                        E.point = t.scale(this.radius_ * a).plus(B), e.push(E)
                    } else {
                        if (!(tt <= et)) {
                            if (k) continue;
                            E.direction = y.scale(-1);
                            let t = new Mt(-E.direction.y, E.direction.x);
                            E.point = t.scale(this.radius_ * a).plus(R), e.push(E);
                            continue
                        } {
                            if (A) continue;
                            E.direction = p;
                            let t = new Mt(-E.direction.y, E.direction.x);
                            E.point = t.scale(this.radius_ * a).plus(B), e.push(E)
                        }
                    }
                }
                let n = e.length,
                    u = 1 / this.timeHorizon;
                for (let a = 0; a < this.agentNeighbors_.length; ++a) {
                    let n, f = this.agentNeighbors_[a].value,
                        g = f.position_.minus(this.position_),
                        _ = f.mass / (this.mass + f.mass),
                        p = this.mass / (this.mass + f.mass),
                        y = _ >= .5 ? this.velocity_.minus(this.velocity_.scale(_)).scale(2) : this.prefVelocity_.plus(this.velocity_.minus(this.prefVelocity_).scale(2 * _)),
                        m = p >= .5 ? f.velocity_.scale(2).scale(1 - p) : f.prefVelocity_.plus(f.velocity_.minus(f.prefVelocity_).scale(2 * p)),
                        b = y.minus(m),
                        w = Nt.absSq(g),
                        x = this.radius_ + f.radius_,
                        v = Nt.sqr(x),
                        S = new Ot;
                    if (w > v) {
                        let t = b.minus(g.scale(u)),
                            e = Nt.absSq(t),
                            a = t.multiply(g);
                        if (a < 0 && Nt.sqr(a) > v * e) {
                            let a = Math.sqrt(e),
                                f = t.scale(1 / a);
                            S.direction = new Mt(f.y, -f.x), n = f.scale(x * u - a)
                        } else {
                            let e = Math.sqrt(w - v);
                            if (Nt.det(g, t) > 0) {
                                let t = new Mt(g.x * e - g.y * x, g.x * x + g.y * e);
                                S.direction = t.scale(1 / w)
                            } else {
                                let t = new Mt(g.x * e + g.y * x, -g.x * x + g.y * e);
                                S.direction = t.scale(-1 / w)
                            }
                            let a = b.multiply(S.direction);
                            n = S.direction.scale(a).minus(b)
                        }
                    } else {
                        let e = 1 / t,
                            a = b.minus(g.scale(e)),
                            u = Nt.abs(a),
                            f = a.scale(1 / u);
                        S.direction = new Mt(f.y, -f.x), n = f.scale(x * e - u)
                    }
                    S.point = y.plus(n.scale(_)), e.push(S)
                }
                let f = this.linearProgram2(e, this.maxSpeed_, this.prefVelocity_, !1, this.newVelocity_);
                f < e.length && this.linearProgram3(e, n, f, this.maxSpeed_, this.newVelocity_)
            }
            insertAgentNeighbor(t, e) {
                if (this != t) {
                    let a = Nt.absSq(this.position_.minus(t.position_));
                    if (a < e) {
                        this.agentNeighbors_.length < this.maxNeighbors_ && this.agentNeighbors_.push(new kt(a, t));
                        let n = this.agentNeighbors_.length - 1;
                        for (; 0 != n && a < this.agentNeighbors_[n - 1].key;) this.agentNeighbors_[n] = this.agentNeighbors_[n - 1], --n;
                        this.agentNeighbors_[n] = new kt(a, t), this.agentNeighbors_.length == this.maxNeighbors_ && (e = this.agentNeighbors_[this.agentNeighbors_.length - 1].key)
                    }
                }
                return e
            }
            insertObstacleNeighbor(t, e) {
                let a = t.next,
                    n = Nt.distSqPointLineSegment(t.point, a.point, this.position_);
                if (n < e) {
                    this.obstaclNeighbors_.push(new kt(n, t));
                    let e = this.obstaclNeighbors_.length - 1;
                    for (; 0 != e && n < this.obstaclNeighbors_[e - 1].key;) this.obstaclNeighbors_[e] = this.obstaclNeighbors_[e - 1], --e;
                    this.obstaclNeighbors_[e] = new kt(n, t)
                }
            }
            update(t) {
                this.velocity_.copy(this.newVelocity_), this.position_.copy(this.position_.plus(this.velocity_.scale(t)))
            }
            linearProgram1(t, e, a, n, u, f) {
                let g = t[e].point.multiply(t[e].direction),
                    _ = Nt.sqr(g) + Nt.sqr(a) - Nt.absSq(t[e].point);
                if (_ < 0) return !1;
                let p = Math.sqrt(_),
                    y = -g - p,
                    m = -g + p;
                for (let a = 0; a < e; ++a) {
                    let n = Nt.det(t[e].direction, t[a].direction),
                        u = Nt.det(t[a].direction, t[e].point.minus(t[a].point));
                    if (Math.abs(n) <= Nt.RVO_EPSILON) {
                        if (u < 0) return !1;
                        continue
                    }
                    let f = u / n;
                    if (n >= 0 ? m = Math.min(m, f) : y = Math.max(y, f), y > m) return !1
                }
                if (u) n.multiply(t[e].direction) > 0 ? f.copy(t[e].point.plus(t[e].direction.scale(m))) : f.copy(t[e].point.plus(t[e].direction.scale(y)));
                else {
                    let a = t[e].direction.multiply(n.minus(t[e].point));
                    a < y ? f.copy(t[e].point.plus(t[e].direction.scale(y))) : a > m ? f.copy(t[e].point.plus(t[e].direction.scale(m))) : f.copy(t[e].point.plus(t[e].direction.scale(a)))
                }
                return !0
            }
            linearProgram2(t, e, a, n, u) {
                n ? u.copy(a.scale(e)) : Nt.absSq(a) > Nt.sqr(e) ? u.copy(Nt.normalize(a).scale(e)) : u.copy(a);
                for (let f = 0; f < t.length; ++f)
                    if (Nt.det(t[f].direction, t[f].point.minus(u)) > 0) {
                        let g = u.clone();
                        if (!this.linearProgram1(t, f, e, a, n, u)) return u.copy(g), f
                    }
                return t.length
            }
            linearProgram3(t, e, a, n, u) {
                let f = 0;
                for (let g = a; g < t.length; ++g)
                    if (Nt.det(t[g].direction, t[g].point.minus(u)) > f) {
                        let a = [];
                        for (let n = 0; n < e; ++n) a.push(t[n]);
                        for (let n = e; n < g; ++n) {
                            let e = new Ot,
                                u = Nt.det(t[g].direction, t[n].direction);
                            if (Math.abs(u) <= Nt.RVO_EPSILON) {
                                if (t[g].direction.multiply(t[n].direction) > 0) continue;
                                e.point = t[g].point.plus(t[n].point).scale(.5)
                            } else e.point = t[g].point.plus(t[g].direction.scale(Nt.det(t[n].direction, t[g].point.minus(t[n].point)) / u));
                            e.direction = Nt.normalize(t[n].direction.minus(t[g].direction)), a.push(e)
                        }
                        let _ = u.clone();
                        this.linearProgram2(a, n, new Mt(-t[g].direction.y, t[g].direction.x), !0, u) < a.length && u.copy(_), f = Nt.det(t[g].direction, t[g].point.minus(u))
                    }
            }
        }
        class Bt {
            constructor(t, e) {
                this.a = t, this.b = e
            }
            lessThan(t) {
                return this.a < t.a || !(t.a < this.a) && this.b < t.b
            }
            lessEqualThan(t) {
                return this.a == t.a && this.b == t.b || this.lessThan(t)
            }
            bigThan(t) {
                return !this.lessEqualThan(t)
            }
            bigEqualThan(t) {
                return !this.lessThan(t)
            }
        }
        class Rt {}
        class Dt {}
        class Ut {
            constructor(t) {
                this.MAX_LEAF_SIZE = 10, this.agents = null, this.agentTree = [], this.obstacleTree = null, this._sim = t
            }
            buildAgentTree(t) {
                if (!this.agents || this.agents.length != t) {
                    this.agents = new Array(t);
                    for (let t = 0; t < this.agents.length; t++) this.agents[t] = this._sim.getAgent(t);
                    this.agentTree = new Array(2 * this.agents.length);
                    for (let t = 0; t < this.agentTree.length; t++) this.agentTree[t] = new Rt
                }
                0 != this.agents.length && this.buildAgentTreeRecursive(0, this.agents.length, 0)
            }
            buildObstacleTree() {
                this.obstacleTree = new Dt;
                let t = new Array(this._sim.obstacles.length);
                for (let e = 0; e < t.length; e++) t[e] = this._sim.obstacles[e];
                this.obstacleTree = this.buildObstacleTreeRecursive(t)
            }
            computeAgentNeighbors(t, e) {
                return this.queryAgentTreeRecursive(t, e, 0)
            }
            computeObstacleNeighbors(t, e) {
                this.queryObstacleTreeRecursive(t, e, this.obstacleTree)
            }
            queryVisibility(t, e, a) {
                return this.queryVisibilityRecursive(t, e, a, this.obstacleTree)
            }
            buildAgentTreeRecursive(t, e, a) {
                this.agentTree[a].begin = t, this.agentTree[a].end = e, this.agentTree[a].minX = this.agentTree[a].maxX = this.agents[t].position_.x, this.agentTree[a].minY = this.agentTree[a].maxY = this.agents[t].position_.y;
                for (let n = t + 1; n < e; ++n) this.agentTree[a].maxX = Math.max(this.agentTree[a].maxX, this.agents[n].position_.x), this.agentTree[a].minX = Math.min(this.agentTree[a].minX, this.agents[n].position_.x), this.agentTree[a].maxY = Math.max(this.agentTree[a].maxY, this.agents[n].position_.y), this.agentTree[a].minY = Math.min(this.agentTree[a].minY, this.agents[n].position_.y);
                if (e - t > this.MAX_LEAF_SIZE) {
                    let n = this.agentTree[a].maxX - this.agentTree[a].minX > this.agentTree[a].maxY - this.agentTree[a].minY,
                        u = .5 * (n ? this.agentTree[a].maxX + this.agentTree[a].minX : this.agentTree[a].maxY + this.agentTree[a].minY),
                        f = t,
                        g = e;
                    for (; f < g;) {
                        for (; f < g && (n ? this.agents[f].position_.x : this.agents[f].position_.y) < u;) ++f;
                        for (; g > f && (n ? this.agents[g - 1].position_.x : this.agents[g - 1].position_.y) >= u;) --g;
                        if (f < g) {
                            let t = this.agents[f];
                            this.agents[f] = this.agents[g - 1], this.agents[g - 1] = t, ++f, --g
                        }
                    }
                    let _ = f - t;
                    0 == _ && (++_, ++f, ++g), this.agentTree[a].left = a + 1, this.agentTree[a].right = a + 2 * _, this.buildAgentTreeRecursive(t, f, this.agentTree[a].left), this.buildAgentTreeRecursive(f, e, this.agentTree[a].right)
                }
            }
            buildObstacleTreeRecursive(t) {
                if (0 == t.length) return null; {
                    let e = new Dt,
                        a = 0,
                        n = t.length,
                        u = n;
                    for (let e = 0; e < t.length; ++e) {
                        let f = 0,
                            g = 0,
                            _ = t[e],
                            p = _.next;
                        for (let a = 0; a < t.length; a++) {
                            if (e == a) continue;
                            let y = t[a],
                                m = y.next,
                                b = Nt.leftOf(_.point, p.point, y.point),
                                w = Nt.leftOf(_.point, p.point, m.point);
                            b >= -Nt.RVO_EPSILON && w >= -Nt.RVO_EPSILON ? ++f : (b <= Nt.RVO_EPSILON && w <= Nt.RVO_EPSILON || ++f, ++g);
                            let x = new Bt(Math.max(f, g), Math.min(f, g)),
                                v = new Bt(Math.max(n, u), Math.min(n, u));
                            if (x.bigEqualThan(v)) break
                        }
                        let y = new Bt(Math.max(f, g), Math.min(f, g)),
                            m = new Bt(Math.max(n, u), Math.min(n, u));
                        y.lessThan(m) && (n = f, u = g, a = e)
                    } {
                        let f = [];
                        for (let t = 0; t < n; ++t) f.push(null);
                        let g = [];
                        for (let t = 0; t < u; ++t) g.push(null);
                        let _ = 0,
                            p = 0,
                            y = a,
                            m = t[y],
                            b = m.next;
                        for (let e = 0; e < t.length; ++e) {
                            if (y == e) continue;
                            let a = t[e],
                                n = a.next,
                                u = Nt.leftOf(m.point, b.point, a.point),
                                w = Nt.leftOf(m.point, b.point, n.point);
                            if (u >= -Nt.RVO_EPSILON && w >= -Nt.RVO_EPSILON) f[_++] = t[e];
                            else if (u <= Nt.RVO_EPSILON && w <= Nt.RVO_EPSILON) g[p++] = t[e];
                            else {
                                let t = Nt.det(b.point.minus(m.point), a.point.minus(m.point)) / Nt.det(b.point.minus(m.point), a.point.minus(n.point)),
                                    e = a.point.plus(n.point.minus(a.point).scale(t)),
                                    y = new It;
                                y.point = e, y.previous = a, y.next = n, y.convex = !0, y.direction = a.direction, y.id = this._sim.obstacles.length, this._sim.obstacles.push(y), a.next = y, n.previous = y, u > 0 ? (f[_++] = a, g[p++] = y) : (g[p++] = a, f[_++] = y)
                            }
                        }
                        return e.obstacle = m, e.left = this.buildObstacleTreeRecursive(f), e.right = this.buildObstacleTreeRecursive(g), e
                    }
                }
            }
            queryAgentTreeRecursive(t, e, a) {
                if (this.agentTree[a].end - this.agentTree[a].begin <= this.MAX_LEAF_SIZE)
                    for (let n = this.agentTree[a].begin; n < this.agentTree[a].end; ++n) e = t.insertAgentNeighbor(this.agents[n], e);
                else {
                    let n = Nt.sqr(Math.max(0, this.agentTree[this.agentTree[a].left].minX - t.position_.x)) + Nt.sqr(Math.max(0, t.position_.x - this.agentTree[this.agentTree[a].left].maxX)) + Nt.sqr(Math.max(0, this.agentTree[this.agentTree[a].left].minY - t.position_.y)) + Nt.sqr(Math.max(0, t.position_.y - this.agentTree[this.agentTree[a].left].maxY)),
                        u = Nt.sqr(Math.max(0, this.agentTree[this.agentTree[a].right].minX - t.position_.x)) + Nt.sqr(Math.max(0, t.position_.x - this.agentTree[this.agentTree[a].right].maxX)) + Nt.sqr(Math.max(0, this.agentTree[this.agentTree[a].right].minY - t.position_.y)) + Nt.sqr(Math.max(0, t.position_.y - this.agentTree[this.agentTree[a].right].maxY));
                    n < u ? n < e && u < (e = this.queryAgentTreeRecursive(t, e, this.agentTree[a].left)) && (e = this.queryAgentTreeRecursive(t, e, this.agentTree[a].right)) : u < e && n < (e = this.queryAgentTreeRecursive(t, e, this.agentTree[a].right)) && (e = this.queryAgentTreeRecursive(t, e, this.agentTree[a].left))
                }
                return e
            }
            queryObstacleTreeRecursive(t, e, a) {
                if (null == a) return e; {
                    let n = a.obstacle,
                        u = n.next,
                        f = Nt.leftOf(n.point, u.point, t.position_);
                    return e = this.queryObstacleTreeRecursive(t, e, f >= 0 ? a.left : a.right), Nt.sqr(f) / Nt.absSq(u.point.minus(n.point)) < e && (f < 0 && t.insertObstacleNeighbor(a.obstacle, e), this.queryObstacleTreeRecursive(t, e, f >= 0 ? a.right : a.left)), e
                }
            }
            queryVisibilityRecursive(t, e, a, n) {
                if (null == n) return !0; {
                    let u = n.obstacle,
                        f = u.next,
                        g = Nt.leftOf(u.point, f.point, t),
                        _ = Nt.leftOf(u.point, f.point, e),
                        p = 1 / Nt.absSq(f.point.minus(u.point));
                    if (g >= 0 && _ >= 0) return this.queryVisibilityRecursive(t, e, a, n.left) && (Nt.sqr(g) * p >= Nt.sqr(a) && Nt.sqr(_) * p >= Nt.sqr(a) || this.queryVisibilityRecursive(t, e, a, n.right));
                    if (g <= 0 && _ <= 0) return this.queryVisibilityRecursive(t, e, a, n.right) && (Nt.sqr(g) * p >= Nt.sqr(a) && Nt.sqr(_) * p >= Nt.sqr(a) || this.queryVisibilityRecursive(t, e, a, n.left));
                    if (g >= 0 && _ <= 0) return this.queryVisibilityRecursive(t, e, a, n.left) && this.queryVisibilityRecursive(t, e, a, n.right); {
                        let g = Nt.leftOf(t, e, u.point),
                            _ = Nt.leftOf(t, e, f.point),
                            p = 1 / Nt.absSq(e.minus(t));
                        return g * _ >= 0 && Nt.sqr(g) * p > Nt.sqr(a) && Nt.sqr(_) * p > Nt.sqr(a) && this.queryVisibilityRecursive(t, e, a, n.left) && this.queryVisibilityRecursive(t, e, a, n.right)
                    }
                }
            }
        }
        class zt {
            constructor(t = !0) {
                this.firstloginTimestamp = void 0, this.logindays = void 0, this.redBag = void 0, this.redBagCnt = void 0, this.noticeVer = void 0, t && f.warpObjectGetterSetter(this, this.dirty)
            }
            dirty(t) {
                Ft.instance.save(t, this[t])
            }
        }
        class Ft extends gt {
            constructor() {
                super(), this.readySaveProps = []
            }
            static get instance() {
                return this._instance || (this._instance = new Ft), this._instance
            }
            onInit(t) {
                let loadData = t => {
                    for (const e in t)
                        if (t.hasOwnProperty(e)) {
                            let a = this.unserialize(e);
                            null != a && "" !== a && (t[e] = a)
                        }
                    t.openId = this.unserialize("openId"), t.name = this.unserialize("name")
                };
                if (t) {
                    let e = new t;
                    loadData(e);
                    for (const t in this.mine)
                        if (this.mine.hasOwnProperty(t)) {
                            let a = this.mine[t];
                            null != a && "" !== a && (e[t] = a)
                        }
                    this.mine = e
                } else this.mine = new zt, loadData(this.mine), this.initData()
            }
            initData() {
                if (void 0 === this.mine.firstloginTimestamp ? (this.mine.firstloginTimestamp = f.getTime(), this.firstLogin = !0) : this.firstLogin = !1, void 0 === this.mine.logindays) this.mine.logindays = 1, this.newDay = !0;
                else {
                    let t = f.getDayInYear(new Date(this.mine.firstloginTimestamp)),
                        e = f.getDayInYear() - t + 1;
                    e > this.mine.logindays ? (this.mine.logindays = e, this.newDay = !0) : this.newDay = !1
                }
                void 0 === this.mine.redBag && (this.mine.redBag = 0, this.mine.redBagCnt = 0)
            }
            getMine() {
                return this.mine
            }
            getMineTrimmed() {
                let t = {},
                    e = this.mine;
                for (const a in e)
                    if (e.hasOwnProperty(a) && "_" == a[0]) {
                        let n = a.substring(1);
                        if (n) {
                            let u = e[a];
                            null != u && "" !== u && (t[n] = u)
                        }
                    }
                return t
            }
            getUserInfo() {
                return this.mine
            }
            update(t) {
                let e = t;
                e.savedTimestamp ? (this.isFirstLogin() || this.mine.openId != e.openId) && (this.mine = new zt, f.assign(this.mine, e, !1), this.initData(), e.openId && this.serialize("openId", e.openId), e.name && this.serialize("name", e.name)) : (f.assign(this.mine, e, !1), e.name && this.serialize("name", e.name), e.openId && this.serialize("openId", e.openId))
            }
            save(t, e) {
                t && this.event(V.E_PROP_CHANGED, [t, e]), this.readySaveProps.includes(t) || this.readySaveProps.push(t), 1 == this.readySaveProps.length && Laya.CallLater.I.callLater(this, this._save)
            }
            _save() {
                this.saveToLocal(), this.saveToServer(), this.readySaveProps.length = 0, at.I.event(V.E_ON_USER_SAVED)
            }
            saveToLocal() {
                let t = this.mine,
                    e = this.readySaveProps;
                if (e && e.length > 0)
                    for (const a of e) {
                        let e = "_" + a;
                        if (t.hasOwnProperty(e)) {
                            const a = t[e];
                            this.serialize(e, a)
                        }
                    }
            }
            saveToServer() {
                let t = Laya.ClassUtils.getRegClass("Sdk");
                if (1 !== t.instance.isLoginServer()) return;
                let e = this.getMineTrimmed();
                f.getLength(e) > 0 && t.instance.saveToServer(e)
            }
            serialize(t, e) {
                e instanceof Array ? Laya.LocalStorage.setItem(t, JSON.stringify(e)) : e instanceof Object ? Laya.LocalStorage.setJSON(t, e) : null != e ? Laya.LocalStorage.setItem(t, e) : Laya.LocalStorage.removeItem(t)
            }
            unserialize(t) {
                let e = Laya.LocalStorage.getItem(t);
                if (e) try {
                    e = JSON.parse(e)
                } catch (a) {
                    console.log("unserialize error: ", t, e)
                }
                return e
            }
            isNewDay() {
                return this.newDay
            }
            isFirstLogin() {
                return this.firstLogin
            }
            addRedBag(t) {
                this.mine.redBag += t, this.mine.redBag = Number(this.mine.redBag.toFixed(2)), this.mine.redBagCnt++
            }
            isNewNotice(t) {
                return !!Laya.ClassUtils.getRegClass("Sdk").instance.getServerJsonCfgNoticeHtmlText() && (!!t && (!this.mine.noticeVer || !fx.Utils.compatibleVersion(t, this.mine.noticeVer)))
            }
            readNotice(t) {
                this.isNewNotice(t) && (this.mine.noticeVer = t)
            }
        }
        class Ht {
            static get I() {
                return this._instance || (this._instance = new Ht), this._instance
            }
            init(t, e, a, n, u, f) {
                this.isInit || (this.isInit = !0, this.saveInterval = n, this.timer = new Laya.Timer, this.storageHandler = u, Lt.I.login({
                    serverUrl: t,
                    gameID: e,
                    platform: a,
                    strict: 1,
                    openid: f ? f.openid : "",
                    anonymousOpenid: f ? f.anonymousOpenid : ""
                }, this, this.onLogin), fx.EventCenter.I.on(V.E_ON_USER_SAVED, this, this.onUserSave))
            }
            onLogin() {
                Lt.I.isLogin() ? Lt.I.getStorage(this, this.onGetStorage) : this.storageHandler.run()
            }
            onGetStorage(t) {
                if (t && t.data) try {
                    let e = t.data;
                    e && f.assign(Ft.instance.getUserInfo(), e, !1)
                } catch (t) {
                    console.log(t)
                }
                this.storageHandler.run()
            }
            onUserSave() {
                this.timer.once(1e3 * this.saveInterval, this, this.save)
            }
            save() {
                let t = Ft.instance.getMineTrimmed(),
                    e = JSON.stringify(t);
                Lt.I.setStorage(e)
            }
        }
        class Vt {
            static setBase64Chars(t) {
                this.base64Chars = t
            }
            static init() {
                if (!this.lookup) {
                    this.lookup = new Uint8Array(256);
                    for (var t = 0; t < this.base64Chars.length; t++) this.lookup[this.base64Chars.charCodeAt(t)] = t
                }
            }
            static encode(t) {
                for (var e = new Uint8Array(t), a = e.length, n = "", u = 0; u < a; u += 3) n += this.base64Chars[e[u] >> 2], n += this.base64Chars[(3 & e[u]) << 4 | e[u + 1] >> 4], n += this.base64Chars[(15 & e[u + 1]) << 2 | e[u + 2] >> 6], n += this.base64Chars[63 & e[u + 2]];
                return a % 3 == 2 ? n = n.substring(0, n.length - 1) + "=" : a % 3 == 1 && (n = n.substring(0, n.length - 2) + "=="), n
            }
            static encodeStr(t) {
                let e = new Laya.Byte;
                return e.writeUTFString(t), this.encodeByte(e)
            }
            static encodeStr2(t) {
                let e = new Laya.Byte;
                e.writeUTFBytes(t);
                for (var a = this.encodeByte(e); 0 <= a.indexOf("+");) a = a.replace("+", "%2B");
                for (; 0 <= a.indexOf("&");) a = a.replace("&", "%26");
                for (; 0 <= a.indexOf("=");) a = a.replace("=", "%3D");
                return a
            }
            static encodeByte(t, e = 0, a = -1) {
                return a = a < 0 ? t.length : a, this.encode(t.getUint8Array(e, a).buffer)
            }
            static decodeToByte(t) {
                let e = new Laya.Byte(this.decode(t));
                return e.pos = 0, e
            }
            static decode(t) {
                this.init();
                var e, a, n, u, f = .75 * t.length,
                    g = t.length,
                    _ = 0;
                "=" === t[t.length - 1] && (f--, "=" === t[t.length - 2] && f--);
                let p = new ArrayBuffer(f),
                    y = new Uint8Array(p);
                for (let f = 0; f < g; f += 4) e = this.lookup[t.charCodeAt(f)], a = this.lookup[t.charCodeAt(f + 1)], n = this.lookup[t.charCodeAt(f + 2)], u = this.lookup[t.charCodeAt(f + 3)], y[_++] = e << 2 | a >> 4, y[_++] = (15 & a) << 4 | n >> 2, y[_++] = (3 & n) << 6 | 63 & u;
                return p
            }
        }
        Vt.lookup = null, Vt.base64Chars = "SNPn2QBOR7A1ghiCj5klmY6opZqrEsDFdeG90HIJK8LMtuv3wxyzabTUVWXcf4+/";
        class Xt {
            constructor() {
                this._size = 0, this._size = 0, this._keys = new Array, this._values = new Array
            }
            contains(t) {
                return 0 <= this._keys.indexOf(t)
            }
            containsKey(t) {
                return this.contains(t)
            }
            containsValue(t) {
                return 0 <= this._values.indexOf(t)
            }
            put(t, e) {
                let a = this._keys.indexOf(t);
                a >= 0 ? this._values[a] = e : (this._size++, this._keys.push(t), this._values.push(e))
            }
            remove(t) {
                let e = this._keys.indexOf(t);
                if (e < 0) return null;
                let a = this._values[e];
                return this._keys.splice(e, 1), this._values.splice(e, 1), this._size--, a
            }
            get(t) {
                let e = this._keys.indexOf(t);
                return e < 0 ? null : this._values[e]
            }
            getV(t) {
                return 0 <= t && t < this.length ? this._values[t] : null
            }
            getK(t) {
                return 0 <= t && t < this.length ? this._keys[t] : null
            }
            removeByIndex(t) {
                if (0 <= t && t < this.length) {
                    var e = this._values[t];
                    return this._keys.splice(t, 1), this._values.splice(t, 1), this._size--, e
                }
                return null
            }
            size() {
                return this._size
            }
            get length() {
                return this._size
            }
            isEmpty() {
                return 0 == this._size
            }
            putAll(t) {
                for (let e = 0; e < this._size; ++e) this.put(t._keys[e], t._values[e])
            }
            clear() {
                this.isEmpty() || (this._values.length = 0, this._keys.length = 0, this._size = 0)
            }
            clone() {
                if (this.isEmpty()) return new Xt;
                let t = new Xt;
                t._size = this._size;
                for (let e = 0; e < this._size; ++e) t._keys[e] = this._keys[e], t._values[e] = this._values[e];
                return t
            }
            putIfAbsent(t, e) {
                return this.get(t) || (this._size++, this._keys.push(t), this._values.push(e), null)
            }
            computeIfAbsent(t, e) {
                var a = this.get(t);
                return a || (e = e(t), this._size++, this._keys.push(t), this._values.push(e), e)
            }
            forEach(t) {
                for (let e = 0; e < this._size; ++e) t(this._keys[e], this._values[e])
            }
            forEachSome(t) {
                for (let e = 0; e < this._size && t(this._keys[e], this._values[e]); ++e);
            }
            getKeys() {
                return this._keys
            }
            getValues() {
                return this._values
            }
            forEachValue(t) {
                for (let e = 0; e < this._size; ++e) t(this._values[e])
            }
            getOrDefault(t, e) {
                return this.isEmpty() ? e : 0 <= (t = this._keys.indexOf(t)) ? this._values[t] : e
            }
            getEver() {
                return this.isEmpty() ? null : this._values[0]
            }
        }
        class qt extends Laya.HTMLDivElement {
            constructor(t = "HtmlText") {
                super(), this._defaultStyle = "color:#000000;bold:true;font:30px Arial", this.name = t, this.style.wordWrap = !1
            }
            get defaultStyle() {
                return this._defaultStyle
            }
            set defaultStyle(t) {
                this._defaultStyle = t
            }
            parse(t) {
                let e = t.split("<br/>");
                return t = "", e.forEach((e => {
                    let a = e.split(/(<span.+?<\/span>)/g);
                    0 == a.length && a.push(e);
                    for (const e of a) e && (this.isRichText(e) ? t += e : t += this.defaultRichText(e));
                    t += "<br/>"
                })), t
            }
            defaultRichText(t) {
                return `<span style='${this._defaultStyle}'>${t}</span>`
            }
            isRichText(t) {
                return -1 != t.indexOf("<span")
            }
            setText(t) {
                t && (t = this.parse(t), this.innerHTML = t)
            }
            addImg(t, e) {
                let a = "";
                a = e ? `<img src='${t}' style='${e}'></img>` : `<img src='${t}' ></img>`;
                let n = "",
                    u = this._innerHTML;
                u && (n = u), n += a, this.setText(n)
            }
            addText(t) {
                let e = "",
                    a = this._innerHTML;
                a && (e = a), e += t, this.setText(e)
            }
        }
        class Yt extends S {
            constructor({
                duration: t = 0
            } = {}) {
                super({
                    name: "Continuous"
                }), this.duration = t
            }
            tick(e) {
                let a = (new Date).getTime(),
                    n = e.blackboard.get("tick_frame", e.tree.id);
                return null == this.curFrame && (this.curFrame = n, this.startTime = a), n - this.curFrame > 1 && (this.startTime = a), this.curFrame = n, a - this.startTime >= this.duration ? t.BTStatus.SUCCESS : t.BTStatus.FAILURE
            }
        }
        Yt.register("BTContinuous", t.BTCategory.ACTION);
        class Gt extends S {
            constructor() {
                super({
                    name: "Runner"
                })
            }
            tick(e) {
                return t.BTStatus.RUNNING
            }
        }
        Gt.register("BTRunner", t.BTCategory.ACTION);
        class jt extends S {
            constructor() {
                super({
                    name: "Failer"
                })
            }
            tick(e) {
                return t.BTStatus.FAILURE
            }
        }
        jt.register("BTFailer", t.BTCategory.ACTION);
        class Wt extends S {
            constructor() {
                super({
                    name: "Error"
                })
            }
            tick(t) {
                throw Error("BTError !")
            }
        }
        Wt.register("BTError", t.BTCategory.ACTION);
        class Zt extends S {
            constructor({
                milliseconds: t = 0
            } = {}) {
                super({
                    name: "Wait",
                    title: "Wait <milliseconds>ms",
                    properties: {
                        milliseconds: 0
                    }
                }), this.endTime = t
            }
            open(t) {
                let e = (new Date).getTime();
                t.blackboard.set("startTime", e, t.tree.id, this.id)
            }
            tick(e) {
                return (new Date).getTime() - e.blackboard.get("startTime", e.tree.id, this.id) > this.endTime ? t.BTStatus.SUCCESS : t.BTStatus.RUNNING
            }
        }
        Zt.register("BTWait", t.BTCategory.ACTION);
        class Kt extends S {
            constructor() {
                super({
                    name: "Succeeder"
                })
            }
            tick(e) {
                return t.BTStatus.SUCCESS
            }
        }
        Kt.register("BTSucceeder", t.BTCategory.ACTION);
        class $t extends S {
            constructor({
                condition: t = null,
                child: e = null
            } = {}) {
                super({
                    name: "WaitUtil",
                    title: "WaitUtil <condition>"
                }), this.cdt = t, this.child = e
            }
            tick(e) {
                if (!this.cdt) throw Error("must have condition node !");
                let a = this.cdt._execute(e);
                return a == t.BTStatus.SUCCESS ? a : (this.child && this.child._execute(e), t.BTStatus.RUNNING)
            }
        }
        $t.register("BTWaitUtil", t.BTCategory.ACTION);
        class Qt extends A {
            constructor({
                children: e = [],
                successPolicy: a = t.EPolicy.RequireOne
            } = {}) {
                super({
                    name: "Parallel",
                    children: e
                }), this.successPolicy = a
            }
            tickRunning(e, a) {
                let n = [];
                if (void 0 !== a && a.length > 0) {
                    let u = a.length;
                    for (; u--;) {
                        let f = a[u],
                            g = this.children[f]._execute(e);
                        n[f] = g, g != t.BTStatus.RUNNING && a.splice(u, 1)
                    }
                    0 == a.length && e.blackboard.set("runningChild", void 0, e.tree.id, this.id)
                }
                return n
            }
            tick(e) {
                let a, n = e.blackboard.get("runningChild", e.tree.id, this.id);
                n && (a = n.concat());
                let u = this.tickRunning(e, n);
                if (u.length > 0 && u.includes(t.BTStatus.RUNNING)) return t.BTStatus.RUNNING;
                let f = 0,
                    g = this.children.length;
                for (let g = 0; g < this.children.length; g++) {
                    if (a && a.includes(g)) {
                        u[g] == t.BTStatus.SUCCESS && f++;
                        continue
                    }
                    let _ = this.children[g]._execute(e);
                    _ == t.BTStatus.RUNNING && (n ? n.push(g) : n = [g], e.blackboard.set("runningChild", n, e.tree.id, this.id)), _ == t.BTStatus.SUCCESS && f++
                }
                return this.successPolicy == t.EPolicy.RequireAll && f == g || this.successPolicy == t.EPolicy.RequireOne && f > 0 ? t.BTStatus.SUCCESS : t.BTStatus.FAILURE
            }
        }
        Qt.register("BTParallel", t.BTCategory.COMPOSITE);
        class Jt extends A {
            constructor({
                children: e = [],
                continuePolicy: a = t.BTStatus.FAILURE,
                successPolicy: n = t.EPolicy.RequireOne
            } = {}) {
                super({
                    name: "Sequence",
                    children: e
                }), this.continuePolicy = a, this.successPolicy = n
            }
            open(t) {
                t.blackboard.set("runningChild", 0, t.tree.id, this.id)
            }
            tick(e) {
                let a = 0,
                    n = e.blackboard.get("runningChild", e.tree.id, this.id);
                for (let u = n; u < this.children.length; u++) {
                    let n = this.children[u]._execute(e);
                    if (n === t.BTStatus.RUNNING) return e.blackboard.set("runningChild", u, e.tree.id, this.id), n;
                    if (n == t.BTStatus.SUCCESS && a++, n != this.continuePolicy) break
                }
                return 0 != n && (a += n), this.successPolicy == t.EPolicy.RequireOne && a > 0 || this.successPolicy == t.EPolicy.RequireAll && a == this.children.length ? t.BTStatus.SUCCESS : t.BTStatus.FAILURE
            }
        }
        Jt.register("BTSequence", t.BTCategory.COMPOSITE);
        class te extends C {
            constructor({
                child: t = null,
                maxLoop: e = 0
            } = {}) {
                if (super({
                        child: t,
                        name: "Limiter",
                        title: "Limit <maxLoop> Activations",
                        properties: {
                            maxLoop: 1
                        }
                    }), !e) throw "maxLoop parameter in Limiter decorator is an obligatory parameter";
                this.maxLoop = e
            }
            open(t) {
                t.blackboard.set("i", 0, t.tree.id, this.id)
            }
            tick(e) {
                if (!this.child) throw Error("BTLimiter no child !");
                let a = e.blackboard.get("i", e.tree.id, this.id);
                if (a < this.maxLoop) {
                    let n = this.child._execute(e);
                    return n != t.BTStatus.SUCCESS && n != t.BTStatus.FAILURE || e.blackboard.set("i", a + 1, e.tree.id, this.id), n
                }
                return t.BTStatus.FAILURE
            }
        }
        te.register("BTLimiter", t.BTCategory.DECORATOR);
        class ee extends C {
            constructor({
                maxTime: t = 0,
                child: e = null
            } = {}) {
                if (super({
                        child: e,
                        name: "MaxTime",
                        title: "Max <maxTime>ms",
                        properties: {
                            maxTime: 0
                        }
                    }), !t) throw "maxTime parameter in MaxTime decorator is an obligatory parameter";
                this.maxTime = t
            }
            open(t) {
                let e = (new Date).getTime();
                t.blackboard.set("startTime", e, t.tree.id, this.id)
            }
            tick(e) {
                if (!this.child) throw Error("BTStatus no child !");
                let a = (new Date).getTime(),
                    n = e.blackboard.get("startTime", e.tree.id, this.id),
                    u = this.child._execute(e);
                return a - n > this.maxTime ? t.BTStatus.FAILURE : u
            }
        }
        ee.register("BTMaxTime", t.BTCategory.DECORATOR);
        class ie extends C {
            constructor({
                child: t = null
            } = {}) {
                super({
                    child: t,
                    name: "Inverter"
                })
            }
            tick(e) {
                if (!this.child) throw Error("BTInverter no child !");
                let a = this.child._execute(e);
                return a == t.BTStatus.SUCCESS ? a = t.BTStatus.FAILURE : a == t.BTStatus.FAILURE && (a = t.BTStatus.SUCCESS), a
            }
        }
        ie.register("BTInverter", t.BTCategory.DECORATOR);
        class se extends C {
            constructor({
                maxLoop: t = -1,
                child: e = null
            } = {}) {
                super({
                    child: e,
                    name: "Repeater",
                    title: "Repeat <maxLoop>x",
                    properties: {
                        maxLoop: -1
                    }
                }), this.maxLoop = t
            }
            open(t) {
                t.blackboard.set("i", 0, t.tree.id, this.id)
            }
            tick(e) {
                if (!this.child) throw Error("BTRepeater no child !");
                let a = e.blackboard.get("i", e.tree.id, this.id),
                    n = t.BTStatus.SUCCESS;
                for (;
                    (this.maxLoop < 0 || a < this.maxLoop) && (n = this.child._execute(e), n == t.BTStatus.SUCCESS || n == t.BTStatus.FAILURE);) a++;
                return e.blackboard.set("i", a, e.tree.id, this.id), n
            }
        }
        se.register("BTRepeater", t.BTCategory.DECORATOR);
        class ae extends C {
            constructor({
                maxLoop: t = -1,
                child: e = null
            } = {}) {
                super({
                    child: e,
                    name: "RepeatUntilFailure",
                    title: "Repeat Until Failure",
                    properties: {
                        maxLoop: -1
                    }
                }), this.maxLoop = t
            }
            open(t) {
                t.blackboard.set("i", 0, t.tree.id, this.id)
            }
            tick(e) {
                if (!this.child) throw Error("BTRepeatUntilFailure no child !");
                let a = e.blackboard.get("i", e.tree.id, this.id),
                    n = t.BTStatus.FAILURE;
                for (;
                    (this.maxLoop < 0 || a < this.maxLoop) && (n = this.child._execute(e), n == t.BTStatus.SUCCESS);) a++;
                return a = e.blackboard.set("i", a, e.tree.id, this.id), n
            }
        }
        ae.register("BTRepeatUntilFailure", t.BTCategory.DECORATOR);
        class ne extends C {
            constructor({
                maxLoop: t = -1,
                child: e = null
            } = {}) {
                super({
                    child: e,
                    name: "RepeatUntilSuccess",
                    title: "Repeat Until Success",
                    properties: {
                        maxLoop: -1
                    }
                }), this.maxLoop = t
            }
            open(t) {
                t.blackboard.set("i", 0, t.tree.id, this.id)
            }
            tick(e) {
                if (!this.child) throw Error("BTRepeatUntilSuccess no child !");
                let a = e.blackboard.get("i", e.tree.id, this.id),
                    n = t.BTStatus.FAILURE;
                for (;
                    (this.maxLoop < 0 || a < this.maxLoop) && (n = this.child._execute(e), n == t.BTStatus.FAILURE);) a++;
                return a = e.blackboard.set("i", a, e.tree.id, this.id), n
            }
        }
        return ne.register("BTRepeatUntilSuccess", t.BTCategory.DECORATOR), t.AniParam = class {
            constructor(t, e, a, n, u, f, g) {
                this.parent = t, this.pos = e, this.lbCaller = a, this.lbCb = n, this.completeCaller = u, this.completeCb = f, this.completeParams = g
            }
        }, t.AnimationImage = Ct, t.AppBase = class {
            constructor(t, e, a) {
                this.lastTimerScale = 1, console.log("Framework Ver: 1.6.130"), this.gameCfg = t;
                let n = null;
                Laya.isWXPlayable ? window.wx && (n = wx.getSystemInfoSync()) : n = window.sdk.Sdk.instance.initMiniAdapter(), this.initGraphicsSetting(n), console.log(`Graphics: ${JSON.stringify(ft)}`), Config.useRetinalCanvas = ft.enableRetinalCanvas, t.config3d = t.config3d || new Config3D, t.config3d.enableMultiLight = ft.enableMultiLight, t.config3d.isAntialias = Config.isAntialias = ft.enableAntialias;
                let cb = () => {
                    Laya.Physics && Laya.Physics.enable(), Laya.stage.scaleMode = t.scaleMode, Laya.stage.alignH = t.alignH, Laya.stage.alignV = t.alignV, Laya.stage.screenMode = t.screenMode, Laya.stage.frameRate = Laya.Stage.FRAME_FAST, Laya.URL.exportSceneToJson = t.exportSceneToJson, (t.debug || "true" == Laya.Utils.getQueryString("debug")) && Laya.enableDebugPanel(), t.physicsDebug && Laya.PhysicsDebugDraw && Laya.PhysicsDebugDraw.enable(), t.stat && Laya.Stat.show(0, 100), Laya.isWXPlayable || window.sdk.Sdk.isOnALIPAY() || Laya.alertGlobalError(t.errorHandler), it.init(), Laya.isWXPlayable || window.sdk.Sdk.instance.afterEngineInit(this.didEnterBackground.bind(this), this.willEnterForeground.bind(this)), e ? Laya.ResourceVersion.enable(e, Laya.Handler.create(this, this.onManifestLoaded)) : st.instance.load(Laya.Handler.create(this, this.onLoaded))
                };
                window.Laya3D ? (t.physic3dSetting && (Laya.Scene3D.physicsSettings = t.physic3dSetting), a ? Laya3D.init(t.width, t.height, t.config3d, new Laya.Handler(this, (() => {
                    cb()
                }))) : (Laya3D.init(t.width, t.height, t.config3d), cb())) : (Laya.init(t.width, t.height, Laya.WebGL), cb())
            }
            didEnterBackground() {
                0 != Laya.timer.scale && (this.lastTimerScale = Laya.timer.scale, Laya.timer.scale = 0, at.I.event(V.E_APP_ON_PAUSE))
            }
            willEnterForeground(t) {
                Laya.timer.scale = this.lastTimerScale, at.I.event(V.E_APP_ON_RESUME, t)
            }
            launch(t, e) {
                return e ? Laya.AtlasInfoManager.enable(e) : Laya.AtlasInfoManager.enable("fileconfig.json"), f.isOnMiniGame() && !Laya.isWXPlayable && window.sdk.Sdk.instance.checkUpdate(), this.onStageResize(), Laya.stage.on(Laya.Event.RESIZE, this, this.onStageResize), t ? dt.changeScene(t) : this.gameCfg.startScene ? dt.changeScene(this.gameCfg.startScene) : console.error("Launch Scene not found !!!"), this
            }
            onStageResize() {
                Laya.isWXPlayable || f.isOnPC() && window.sdk.Sdk.isOnPC() && (document.title = `${Laya.stage.width}x${Laya.stage.height}`)
            }
            onManifestLoaded() {
                st.instance.load(Laya.Handler.create(this, this.onLoaded))
            }
            onLoaded() {}
            initGraphicsSetting(t) {
                if (!t) return;
                let e = ft;
                if (t.deviceScore) {
                    let a = t.deviceScore.overall;
                    f.isNumber(a) && (e.enableShadow = a > 7);
                    let n = t.deviceScore.gpu;
                    f.isNumber(n) && (e.enableMultiLight = n > 7)
                } else if (t.benchmarkLevel) {
                    let a = t.benchmarkLevel;
                    f.isNumber(a) && (e.enableShadow = a > 20, e.enableMultiLight = a > 15)
                }
            }
        }, t.AudioContextPool = ht, t.AutoReleaseManager = bt, t.BTAction = S, t.BTActions = w, t.BTBaseNode = XBTBaseNode, t.BTBlackboard = class {
            constructor() {
                this._baseMemory = {}, this._treeMemory = {}
            }
            _getTreeMemory(t) {
                return this._treeMemory[t] || (this._treeMemory[t] = {
                    nodeMemory: {},
                    openNodes: [],
                    traversalDepth: 0,
                    traversalCycle: 0
                }), this._treeMemory[t]
            }
            _getNodeMemory(t, e) {
                let a = t.nodeMemory;
                return a[e] || (a[e] = {}), a[e]
            }
            _getMemory(t, e) {
                let a = this._baseMemory;
                return t && (a = this._getTreeMemory(t), e && (a = this._getNodeMemory(a, e))), a
            }
            set(t, e, a, n) {
                this._getMemory(a, n)[t] = e
            }
            get(t, e, a) {
                return this._getMemory(e, a)[t]
            }
        }, t.BTComposite = A, t.BTComposites = b, t.BTCondition = class extends XBTBaseNode {
            constructor({
                child: e = null,
                name: a = "Condition",
                title: n = "",
                properties: u
            }) {
                super({
                    category: t.BTCategory.CONDITION,
                    name: a,
                    title: n,
                    properties: u
                }), this.child = e
            }
            satisfy(t) {
                return !1
            }
            tick(e) {
                if (e.blackboard.get("runningChild", e.tree.id, this.id)) {
                    let a = this.child._execute(e);
                    return a != t.BTStatus.RUNNING && e.blackboard.set("runningChild", !1, e.tree.id, this.id), a
                }
                if (this.satisfy(e)) {
                    if (this.child) {
                        let a = this.child._execute(e);
                        return a == t.BTStatus.RUNNING && e.blackboard.set("runningChild", !0, e.tree.id, this.id), a
                    }
                    return t.BTStatus.SUCCESS
                }
                return t.BTStatus.FAILURE
            }
            add(t) {
                this.child = t
            }
        }, t.BTConditions = x, t.BTContinuous = Yt, t.BTDecorator = C, t.BTDecorators = m, t.BTError = Wt, t.BTFailer = jt, t.BTInverter = ie, t.BTLimiter = te, t.BTMaxTime = ee, t.BTParallel = Qt, t.BTRepeatUntilFailure = ae, t.BTRepeatUntilSuccess = ne, t.BTRepeater = se, t.BTRunner = Gt, t.BTSequence = Jt, t.BTSucceeder = Kt, t.BTTick = E, t.BTWait = Zt, t.BTWaitUtil = $t, t.Base64Encrypt = Vt, t.BaseData = class {
            constructor(t, e) {
                this.id = t, this.gid = f.getGID(), null != e && (this.iniName = e, this.ini = st.instance.get(e, t))
            }
            clone() {
                let t = f.getModule(this);
                return this.iniName ? t = new t(this.id, this.iniName) : (t = new t, f.assign(t, this, !1)), t
            }
            from(t) {
                this.ini ? f.assign(this, t) : f.assign(this, t, !1)
            }
        }, t.BaseDataModel = class {
            constructor(t, e) {
                this.dataModule = e, this.name = t;
                let a = st.instance.get(t);
                a && (this.data = {}, this.ini = a, this._length = Object.keys(a).length)
            }
            get length() {
                return this._length
            }
            get(t) {
                return this.getWith(t, this.dataModule)
            }
            create(t) {
                return this.createWith(t, this.dataModule)
            }
            createWith(t, e) {
                if (this.ini[t]) {
                    let a = new e(t, this.name);
                    return f.assign(a, f.cloneDeep(a.ini), !1, !1), a
                }
            }
            getWith(t, e) {
                let a = this.data;
                if (a) {
                    if (a[t]) return a[t];
                    if (this.ini[t]) {
                        let a = this.data[t] = new e(t, this.name);
                        return f.assign(a, f.cloneDeep(a.ini), !1, !1), this.data[t]
                    }
                }
            }
            getValues(t) {
                let e = [];
                return this.recurisRaw((a => {
                    e.push(a[t])
                })), e
            }
            recurisRaw(t) {
                for (const e in this.ini) {
                    let a = t(this.ini[e], e);
                    if (!1 === a) return a
                }
            }
            foreach(t) {
                for (const e in this.ini) {
                    let a = t(this.ini[e], e);
                    if (!1 === a) return a
                }
            }
            getList(t = !1) {
                return this.list || (this.list = [], this.foreach(((e, a) => {
                    if (t) {
                        let t = this.get(a);
                        this.list.push(t)
                    } else this.list.push(e)
                }))), this.list
            }
        }, t.BaseDialog = lt, t.BaseEvent = V, t.BaseEventDispatcher = nt, t.BaseExtend = it, t.BaseLogic = gt, t.BaseScene = rt, t.BaseStorage = pt, t.BaseStorageModel = _t, t.BaseView = ot, t.BehaviorTree = class {
            constructor() {
                this.id = f.createUUIDEx(5), this.title = "The behavior tree", this.description = "Default description", this.properties = {}, this.root = null, this.debug = null
            }
            load(e, a) {
                a = a || {}, this.title = e.title || this.title, this.description = e.description || this.description, this.properties = e.properties || this.properties;
                let n, u, f, g = {};
                for (n in e.nodes) {
                    let t;
                    if (u = e.nodes[n], u.name in a) t = a[u.name];
                    else if (u.name in m) t = m[u.name];
                    else if (u.name in b) t = b[u.name];
                    else {
                        if (!(u.name in w)) throw new EvalError('BehaviorTree.load: Invalid node name + "' + u.name + '".');
                        t = w[u.name]
                    }
                    f = new t(u.properties), f.id = u.id || f.id, f.title = u.title || f.title, f.description = u.description || f.description, f.properties = u.properties || f.properties, g[n] = f
                }
                for (n in e.nodes)
                    if (u = e.nodes[n], f = g[n], f.category === t.BTCategory.COMPOSITE && u.children)
                        for (let t = 0; t < u.children.length; t++) {
                            let e = u.children[t];
                            f.children.push(g[e])
                        } else f.category === t.BTCategory.DECORATOR && u.child && (f.child = g[u.child]);
                this.root = g[e.root]
            }
            dump() {
                let e = {},
                    a = [];
                if (e.title = this.title, e.description = this.description, e.root = this.root ? this.root.id : null, e.properties = this.properties, e.nodes = {}, e.custom_nodes = [], !this.root) return e;
                let n = [this.root];
                for (; n.length > 0;) {
                    let u = n.pop(),
                        f = {};
                    f.id = u.id, f.name = u.name, f.title = u.title, f.description = u.description, f.properties = u.properties;
                    let g = u.constructor && u.constructor.prototype,
                        _ = g && g.name || u.name;
                    if (!m[_] && !b[_] && !w[_] && a.indexOf(_) < 0) {
                        let t = {};
                        t.name = _, t.title = g && g.title || u.title, t.category = u.category, a.push(_), e.custom_nodes.push(t)
                    }
                    if (u.category === t.BTCategory.COMPOSITE && u.children) {
                        let t = [];
                        for (let e = u.children.length - 1; e >= 0; e--) t.push(u.children[e].id), n.push(u.children[e]);
                        f.children = t
                    } else u.category === t.BTCategory.DECORATOR && u.child && (n.push(u.child), f.child = u.child.id);
                    e.nodes[u.id] = f
                }
                return e
            }
            tick(t, e) {
                if (!e) throw "The blackboard parameter is obligatory and must be an instance of b3.Blackboard";
                if (!this.root) return;
                let a = new E;
                a.debug = this.debug, a.target = t, a.blackboard = e, a.tree = this;
                let n = e.get("tick_frame", a.tree.id);
                null == n ? e.set("tick_frame", 0, a.tree.id) : e.set("tick_frame", n + 1, a.tree.id);
                let u, f = this.root._execute(a),
                    g = e.get("openNodes", this.id),
                    _ = a._openNodes.slice(0),
                    p = 0;
                for (u = 0; u < Math.min(g.length, _.length) && (p = u + 1, g[u] === _[u]); u++);
                for (u = g.length - 1; u >= p; u--) g[u]._close(a);
                return e.set("openNodes", _, this.id), e.set("nodeCount", a._nodeCount, this.id), f
            }
        }, t.ByteUtil = class {
            static readShort(t) {
                return t.readInt16()
            }
            static writeShort(t, e) {
                t.writeInt16(e)
            }
            static readInt(t) {
                return t.readInt32()
            }
            static writeInt(t, e) {
                t.writeInt32(e)
            }
            static readFloat(t) {
                return t.readFloat32()
            }
            static writeFloat(t, e) {
                t.writeFloat32(e)
            }
            static readDouble(t) {
                return t.readFloat64()
            }
            static writeDouble(t, e) {
                t.writeFloat64(e)
            }
            static readBoolean(t) {
                return 1 == t.readInt16()
            }
            static writeBoolean(t, e) {
                this.writeShort(t, e ? 1 : 0)
            }
            static readString(t) {
                let e = t.readInt16();
                return e <= 0 ? "" : t.readUTFBytes(e)
            }
            static writeString(t, e) {
                if (e && "" != e) {
                    let a = new Laya.Byte;
                    a.writeUTFBytes(e);
                    let n = a.length;
                    t.writeInt16(n), n > 0 && t.writeUTFBytes(e)
                } else t.writeInt16(0)
            }
            static readStringArray(t) {
                let e = t.readInt16();
                if (e <= 0) return null;
                let a = [];
                for (let n = 0; n < e; ++n) a.push(this.readString(t));
                return a
            }
            static writeStringArray(t, e) {
                if (!e || e.length <= 0) t.writeInt16(0);
                else {
                    let a = e.length;
                    t.writeInt16(a);
                    for (let n = 0; n < a; ++n) this.writeString(t, e[n])
                }
            }
            static readShortArray(t) {
                let e = t.readInt16();
                if (e <= 0) return null;
                let a = [];
                for (let n = 0; n < e; ++n) a.push(this.readShort(t));
                return a
            }
            static writeShortArray(t, e) {
                if (!e || e.length <= 0) t.writeInt16(0);
                else {
                    let a = e.length;
                    t.writeInt16(a);
                    for (let n = 0; n < a; ++n) this.writeShort(t, e[n])
                }
            }
            static readIntArray(t) {
                let e = t.readInt16();
                if (e <= 0) return null;
                let a = [];
                for (let n = 0; n < e; ++n) a.push(this.readInt(t));
                return a
            }
            static writeIntArray(t, e) {
                if (!e || e.length <= 0) t.writeInt16(0);
                else {
                    let a = e.length;
                    t.writeInt16(a);
                    for (let n = 0; n < a; ++n) this.writeInt(t, e[n])
                }
            }
            static readFloatArray(t) {
                let e = t.readInt16();
                if (e <= 0) return null;
                let a = [];
                for (let n = 0; n < e; ++n) a.push(this.readFloat(t));
                return a
            }
            static writeFloatArray(t, e) {
                if (!e || e.length <= 0) t.writeInt16(0);
                else {
                    let a = e.length;
                    t.writeInt16(a);
                    for (let n = 0; n < a; ++n) this.writeFloat(t, e[n])
                }
            }
            static readDoubleArray(t) {
                let e = t.readInt16();
                if (e <= 0) return null;
                let a = [];
                for (let n = 0; n < e; ++n) a.push(this.readDouble(t));
                return a
            }
            static writeDoubleArray(t, e) {
                if (!e || e.length <= 0) t.writeInt16(0);
                else {
                    let a = e.length;
                    t.writeInt16(a);
                    for (let n = 0; n < a; ++n) this.writeDouble(t, e[n])
                }
            }
        }, t.CColor = {
            RED: "#FF0000",
            GREEN: "#00FF00",
            BLUE: "#0000FF",
            CYAN: "#00FFFF",
            GRAY: "#808080",
            WHITE: "#FFFFFF",
            BLACK: "#000000"
        }, t.CfgMgr = st, t.Color = B, t.CryptUtil = mt, t.Dialog = R, t.Effect = ut, t.EventCenter = at, t.EventDispatcher = z, t.FX_VERSION = k, t.GraphicsCfg = ft, t.HelperEx = class {
            static destroyBySign(t, e) {
                let a = Laya.Pool._poolDic;
                if (e) {
                    for (const e in a)
                        if (-1 != e.indexOf(t)) {
                            let t = a[e];
                            for (const e of t) e.destroy();
                            t.length = 0, delete a[e]
                        }
                    return
                }
                let n = Laya.Pool.getPoolBySign(t);
                for (const t of n) t.destroy();
                n.length = 0, delete a[t]
            }
            static checkPoolBySign(t) {
                return Laya.Pool._poolDic[t]
            }
            static clone(t, e) {
                let a;
                if (t instanceof Laya.Image) a = new Laya.Image, this.cloneToImage(t, a, e);
                else if (t instanceof Laya.Box) a = new Laya.Box, this.cloneToBox(t, a);
                else {
                    if (!(t instanceof Laya.Label)) throw Error("clone type not implement !");
                    a = new Laya.Label, this.cloneToLabel(t, a)
                }
                let n = t.getChildren();
                for (const t of n) {
                    let n = this.clone(t, e);
                    a.addChild(n)
                }
                return a
            }
            static cloneToImage(t, e, a) {
                this.cloneToUIComp(t, e), e.skin = t.skin, a && (e.graphics = t.graphics, e.source = t.source)
            }
            static cloneToBox(t, e) {
                this.cloneToUIComp(t, e), e.bgColor = t.bgColor
            }
            static cloneToLabel(t, e) {
                this.cloneToUIComp(t, e), e.align = t.align, e.bold = t.bold, e.borderColor = t.borderColor, e.color = t.color, e.font = t.font, e.fontSize = t.fontSize, e.italic = t.italic, e.leading = t.leading, e.overflow = t.overflow, e.padding = t.padding, e.text = t.text, e.underline = t.underline, e.underlineColor = t.underlineColor, e.valign = t.valign, e.wordWrap = t.wordWrap
            }
            static cloneToUIComp(t, e) {
                e.alpha = t.alpha, e.anchorX = t.anchorX, e.anchorY = t.anchorY, e.autoSize = t.autoSize, e.blendMode = t.blendMode, e.bottom = t.bottom, e.cacheAs = t.cacheAs, e.centerX = t.centerX, e.centerY = t.centerY, e.cid = t.cid, e.customRenderEnable = t.customRenderEnable, e.dataSource = t.dataSource, e.destroyed = !1, e.disabled = t.disabled, e.drawCallOptimize = t.drawCallOptimize, t.filters && (e.filters = t.filters.splice(0)), e.gray = t.gray, e.height = t.height, e.hitArea = t.hitArea, e.hitTestPrior = t.hitTestPrior, e.left = t.left, e.mask = t.mask, e.mouseEnabled = t.mouseEnabled, e.mouseThrough = t.mouseThrough, e.name = t.name, e.pivotX = t.pivotX, e.pivotY = t.pivotY, e.right = t.right, e.rotation = t.rotation, e.scaleX = t.scaleX, e.scaleY = t.scaleY, e.scrollRect = t.scrollRect, e.skewX = t.skewX, e.skewY = t.skewY, e.staticCache = t.staticCache, e.tag = t.tag, e.texture = t.texture, e.toolTip = t.toolTip, e.top = t.top, t.transform && (e.transform = t.transform.clone()), t.viewport && (e.viewport = t.viewport.clone()), e.visible = t.visible, e.width = t.width, e.x = t.x, e.y = t.y, e.zOrder = t.zOrder
            }
            static typeText(t, e, a, n) {
                this.stopTypeText(t);
                let u = 1 / a;
                u = Math.max(u, .033);
                let f = Math.ceil(u * a);
                f = Math.max(f, 1);
                let g = 0;
                const updateFunc = function() {
                    t.destroyed || (g = Math.min(g + f, e.length), t.text = e.substring(0, g), g == e.length && (this.stopTypeText(t), n && n.run()))
                };
                t.text = "", t._typeUpdateFunc = updateFunc, t.timerLoop(1e3 * u, this, updateFunc)
            }
            static stopTypeText(t) {
                t._typeUpdateFunc && (t.timer.clear(this, t._typeUpdateFunc), t._typeUpdateFunc = null)
            }
            static randomPointUnitArcCircle(t, e, a = null) {
                var n;
                n = null !== a ? a * t : Math.random() * t, e.x = Math.cos(n), e.y = Math.sin(n)
            }
            static randomPointInsideUnitArcCircle(t, e, a = null) {
                var n;
                this.randomPointUnitArcCircle(t, e, a), n = null !== a ? Math.pow(a, .5) : Math.pow(Math.random(), .5), e.x = e.x * n, e.y = e.y * n
            }
            static randomPointUnitCircle(t, e = null) {
                var a;
                a = null !== e ? e * Math.PI * 2 : Math.random() * Math.PI * 2, t.x = Math.cos(a), t.y = Math.sin(a)
            }
            static randomPointInsideUnitCircle(t, e = null) {
                var a;
                this.randomPointUnitCircle(t), a = null !== e ? Math.pow(e, .5) : Math.pow(Math.random(), .5), t.x = t.x * a, t.y = t.y * a
            }
        }, t.HtmlText = qt, t.Http = wt, t.HttpManager = xt, t.HttpServer = Lt, t.MD5 = class {
            constructor() {
                this.hexcase = 0, this.b64pad = ""
            }
            hex_md5(t) {
                return this.rstr2hex(this.rstr_md5(this.str2rstr_utf8(t)))
            }
            b64_md5(t) {
                return this.rstr2b64(this.rstr_md5(this.str2rstr_utf8(t)))
            }
            any_md5(t, e) {
                return this.rstr2any(this.rstr_md5(this.str2rstr_utf8(t)), e)
            }
            hex_hmac_md5(t, e) {
                return this.rstr2hex(this.rstr_hmac_md5(this.str2rstr_utf8(t), this.str2rstr_utf8(e)))
            }
            b64_hmac_md5(t, e) {
                return this.rstr2b64(this.rstr_hmac_md5(this.str2rstr_utf8(t), this.str2rstr_utf8(e)))
            }
            any_hmac_md5(t, e, a) {
                return this.rstr2any(this.rstr_hmac_md5(this.str2rstr_utf8(t), this.str2rstr_utf8(e)), a)
            }
            md5_vm_test() {
                return "900150983cd24fb0d6963f7d28e17f72" == this.hex_md5("abc").toLowerCase()
            }
            rstr_md5(t) {
                return this.binl2rstr(this.binl_md5(this.rstr2binl(t), 8 * t.length))
            }
            rstr_hmac_md5(t, e) {
                var a = this.rstr2binl(t);
                a.length > 16 && (a = this.binl_md5(a, 8 * t.length));
                for (var n = Array(16), u = Array(16), f = 0; f < 16; f++) n[f] = 909522486 ^ a[f], u[f] = 1549556828 ^ a[f];
                var g = this.binl_md5(n.concat(this.rstr2binl(e)), 512 + 8 * e.length);
                return this.binl2rstr(this.binl_md5(u.concat(g), 640))
            }
            rstr2hex(t) {
                try {
                    this.hexcase
                } catch (t) {
                    this.hexcase = 0
                }
                for (var e, a = this.hexcase ? "0123456789ABCDEF" : "0123456789abcdef", n = "", u = 0; u < t.length; u++) e = t.charCodeAt(u), n += a.charAt(e >>> 4 & 15) + a.charAt(15 & e);
                return n
            }
            rstr2b64(t) {
                try {
                    this.b64pad
                } catch (t) {
                    this.b64pad = ""
                }
                for (var e = "", a = t.length, n = 0; n < a; n += 3)
                    for (var u = t.charCodeAt(n) << 16 | (n + 1 < a ? t.charCodeAt(n + 1) << 8 : 0) | (n + 2 < a ? t.charCodeAt(n + 2) : 0), f = 0; f < 4; f++) 8 * n + 6 * f > 8 * t.length ? e += this.b64pad : e += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(u >>> 6 * (3 - f) & 63);
                return e
            }
            rstr2any(t, e) {
                var a, n, u, f, g, _ = e.length,
                    p = Array(Math.ceil(t.length / 2));
                for (a = 0; a < p.length; a++) p[a] = t.charCodeAt(2 * a) << 8 | t.charCodeAt(2 * a + 1);
                var y = Math.ceil(8 * t.length / (Math.log(e.length) / Math.log(2))),
                    m = Array(y);
                for (n = 0; n < y; n++) {
                    for (g = Array(), f = 0, a = 0; a < p.length; a++) f = (f << 16) + p[a], f -= (u = Math.floor(f / _)) * _, (g.length > 0 || u > 0) && (g[g.length] = u);
                    m[n] = f, p = g
                }
                var b = "";
                for (a = m.length - 1; a >= 0; a--) b += e.charAt(m[a]);
                return b
            }
            str2rstr_utf8(t) {
                for (var e, a, n = "", u = -1; ++u < t.length;) e = t.charCodeAt(u), a = u + 1 < t.length ? t.charCodeAt(u + 1) : 0, 55296 <= e && e <= 56319 && 56320 <= a && a <= 57343 && (e = 65536 + ((1023 & e) << 10) + (1023 & a), u++), e <= 127 ? n += String.fromCharCode(e) : e <= 2047 ? n += String.fromCharCode(192 | e >>> 6 & 31, 128 | 63 & e) : e <= 65535 ? n += String.fromCharCode(224 | e >>> 12 & 15, 128 | e >>> 6 & 63, 128 | 63 & e) : e <= 2097151 && (n += String.fromCharCode(240 | e >>> 18 & 7, 128 | e >>> 12 & 63, 128 | e >>> 6 & 63, 128 | 63 & e));
                return n
            }
            str2rstr_utf16le(t) {
                for (var e = "", a = 0; a < t.length; a++) e += String.fromCharCode(255 & t.charCodeAt(a), t.charCodeAt(a) >>> 8 & 255);
                return e
            }
            str2rstr_utf16be(t) {
                for (var e = "", a = 0; a < t.length; a++) e += String.fromCharCode(t.charCodeAt(a) >>> 8 & 255, 255 & t.charCodeAt(a));
                return e
            }
            rstr2binl(t) {
                for (var e = Array(t.length >> 2), a = 0; a < e.length; a++) e[a] = 0;
                for (a = 0; a < 8 * t.length; a += 8) e[a >> 5] |= (255 & t.charCodeAt(a / 8)) << a % 32;
                return e
            }
            binl2rstr(t) {
                for (var e = "", a = 0; a < 32 * t.length; a += 8) e += String.fromCharCode(t[a >> 5] >>> a % 32 & 255);
                return e
            }
            binl_md5(t, e) {
                t[e >> 5] |= 128 << e % 32, t[14 + (e + 64 >>> 9 << 4)] = e;
                for (var a = 1732584193, n = -271733879, u = -1732584194, f = 271733878, g = 0; g < t.length; g += 16) {
                    var _ = a,
                        p = n,
                        y = u,
                        m = f;
                    a = this.md5_ff(a, n, u, f, t[g + 0], 7, -680876936), f = this.md5_ff(f, a, n, u, t[g + 1], 12, -389564586), u = this.md5_ff(u, f, a, n, t[g + 2], 17, 606105819), n = this.md5_ff(n, u, f, a, t[g + 3], 22, -1044525330), a = this.md5_ff(a, n, u, f, t[g + 4], 7, -176418897), f = this.md5_ff(f, a, n, u, t[g + 5], 12, 1200080426), u = this.md5_ff(u, f, a, n, t[g + 6], 17, -1473231341), n = this.md5_ff(n, u, f, a, t[g + 7], 22, -45705983), a = this.md5_ff(a, n, u, f, t[g + 8], 7, 1770035416), f = this.md5_ff(f, a, n, u, t[g + 9], 12, -1958414417), u = this.md5_ff(u, f, a, n, t[g + 10], 17, -42063), n = this.md5_ff(n, u, f, a, t[g + 11], 22, -1990404162), a = this.md5_ff(a, n, u, f, t[g + 12], 7, 1804603682), f = this.md5_ff(f, a, n, u, t[g + 13], 12, -40341101), u = this.md5_ff(u, f, a, n, t[g + 14], 17, -1502002290), n = this.md5_ff(n, u, f, a, t[g + 15], 22, 1236535329), a = this.md5_gg(a, n, u, f, t[g + 1], 5, -165796510), f = this.md5_gg(f, a, n, u, t[g + 6], 9, -1069501632), u = this.md5_gg(u, f, a, n, t[g + 11], 14, 643717713), n = this.md5_gg(n, u, f, a, t[g + 0], 20, -373897302), a = this.md5_gg(a, n, u, f, t[g + 5], 5, -701558691), f = this.md5_gg(f, a, n, u, t[g + 10], 9, 38016083), u = this.md5_gg(u, f, a, n, t[g + 15], 14, -660478335), n = this.md5_gg(n, u, f, a, t[g + 4], 20, -405537848), a = this.md5_gg(a, n, u, f, t[g + 9], 5, 568446438), f = this.md5_gg(f, a, n, u, t[g + 14], 9, -1019803690), u = this.md5_gg(u, f, a, n, t[g + 3], 14, -187363961), n = this.md5_gg(n, u, f, a, t[g + 8], 20, 1163531501), a = this.md5_gg(a, n, u, f, t[g + 13], 5, -1444681467), f = this.md5_gg(f, a, n, u, t[g + 2], 9, -51403784), u = this.md5_gg(u, f, a, n, t[g + 7], 14, 1735328473), n = this.md5_gg(n, u, f, a, t[g + 12], 20, -1926607734), a = this.md5_hh(a, n, u, f, t[g + 5], 4, -378558), f = this.md5_hh(f, a, n, u, t[g + 8], 11, -2022574463), u = this.md5_hh(u, f, a, n, t[g + 11], 16, 1839030562), n = this.md5_hh(n, u, f, a, t[g + 14], 23, -35309556), a = this.md5_hh(a, n, u, f, t[g + 1], 4, -1530992060), f = this.md5_hh(f, a, n, u, t[g + 4], 11, 1272893353), u = this.md5_hh(u, f, a, n, t[g + 7], 16, -155497632), n = this.md5_hh(n, u, f, a, t[g + 10], 23, -1094730640), a = this.md5_hh(a, n, u, f, t[g + 13], 4, 681279174), f = this.md5_hh(f, a, n, u, t[g + 0], 11, -358537222), u = this.md5_hh(u, f, a, n, t[g + 3], 16, -722521979), n = this.md5_hh(n, u, f, a, t[g + 6], 23, 76029189), a = this.md5_hh(a, n, u, f, t[g + 9], 4, -640364487), f = this.md5_hh(f, a, n, u, t[g + 12], 11, -421815835), u = this.md5_hh(u, f, a, n, t[g + 15], 16, 530742520), n = this.md5_hh(n, u, f, a, t[g + 2], 23, -995338651), a = this.md5_ii(a, n, u, f, t[g + 0], 6, -198630844), f = this.md5_ii(f, a, n, u, t[g + 7], 10, 1126891415), u = this.md5_ii(u, f, a, n, t[g + 14], 15, -1416354905), n = this.md5_ii(n, u, f, a, t[g + 5], 21, -57434055), a = this.md5_ii(a, n, u, f, t[g + 12], 6, 1700485571), f = this.md5_ii(f, a, n, u, t[g + 3], 10, -1894986606), u = this.md5_ii(u, f, a, n, t[g + 10], 15, -1051523), n = this.md5_ii(n, u, f, a, t[g + 1], 21, -2054922799), a = this.md5_ii(a, n, u, f, t[g + 8], 6, 1873313359), f = this.md5_ii(f, a, n, u, t[g + 15], 10, -30611744), u = this.md5_ii(u, f, a, n, t[g + 6], 15, -1560198380), n = this.md5_ii(n, u, f, a, t[g + 13], 21, 1309151649), a = this.md5_ii(a, n, u, f, t[g + 4], 6, -145523070), f = this.md5_ii(f, a, n, u, t[g + 11], 10, -1120210379), u = this.md5_ii(u, f, a, n, t[g + 2], 15, 718787259), n = this.md5_ii(n, u, f, a, t[g + 9], 21, -343485551), a = this.safe_add(a, _), n = this.safe_add(n, p), u = this.safe_add(u, y), f = this.safe_add(f, m)
                }
                return [a, n, u, f]
            }
            md5_cmn(t, e, a, n, u, f) {
                return this.safe_add(this.bit_rol(this.safe_add(this.safe_add(e, t), this.safe_add(n, f)), u), a)
            }
            md5_ff(t, e, a, n, u, f, g) {
                return this.md5_cmn(e & a | ~e & n, t, e, u, f, g)
            }
            md5_gg(t, e, a, n, u, f, g) {
                return this.md5_cmn(e & n | a & ~n, t, e, u, f, g)
            }
            md5_hh(t, e, a, n, u, f, g) {
                return this.md5_cmn(e ^ a ^ n, t, e, u, f, g)
            }
            md5_ii(t, e, a, n, u, f, g) {
                return this.md5_cmn(a ^ (e | ~n), t, e, u, f, g)
            }
            safe_add(t, e) {
                var a = (65535 & t) + (65535 & e);
                return (t >> 16) + (e >> 16) + (a >> 16) << 16 | 65535 & a
            }
            bit_rol(t, e) {
                return t << e | t >>> 32 - e
            }
        }, t.MapEx = Xt, t.ModalDialogBox = class extends R {
            constructor(t, e, a) {
                if (super(), this.handler_close = Laya.Handler.create(this, (function() {
                        this.removeSelf()
                    })), a.tex_bgMask && (this.img_bgmask = new Laya.Image, this.img_bgmask.name = "img_bg", this.addChild(this.img_bgmask), this.img_bgmask.left = 0, this.img_bgmask.right = 0, this.img_bgmask.top = 0, this.img_bgmask.bottom = 0, this.img_bgmask.skin = a.tex_bgMask, a.texSizegrid_bgMask && (this.img_bgmask.sizeGrid = a.texSizegrid_bgMask)), this.img_bg = new Laya.Image, this.addChild(this.img_bg), a.tex_bg ? this.img_bg.skin = a.tex_bg : (console.log("模态弹出框背景纹理为空!!!"), this.img_bg.width = 500, this.img_bg.height = 400), a.texSizegrid_bg && (this.img_bg.sizeGrid = a.texSizegrid_bg), this.img_bg.centerX = 0, this.img_bg.centerY = 0, !a.texSize_bg && (a.texSize_bg = {
                        width: 600,
                        height: 400
                    }), !a.texSize_bg.width && (a.texSize_bg.width = 600), !a.texSize_bg.height && (a.texSize_bg.height = 400), this.img_bg.size(a.texSize_bg.width, a.texSize_bg.height), this.label_title = new Laya.Label, this.img_bg.addChild(this.label_title), this.label_title.fontSize = 40, this.label_title.bold = !0, this.label_title.color = "#ffffff", this.label_title.centerX = 0, this.label_title.top = 25, this.label_content = new Laya.Label, this.img_bg.addChild(this.label_content), this.label_content.fontSize = 36, this.label_content.bold = !0, this.label_content.color = "#ffffff", this.label_content.centerX = 0, this.label_content.centerY = 0, a.contentLeading && (this.label_content.leading = a.contentLeading), a.tex_closeBtn ? (this.btn_close = new Laya.Button, this.img_bg.addChild(this.btn_close), this.btn_close.skin = a.tex_closeBtn, this.btn_close.stateNum = 1, this.btn_close.anchorX = 1, this.btn_close.anchorY = 1, this.btn_close.top = 0, this.btn_close.right = 0, a.handler_closeBtn ? this.handler_closeBtn = a.handler_cancelBtn : this.handler_closeBtn = this.handler_close, this.btn_close.on(Laya.Event.CLICK, this, (function() {
                        this.handler_closeBtn.run()
                    }))) : console.log("模态弹出框关闭按钮纹理为空!!!"), a.tex_sureBtn) {
                    if (this.btn_sure = new Laya.Button, this.img_bg.addChild(this.btn_sure), this.btn_sure.stateNum = 1, this.btn_sure.skin = a.tex_sureBtn, a.texSizegrid_sureBtn && (this.btn_sure.sizeGrid = a.texSizegrid_sureBtn), this.btn_sure.size(200, 120), this.handler_sureBtn = a.handler_sureBtn, this.btn_sure.on(Laya.Event.CLICK, this, (function() {
                            this.handler_sureBtn && this.handler_sureBtn.run(), this.handler_close.run()
                        })), a.font_sureBtn) {
                        let t = Laya.loader.getRes(a.font_sureBtn);
                        t ? (this.font_btn_sure = new Laya.Image, this.btn_sure.addChild(this.font_btn_sure), this.font_btn_sure.source = t) : (this.font_btn_sure = new Laya.Label, this.btn_sure.addChild(this.font_btn_sure), this.font_btn_sure.text = a.font_sureBtn, this.font_btn_sure.color = "#ffffff", this.font_btn_sure.fontSize = 34, this.font_btn_sure.bold = !0), !a.font_suereBtn_centeroffset && (a.font_suereBtn_centeroffset = new Laya.Point(0, 0)), this.font_btn_sure.centerX = a.font_suereBtn_centeroffset.x, this.font_btn_sure.centerY = a.font_suereBtn_centeroffset.y
                    }
                } else console.log("模态对话框确认按钮纹理缺失!!!");
                if (a.tex_cancelBtn) {
                    if (this.btn_cancel = new Laya.Button, this.img_bg.addChild(this.btn_cancel), this.btn_cancel.stateNum = 1, this.btn_cancel.skin = a.tex_cancelBtn, a.texSizegrid_cancelBtn && (this.btn_cancel.sizeGrid = a.texSizegrid_cancelBtn), this.btn_cancel.size(200, 120), this.handler_cancelBtn = a.handler_cancelBtn, this.btn_cancel.on(Laya.Event.CLICK, this, (function() {
                            this.handler_cancelBtn && this.handler_cancelBtn.run(), this.handler_close.run()
                        })), a.font_cancelBtn) {
                        let t = Laya.loader.getRes(a.font_cancelBtn);
                        t ? (this.font_btn_cancel = new Laya.Image, this.btn_cancel.addChild(this.font_btn_cancel), this.font_btn_cancel.source = t) : (this.font_btn_cancel = new Laya.Label, this.btn_cancel.addChild(this.font_btn_cancel), this.font_btn_cancel.text = a.font_cancelBtn, this.font_btn_cancel.color = "#ffffff", this.font_btn_cancel.fontSize = 34, this.font_btn_cancel.bold = !0), !a.font_cancelBtn_centeroffset && (a.font_cancelBtn_centeroffset = new Laya.Point(0, 0)), this.font_btn_cancel.centerX = a.font_cancelBtn_centeroffset.x, this.font_btn_cancel.centerY = a.font_cancelBtn_centeroffset.y
                    }
                } else console.log("模态对话框取消按钮纹理缺失!!!");
                this.btn_sure && this.btn_cancel ? (this.btn_sure.centerX = (this.img_bg.width / 2 - this.btn_sure.width) / 2 + this.btn_sure.width / 2, this.btn_sure.bottom = -this.btn_sure.height / 3, this.btn_cancel.centerX = -(this.img_bg.width / 2 - this.btn_cancel.width) / 2 - this.btn_cancel.width / 2, this.btn_cancel.bottom = -this.btn_cancel.height / 3) : this.btn_sure && !this.btn_cancel ? (this.btn_sure.centerX = 0, this.btn_sure.bottom = 0) : !this.btn_sure && this.btn_cancel && (this.btn_cancel.centerX = 0, this.btn_cancel.bottom = 0)
            }
            get label_title() {
                return this._label_title
            }
            set label_title(t) {
                this._label_title = t
            }
            get label_content() {
                return this._label_content
            }
            set label_content(t) {
                this._label_content = t
            }
            get img_bgmask() {
                return this._img_bgmask
            }
            set img_bgmask(t) {
                this._img_bgmask = t
            }
            get img_bg() {
                return this._img_bg
            }
            set img_bg(t) {
                this._img_bg = t
            }
            get btn_close() {
                return this._btn_close
            }
            set btn_close(t) {
                this._btn_close = t
            }
            get btn_sure() {
                return this._btn_sure
            }
            set btn_sure(t) {
                this._btn_sure = t
            }
            get font_btn_sure() {
                return this._font_btn_sure
            }
            set font_btn_sure(t) {
                this._font_btn_sure = t
            }
            get btn_cancel() {
                return this._btn_cancel
            }
            set btn_cancel(t) {
                this._btn_cancel = t
            }
            get font_btn_cancel() {
                return this._font_btn_cancel
            }
            set font_btn_cancel(t) {
                this._font_btn_cancel = t
            }
        }, t.Physics = $, t.RVOMath = Nt, t.RandomUtil = class {
            init(t) {
                this._seed = t
            }
            random() {
                return this._seed = (9301 * this._seed + 49297) % 233280, this._seed / 233280
            }
            getIntRandom(t, e) {
                return Math.floor(this.random() * (e - t + 1) + t)
            }
            randomArray(t) {
                if (!t || 0 == t.length) return;
                let e = t.length;
                for (; e;) {
                    let a = Math.floor(this.random() * e--);
                    [t[a], t[e]] = [t[e], t[a]]
                }
                return t
            }
            randomInArray(t) {
                if (!t || 0 == t.length) return null;
                return t[Math.floor(this.random() * t.length)]
            }
        }, t.RvoAgent = Pt, t.RvoKdTree = Ut, t.RvoKeyValuePair = kt, t.RvoLine = Ot, t.RvoObstacle = It, t.RvoSimulator = class {
            constructor() {
                this.agentId = 0, this.agentIdLst = [], this.aid2agent = Object.create(null), this.obstacles = [], this.time = 0, this.kdTree = new Ut(this)
            }
            getAgent(t) {
                return this.aid2agent[this.agentIdLst[t]]
            }
            getAgentByAid(t) {
                return this.aid2agent[t]
            }
            getGlobalTime() {
                return this.time
            }
            getNumAgents() {
                return this.agentIdLst.length
            }
            setAgentPrefVelocity(t, e) {
                this.aid2agent[t].prefVelocity_.copy(e)
            }
            getAgentPosition(t) {
                return this.aid2agent[t].position_
            }
            getAgentPrefVelocity(t) {
                return this.aid2agent[t].prefVelocity_
            }
            getAgentVelocity(t) {
                return this.aid2agent[t].velocity_
            }
            getAgentRadius(t) {
                return this.aid2agent[t].radius_
            }
            getAgentOrcaLines(t) {
                return this.aid2agent[t].orcaLines_
            }
            addAgent(t, e, a, n, u) {
                if (!this.defaultAgent) throw new Error("no default agent");
                let f = new Pt;
                return f.position_.copy(t), f.maxNeighbors_ = this.defaultAgent.maxNeighbors_, f.maxSpeed_ = a || this.defaultAgent.maxSpeed_, f.neighborDist = this.defaultAgent.neighborDist, f.radius_ = e || this.defaultAgent.radius_, f.timeHorizon = this.defaultAgent.timeHorizon, f.timeHorizonObst = this.defaultAgent.timeHorizonObst, f.velocity_.copy(n || this.defaultAgent.velocity_), u && (f.mass = u), f.id = this.agentId++, this.aid2agent[f.id] = f, this.agentIdLst.push(f.id), f.id
            }
            removeAgent(t) {
                if (this.hasAgent(t)) {
                    delete this.aid2agent[t];
                    let e = this.agentIdLst.indexOf(t);
                    this.agentIdLst[e] = this.agentIdLst[this.agentIdLst.length - 1], this.agentIdLst.length--
                }
            }
            hasAgent(t) {
                return !!this.aid2agent[t]
            }
            setAgentMass(t, e) {
                this.aid2agent[t].mass = e
            }
            getAgentMass(t) {
                return this.aid2agent[t].mass
            }
            setAgentRadius(t, e) {
                this.aid2agent[t].radius_ = e
            }
            setAgentDefaults(t, e, a, n, u, f, g) {
                this.defaultAgent || (this.defaultAgent = new Pt), this.defaultAgent.maxNeighbors_ = e, this.defaultAgent.maxSpeed_ = f, this.defaultAgent.neighborDist = t, this.defaultAgent.radius_ = u, this.defaultAgent.timeHorizon = a, this.defaultAgent.timeHorizonObst = n, this.defaultAgent.velocity_ = g
            }
            run(t) {
                this.kdTree.buildAgentTree(this.getNumAgents());
                let e = this.agentIdLst.length;
                for (let a = 0; a < e; a++) this.aid2agent[this.agentIdLst[a]].computeNeighbors(this), this.aid2agent[this.agentIdLst[a]].computeNewVelocity(t);
                for (let a = 0; a < e; a++) this.aid2agent[this.agentIdLst[a]].update(t);
                this.time += t
            }
            addObstacle(t) {
                if (t.length < 2) return -1;
                let e = this.obstacles.length;
                for (let a = 0; a < t.length; ++a) {
                    let n = new It;
                    n.point = t[a], 0 != a && (n.previous = this.obstacles[this.obstacles.length - 1], n.previous.next = n), a == t.length - 1 && (n.next = this.obstacles[e], n.next.previous = n), n.direction = Nt.normalize(t[a == t.length - 1 ? 0 : a + 1].minus(t[a])), 2 == t.length ? n.convex = !0 : n.convex = Nt.leftOf(t[0 == a ? t.length - 1 : a - 1], t[a], t[a == t.length - 1 ? 0 : a + 1]) >= 0, n.id = this.obstacles.length, this.obstacles.push(n)
                }
                return e
            }
            processObstacles() {
                this.kdTree.buildObstacleTree()
            }
            queryVisibility(t, e, a) {
                return this.kdTree.queryVisibility(t, e, a)
            }
            getObstacles() {
                return this.obstacles
            }
            clear() {
                this.agentIdLst.length = 0, this.agentId = 0, this.aid2agent = Object.create(null), this.defaultAgent = null, this.kdTree = new Ut(this), this.obstacles.length = 0
            }
        }, t.RvoVector2 = Mt, t.SceneManager = dt, t.Sequence = g, t.ServerStorage = Ht, t.Size = et, t.SoundCfg = class {}, t.SoundManager = ct, t.TableView = Tt, t.Trail = At, t.UserInfoEntity = zt, t.UserLogic = Ft, t.Utils = f, t.V2 = e, t.V3 = a, t.V4 = n, t.WebSocket = class {
            constructor() {
                this.byte = new Laya.Byte, this.byte.endian = Laya.Byte.LITTLE_ENDIAN, this.ws = new Laya.Socket, this.ws.endian = Laya.Byte.LITTLE_ENDIAN, this.ws.on(Laya.Event.MESSAGE, this, this._onMessage), this.ws.on(Laya.Event.OPEN, this, this._onOpen), this.ws.on(Laya.Event.CLOSE, this, this._onClose), this.ws.on(Laya.Event.ERROR, this, this._onError)
            }
            isConnected() {
                return this.ws.connected
            }
            _onMessage(t) {
                this.onMessage && this.onMessage(t)
            }
            _onOpen(t) {
                console.log("WebSocket onOpen"), this.onOpen && this.onOpen(t)
            }
            _onClose(t) {
                console.log("WebSocket onClose"), this.token = void 0, this.onClose && this.onClose(t)
            }
            _onError(t) {
                console.log("WebSocket onError"), this.onError && this.onError(t)
            }
            connect(t, e) {
                return console.log(`WebSocket connect ${t} port:${e}`), e ? this.ws.connect(t, e) : this.ws.connectByUrl(t), this
            }
            close() {
                this.ws.close(), this.token = void 0
            }
            destroy() {
                this.ws.offAll();
                try {
                    this.ws.cleanSocket()
                } catch (t) {}
                this.ws = null, this.token = void 0
            }
            send(t) {
                return this.ws.send(t), this
            }
        }, t.cheatClass = function(t, e = "_", a = !0, n, u, g) {
            return function(_) {
                if (f.definePropertyEx(_.prototype, "cheatPrefix", {
                        value: e,
                        enumerable: !1,
                        writable: !1
                    }), f.definePropertyEx(_.prototype, "cheatOnlyDetect", {
                        value: a,
                        enumerable: !1,
                        writable: !1
                    }), f.definePropertyEx(_.prototype, "cheatGet", {
                        value: n,
                        enumerable: !1,
                        writable: !1
                    }), f.definePropertyEx(_.prototype, "cheatSet", {
                        value: u,
                        enumerable: !1,
                        writable: !1
                    }), f.definePropertyEx(_.prototype, "cheatScene", {
                        value: t,
                        enumerable: !1,
                        writable: !1
                    }), (n || u) && !g) throw Error("cheatGet or cheatSet must have callback !");
                f.definePropertyEx(_.prototype, "cheatCallback", {
                    value: g,
                    enumerable: !1,
                    writable: !1
                })
            }
        }, t.cheatProperty = function() {
            return function(t, e) {
                function checkCheat(a, n) {
                    let u = this[n],
                        g = t.cheatOnlyDetect ? mt.encryptAes(u) : u,
                        _ = function(t, e) {
                            return t.hasOwnProperty("$isInitCiphertextMap") || (f.definePropertyEx(t, "ciphertextMap", {
                                value: {},
                                enumerable: !1,
                                writable: !1
                            }), f.definePropertyEx(t, "$isInitCiphertextMap", {
                                value: !0,
                                enumerable: !1,
                                writable: !1
                            })), t.ciphertextMap.hasOwnProperty(e) ? t.ciphertextMap[e] : ""
                        }(a, e);
                    _ && g != _ && t.cheatCallback(t.cheatScene)
                }
                delete t[e], Object.defineProperty(t, e, {get: function() {
                        let a = t.cheatPrefix + e;
                        return t.cheatGet && checkCheat(this, a), t.cheatOnlyDetect ? this[a] : mt.decryptAes(this[a])
                    },
                    set: function(a) {
                        let n = t.cheatPrefix + e;
                        if (this[n] != a) {
                            t.cheatSet && checkCheat(this, n);
                            let u = mt.encryptAes(a);
                            ! function(t, e, a) {
                                t.hasOwnProperty("$isInitCiphertextMap") || (f.definePropertyEx(t, "ciphertextMap", {
                                    value: {},
                                    enumerable: !1,
                                    writable: !1
                                }), f.definePropertyEx(t, "$isInitCiphertextMap", {
                                    value: !0,
                                    enumerable: !1,
                                    writable: !1
                                })), t.ciphertextMap[e] = a
                            }(this, e, u), t.cheatOnlyDetect ? this[n] = a : this[n] = u
                        }
                    },
                    enumerable: !1,
                    configurable: !0
                })
            }
        }, Object.defineProperty(t, "__esModule", {
            value: !0
        }), t
    }({});
});
define("libs/min/gravityengine.mg.layats.min.js", function(require, module, exports) {
    var e, t;
    e = void 0, t = function() {
        function e(e, t) {
            var n = Object.keys(e);
            if (Object.getOwnPropertySymbols) {
                var i = Object.getOwnPropertySymbols(e);
                t && (i = i.filter((function(t) {
                    return Object.getOwnPropertyDescriptor(e, t).enumerable
                }))), n.push.apply(n, i)
            }
            return n
        }

        function t(t) {
            for (var n = 1; n < arguments.length; n++) {
                var i = null != arguments[n] ? arguments[n] : {};
                n % 2 ? e(Object(i), !0).forEach((function(e) {
                    u(t, e, i[e])
                })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(i)) : e(Object(i)).forEach((function(e) {
                    Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(i, e))
                }))
            }
            return t
        }

        function n() {
            n = function() {
                return e
            };
            var e = {},
                t = Object.prototype,
                i = t.hasOwnProperty,
                r = Object.defineProperty || function(e, t, n) {
                    e[t] = n.value
                },
                a = "function" == typeof Symbol ? Symbol : {},
                s = a.iterator || "@@iterator",
                o = a.asyncIterator || "@@asyncIterator",
                c = a.toStringTag || "@@toStringTag";

            function u(e, t, n) {
                return Object.defineProperty(e, t, {
                    value: n,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }), e[t]
            }
            try {
                u({}, "")
            } catch (e) {
                u = function(e, t, n) {
                    return e[t] = n
                }
            }

            function l(e, t, n, i) {
                var a = t && t.prototype instanceof h ? t : h,
                    s = Object.create(a.prototype),
                    o = new O(i || []);
                return r(s, "_invoke", {
                    value: w(e, n, o)
                }), s
            }

            function p(e, t, n) {
                try {
                    return {
                        type: "normal",
                        arg: e.call(t, n)
                    }
                } catch (e) {
                    return {
                        type: "throw",
                        arg: e
                    }
                }
            }
            e.wrap = l;
            var f = {};

            function h() {}

            function d() {}

            function v() {}
            var g = {};
            u(g, s, (function() {
                return this
            }));
            var m = Object.getPrototypeOf,
                y = m && m(m(N([])));
            y && y !== t && i.call(y, s) && (g = y);
            var _ = v.prototype = h.prototype = Object.create(g);

            function k(e) {
                ["next", "throw", "return"].forEach((function(t) {
                    u(e, t, (function(e) {
                        return this._invoke(t, e)
                    }))
                }))
            }

            function b(e, t) {
                var n;
                r(this, "_invoke", {
                    value: function(r, a) {
                        function s() {
                            return new t((function(n, s) {
                                ! function n(r, a, s, o) {
                                    var c = p(e[r], e, a);
                                    if ("throw" !== c.type) {
                                        var u = c.arg,
                                            l = u.value;
                                        return l && "object" == typeof l && i.call(l, "__await") ? t.resolve(l.__await).then((function(e) {
                                            n("next", e, s, o)
                                        }), (function(e) {
                                            n("throw", e, s, o)
                                        })) : t.resolve(l).then((function(e) {
                                            u.value = e, s(u)
                                        }), (function(e) {
                                            return n("throw", e, s, o)
                                        }))
                                    }
                                    o(c.arg)
                                }(r, a, n, s)
                            }))
                        }
                        return n = n ? n.then(s, s) : s()
                    }
                })
            }

            function w(e, t, n) {
                var i = "suspendedStart";
                return function(r, a) {
                    if ("executing" === i) throw new Error("Generator is already running");
                    if ("completed" === i) {
                        if ("throw" === r) throw a;
                        return {
                            value: void 0,
                            done: !0
                        }
                    }
                    for (n.method = r, n.arg = a;;) {
                        var s = n.delegate;
                        if (s) {
                            var o = S(s, n);
                            if (o) {
                                if (o === f) continue;
                                return o
                            }
                        }
                        if ("next" === n.method) n.sent = n._sent = n.arg;
                        else if ("throw" === n.method) {
                            if ("suspendedStart" === i) throw i = "completed", n.arg;
                            n.dispatchException(n.arg)
                        } else "return" === n.method && n.abrupt("return", n.arg);
                        i = "executing";
                        var c = p(e, t, n);
                        if ("normal" === c.type) {
                            if (i = n.done ? "completed" : "suspendedYield", c.arg === f) continue;
                            return {
                                value: c.arg,
                                done: n.done
                            }
                        }
                        "throw" === c.type && (i = "completed", n.method = "throw", n.arg = c.arg)
                    }
                }
            }

            function S(e, t) {
                var n = t.method,
                    i = e.iterator[n];
                if (void 0 === i) return t.delegate = null, "throw" === n && e.iterator.return && (t.method = "return", t.arg = void 0, S(e, t), "throw" === t.method) || "return" !== n && (t.method = "throw", t.arg = new TypeError("The iterator does not provide a '" + n + "' method")), f;
                var r = p(i, e.iterator, t.arg);
                if ("throw" === r.type) return t.method = "throw", t.arg = r.arg, t.delegate = null, f;
                var a = r.arg;
                return a ? a.done ? (t[e.resultName] = a.value, t.next = e.nextLoc, "return" !== t.method && (t.method = "next", t.arg = void 0), t.delegate = null, f) : a : (t.method = "throw", t.arg = new TypeError("iterator result is not an object"), t.delegate = null, f)
            }

            function P(e) {
                var t = {
                    tryLoc: e[0]
                };
                1 in e && (t.catchLoc = e[1]), 2 in e && (t.finallyLoc = e[2], t.afterLoc = e[3]), this.tryEntries.push(t)
            }

            function I(e) {
                var t = e.completion || {};
                t.type = "normal", delete t.arg, e.completion = t
            }

            function O(e) {
                this.tryEntries = [{
                    tryLoc: "root"
                }], e.forEach(P, this), this.reset(!0)
            }

            function N(e) {
                if (e || "" === e) {
                    var t = e[s];
                    if (t) return t.call(e);
                    if ("function" == typeof e.next) return e;
                    if (!isNaN(e.length)) {
                        var n = -1,
                            r = function t() {
                                for (; ++n < e.length;)
                                    if (i.call(e, n)) return t.value = e[n], t.done = !1, t;
                                return t.value = void 0, t.done = !0, t
                            };
                        return r.next = r
                    }
                }
                throw new TypeError(typeof e + " is not iterable")
            }
            return d.prototype = v, r(_, "constructor", {
                value: v,
                configurable: !0
            }), r(v, "constructor", {
                value: d,
                configurable: !0
            }), d.displayName = u(v, c, "GeneratorFunction"), e.isGeneratorFunction = function(e) {
                var t = "function" == typeof e && e.constructor;
                return !!t && (t === d || "GeneratorFunction" === (t.displayName || t.name))
            }, e.mark = function(e) {
                return Object.setPrototypeOf ? Object.setPrototypeOf(e, v) : (e.__proto__ = v, u(e, c, "GeneratorFunction")), e.prototype = Object.create(_), e
            }, e.awrap = function(e) {
                return {
                    __await: e
                }
            }, k(b.prototype), u(b.prototype, o, (function() {
                return this
            })), e.AsyncIterator = b, e.async = function(t, n, i, r, a) {
                void 0 === a && (a = Promise);
                var s = new b(l(t, n, i, r), a);
                return e.isGeneratorFunction(n) ? s : s.next().then((function(e) {
                    return e.done ? e.value : s.next()
                }))
            }, k(_), u(_, c, "Generator"), u(_, s, (function() {
                return this
            })), u(_, "toString", (function() {
                return "[object Generator]"
            })), e.keys = function(e) {
                var t = Object(e),
                    n = [];
                for (var i in t) n.push(i);
                return n.reverse(),
                    function e() {
                        for (; n.length;) {
                            var i = n.pop();
                            if (i in t) return e.value = i, e.done = !1, e
                        }
                        return e.done = !0, e
                    }
            }, e.values = N, O.prototype = {
                constructor: O,
                reset: function(e) {
                    if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = !1, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(I), !e)
                        for (var t in this) "t" === t.charAt(0) && i.call(this, t) && !isNaN(+t.slice(1)) && (this[t] = void 0)
                },
                stop: function() {
                    this.done = !0;
                    var e = this.tryEntries[0].completion;
                    if ("throw" === e.type) throw e.arg;
                    return this.rval
                },
                dispatchException: function(e) {
                    if (this.done) throw e;
                    var t = this;

                    function n(n, i) {
                        return s.type = "throw", s.arg = e, t.next = n, i && (t.method = "next", t.arg = void 0), !!i
                    }
                    for (var r = this.tryEntries.length - 1; r >= 0; --r) {
                        var a = this.tryEntries[r],
                            s = a.completion;
                        if ("root" === a.tryLoc) return n("end");
                        if (a.tryLoc <= this.prev) {
                            var o = i.call(a, "catchLoc"),
                                c = i.call(a, "finallyLoc");
                            if (o && c) {
                                if (this.prev < a.catchLoc) return n(a.catchLoc, !0);
                                if (this.prev < a.finallyLoc) return n(a.finallyLoc)
                            } else if (o) {
                                if (this.prev < a.catchLoc) return n(a.catchLoc, !0)
                            } else {
                                if (!c) throw new Error("try statement without catch or finally");
                                if (this.prev < a.finallyLoc) return n(a.finallyLoc)
                            }
                        }
                    }
                },
                abrupt: function(e, t) {
                    for (var n = this.tryEntries.length - 1; n >= 0; --n) {
                        var r = this.tryEntries[n];
                        if (r.tryLoc <= this.prev && i.call(r, "finallyLoc") && this.prev < r.finallyLoc) {
                            var a = r;
                            break
                        }
                    }
                    a && ("break" === e || "continue" === e) && a.tryLoc <= t && t <= a.finallyLoc && (a = null);
                    var s = a ? a.completion : {};
                    return s.type = e, s.arg = t, a ? (this.method = "next", this.next = a.finallyLoc, f) : this.complete(s)
                },
                complete: function(e, t) {
                    if ("throw" === e.type) throw e.arg;
                    return "break" === e.type || "continue" === e.type ? this.next = e.arg : "return" === e.type ? (this.rval = this.arg = e.arg, this.method = "return", this.next = "end") : "normal" === e.type && t && (this.next = t), f
                },
                finish: function(e) {
                    for (var t = this.tryEntries.length - 1; t >= 0; --t) {
                        var n = this.tryEntries[t];
                        if (n.finallyLoc === e) return this.complete(n.completion, n.afterLoc), I(n), f
                    }
                },
                catch: function(e) {
                    for (var t = this.tryEntries.length - 1; t >= 0; --t) {
                        var n = this.tryEntries[t];
                        if (n.tryLoc === e) {
                            var i = n.completion;
                            if ("throw" === i.type) {
                                var r = i.arg;
                                I(n)
                            }
                            return r
                        }
                    }
                    throw new Error("illegal catch attempt")
                },
                delegateYield: function(e, t, n) {
                    return this.delegate = {
                        iterator: N(e),
                        resultName: t,
                        nextLoc: n
                    }, "next" === this.method && (this.arg = void 0), f
                }
            }, e
        }

        function i(e) {
            return (i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                return typeof e
            } : function(e) {
                return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
            })(e)
        }

        function r(e, t, n, i, r, a, s) {
            try {
                var o = e[a](s),
                    c = o.value
            } catch (e) {
                return void n(e)
            }
            o.done ? t(c) : Promise.resolve(c).then(i, r)
        }

        function a(e) {
            return function() {
                var t = this,
                    n = arguments;
                return new Promise((function(i, a) {
                    var s = e.apply(t, n);

                    function o(e) {
                        r(s, i, a, o, c, "next", e)
                    }

                    function c(e) {
                        r(s, i, a, o, c, "throw", e)
                    }
                    o(void 0)
                }))
            }
        }

        function s(e, t) {
            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
        }

        function o(e, t) {
            for (var n = 0; n < t.length; n++) {
                var i = t[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, h(i.key), i)
            }
        }

        function c(e, t, n) {
            return t && o(e.prototype, t), n && o(e, n), Object.defineProperty(e, "prototype", {
                writable: !1
            }), e
        }

        function u(e, t, n) {
            return (t = h(t)) in e ? Object.defineProperty(e, t, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[t] = n, e
        }

        function l(e, t) {
            return function(e) {
                if (Array.isArray(e)) return e
            }(e) || function(e, t) {
                var n = null == e ? null : "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
                if (null != n) {
                    var i, r, a, s, o = [],
                        c = !0,
                        u = !1;
                    try {
                        if (a = (n = n.call(e)).next, 0 === t) {
                            if (Object(n) !== n) return;
                            c = !1
                        } else
                            for (; !(c = (i = a.call(n)).done) && (o.push(i.value), o.length !== t); c = !0);
                    } catch (e) {
                        u = !0, r = e
                    } finally {
                        try {
                            if (!c && null != n.return && (s = n.return(), Object(s) !== s)) return
                        } finally {
                            if (u) throw r
                        }
                    }
                    return o
                }
            }(e, t) || p(e, t) || function() {
                throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }()
        }

        function p(e, t) {
            if (e) {
                if ("string" == typeof e) return f(e, t);
                var n = Object.prototype.toString.call(e).slice(8, -1);
                return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? f(e, t) : void 0
            }
        }

        function f(e, t) {
            (null == t || t > e.length) && (t = e.length);
            for (var n = 0, i = new Array(t); n < t; n++) i[n] = e[n];
            return i
        }

        function h(e) {
            var t = function(e, t) {
                if ("object" != typeof e || null === e) return e;
                var n = e[Symbol.toPrimitive];
                if (void 0 !== n) {
                    var i = n.call(e, t || "default");
                    if ("object" != typeof i) return i;
                    throw new TypeError("@@toPrimitive must return a primitive value.")
                }
                return ("string" === t ? String : Number)(e)
            }(e, "string");
            return "symbol" == typeof t ? t : String(t)
        }
        var d = "4.8.21",
            v = "MG",
            g = "laya",
            m = "https://backend.gravity-engine.com/event_center/api/v1",
            y = function() {
                function e() {
                    s(this, e), this.config = {
                        persistenceName: "GravityEngine",
                        persistenceNameOld: "GravityEngine_web"
                    }
                }
                return c(e, [{
                    key: "getConfig",
                    value: function() {
                        return this.config
                    }
                }, {
                    key: "getStorage",
                    value: function(e, t, n) {
                        var i = localStorage.getItem(e);
                        if (!t) return x.isJSONString(i) ? JSON.parse(i) : {};
                        x.isJSONString(i) ? n(JSON.parse(i)) : n({})
                    }
                }, {
                    key: "setStorage",
                    value: function(e, t) {
                        localStorage.setItem(e, t)
                    }
                }, {
                    key: "_setSystemProxy",
                    value: function(e) {
                        this._sysCallback = e
                    }
                }, {
                    key: "getSystemInfo",
                    value: function(e) {
                        var t = this._getOs(),
                            n = {
                                mp_platform: "web",
                                system: t,
                                platform: t,
                                screenWidth: window.screen.width,
                                screenHeight: window.screen.height,
                                systemLanguage: navigator.language
                            };
                        this._sysCallback && (n = x.extend(n, this._sysCallback(e))), e.success(n), e.complete()
                    }
                }, {
                    key: "_getOs",
                    value: function() {
                        var e = navigator.userAgent;
                        return /Windows/i.test(e) ? /Phone/.test(e) || /WPDesktop/.test(e) ? "Windows Phone" : "Windows" : /(iPhone|iPad|iPod)/.test(e) ? "iOS" : /Android/.test(e) ? "Android" : /(BlackBerry|PlayBook|BB10)/i.test(e) ? "BlackBerry" : /Mac/i.test(e) ? "MacOS" : /Linux/.test(e) ? "Linux" : /CrOS/.test(e) ? "ChromeOS" : ""
                    }
                }, {
                    key: "getNetworkType",
                    value: function(e) {
                        e.complete()
                    }
                }, {
                    key: "onNetworkStatusChange",
                    value: function() {}
                }, {
                    key: "request",
                    value: function(e) {
                        var t = {},
                            n = new XMLHttpRequest;
                        if (n.open(e.method, e.url), e.header)
                            for (var i in e.header) n.setRequestHeader(i, e.header[i]);
                        return n.onreadystatechange = function() {
                            4 === n.readyState && 200 === n.status ? (t.statusCode = 200, x.isJSONString(n.responseText) && (t.data = JSON.parse(n.responseText)), e.success(t)) : 200 !== n.status && (t.errMsg = "network error", e.fail(t))
                        }, n.ontimeout = function() {
                            t.errMsg = "timeout", e.fail(t)
                        }, n.send(e.data), n
                    }
                }, {
                    key: "initAutoTrackInstance",
                    value: function(e, t) {
                        this.instance = e, this.autoTrack = t.autoTrack;
                        var n = this;
                        "onpagehide" in window ? window.onpagehide = function() {
                            n.onPageHide(!0)
                        } : window.onbeforeunload = function() {
                            n.onPageHide(!0)
                        }, n.onPageShow(), n.autoTrack.appHide && n.instance.timeEvent("ta_page_hide"), "onvisibilitychange" in document && (document.onvisibilitychange = function() {
                            document.hidden ? n.onPageHide(!1) : (n.onPageShow(), n.autoTrack.appHide && n.instance.timeEvent("ta_page_hide"))
                        })
                    }
                }, {
                    key: "setGlobal",
                    value: function(e, t) {
                        window[t] = e
                    }
                }, {
                    key: "getAppOptions",
                    value: function() {}
                }, {
                    key: "showToast",
                    value: function() {}
                }, {
                    key: "onPageShow",
                    value: function() {
                        if (this.autoTrack.appShow) {
                            var e = {};
                            x.extend(e, this.autoTrack.properties), x.isFunction(this.autoTrack.callback) && x.extend(e, this.autoTrack.callback("appShow")), this.instance._internalTrack("$WebPageView", e)
                        }
                    }
                }, {
                    key: "onPageHide",
                    value: function(e) {
                        if (this.autoTrack.appHide) {
                            var t = {};
                            x.extend(t, this.autoTrack.properties), x.isFunction(this.autoTrack.callback) && x.extend(t, this.autoTrack.callback("appHide")), this.instance._internalTrack("$WebPageHide", t, new Date, null, e)
                        }
                    }
                }], [{
                    key: "createInstance",
                    value: function() {
                        return new e
                    }
                }]), e
            }(),
            _ = function() {
                function e(t, n) {
                    if (s(this, e), this.taInstance = t, this.config = n || {}, this.referrer = "Directly open", this.config.isPlugin) t.App = function() {
                        App.apply(this, arguments)
                    }, inension(t.Page);
                    else {
                        var i = App;
                        App = this._initAppExtention(i);
                        var r = Page;
                        Page = this._initPageExtension(r)
                    }
                }
                return c(e, [{
                    key: "_initPageExtension",
                    value: function(e) {
                        var t = this;
                        return function(n) {
                            var i = n.onLoad,
                                r = n.onShow,
                                a = n.onShareAppMessage,
                                s = {};
                            return n.onLoad = function(e) {
                                s = e || {}, "function" == typeof i && i.call(this, e)
                            }, n.onShow = function(e) {
                                t.onPageShow(s), "function" == typeof r && r.call(this, e)
                            }, "function" == typeof a && (n.onShareAppMessage = function(e) {
                                var n = a.call(this, e);
                                return t.onPageShare(n)
                            }), e(n)
                        }
                    }
                }, {
                    key: "_initAppExtention",
                    value: function(e) {
                        var t = this;
                        return function(n) {
                            var i = n.onLaunch,
                                r = n.onShow,
                                a = n.onHide;
                            return n.onLaunch = function(e) {
                                t.onAppLaunch(e, this), "function" == typeof i && i.call(this, e)
                            }, n.onShow = function(e) {
                                t.onAppShow(e), "function" == typeof r && r.call(this, e)
                            }, n.onHide = function() {
                                t.onAppHide(), "function" == typeof a && a.call(this)
                            }, e(n)
                        }
                    }
                }, {
                    key: "onAppLaunch",
                    value: function(e, t) {
                        if (this._setAutoTrackProperties(e), x.isUndefined(t) || (t[this.taInstance.name] = this.taInstance), this.config.appLaunch) {
                            var n = {};
                            e && e.path && (n.$url_query = x.setQuery(e.query), n.$scene = String(e.scene || e.from)), this.taInstance._internalTrack("$MPLaunch", n)
                        }
                    }
                }, {
                    key: "onAppShow",
                    value: function(e) {
                        if (this.config.appHide && this.taInstance.timeEvent("$MPHide"), this._setAutoTrackProperties(e), this.config.appShow) {
                            var t = {};
                            e && e.path && (t.$url_path = this._getPath(e.path), t.$url_query = x.setQuery(e.query), t.$scene = String(e.scene || e.from)), x.extend(t, this.config.properties), x.isFunction(this.config.callback) && x.extend(t, this.config.callback("appShow")), this.taInstance._internalTrack("$MPShow", t)
                        }
                    }
                }, {
                    key: "onAppHide",
                    value: function() {
                        if (this.config.appHide) {
                            var e = {};
                            x.extend(e, this.config.properties), x.isFunction(this.config.callback) && x.extend(e, this.config.callback("appHide")), this.taInstance._internalTrack("$MPHide", e)
                        }
                    }
                }, {
                    key: "_getCurrentPath",
                    value: function() {
                        var e = "Not to get";
                        try {
                            var t = getCurrentPages();
                            e = t[t.length - 1].route
                        } catch (e) {
                            j.info(e)
                        }
                        return e
                    }
                }, {
                    key: "_setAutoTrackProperties",
                    value: function(e) {
                        this.taInstance._setAutoTrackProperties({})
                    }
                }, {
                    key: "_getPath",
                    value: function(e) {
                        return "string" == typeof e ? e.replace(/^\//, "") : "Abnormal values"
                    }
                }, {
                    key: "onPageShare",
                    value: function(e) {
                        if (this.config.pageShare) {
                            var t = 1;
                            try {
                                t = getCurrentPages().length
                            } catch (e) {
                                t = 1
                            }
                            this.taInstance._internalTrack("$MPShare", {
                                $share_method: "转发消息卡片",
                                $share_depth: t,
                                $url_path: this._getCurrentPath()
                            })
                        }
                        return x.isObject(e) ? e : {}
                    }
                }, {
                    key: "onPageShow",
                    value: function(e) {
                        if (this.config.pageShow) {
                            var t = this._getCurrentPath();
                            x.setQuery(e), this.referrer = t
                        }
                    }
                }]), e
            }(),
            k = function() {
                function e(t, n, i) {
                    var r = this;
                    s(this, e), this.taInstance = t, this.config = n || {};
                    var a = {};
                    try {
                        a = i.getLaunchOptionsSync()
                    } catch (e) {
                        a = {}
                    }
                    this._onShow(a), this.startTracked = !0, i.onShow((function(e) {
                        r._onShow(e)
                    })), i.onHide((function() {
                        if (r.startTracked = !1, r.config.appHide) {
                            var e = {};
                            x.extend(e, r.config.properties), x.isFunction(r.config.callback) && x.extend(e, r.config.callback("appHide")), r.taInstance._internalTrack("$MPHide", e)
                        }
                    }))
                }
                return c(e, [{
                    key: "_onShow",
                    value: function(e) {
                        if (x.isObject(e) || (e = {}), !this.startTracked && (this.config.appHide && this.taInstance.timeEvent("$MPHide"), this.config.appShow)) {
                            var n, i, r, a = {};
                            x.extend(a, this.config.properties), x.isFunction(this.config.callback) && x.extend(a, this.config.callback("appShow")), this.taInstance._internalTrack("$MPShow", t(t({}, a), {}, {
                                $scene: String((null === (n = e) || void 0 === n ? void 0 : n.scene) || (null === (i = e) || void 0 === i ? void 0 : i.from)),
                                $url_query: x.setQuery((null === (r = N.getAppOptions()) || void 0 === r ? void 0 : r.query) || {})
                            }))
                        }
                    }
                }]), e
            }(),
            b = function() {
                function e(t, n, i) {
                    s(this, e), this.api = t, this.config = n, this._config = i
                }
                return c(e, [{
                    key: "getConfig",
                    value: function() {
                        return this.config
                    }
                }, {
                    key: "getStorage",
                    value: function(e, t, n) {
                        if (!t) {
                            if ("dd_mp" === this._config.platform) {
                                var i = this.api.getStorageSync({
                                    key: e
                                });
                                return x.isJSONString(i.data) ? JSON.parse(i.data) : {}
                            }
                            var r = this.api.getStorageSync(e);
                            return x.isJSONString(r) ? JSON.parse(r) : {}
                        }
                        this.api.getStorage({
                            key: e,
                            success: function(e) {
                                var t = x.isJSONString(e.data) ? JSON.parse(e.data) : {};
                                n(t)
                            },
                            fail: function() {
                                j.warn("getStorage faild"), n({})
                            }
                        })
                    }
                }, {
                    key: "setStorage",
                    value: function(e, t) {
                        this.api.setStorage({
                            key: e,
                            data: t
                        })
                    }
                }, {
                    key: "_getPlatform",
                    value: function() {
                        return ""
                    }
                }, {
                    key: "getSystemInfo",
                    value: function(e) {
                        var t = this._config.mpPlatform;
                        this.api.getSystemInfo({
                            success: function(n) {
                                x.isFunction(t) ? n.mp_platform = t(n) : n.mp_platform = t, e.success(n), "wechat" === t && e.complete()
                            },
                            complete: function() {
                                e.complete()
                            }
                        })
                    }
                }, {
                    key: "getNetworkType",
                    value: function(e) {
                        x.isFunction(this.api.getNetworkType) ? this.api.getNetworkType({
                            success: function(t) {
                                e.success(t)
                            },
                            complete: function() {
                                e.complete()
                            }
                        }) : (e.success({}), e.complete())
                    }
                }, {
                    key: "onNetworkStatusChange",
                    value: function(e) {
                        x.isFunction(this.api.onNetworkStatusChange) ? this.api.onNetworkStatusChange(e) : e({})
                    }
                }, {
                    key: "request",
                    value: function(e) {
                        if ("ali_mp" === this._config.platform || "dd_mp" === this._config.platform) {
                            var t = x.extend({}, e);
                            return t.headers = e.header, t.success = function(t) {
                                t.statusCode = t.status, e.success(t)
                            }, t.fail = function(t) {
                                t.errMsg = t.errorMessage, e.fail(t)
                            }, "dd_mp" === this._config.platform ? this.api.httpRequest(t) : this.api.request(t)
                        }
                        try {
                            return "taobao_mg" === this._config.platform ? function(e) {
                                var t = {},
                                    n = new XMLHttpRequest;
                                if (n.open(e.method, e.url), e.header)
                                    for (var i in e.header) n.setRequestHeader(i, e.header[i]);
                                return n.onreadystatechange = function() {
                                    4 === n.readyState && 200 === n.status ? (t.statusCode = 200, x.isJSONString(n.responseText) && (t.data = JSON.parse(n.responseText)), e.success(t)) : 200 !== n.status && (t.errMsg = "network error", e.fail(t))
                                }, n.ontimeout = function() {
                                    t.errMsg = "timeout", e.fail(t)
                                }, n.send(JSON.parse(e.data)), n
                            }(e) : this.api.request(e)
                        } catch (e) {}
                    }
                }, {
                    key: "initAutoTrackInstance",
                    value: function(e, t) {
                        return x.isObject(t.autoTrack) && (t.autoTrack.isPlugin = t.is_plugin), this._config.mp ? new _(e, t.autoTrack, this.api) : new k(e, t.autoTrack, this.api)
                    }
                }, {
                    key: "setGlobal",
                    value: function(e, t) {
                        if (this._config.mp) j.warn("GravityAnalytics: we do not set global name for GE instance when you do not enable auto track.");
                        else if ("ali_mg" !== this._config.platform) try {
                            GameGlobal[t] = e
                        } catch (e) {}
                    }
                }, {
                    key: "getAppOptions",
                    value: function(e) {
                        var t = {};
                        try {
                            t = this.api.getLaunchOptionsSync()
                        } catch (e) {
                            t = {}
                        }
                        if (x.isFunction(e)) try {
                            this._config.mp ? this.api.onAppShow(e) : this.api.onShow(e)
                        } catch (e) {
                            j.warn("Cannot register onShow callback.")
                        }
                        return t
                    }
                }, {
                    key: "showToast",
                    value: function(e) {
                        if (x.isFunction(this.api.showToast)) {
                            var t = {
                                title: e
                            };
                            "dd_mp" !== this._config.platform && "ali_mp" !== this._config.platform || (t.content = e), this.api.showToast(t)
                        }
                    }
                }], [{
                    key: "createInstance",
                    value: function() {
                        return this._createInstance("R_CURRENT_PLATFORM")
                    }
                }, {
                    key: "_createInstance",
                    value: function(t) {
                        switch (t) {
                            case "wechat_mp":
                                return new e(wx, {
                                    persistenceName: "GravityEngine",
                                    persistenceNameOld: "GravityEngine_wechat"
                                }, {
                                    mpPlatform: "wechat",
                                    mp: !0,
                                    platform: t
                                });
                            case "wechat_mg":
                                return new e(wx, {
                                    persistenceName: "GravityEngine",
                                    persistenceNameOld: "GravityEngine_wechat_game"
                                }, {
                                    mpPlatform: "wechat",
                                    platform: t
                                });
                            case "qq_mp":
                                return new e(qq, {
                                    persistenceName: "GravityEngine",
                                    persistenceNameOld: "GravityEngine_qq"
                                }, {
                                    mpPlatform: "qq",
                                    mp: !0,
                                    platform: t
                                });
                            case "qq_mg":
                                return new e(qq, {
                                    persistenceName: "GravityEngine",
                                    persistenceNameOld: "GravityEngine_qq_game"
                                }, {
                                    mpPlatform: "qq",
                                    platform: t
                                });
                            case "baidu_mp":
                                return new e(swan, {
                                    persistenceName: "GravityEngine",
                                    persistenceNameOld: "GravityEngine_swan"
                                }, {
                                    mpPlatform: function(e) {
                                        return e.host
                                    },
                                    mp: !0,
                                    platform: t
                                });
                            case "baidu_mg":
                                return new e(swan, {
                                    persistenceName: "GravityEngine",
                                    persistenceNameOld: "GravityEngine_swan_game"
                                }, {
                                    mpPlatform: function(e) {
                                        return e.host
                                    },
                                    platform: t
                                });
                            case "taobao_mg":
                                return new e(my, {
                                    persistenceName: "GravityEngine",
                                    persistenceNameOld: "GravityEngine_taobao_game"
                                }, {
                                    mpPlatform: "taobao",
                                    platform: t
                                });
                            case "tt_mg":
                                return new e(tt, {
                                    persistenceName: "GravityEngine",
                                    persistenceNameOld: "GravityEngine_tt_game"
                                }, {
                                    mpPlatform: function(e) {
                                        return e.appName
                                    },
                                    platform: t
                                });
                            case "tt_mp":
                                return new e(tt, {
                                    persistenceName: "GravityEngine",
                                    persistenceNameOld: "GravityEngine_tt"
                                }, {
                                    mpPlatform: function(e) {
                                        return e.appName
                                    },
                                    mp: !0,
                                    platform: t
                                });
                            case "ali_mp":
                                return new e(my, {
                                    persistenceName: "GravityEngine",
                                    persistenceNameOld: "GravityEngine_ali"
                                }, {
                                    mpPlatform: function(e) {
                                        return e.app
                                    },
                                    mp: !0,
                                    platform: t
                                });
                            case "ali_mg":
                                return new e(my, {
                                    persistenceName: "GravityEngine",
                                    persistenceNameOld: "GravityEngine_ali_game"
                                }, {
                                    mpPlatform: function(e) {
                                        return e.app
                                    },
                                    platform: t
                                });
                            case "dd_mp":
                                return new e(dd, {
                                    persistenceName: "GravityEngine",
                                    persistenceNameOld: "GravityEngine_dd"
                                }, {
                                    mpPlatform: "dingding",
                                    mp: !0,
                                    platform: t
                                });
                            case "bl_mg":
                                return new e(bl, {
                                    persistenceName: "GravityEngine",
                                    persistenceNameOld: "GravityEngine_bl_game"
                                }, {
                                    mpPlatform: "bilibili",
                                    platform: t
                                });
                            case "kuaishou_mp":
                                return new e(ks, {
                                    persistenceName: "GravityEngine",
                                    persistenceNameOld: "GravityEngine_kuaishou_program"
                                }, {
                                    mpPlatform: "kuaishou",
                                    mp: !0,
                                    platform: t
                                });
                            case "kuaishou_mg":
                                return new e(ks, {
                                    persistenceName: "GravityEngine",
                                    persistenceNameOld: "GravityEngine_kuaishou_game"
                                }, {
                                    mpPlatform: "kuaishou_game",
                                    platform: t
                                });
                            case "qh360_mg":
                                return new e(qh, {
                                    persistenceName: "GravityEngine",
                                    persistenceNameOld: "GravityEngine_qh360"
                                }, {
                                    mpPlatform: "qh360",
                                    platform: t
                                });
                            case "tb_mp":
                                return new e(my, {
                                    persistenceName: "GravityEngine",
                                    persistenceNameOld: "GravityEngine_tb"
                                }, {
                                    mpPlatform: "tb",
                                    mp: !0,
                                    platform: t
                                });
                            case "jd_mp":
                                return new e(jd, {
                                    persistenceName: "GravityEngine",
                                    persistenceNameOld: "GravityEngine_jd"
                                }, {
                                    mpPlatform: "jd",
                                    mp: !0,
                                    platform: t
                                });
                            case "qh360_mp":
                                return new e(qh, {
                                    persistenceName: "GravityEngine",
                                    persistenceNameOld: "GravityEngine_qh360"
                                }, {
                                    mpPlatform: "qh360",
                                    mp: !0,
                                    platform: t
                                });
                            case "WEB":
                                return new y.createInstance
                        }
                    }
                }]), e
            }(),
            w = c((function e(t, n) {
                var i = this;
                s(this, e), this.taInstance = t, this.config = n || {}, this.config.appShow && this.taInstance._internalTrack("$MPShow"), this.config.appHide && this.taInstance.timeEvent("$MPHide"), qg.onShow((function() {
                    if (i.config.appHide && i.taInstance.timeEvent("$MPHide"), i.config.appShow) {
                        var e = {};
                        x.extend(e, i.config.properties), x.isFunction(i.config.callback) && x.extend(e, i.config.callback("appShow")), i.taInstance._internalTrack("$MPShow")
                    }
                })), qg.onHide((function() {
                    if (i.config.appHide) {
                        var e = {};
                        x.extend(e, i.config.properties), x.isFunction(i.config.callback) && x.extend(e, i.config.callback("appHide")), i.taInstance._internalTrack("$MPHide")
                    }
                }))
            })),
            S = function() {
                function e() {
                    s(this, e), this.config = {
                        persistenceName: "gravityengine",
                        persistenceNameOld: "gravityengine_qg_vivo_game",
                        asyncPersistence: !0
                    }
                }
                return c(e, [{
                    key: "getConfig",
                    value: function() {
                        return this.config || {}
                    }
                }, {
                    key: "getStorage",
                    value: function(e, t, n) {
                        if (!t) {
                            var i = qg.getStorageSync({
                                key: e
                            });
                            return x.isJSONString(i) ? JSON.parse(i) : {}
                        }
                        qg.getStorage({
                            key: e,
                            success: function(e) {
                                var t = x.isJSONString(e) ? JSON.parse(e) : {};
                                n(t)
                            },
                            fail: function() {
                                n({})
                            }
                        })
                    }
                }, {
                    key: "setStorage",
                    value: function(e, t) {
                        qg.setStorage({
                            key: e,
                            value: t
                        })
                    }
                }, {
                    key: "getSystemInfo",
                    value: function(e) {
                        qg.getSystemInfo({
                            success: function(t) {
                                var n = t,
                                    i = [t.osType, t.osVersionName].join(" ");
                                n.brand = t.manufacturer, n.system = i, n.mp_platform = "vivo_qg", e.success(n)
                            },
                            complete: function() {
                                e.complete()
                            }
                        })
                    }
                }, {
                    key: "getQuickDevice",
                    value: function(e) {
                        var t = {
                            os_name: "android",
                            android_id: "",
                            imei: "",
                            oaid: "",
                            mac: "",
                            android_version: "",
                            api_version: 0,
                            rom: {
                                gravityengine_qg_huawei_game: "EMUI",
                                gravityengine_qg: "MIUI",
                                gravityengine_qg_oppo_game: "ColorOS",
                                gravityengine_qg_vivo_game: "FuntouchOS",
                                gravityengine_qg_mz_game: "Flyme"
                            }[e.platform],
                            rom_version: "",
                            phone_brand: "",
                            phone_model: ""
                        };
                        qg.getSystemInfo({
                            success: function(n) {
                                if (t.android_version = n.system, t.api_version = n.platformVersionCode, t.rom_version = n.COREVersion, t.phone_brand = n.brand, t.phone_model = n.model, qg.getOAID) {
                                    var i, r, a, s = null !== (i = null === (r = (a = qg).getOAID) || void 0 === r ? void 0 : r.call(a).oaid) && void 0 !== i ? i : "";
                                    t.android_id = s, t.imei = s, t.oaid = s
                                }
                                e.success(t)
                            }
                        })
                    }
                }, {
                    key: "getNetworkType",
                    value: function(e) {
                        qg.getNetworkType({
                            success: function(t) {
                                var n = t;
                                n.networkType = t.type, e.success(n)
                            },
                            complete: function() {
                                e.complete()
                            }
                        })
                    }
                }, {
                    key: "onNetworkStatusChange",
                    value: function(e) {
                        qg.subscribeNetworkStatus({
                            callback: function(t) {
                                var n = t;
                                n.networkType = t.type, e(n)
                            }
                        })
                    }
                }, {
                    key: "request",
                    value: function(e) {
                        return qg.request({
                            url: e.url,
                            data: e.data,
                            method: e.method,
                            header: e.header,
                            success: function(t) {
                                e.success(t)
                            },
                            fail: function(t) {
                                e.fail(t)
                            }
                        })
                    }
                }, {
                    key: "initAutoTrackInstance",
                    value: function(e, t) {
                        return new w(e, t.autoTrack)
                    }
                }, {
                    key: "setGlobal",
                    value: function(e, t) {
                        globalThis[t] = e
                    }
                }, {
                    key: "getAppOptions",
                    value: function() {
                        try {
                            if (!qg.getLaunchOptionsSync) return {};
                            var e = qg.getLaunchOptionsSync(),
                                t = e.referrerInfo.extraData,
                                n = e.query.internal,
                                i = n && n.channel ? n.channel : "";
                            if (t) return {
                                query: t,
                                scene: ""
                            };
                            if ("deeplink" === i) {
                                var r, a = n.custom_params,
                                    s = JSON.parse(a).cus_origin_uri,
                                    o = new URLSearchParams(s.split("?")[1]),
                                    c = {},
                                    u = function(e, t) {
                                        var n = "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
                                        if (!n) {
                                            if (Array.isArray(e) || (n = p(e)) || t && e && "number" == typeof e.length) {
                                                n && (e = n);
                                                var i = 0,
                                                    r = function() {};
                                                return {
                                                    s: r,
                                                    n: function() {
                                                        return i >= e.length ? {
                                                            done: !0
                                                        } : {
                                                            done: !1,
                                                            value: e[i++]
                                                        }
                                                    },
                                                    e: function(e) {
                                                        throw e
                                                    },
                                                    f: r
                                                }
                                            }
                                            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                                        }
                                        var a, s = !0,
                                            o = !1;
                                        return {
                                            s: function() {
                                                n = n.call(e)
                                            },
                                            n: function() {
                                                var e = n.next();
                                                return s = e.done, e
                                            },
                                            e: function(e) {
                                                o = !0, a = e
                                            },
                                            f: function() {
                                                try {
                                                    s || null == n.return || n.return()
                                                } finally {
                                                    if (o) throw a
                                                }
                                            }
                                        }
                                    }(o);
                                try {
                                    for (u.s(); !(r = u.n()).done;) {
                                        var f = l(r.value, 2),
                                            h = f[0],
                                            d = f[1];
                                        c[h] = d
                                    }
                                } catch (e) {
                                    u.e(e)
                                } finally {
                                    u.f()
                                }
                                return {
                                    query: c,
                                    scene: ""
                                }
                            }
                            return {}
                        } catch (e) {
                            return {}
                        }
                    }
                }, {
                    key: "showToast",
                    value: function(e) {
                        qg.showToast({
                            message: e,
                            duration: 0
                        })
                    }
                }], [{
                    key: "createInstance",
                    value: function() {
                        return new e
                    }
                }]), e
            }(),
            P = c((function e(t, n, i) {
                var r = this;
                if (s(this, e), this.taInstance = t, this.config = n || {}, this.config.appShow) {
                    var a = {};
                    x.extend(a, this.config.properties), x.isFunction(this.config.callback) && x.extend(a, this.config.callback("appShow")), this.taInstance._internalTrack("$MPShow", a)
                }
                this.config.appHide && this.taInstance.timeEvent("$MPHide"), i.onShow((function() {
                    if (r.config.appHide && r.taInstance.timeEvent("$MPHide"), r.config.appShow) {
                        var e = {};
                        x.extend(e, r.config.properties), x.isFunction(r.config.callback) && x.extend(e, r.config.callback("appShow")), r.taInstance._internalTrack("$MPShow", e)
                    }
                })), i.onHide((function() {
                    if (r.config.appHide) {
                        var e = {};
                        x.extend(e, r.config.properties), x.isFunction(r.config.callback) && x.extend(e, r.config.callback("appHide")), r.taInstance._internalTrack("$MPHide", e)
                    }
                }))
            })),
            I = function() {
                function e(t, n, i) {
                    s(this, e), this.api = t, this.config = n, this._config = i
                }
                return c(e, [{
                    key: "getConfig",
                    value: function() {
                        return this.config || {}
                    }
                }, {
                    key: "getStorage",
                    value: function(e, t, n) {
                        var i = localStorage.getItem(e);
                        if (!t) return x.isJSONString(i) ? JSON.parse(i) : {};
                        x.isJSONString(i) ? n(JSON.parse(i)) : n({})
                    }
                }, {
                    key: "setStorage",
                    value: function(e, t) {
                        localStorage.setItem(e, t)
                    }
                }, {
                    key: "getSystemInfo",
                    value: function(e) {
                        var t = this._config.mpPlatform;
                        this.api.getSystemInfo({
                            success: function(n) {
                                n.mp_platform = t, e.success(n)
                            },
                            complete: function() {
                                e.complete()
                            }
                        })
                    }
                }, {
                    key: "getQuickDevice",
                    value: function(e) {
                        var t = {
                                os_name: "android",
                                android_id: "",
                                imei: "",
                                oaid: "",
                                mac: "",
                                android_version: "",
                                api_version: 0,
                                rom: {
                                    gravityengine_qg_huawei_game: "EMUI",
                                    gravityengine_qg: "MIUI",
                                    gravityengine_qg_oppo_game: "ColorOS",
                                    gravityengine_qg_vivo_game: "FuntouchOS",
                                    gravityengine_qg_mz_game: "Flyme"
                                }[e.platform],
                                rom_version: "",
                                phone_brand: "",
                                phone_model: ""
                            },
                            n = this;
                        this.api.getSystemInfo({
                            success: function(i) {
                                function r() {
                                    e.success(t)
                                }
                                t.android_version = i.system, t.api_version = i.platformVersionCode, t.rom_version = i.COREVersion, t.phone_brand = i.brand, t.phone_model = i.model, n.api.getDeviceId ? n.api.getDeviceId({
                                    success: function(e) {
                                        t.android_id = e.deviceId, t.imei = e.deviceId, t.oaid = e.deviceId, r()
                                    }
                                }) : n.api.getOAID ? n.api.getOAID({
                                    success: function(e) {
                                        t.android_id = e.oaid, t.imei = e.oaid, t.oaid = e.oaid, r()
                                    }
                                }) : r()
                            }
                        })
                    }
                }, {
                    key: "getNetworkType",
                    value: function(e) {
                        this.api.getNetworkType({
                            success: function(t) {
                                e.success(t)
                            },
                            complete: function() {
                                e.complete()
                            }
                        })
                    }
                }, {
                    key: "onNetworkStatusChange",
                    value: function(e) {
                        this.api.onNetworkStatusChange({
                            callback: function(t) {
                                e(t)
                            }
                        })
                    }
                }, {
                    key: "request",
                    value: function(e) {
                        var t = {},
                            n = new XMLHttpRequest;
                        if (n.open(e.method, e.url), e.header)
                            for (var i in e.header) n.setRequestHeader(i, e.header[i]);
                        return n.onreadystatechange = function() {
                            4 === n.readyState && 200 === n.status ? (t.statusCode = 200, x.isJSONString(n.responseText) && (t.data = JSON.parse(n.responseText)), e.success(t)) : 200 !== n.status && (t.errMsg = "network error", e.fail(t))
                        }, n.ontimeout = function() {
                            t.errMsg = "timeout", e.fail(t)
                        }, n.send(e.data), n
                    }
                }, {
                    key: "initAutoTrackInstance",
                    value: function(e, t) {
                        return new P(e, t.autoTrack, this.api)
                    }
                }, {
                    key: "setGlobal",
                    value: function(e, t) {
                        globalThis[t] = e
                    }
                }, {
                    key: "getAppOptions",
                    value: function() {
                        return "oppo_qg" === this._config.mpPlatform ? this.api.getEnterOptionsSync() : this.api.getLaunchOptionsSync()
                    }
                }, {
                    key: "showToast",
                    value: function(e) {
                        this.api.showToast({
                            title: e,
                            icon: "none",
                            duration: 2e3
                        })
                    }
                }], [{
                    key: "createInstance",
                    value: function() {
                        return this._createInstance("R_CURRENT_PLATFORM")
                    }
                }, {
                    key: "_createInstance",
                    value: function(t) {
                        switch (t) {
                            case "oppo":
                                return new e(qg, {
                                    persistenceName: "gravityengine",
                                    persistenceNameOld: "gravityengine_qg_oppo_game"
                                }, {
                                    mpPlatform: "oppo_qg"
                                });
                            case "huawei":
                                return new e(hbs, {
                                    persistenceName: "gravityengine",
                                    persistenceNameOld: "gravityengine_qg_huawei_game"
                                }, {
                                    mpPlatform: "huawei_qg"
                                });
                            case "mz":
                                return new e(qg, {
                                    persistenceName: "gravityengine",
                                    persistenceNameOld: "gravityengine_qg_mz_game"
                                }, {
                                    mpPlatform: "mz"
                                });
                            case "xiaomi":
                                return new e(qg, {
                                    persistenceName: "gravityengine",
                                    persistenceNameOld: "gravityengine_qg"
                                }, {
                                    mpPlatform: "xiaomi"
                                })
                        }
                    }
                }]), e
            }(),
            O = function() {
                function e() {
                    s(this, e)
                }
                return c(e, null, [{
                    key: "createInstance",
                    value: function() {
                        return Laya.Browser.onMiniGame ? b._createInstance("wechat_mg") : Laya.Browser.onBDMiniGame ? b._createInstance("baidu_mg") : Laya.Browser.onVVMiniGame ? S.createInstance() : Laya.Browser.onQQMiniGame ? b._createInstance("qq_mg") : Laya.Browser.onQGMiniGame ? I._createInstance("oppo") : Laya.Browser.onHWMiniGame ? I._createInstance("huawei") : Laya.Browser.onKGMiniGame ? I._createInstance("xiaomi") : Laya.Browser.onTTMiniGame ? b._createInstance("tt_mg") : Laya.Browser.onBLMiniGame ? b._createInstance("bl_mg") : Laya.Browser.onAlipayMiniGame ? b._createInstance("ali_mg") : Laya.Browser.onTBMiniGame ? b._createInstance("tb_mp") : y.createInstance()
                    }
                }]), e
            }(),
            N = function() {
                function e() {
                    s(this, e)
                }
                return c(e, null, [{
                    key: "_getCurrentPlatform",
                    value: function() {
                        return this.currentPlatform || (this.currentPlatform = O.createInstance())
                    }
                }, {
                    key: "getConfig",
                    value: function() {
                        return this._getCurrentPlatform().getConfig()
                    }
                }, {
                    key: "getStorage",
                    value: function(e, t, n) {
                        return this._getCurrentPlatform().getStorage(e, t, n)
                    }
                }, {
                    key: "setStorage",
                    value: function(e, t) {
                        return this._getCurrentPlatform().setStorage(e, t)
                    }
                }, {
                    key: "getSystemInfo",
                    value: function(e) {
                        return this._getCurrentPlatform().getSystemInfo(e)
                    }
                }, {
                    key: "getNetworkType",
                    value: function(e) {
                        return this._getCurrentPlatform().getNetworkType(e)
                    }
                }, {
                    key: "getQuickDevice",
                    value: function(e) {
                        return this._getCurrentPlatform().getQuickDevice(e)
                    }
                }, {
                    key: "onNetworkStatusChange",
                    value: function(e) {
                        this._getCurrentPlatform().onNetworkStatusChange(e)
                    }
                }, {
                    key: "request",
                    value: function(e) {
                        return this._getCurrentPlatform().request(e)
                    }
                }, {
                    key: "initAutoTrackInstance",
                    value: function(e, t) {
                        return this._getCurrentPlatform().initAutoTrackInstance(e, t)
                    }
                }, {
                    key: "setGlobal",
                    value: function(e, t) {
                        e && t && this._getCurrentPlatform().setGlobal(e, t)
                    }
                }, {
                    key: "getAppOptions",
                    value: function(e) {
                        return this._getCurrentPlatform().getAppOptions(e)
                    }
                }, {
                    key: "showDebugToast",
                    value: function(e) {
                        this._getCurrentPlatform().showToast(e)
                    }
                }]), e
            }(),
            x = {},
            A = Array.prototype,
            T = Object.prototype,
            E = A.slice,
            D = T.toString,
            q = Object.prototype.hasOwnProperty,
            C = A.forEach,
            U = Array.isArray,
            $ = {};
        x.isNumber = function(e) {
            return "number" == typeof e ? 0 == e - e : "string" == typeof e && "" !== e.trim() && (Number.isFinite ? Number.isFinite(+e) : isFinite(+e))
        }, x.each = function(e, t, n) {
            if (null == e) return !1;
            if (C && e.forEach === C) e.forEach(t, n);
            else if (e.length === +e.length) {
                for (var i = 0, r = e.length; i < r; i++)
                    if (i in e && t.call(n, e[i], i, e) === $) return !1
            } else
                for (var a in e)
                    if (q.call(e, a) && t.call(n, e[a], a, e) === $) return !1
        }, x.sleep = function(e) {
            return new Promise((function(t) {
                return setTimeout(t, e)
            }))
        }, x.extend = function(e) {
            return x.each(E.call(arguments, 1), (function(t) {
                for (var n in t) void 0 !== t[n] && (e[n] = t[n])
            })), e
        }, x.extend2Layers = function(e) {
            return x.each(E.call(arguments, 1), (function(t) {
                for (var n in t) void 0 !== t[n] && (x.isObject(t[n]) && x.isObject(e[n]) ? x.extend(e[n], t[n]) : e[n] = t[n])
            })), e
        }, x.isArray = U || function(e) {
            return "[object Array]" === D.call(e)
        }, x.isFunction = function(e) {
            try {
                return "function" == typeof e
            } catch (e) {
                return !1
            }
        }, x.isPromise = function(e) {
            return "[object Promise]" === D.call(e) && null != e
        }, x.isObject = function(e) {
            return "[object Object]" === D.call(e) && null != e
        }, x.isEmptyObject = function(e) {
            if (x.isObject(e)) {
                for (var t in e)
                    if (q.call(e, t)) return !1;
                return !0
            }
            return !1
        }, x.isUndefined = function(e) {
            return void 0 === e
        }, x.isString = function(e) {
            return "[object String]" === D.call(e)
        }, x.isDate = function(e) {
            return "[object Date]" === D.call(e)
        }, x.isBoolean = function(e) {
            return "[object Boolean]" === D.call(e)
        }, x.isNumber = function(e) {
            return "[object Number]" === D.call(e) && /[\d\.]+/.test(String(e))
        }, x.isJSONString = function(e) {
            try {
                JSON.parse(e)
            } catch (e) {
                return !1
            }
            return !0
        }, x.decodeURIComponent = function(e) {
            var t = "";
            try {
                t = decodeURIComponent(e)
            } catch (n) {
                t = e
            }
            return t
        }, x.encodeURIComponent = function(e) {
            var t = "";
            try {
                t = encodeURIComponent(e)
            } catch (n) {
                t = e
            }
            return t
        }, x.utf8Encode = function(e) {
            var t, n, i, r, a = "";
            for (t = n = 0, i = (e = (e + "").replace(/\r\n/g, "\n").replace(/\r/g, "\n")).length, r = 0; r < i; r++) {
                var s = e.charCodeAt(r),
                    o = null;
                s < 128 ? n++ : o = s > 127 && s < 2048 ? String.fromCharCode(s >> 6 | 192, 63 & s | 128) : String.fromCharCode(s >> 12 | 224, s >> 6 & 63 | 128, 63 & s | 128), null !== o && (n > t && (a += e.substring(t, n)), a += o, t = n = r + 1)
            }
            return n > t && (a += e.substring(t, e.length)), a
        }, x.base64Encode = function(e) {
            var t, n, i, r, a, s = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
                o = 0,
                c = 0,
                u = "",
                l = [];
            if (!e) return e;
            e = x.utf8Encode(e);
            do {
                t = (a = e.charCodeAt(o++) << 16 | e.charCodeAt(o++) << 8 | e.charCodeAt(o++)) >> 18 & 63, n = a >> 12 & 63, i = a >> 6 & 63, r = 63 & a, l[c++] = s.charAt(t) + s.charAt(n) + s.charAt(i) + s.charAt(r)
            } while (o < e.length);
            switch (u = l.join(""), e.length % 3) {
                case 1:
                    u = u.slice(0, -2) + "==";
                    break;
                case 2:
                    u = u.slice(0, -1) + "="
            }
            return u
        }, x.encodeDates = function(e) {
            return x.each(e, (function(t, n) {
                if (x.isDate(t)) e[n] = x.formatDate(t);
                else if (x.isObject(t)) e[n] = x.encodeDates(t);
                else if (x.isArray(t))
                    for (var i = 0; i < t.length; i++) x.isDate(t[i]) && (e[n][i] = x.formatDate(t[i]))
            })), e
        }, x.formatDate = function(e) {
            function t(e) {
                return e < 10 ? "0" + e : e
            }
            return e.getFullYear() + "-" + t(e.getMonth() + 1) + "-" + t(e.getDate()) + " " + t(e.getHours()) + ":" + t(e.getMinutes()) + ":" + t(e.getSeconds()) + "." + ((n = e.getMilliseconds()) < 100 && n > 9 ? "0" + n : n < 10 ? "00" + n : n);
            var n
        }, x.searchObjDate = function(e) {
            try {
                (x.isObject(e) || x.isArray(e)) && x.each(e, (function(t, n) {
                    x.isObject(t) || x.isArray(t) ? x.searchObjDate(e[n]) : x.isDate(t) && (e[n] = x.formatDate(t))
                }))
            } catch (e) {
                j.warn(e)
            }
        }, x.UUID = function() {
            var e = (new Date).getTime();
            return String(Math.random()).replace(".", "").slice(1, 11) + "-" + e
        }, x.UUIDv4 = function() {
            return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (function(e) {
                var t = 16 * Math.random() | 0;
                return ("x" === e ? t : 3 & t | 8).toString(16)
            }))
        }, x.setMpPlatform = function(e) {
            x.mpPlatform = e
        }, x.getMpPlatform = function() {
            return x.mpPlatform
        }, x.createExtraHeaders = function() {
            return {
                "GE-Integration-Type": v,
                "GE-Integration-Version": d,
                "GE-Integration-Count": "1",
                "GE-Integration-Extra": x.getMpPlatform()
            }
        }, x.checkAppId = function(e) {
            if ("number" == typeof e) e = String(e);
            else if ("string" != typeof e) return "";
            return e = e.replace(/\s*/g, "")
        }, x.checkUrl = function(e) {
            return e = e.replace(/\s*/g, ""), e = x.url("basic", e)
        }, x.url = function() {
            function e() {
                return new RegExp(/(.*?)\.?([^.]*?)\.(com|net|org|biz|ws|in|me|co\.uk|co|org\.uk|ltd\.uk|plc\.uk|me\.uk|edu|mil|br\.com|cn\.com|eu\.com|hu\.com|no\.com|qc\.com|sa\.com|se\.com|se\.net|us\.com|uy\.com|ac|co\.ac|gv\.ac|or\.ac|ac\.ac|af|am|as|at|ac\.at|co\.at|gv\.at|or\.at|asn\.au|com\.au|edu\.au|org\.au|net\.au|id\.au|be|ac\.be|adm\.br|adv\.br|am\.br|arq\.br|art\.br|bio\.br|cng\.br|cnt\.br|com\.br|ecn\.br|eng\.br|esp\.br|etc\.br|eti\.br|fm\.br|fot\.br|fst\.br|g12\.br|gov\.br|ind\.br|inf\.br|jor\.br|lel\.br|med\.br|mil\.br|net\.br|nom\.br|ntr\.br|odo\.br|org\.br|ppg\.br|pro\.br|psc\.br|psi\.br|rec\.br|slg\.br|tmp\.br|tur\.br|tv\.br|vet\.br|zlg\.br|br|ab\.ca|bc\.ca|mb\.ca|nb\.ca|nf\.ca|ns\.ca|nt\.ca|on\.ca|pe\.ca|qc\.ca|sk\.ca|yk\.ca|ca|cc|ac\.cn|net\.cn|com\.cn|edu\.cn|gov\.cn|org\.cn|bj\.cn|sh\.cn|tj\.cn|cq\.cn|he\.cn|nm\.cn|ln\.cn|jl\.cn|hl\.cn|js\.cn|zj\.cn|ah\.cn|gd\.cn|gx\.cn|hi\.cn|sc\.cn|gz\.cn|yn\.cn|xz\.cn|sn\.cn|gs\.cn|qh\.cn|nx\.cn|xj\.cn|tw\.cn|hk\.cn|mo\.cn|cn|cx|cz|de|dk|fo|com\.ec|tm\.fr|com\.fr|asso\.fr|presse\.fr|fr|gf|gs|co\.il|net\.il|ac\.il|k12\.il|gov\.il|muni\.il|ac\.in|co\.in|org\.in|ernet\.in|gov\.in|net\.in|res\.in|is|it|ac\.jp|co\.jp|go\.jp|or\.jp|ne\.jp|ac\.kr|co\.kr|go\.kr|ne\.kr|nm\.kr|or\.kr|li|lt|lu|asso\.mc|tm\.mc|com\.mm|org\.mm|net\.mm|edu\.mm|gov\.mm|ms|nl|no|nu|pl|ro|org\.ro|store\.ro|tm\.ro|firm\.ro|www\.ro|arts\.ro|rec\.ro|info\.ro|nom\.ro|nt\.ro|se|si|com\.sg|org\.sg|net\.sg|gov\.sg|sk|st|tf|ac\.th|co\.th|go\.th|mi\.th|net\.th|or\.th|tm|to|com\.tr|edu\.tr|gov\.tr|k12\.tr|net\.tr|org\.tr|com\.tw|org\.tw|net\.tw|ac\.uk|uk\.com|uk\.net|gb\.com|gb\.net|vg|sh|kz|ch|info|ua|gov|name|pro|ie|hk|com\.hk|org\.hk|net\.hk|edu\.hk|us|tk|cd|by|ad|lv|eu\.lv|bz|es|jp|cl|ag|mobi|eu|co\.nz|org\.nz|net\.nz|maori\.nz|iwi\.nz|io|la|md|sc|sg|vc|tw|travel|my|se|tv|pt|com\.pt|edu\.pt|asia|fi|com\.ve|net\.ve|fi|org\.ve|web\.ve|info\.ve|co\.ve|tel|im|gr|ru|net\.ru|org\.ru|hr|com\.hr|ly|xyz)$/)
            }

            function t(e, t) {
                var n = e.charAt(0),
                    i = t.split(n);
                return n === e ? i : i[(e = parseInt(e.substring(1), 10)) < 0 ? i.length + e : e - 1]
            }

            function n(e, t) {
                for (var n, i = e.charAt(0), r = t.split("&"), a = [], s = {}, o = [], c = e.substring(1), u = 0, l = r.length; u < l; u++)
                    if ((a = r[u].match(/(.*?)=(.*)/)) || (a = [r[u], r[u], ""]), "" !== a[1].replace(/\s/g, "")) {
                        if (a[2] = (n = a[2] || "", x.decodeURIComponent(n.replace(/\+/g, " "))), c === a[1]) return a[2];
                        (o = a[1].match(/(.*)\[([0-9]+)\]/)) ? (s[o[1]] = s[o[1]] || [], s[o[1]][o[2]] = a[2]) : s[a[1]] = a[2]
                    }
                return i === e ? s : s[c]
            }
            return function(i, r) {
                var a, s = {};
                if ("tld?" === i) return e();
                if (r = r || window.location.toString(), !i) return r;
                if (i = i.toString(), r.match(/^mailto:([^/].+)/)) a = r.match(/^mailto:([^/].+)/), s.protocol = "mailto", s.email = a[1];
                else {
                    if (r.match(/(.*?)\/#!(.*)/) && (a = r.match(/(.*?)\/#!(.*)/), r = a[1] + a[2]), r.match(/(.*?)#(.*)/) && (a = r.match(/(.*?)#(.*)/), s.hash = a[2], r = a[1]), s.hash && i.match(/^#/)) return n(i, s.hash);
                    if (r.match(/(.*?)\?(.*)/) && (a = r.match(/(.*?)\?(.*)/), s.query = a[2], r = a[1]), s.query && i.match(/^\?/)) return n(i, s.query);
                    if (r.match(/(.*?):?\/\/(.*)/) && (a = r.match(/(.*?):?\/\/(.*)/), s.protocol = a[1].toLowerCase(), r = a[2]), r.match(/(.*?)(\/.*)/) && (a = r.match(/(.*?)(\/.*)/), s.path = a[2], r = a[1]), s.path = (s.path || "").replace(/^([^/])/, "/$1").replace(/\/$/, ""), i.match(/^[-0-9]+$/) && (i = i.replace(/^([^/])/, "/$1")), i.match(/^\//)) return t(i, s.path.substring(1));
                    if ((a = t("/-1", s.path.substring(1))) && (a = a.match(/(.*?)\.(.*)/)) && (s.file = a[0], s.filename = a[1], s.fileext = a[2]), r.match(/(.*):([0-9]+)$/) && (a = r.match(/(.*):([0-9]+)$/), s.port = a[2], r = a[1]), r.match(/(.*?)@(.*)/) && (a = r.match(/(.*?)@(.*)/), s.auth = a[1], r = a[2]), s.auth && (a = s.auth.match(/(.*):(.*)/), s.user = a ? a[1] : s.auth, s.pass = a ? a[2] : void 0), s.hostname = r.toLowerCase(), "." === i.charAt(0)) return t(i, s.hostname);
                    e() && (a = s.hostname.match(e())) && (s.tld = a[3], s.domain = a[2] ? a[2] + "." + a[3] : void 0, s.sub = a[1] || void 0);
                    var o = s.port ? ":" + s.port : "";
                    s.protocol = s.protocol || window.location.protocol.replace(":", ""), s.port = s.port || ("https" === s.protocol ? "443" : "80"), s.protocol = s.protocol || ("443" === s.port ? "https" : "http"), s.basic = s.protocol + "://" + s.hostname + o
                }
                return i in s ? s[i] : "{}" === i ? s : ""
            }
        }(), x.createString = function(e) {
            for (var t = e, n = Math.random().toString(36).substr(2); n.length < t;) n += Math.random().toString(36).substr(2);
            return n = n.substr(0, e)
        }, x.createAesKey = function() {
            return x.createString(16)
        }, x.setQuery = function(e) {
            try {
                if (!x.isObject(e)) return "";
                var t = N.getConfig().persistenceNameOld.includes("GravityEngine_ali"),
                    n = [];
                for (var i in e)(t || e.hasOwnProperty(i)) && n.push(encodeURIComponent(i) + "=" + encodeURIComponent(e[i]));
                return n.join("&")
            } catch (e) {
                return ""
            }
        }, x.generateEncryptyData = function(e, t) {
            if (void 0 === t) return e;
            var n = t.publicKey,
                i = t.version;
            if (void 0 === n || void 0 === i) return e;
            if ("undefined" == typeof CryptoJS || "undefined" == typeof JSEncrypt) return e;
            var r = x.createAesKey();
            try {
                var a = CryptoJS.enc.Utf8.parse(r),
                    s = CryptoJS.enc.Utf8.parse(JSON.stringify(e)),
                    o = x.isUndefined(CryptoJS.pad.Pkcs7) ? CryptoJS.pad.PKCS7 : CryptoJS.pad.Pkcs7,
                    c = CryptoJS.AES.encrypt(s, a, {
                        mode: CryptoJS.mode.ECB,
                        padding: o
                    }).toString(),
                    u = new JSEncrypt;
                u.setPublicKey(n);
                var l = u.encrypt(r);
                return !1 === l ? (j.warn("私钥加密失败，返回原数据"), e) : {
                    pkv: i,
                    ekey: l,
                    payload: c
                }
            } catch (e) {
                j.warn("数据加密失败，返回原数据: " + e)
            }
            return e
        };
        var j = "object" === i(j) ? j : {};
        j.info = function() {
            if ("object" === ("undefined" == typeof console ? "undefined" : i(console)) && console.log && j.enabled) try {
                return console.log.apply(console, arguments)
            } catch (e) {
                console.log(arguments[0])
            }
        }, j.warn = function() {
            if ("object" === ("undefined" == typeof console ? "undefined" : i(console)) && console.log && j.enabled) try {
                return console.warn.apply(console, arguments)
            } catch (e) {
                console.warn(arguments[0])
            }
        };
        var F = /^\$?[a-zA-Z][a-zA-Z0-9_]{0,49}$/,
            J = function() {
                function e() {
                    s(this, e)
                }
                return c(e, null, [{
                    key: "stripProperties",
                    value: function(e) {
                        return x.isObject(e) ? (x.each(e, (function(e, t) {
                            x.isString(e) || x.isNumber(e) || x.isDate(e) || x.isBoolean(e) || x.isArray(e) || x.isObject(e) || j.warn("Your data -", t, e, "- format does not meet requirements and may not be stored correctly. Attribute values only support String, Number, Date, Boolean, Array, Object")
                        })), e) : e
                    }
                }, {
                    key: "_checkPropertiesKey",
                    value: function(e) {
                        var t = !0;
                        return x.each(e, (function(e, n) {
                            F.test(n) || (j.warn("Invalid KEY: " + n), t = !1)
                        })), t
                    }
                }, {
                    key: "event",
                    value: function(e) {
                        return !(!x.isString(e) || !F.test(e)) || (j.warn("Check the parameter format. The eventName must start with an English letter and contain no more than 50 characters including letters, digits, and underscores: " + e), !1)
                    }
                }, {
                    key: "propertyName",
                    value: function(e) {
                        return !(!x.isString(e) || !F.test(e)) || (j.warn("Check the parameter format. PropertyName must start with a letter and contain letters, digits, and underscores (_). The value is a string of no more than 50 characters: " + e), !1)
                    }
                }, {
                    key: "properties",
                    value: function(e) {
                        return this.stripProperties(e), !(e && (x.isObject(e) ? !this._checkPropertiesKey(e) && (j.warn("Check the parameter format. The properties key must start with a letter, contain digits, letters, and underscores (_), and contain a maximum of 50 characters"), 1) : (j.warn("properties can be none, but it must be an object"), 1)))
                    }
                }, {
                    key: "propertiesMust",
                    value: function(e) {
                        return this.stripProperties(e), void 0 === e || !x.isObject(e) || x.isEmptyObject(e) ? (j.warn("properties must be an object with a value"), !1) : !!this._checkPropertiesKey(e) || (j.warn("Check the parameter format. The properties key must start with a letter, contain digits, letters, and underscores (_), and contain a maximum of 50 characters"), !1)
                    }
                }, {
                    key: "userId",
                    value: function(e) {
                        return !(!x.isString(e) || !/^.{1,64}$/.test(e)) || (j.warn("The user ID must be a string of less than 64 characters and cannot be null"), !1)
                    }
                }, {
                    key: "userAddProperties",
                    value: function(e) {
                        if (!this.propertiesMust(e)) return !1;
                        for (var t in e)
                            if (!x.isNumber(e[t])) return j.warn("The attributes of userAdd need to be Number"), !1;
                        return !0
                    }
                }, {
                    key: "userAppendProperties",
                    value: function(e) {
                        if (!this.propertiesMust(e)) return !1;
                        for (var t in e)
                            if (!x.isArray(e[t])) return j.warn("The attribute of userAppend must be Array"), !1;
                        return !0
                    }
                }]), e
            }(),
            G = function() {
                function e(t, n, i, r, a, o) {
                    s(this, e), this.data = t, this.serverUrl = n, this.callback = o, this.debugMode = a, this.tryCount = x.isNumber(i) ? i : 1, this.permissionTryCount = 6, this.timeout = x.isNumber(r) ? r : 3e3, this.taClassName = "HttpTask"
                }
                return c(e, [{
                    key: "run",
                    value: function() {
                        var e = this,
                            t = x.createExtraHeaders();
                        t["content-type"] = "application/json", "debug" === this.debugMode && (t["Turbo-Debug-Mode"] = 1);
                        var n = N.request({
                            url: this.serverUrl,
                            method: "POST",
                            data: this.data,
                            header: t,
                            success: function(t) {
                                var n;
                                0 === (null == t || null === (n = t.data) || void 0 === n ? void 0 : n.code) ? e.onSuccess(t) : e.onFailed(t)
                            },
                            fail: function(t) {
                                e.onFailed(t)
                            }
                        });
                        setTimeout((function() {
                            if ((x.isObject(n) || x.isPromise(n)) && x.isFunction(n.abort)) try {
                                n.abort()
                            } catch (e) {}
                        }), this.timeout)
                    }
                }, {
                    key: "onSuccess",
                    value: function(e) {
                        if (200 === e.statusCode) {
                            var t, n, i = "Data Verified";
                            null != e && null !== (t = e.data) && void 0 !== t && null !== (t = t.extra) && void 0 !== t && null !== (t = t.errors) && void 0 !== t && t.length && (i = e.data.extra.errors), this.callback({
                                code: null == e || null === (n = e.data) || void 0 === n ? void 0 : n.code,
                                msg: i
                            })
                        } else this.callback({
                            code: (null == e ? void 0 : e.statusCode) || -3,
                            msg: e.statusCode
                        })
                    }
                }, {
                    key: "onFailed",
                    value: function(e) {
                        var t, n, i = this;
                        --this.tryCount > 0 ? setTimeout((function() {
                            i.run()
                        }), 1e3) : this.callback({
                            code: -3,
                            msg: "".concat(null == e || null === (t = e.data) || void 0 === t ? void 0 : t.msg, "：").concat(null == e || null === (n = e.data) || void 0 === n || null === (n = n.extra) || void 0 === n ? void 0 : n.error)
                        })
                    }
                }]), e
            }(),
            M = new(function() {
                function e() {
                    s(this, e), this.items = [], this.isRunning = !1, this.showDebug = !1
                }
                return c(e, [{
                    key: "enqueue",
                    value: function(e, t, n) {
                        var i, r = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3],
                            a = "debug" === n.debugMode,
                            s = this;
                        i = new G(JSON.stringify(e), t, n.maxRetries, n.sendTimeout, n.debugMode, (function(e) {
                            s.isRunning = !1, x.isFunction(n.callback) && n.callback(e), s._runNext(a), a && j.info("code ".concat(e.code, " and msg is,"), e.msg)
                        })), !0 === r ? (this.items.push(i), this._runNext(a)) : i.run()
                    }
                }, {
                    key: "_dequeue",
                    value: function() {
                        return this.items.shift()
                    }
                }, {
                    key: "_runNext",
                    value: function(e) {
                        if (this.items.length > 0 && !this.isRunning)
                            if (this.isRunning = !0, e) this._dequeue().run();
                            else {
                                for (var t = this.items.splice(0, this.items.length), n = t[0], i = JSON.parse(n.data), r = 1; r < t.length; r++) {
                                    var a = t[r],
                                        s = JSON.parse(a.data);
                                    i.event_list = i.event_list.concat(s.event_list)
                                }
                                var o = (new Date).getTime();
                                i.$flush_time = o, new G(JSON.stringify(i), n.serverUrl, n.tryCount, n.timeout, null == n ? void 0 : n.debugMode, n.callback).run()
                            }
                    }
                }]), e
            }()),
            L = {
                name: "GravityEngine",
                is_plugin: !1,
                maxRetries: 3,
                sendTimeout: 5e3,
                enablePersistence: !0,
                asyncPersistence: !1,
                strict: !1,
                debugMode: "none"
            },
            H = {
                properties: {
                    $lib_version: d,
                    $lib: g,
                    $scene: "",
                    $today_first_scene: ""
                },
                getSystemInfo: function(e) {
                    var t = this;
                    N.onNetworkStatusChange((function(e) {
                        t.properties.$network_type = e.networkType
                    })), N.getNetworkType({
                        success: function(e) {
                            t.properties.$network_type = e.networkType
                        },
                        complete: function() {
                            N.getSystemInfo({
                                success: function(e) {
                                    j.info(JSON.stringify(e, null, 4));
                                    var n = {
                                        $manufacturer: e.brand,
                                        $brand: e.brand,
                                        $model: e.model,
                                        $screen_width: Number(e.screenWidth),
                                        $screen_height: Number(e.screenHeight),
                                        $system_language: e.language,
                                        $os: e.platform,
                                        $os_version: e.system
                                    };
                                    x.extend(t.properties, n), x.setMpPlatform(e.mp_platform)
                                },
                                complete: function() {
                                    e()
                                }
                            })
                        }
                    })
                }
            },
            R = function() {
                function e(t, n) {
                    var i = this;
                    s(this, e), this.enabled = t.enablePersistence, this.enabled ? (t.isChildInstance ? (this.name = t.persistenceName + "_" + t.name, this.nameOld = t.persistenceNameOld + "_" + t.name) : (this.name = t.persistenceName, this.nameOld = t.persistenceNameOld), t.asyncPersistence ? (this._state = {}, N.getStorage(this.name, !0, (function(e) {
                        x.isEmptyObject(e) ? N.getStorage(i.nameOld, !0, (function(e) {
                            i._state = x.extend2Layers({}, e, i._state), i._init(t, n), i._save()
                        })) : (i._state = x.extend2Layers({}, e, i._state), i._init(t, n), i._save())
                    }))) : (this._state = N.getStorage(this.name) || {}, x.isEmptyObject(this._state) && (this._state = N.getStorage(this.nameOld) || {}), this._init(t, n))) : (this._state = {}, this._init(t, n))
                }
                return c(e, [{
                    key: "_init",
                    value: function(e, t) {
                        this.getDistinctId() || this.setDistinctId(x.UUID()), e.isChildInstance || this.getDeviceId() || this._setDeviceId(x.UUID()), this.initComplete = !0, "function" == typeof t && t();
                        var n = N.getStorage(this.name),
                            i = null == n ? void 0 : n.current_first_scene_date,
                            r = null == n ? void 0 : n.current_first_scene,
                            a = (new Date).toLocaleDateString();
                        if (r && i && i === a) H.properties.$today_first_scene = String(null == n ? void 0 : n.current_first_scene);
                        else {
                            var s, o, c = String((null === (s = N.getAppOptions()) || void 0 === s ? void 0 : s.scene) || (null === (o = N.getAppOptions()) || void 0 === o ? void 0 : o.from));
                            H.properties.$today_first_scene = c, this._state.current_first_scene = c, this._state.current_first_scene_date = a
                        }
                        this._save()
                    }
                }, {
                    key: "_save",
                    value: function() {
                        this.enabled && this.initComplete && N.setStorage(this.name, JSON.stringify(this._state))
                    }
                }, {
                    key: "_set",
                    value: function(e, t) {
                        var n, r = this;
                        "string" == typeof e ? (n = {})[e] = t : "object" === i(e) && (n = e), x.each(n, (function(e, t) {
                            r._state[t] = e
                        })), this._save()
                    }
                }, {
                    key: "_get",
                    value: function(e) {
                        return this._state[e]
                    }
                }, {
                    key: "setEventTimer",
                    value: function(e, t) {
                        var n = this._state.event_timers || {};
                        n[e] = t, this._set("event_timers", n)
                    }
                }, {
                    key: "removeEventTimer",
                    value: function(e) {
                        var t = (this._state.event_timers || {})[e];
                        return x.isUndefined(t) || (delete this._state.event_timers[e], this._save()), t
                    }
                }, {
                    key: "getDeviceId",
                    value: function() {
                        return this._state.device_id
                    }
                }, {
                    key: "_setDeviceId",
                    value: function(e) {
                        this.getDeviceId() ? j.warn("cannot modify the device id.") : this._set("device_id", e)
                    }
                }, {
                    key: "getDistinctId",
                    value: function() {
                        return this._state.distinct_id
                    }
                }, {
                    key: "setDistinctId",
                    value: function(e) {
                        this._set("distinct_id", e)
                    }
                }, {
                    key: "getAccountId",
                    value: function() {
                        return this._state.account_id
                    }
                }, {
                    key: "setAccountId",
                    value: function(e) {
                        this._set("account_id", e)
                    }
                }, {
                    key: "getSuperProperties",
                    value: function() {
                        return this._state.props || {}
                    }
                }, {
                    key: "setSuperProperties",
                    value: function(e, t) {
                        var n = t ? e : x.extend(this.getSuperProperties(), e);
                        this._set("props", n)
                    }
                }]), e
            }();

        function B() {
            return N.getConfig().persistenceNameOld
        }
        var z = function() {
                function e(t) {
                    s(this, e), t.appId = x.checkAppId((null == t ? void 0 : t.clientId) || ""), t.accessToken = t.accessToken, t.accessToken || console.warn("GravityAnalytics: accessToken must be required"), t.autoTrack = {
                        appLaunch: !0,
                        appShow: !0,
                        appHide: !0,
                        pageShare: !0
                    }, t.serverUrl = "".concat(m, "/event/collect/?access_token=").concat(t.accessToken);
                    var n = x.extend({}, L, N.getConfig());
                    x.isObject(t) ? this.config = x.extend(n, t) : this.config = n, this._init(this.config)
                }
                var t, i;
                return c(e, [{
                    key: "_init",
                    value: function(e) {
                        var t, n, i, r = this;
                        this.name = e.name, this.appId = e.clientId, this.accessToken = e.accessToken;
                        var a = e.serverUrl || e.server_url;
                        this.serverUrl = a, this.serverDebugUrl = a, this.configUrl = a + "/config", this.autoTrackProperties = {}, this._queue = [], this.config.syncBatchSize = 100, this.config.syncInterval = 60, e.isChildInstance ? this._state = {} : (j.enabled = "debug" === e.debugMode, this.instances = [], this._state = {
                            getSystemInfo: !1,
                            initComplete: !1
                        }, H.getSystemInfo((function() {
                            r._updateState({
                                getSystemInfo: !0
                            })
                        })), N.setGlobal(this, this.name)), H.properties.$scene = String((null === (t = N.getAppOptions()) || void 0 === t ? void 0 : t.scene) || (null === (n = N.getAppOptions()) || void 0 === n ? void 0 : n.from)), this.store = new R(e, (function() {
                            r.config.asyncPersistence && x.isFunction(r.config.persistenceComplete) && r.config.persistenceComplete(r), r._updateState()
                        })), this.enabled = !x.isBoolean(this.store._get("ge_enabled")) || this.store._get("ge_enabled"), this.isOptOut = !!x.isBoolean(this.store._get("ge_isOptOut")) && this.store._get("ge_isOptOut");
                        var s = B(),
                            o = "GravityEngine_quick_mp" === s;
                        (o || "GravityEngine_wechat_game" === s || "GravityEngine_taobao_game" === s || "GravityEngine_tt_game" === s || "GravityEngine_ali_game" === s || s.includes("gravityengine_qg")) && null != e && null !== (i = e.autoTrack) && void 0 !== i && i.appLaunch && this.track(o ? "$AppStart" : "$MPLaunch", {
                            $url_query: x.setQuery(this.getQuery())
                        }), !e.isChildInstance && e.autoTrack && (this.autoTrack = N.initAutoTrackInstance(this, e))
                    }
                }, {
                    key: "updateConfig",
                    value: function(e, t) {}
                }, {
                    key: "initInstance",
                    value: function(t, n) {
                        if (this.config.isChildInstance) j.warn("initInstance() cannot be called on child instance");
                        else {
                            if (x.isString(t) && t !== this.name && x.isUndefined(this[t])) {
                                var i = new e(x.extend({}, this.config, {
                                    enablePersistence: !1,
                                    isChildInstance: !0,
                                    name: t
                                }, n));
                                return this[t] = i, this.instances.push(t), this[t]._state = this._state, i
                            }
                            j.warn("initInstance() failed due to the name is invalid: " + t)
                        }
                    }
                }, {
                    key: "lightInstance",
                    value: function(e) {
                        return this[e]
                    }
                }, {
                    key: "_setAutoTrackProperties",
                    value: function(e) {
                        x.extend(this.autoTrackProperties, e)
                    }
                }, {
                    key: "setupAndStart",
                    value: function(e) {
                        if (null != e && e.clientId && (this.config.appId = e.clientId, this.appId = e.clientId), this._state.initComplete) return !1;
                        this._updateState({
                            initComplete: !0
                        })
                    }
                }, {
                    key: "_isReady",
                    value: function() {
                        return this._state.getSystemInfo && this._state.initComplete && this.store.initComplete && this.config.appId && this.config.accessToken
                    }
                }, {
                    key: "_updateState",
                    value: function(e) {
                        var t = this;
                        x.isObject(e) && x.extend(this._state, e), this._onStateChange(), x.each(this.instances, (function(e) {
                            t[e]._onStateChange()
                        }))
                    }
                }, {
                    key: "_onStateChange",
                    value: function() {
                        var e = this;
                        this._isReady() && this._queue && this._queue.length > 0 && (x.each(this._queue, (function(t) {
                            e[t[0]].apply(e, E.call(t[1]))
                        })), this._queue = [])
                    }
                }, {
                    key: "_hasDisabled",
                    value: function() {
                        var e = !this.enabled || this.isOptOut;
                        return e && j.info("GravityEngine is Pause or Stop!"), e
                    }
                }, {
                    key: "_sendRequest",
                    value: function(e, t, n) {
                        if (!this._hasDisabled())
                            if (x.isUndefined(this.config.disableEventList) || !this.config.disableEventList.includes(e.eventName)) {
                                t = x.isDate(t) ? t : new Date;
                                var i = {
                                    event_list: [{
                                        type: e.type,
                                        time: new Date(t).getTime()
                                    }]
                                };
                                if (i.event_list[0].event = e.eventName, "track" === e.type) {
                                    i.event_list[0].properties = this.getSendProperties();
                                    var r = this.store.removeEventTimer(e.eventName);
                                    if (!x.isUndefined(r)) {
                                        var a = (new Date).getTime() - r,
                                            s = parseFloat((a / 1e3).toFixed(3));
                                        s > 86400 ? s = 86400 : s < 0 && (s = 0), i.event_list[0].properties.$event_duration = s
                                    }
                                } else i.event_list[0].properties = {};
                                x.isObject(e.properties) && !x.isEmptyObject(e.properties) && x.extend(i.event_list[0].properties, e.properties), x.searchObjDate(i.event_list[0]), i.client_id = this.appId, j.info(JSON.stringify(i, null, 4));
                                var o = this.serverUrl;
                                if (x.isBoolean(this.config.enableEncrypt) && 1 == this.config.enableEncrypt && (i.event_list[0] = x.generateEncryptyData(i.event_list[0], void 0)), n) {
                                    var c = new FormData;
                                    if ("debug" === this.config.debugMode) c.append("source", "client"), c.append("appid", this.appId), c.append("deviceId", this.getDeviceId()), c.append("data", JSON.stringify(i.event_list[0]));
                                    else {
                                        var u = x.base64Encode(JSON.stringify(i));
                                        c.append("data", u)
                                    }
                                    try {
                                        navigator.sendBeacon(o, c)
                                    } catch (e) {}
                                    x.isFunction(e.onComplete) && e.onComplete({
                                        statusCode: 200
                                    })
                                } else M.enqueue(i, o, {
                                    maxRetries: this.config.maxRetries,
                                    sendTimeout: this.config.sendTimeout,
                                    callback: e.onComplete,
                                    debugMode: this.config.debugMode
                                })
                            } else j.info("disabled Event : " + e.eventName)
                    }
                }, {
                    key: "_isObjectParams",
                    value: function(e) {
                        return x.isObject(e) && x.isFunction(e.onComplete)
                    }
                }, {
                    key: "track",
                    value: function(e, t, n, i) {
                        if (!this._hasDisabled()) {
                            if (this._isObjectParams(e)) {
                                var r = e;
                                e = r.eventName, t = r.properties, n = r.time, i = r.onComplete
                            }
                            J.event(e) && J.properties(t) || !this.config.strict ? this._internalTrack(e, t, n, i) : x.isFunction(i) && i({
                                code: -1,
                                msg: "invalid parameters"
                            })
                        }
                    }
                }, {
                    key: "_internalTrack",
                    value: function(e, t, n, i, r) {
                        this._hasDisabled() || (n = x.isDate(n) ? n : new Date, this._isReady() ? this._sendRequest({
                            type: "track",
                            eventName: e,
                            properties: t,
                            onComplete: i
                        }, n, r) : this._queue.push(["_internalTrack", [e, t, n, i]]))
                    }
                }, {
                    key: "userSet",
                    value: function(e, t, n) {
                        if (!this._hasDisabled()) {
                            if (this._isObjectParams(e)) {
                                var i = e;
                                e = i.properties, t = i.time, n = i.onComplete
                            }
                            J.propertiesMust(e) || !this.config.strict ? (t = x.isDate(t) ? t : new Date, this._isReady() ? this._sendRequest({
                                type: "profile",
                                eventName: "profile_set",
                                properties: e,
                                onComplete: n
                            }, t) : this._queue.push(["userSet", [e, t, n]])) : (j.warn("calling userSet failed due to invalid arguments"), x.isFunction(n) && n({
                                code: -1,
                                msg: "invalid parameters"
                            }))
                        }
                    }
                }, {
                    key: "userSetOnce",
                    value: function(e, t, n) {
                        if (!this._hasDisabled()) {
                            if (this._isObjectParams(e)) {
                                var i = e;
                                e = i.properties, t = i.time, n = i.onComplete
                            }
                            J.propertiesMust(e) || !this.config.strict ? (t = x.isDate(t) ? t : new Date, this._isReady() ? this._sendRequest({
                                type: "profile",
                                eventName: "profile_set_once",
                                properties: e,
                                onComplete: n
                            }, t) : this._queue.push(["userSetOnce", [e, t, n]])) : (j.warn("calling userSetOnce failed due to invalid arguments"), x.isFunction(n) && n({
                                code: -1,
                                msg: "invalid parameters"
                            }))
                        }
                    }
                }, {
                    key: "userAdd",
                    value: function(e, t, n) {
                        if (!this._hasDisabled()) {
                            if (this._isObjectParams(e)) {
                                var i = e;
                                e = i.properties, t = i.time, n = i.onComplete
                            }
                            J.propertiesMust(e) || !this.config.strict ? (t = x.isDate(t) ? t : new Date, this._isReady() ? this._sendRequest({
                                type: "profile",
                                eventName: "profile_increment",
                                properties: e,
                                onComplete: n
                            }, t) : this._queue.push(["userAdd", [e, t, n]])) : (j.warn("calling userAdd failed due to invalid arguments"), x.isFunction(n) && n({
                                code: -1,
                                msg: "invalid parameters"
                            }))
                        }
                    }
                }, {
                    key: "userNumberMax",
                    value: function(e, t, n) {
                        if (!this._hasDisabled()) {
                            if (this._isObjectParams(e)) {
                                var i = e;
                                e = i.properties, t = i.time, n = i.onComplete
                            }
                            for (var r in e)
                                if ("number" != typeof e[r]) {
                                    var a = "The key ".concat(r, " must be type of number");
                                    return console.warn(a), void(x.isFunction(n) && n({
                                        code: -1,
                                        msg: a
                                    }))
                                }
                            J.propertiesMust(e) || !this.config.strict ? (t = x.isDate(t) ? t : new Date, this._isReady() ? this._sendRequest({
                                type: "profile",
                                eventName: "profile_number_max",
                                properties: e,
                                onComplete: n
                            }, t) : this._queue.push(["userNumberMax", [e, t, n]])) : (j.warn("calling userNumberMax failed due to invalid arguments"), x.isFunction(n) && n({
                                code: -1,
                                msg: "invalid parameters"
                            }))
                        }
                    }
                }, {
                    key: "userNumberMin",
                    value: function(e, t, n) {
                        if (!this._hasDisabled()) {
                            if (this._isObjectParams(e)) {
                                var i = e;
                                e = i.properties, t = i.time, n = i.onComplete
                            }
                            for (var r in e)
                                if ("number" != typeof e[r]) {
                                    var a = "The key ".concat(r, " must be type of number");
                                    return console.warn(a), void(x.isFunction(n) && n({
                                        code: -1,
                                        msg: a
                                    }))
                                }
                            J.propertiesMust(e) || !this.config.strict ? (t = x.isDate(t) ? t : new Date, this._isReady() ? this._sendRequest({
                                type: "profile",
                                eventName: "profile_number_min",
                                properties: e,
                                onComplete: n
                            }, t) : this._queue.push(["userNumberMin", [e, t, n]])) : (j.warn("calling userNumberMin failed due to invalid arguments"), x.isFunction(n) && n({
                                code: -1,
                                msg: "invalid parameters"
                            }))
                        }
                    }
                }, {
                    key: "userDel",
                    value: function(e, t) {
                        var n = {};
                        if (!this._hasDisabled()) {
                            if (this._isObjectParams(n)) {
                                var i = n;
                                n = i.properties, e = i.time, t = i.onComplete
                            }
                            J.propertiesMust(n) || !this.config.strict ? (e = x.isDate(e) ? e : new Date, this._isReady() ? this._sendRequest({
                                type: "profile",
                                eventName: "profile_delete",
                                properties: n,
                                onComplete: t
                            }, e) : this._queue.push(["userDel", [n, e, t]])) : (j.warn("calling userDel failed due to invalid arguments"), x.isFunction(t) && t({
                                code: -1,
                                msg: "invalid parameters"
                            }))
                        }
                    }
                }, {
                    key: "userAppend",
                    value: function(e, t, n) {
                        if (!this._hasDisabled()) {
                            if (this._isObjectParams(e)) {
                                var i = e;
                                e = i.properties, t = i.time, n = i.onComplete
                            }
                            J.propertiesMust(e) || !this.config.strict ? (t = x.isDate(t) ? t : new Date, this._isReady() ? this._sendRequest({
                                type: "profile",
                                eventName: "profile_append",
                                properties: e,
                                onComplete: n
                            }, t) : this._queue.push(["userAppend", [e, t, n]])) : (j.warn("calling userAppend failed due to invalid arguments"), x.isFunction(n) && n({
                                code: -1,
                                msg: "invalid parameters"
                            }))
                        }
                    }
                }, {
                    key: "userUniqAppend",
                    value: function(e, t, n) {
                        if (!this._hasDisabled()) {
                            if (this._isObjectParams(e)) {
                                var i = e;
                                e = i.properties, t = i.time, n = i.onComplete
                            }
                            J.userAppendProperties(e) || !this.config.strict ? (t = x.isDate(t) ? t : new Date, this._isReady() ? this._sendRequest({
                                type: "profile",
                                eventName: "profile_uniq_append",
                                properties: e,
                                onComplete: n
                            }, t) : this._queue.push(["userUniqAppend", [e, t, n]])) : (j.warn("calling userAppend failed due to invalid arguments"), x.isFunction(n) && n({
                                code: -1,
                                msg: "invalid parameters"
                            }))
                        }
                    }
                }, {
                    key: "userUnset",
                    value: function(e, t, n) {
                        var i = u({}, e, null);
                        if (!this._hasDisabled()) {
                            if (this._isObjectParams(i)) {
                                var r = i;
                                i = r.properties, t = r.time, n = r.onComplete
                            }
                            J.propertiesMust(i) || !this.config.strict ? (t = x.isDate(t) ? t : new Date, this._isReady() ? this._sendRequest({
                                type: "profile",
                                eventName: "profile_unset",
                                properties: i,
                                onComplete: n
                            }, t) : this._queue.push(["userUnset", [i, t, n]])) : (j.warn("calling userUnset failed due to invalid arguments"), x.isFunction(n) && n({
                                code: -1,
                                msg: "invalid parameters"
                            }))
                        }
                    }
                }, {
                    key: "getQuickAppInfo",
                    value: function() {
                        return new Promise((function(e, t) {
                            var i;
                            N.getQuickDevice({
                                success: (i = a(n().mark((function t(i) {
                                    var r;
                                    return n().wrap((function(t) {
                                        for (;;) switch (t.prev = t.next) {
                                            case 0:
                                                return r = {
                                                    os_name: "android",
                                                    android_id: i.user,
                                                    imei: i.device,
                                                    oaid: i.oaid,
                                                    mac: i.mac,
                                                    android_version: i.system,
                                                    api_version: i.osVersionCode,
                                                    rom: i.vendorOsName,
                                                    rom_version: i.vendorOsVersion,
                                                    phone_brand: i.manufacturer,
                                                    phone_model: i.model
                                                }, t.abrupt("return", e(r));
                                            case 2:
                                            case "end":
                                                return t.stop()
                                        }
                                    }), t)
                                }))), function(e) {
                                    return i.apply(this, arguments)
                                })
                            })
                        }))
                    }
                }, {
                    key: "getQuickGameInfo",
                    value: function() {
                        return new Promise((function(e) {
                            var t = B();
                            N.getQuickDevice({
                                platform: t,
                                success: function(t) {
                                    return e(t)
                                }
                            })
                        }))
                    }
                }, {
                    key: "uploadQuickAppDeviceInfo",
                    value: function() {
                        var e = this;
                        return new Promise((function(t, i) {
                            var r;
                            N.getQuickDevice({
                                success: (r = a(n().mark((function r(a) {
                                    var s, o, c;
                                    return n().wrap((function(n) {
                                        for (;;) switch (n.prev = n.next) {
                                            case 0:
                                                return s = {
                                                    os_name: "android",
                                                    android_id: a.user,
                                                    imei: a.device,
                                                    oaid: a.oaid,
                                                    mac: a.mac,
                                                    android_version: a.system,
                                                    api_version: a.osVersionCode,
                                                    rom: a.vendorOsName,
                                                    rom_version: a.vendorOsVersion,
                                                    phone_brand: a.manufacturer,
                                                    phone_model: a.model
                                                }, o = "".concat(m, "/user/device_info/?access_token=").concat(e.accessToken, "&client_id=").concat(e.appId), n.next = 4, e.sendNetWork(o, {
                                                    data: s
                                                });
                                            case 4:
                                                return c = n.sent, n.abrupt("return", 0 === c.code ? t(c) : i(c));
                                            case 6:
                                            case "end":
                                                return n.stop()
                                        }
                                    }), r)
                                }))), function(e) {
                                    return r.apply(this, arguments)
                                })
                            })
                        }))
                    }
                }, {
                    key: "uploadQuickGameDeviceInfo",
                    value: function() {
                        var e = this;
                        return new Promise((function(t, i) {
                            var r, s = B();
                            N.getQuickDevice({
                                platform: s,
                                success: (r = a(n().mark((function r(a) {
                                    var s, o, c;
                                    return n().wrap((function(n) {
                                        for (;;) switch (n.prev = n.next) {
                                            case 0:
                                                return s = a, o = "".concat(m, "/user/device_info/?access_token=").concat(e.accessToken, "&client_id=").concat(e.appId), n.next = 4, e.sendNetWork(o, {
                                                    data: s
                                                });
                                            case 4:
                                                return c = n.sent, n.abrupt("return", 0 === c.code ? t(c) : i(c));
                                            case 6:
                                            case "end":
                                                return n.stop()
                                        }
                                    }), r)
                                }))), function(e) {
                                    return r.apply(this, arguments)
                                })
                            })
                        }))
                    }
                }, {
                    key: "logoutEvent",
                    value: function() {
                        this.track("$MPLogout", {})
                    }
                }, {
                    key: "loginEvent",
                    value: function() {
                        this.track("$MPLogin", {})
                    }
                }, {
                    key: "registerEvent",
                    value: function() {
                        "GravityEngine_quick_mp" !== B() ? this.track("$MPRegister", {}) : this.track("$AppRegister", {})
                    }
                }, {
                    key: "payEvent",
                    value: function(e, t, n, i, r) {
                        if ("number" != typeof e) throw new Error("pay_amount must be a number");
                        if ("string" != typeof t) throw new Error("pay_type must be a string");
                        if ("string" != typeof n) throw new Error("order_id must be a string");
                        if ("string" != typeof i) throw new Error("pay_reason must be a string");
                        if ("string" != typeof r) throw new Error("pay_method must be a string");
                        this.track("$PayEvent", {
                            $pay_amount: e,
                            $pay_type: t,
                            $order_id: n,
                            $pay_reason: i,
                            $pay_method: r
                        })
                    }
                }, {
                    key: "bindTAThirdPlatform",
                    value: function(e, t) {
                        if (!e && !t) throw new Error("taAccountId or taDistinctId must be required");
                        if (e && "string" != typeof e) throw new Error("taAccountId must be a string");
                        if (t && "string" != typeof t) throw new Error("taDistinctId must be a string");
                        this.track("$BindThirdPlatform", {
                            $third_platform_type: "ta",
                            $ta_account_id: e,
                            $ta_distinct_id: t
                        })
                    }
                }, {
                    key: "adShowEvent",
                    value: function(e, t, n) {
                        var i = B(),
                            r = "wechat";
                        if ("GravityEngine_ali_game" === i && (r = "alipay"), "GravityEngine_wechat" === i || "GravityEngine_wechat_game" === i || "GravityEngine_ali_game" === i) {
                            if ("string" != typeof e) throw new Error("ad_type must be a string");
                            if ("string" != typeof t) throw new Error("ad_unit_id must be a string");
                            if ("wechat" === r && !t.startsWith("adunit-")) throw new Error("您传入的ad_unit_id格式不正确，请检查");
                            var a = {
                                $ad_type: e,
                                $ad_unit_id: t,
                                $adn_type: r
                            };
                            "[object Object]" === Object.prototype.toString.call(n) && Object.assign(a, n), this.track("$AdShow", a)
                        }
                    }
                }, {
                    key: "getQuery",
                    value: function() {
                        try {
                            var e;
                            return null != N && N.getAppOptions && null !== (e = N.getAppOptions()) && void 0 !== e && e.query && N.getAppOptions().query || {}
                        } catch (e) {
                            return {}
                        }
                    }
                }, {
                    key: "sendNetWork",
                    value: function(e, t) {
                        var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "POST";
                        return new Promise((function(i, r) {
                            N.request({
                                url: e,
                                method: n,
                                data: "string" == typeof t ? t : JSON.stringify(t),
                                header: {
                                    "content-type": "application/json"
                                },
                                success: function(e) {
                                    200 !== e.statusCode && 200 !== e.status ? r(e) : i(e.data)
                                },
                                fail: function(e) {
                                    r(e)
                                }
                            })
                        }))
                    }
                }, {
                    key: "_errorPromise",
                    value: function(e) {
                        return Promise.reject(new Error(e))
                    }
                }, {
                    key: "initializeWithHistoryUserInfo",
                    value: (i = a(n().mark((function e() {
                        var t, i, r = arguments;
                        return n().wrap((function(e) {
                            for (;;) switch (e.prev = e.next) {
                                case 0:
                                    return t = r.length > 0 && void 0 !== r[0] ? r[0] : {}, i = r.length > 1 ? r[1] : void 0, e.abrupt("return", this.initialize(t, i));
                                case 3:
                                case "end":
                                    return e.stop()
                            }
                        }), e, this)
                    }))), function() {
                        return i.apply(this, arguments)
                    })
                }, {
                    key: "initialize",
                    value: (t = a(n().mark((function e() {
                        var t, i, r = this,
                            s = arguments;
                        return n().wrap((function(e) {
                            for (;;) switch (e.prev = e.next) {
                                case 0:
                                    return t = s.length > 0 && void 0 !== s[0] ? s[0] : {}, i = s.length > 1 ? s[1] : void 0, e.abrupt("return", new Promise(function() {
                                        var e = a(n().mark((function e(s, o) {
                                            return n().wrap((function(e) {
                                                for (;;) switch (e.prev = e.next) {
                                                    case 0:
                                                        try {
                                                            N.getStorage("is_ge_registered", !0, function() {
                                                                var e = a(n().mark((function e(a) {
                                                                    var c, u, l, p, f, h, d, v, g, y, _, k, b, w, S, P, I, O, A, T, E;
                                                                    return n().wrap((function(e) {
                                                                        for (;;) switch (e.prev = e.next) {
                                                                            case 0:
                                                                                if (c = "", r._state.initComplete ? null != t && t.name ? null != t && t.version || 0 === (null == t ? void 0 : t.version) ? x.isNumber(null == t ? void 0 : t.version) && "number" == typeof(null == t ? void 0 : t.version) ? void 0 !== i && ("[object Object]" !== Object.prototype.toString.call(i) ? c = "history_info must be type: Object" : null != i && i.company ? "string" != typeof i.company ? c = "history_info.company must be type: String" : null != i && i.create_time || 0 === i.create_time ? x.isNumber(i.create_time) && "number" == typeof i.create_time || (c = "history_info.create_time must be type: Number") : c = "history_info.create_time must be required" : c = "history_info.company must be required") : c = "version must be type: Number" : c = "version must be required" : c = "name must be required" : c = "initialize must be called after setupAndStart", !c) {
                                                                                    e.next = 4;
                                                                                    break
                                                                                }
                                                                                return e.abrupt("return", o(c));
                                                                            case 4:
                                                                                if (u = r.getQuery(), l = B(), p = l.includes("GravityEngine_ali"), f = (null == t ? void 0 : t.channel) || "base_channel", h = (null == t ? void 0 : t.enable_sync_attribution) || !1, d = {
                                                                                        client_id: r.appId,
                                                                                        name: t.name,
                                                                                        channel: p && null != u && u.channel ? u.channel : f,
                                                                                        version: t.version,
                                                                                        wx_openid: (null == t ? void 0 : t.openid) || (null == t ? void 0 : t.wx_openid) || "",
                                                                                        wx_unionid: (null == t ? void 0 : t.wx_unionid) || "",
                                                                                        promoted_object_id: (null == t ? void 0 : t.promoted_object_id) || "",
                                                                                        need_return_attribution: h,
                                                                                        ad_data: u
                                                                                    }, i && (d.history_info = i), "GravityEngine_quick_mp" !== (v = B())) {
                                                                                    e.next = 16;
                                                                                    break
                                                                                }
                                                                                return e.next = 15, r.getQuickAppInfo();
                                                                            case 15:
                                                                                d.device_info = e.sent;
                                                                            case 16:
                                                                                if (!v.includes("gravityengine_qg")) {
                                                                                    e.next = 20;
                                                                                    break
                                                                                }
                                                                                return e.next = 19, r.getQuickGameInfo();
                                                                            case 19:
                                                                                d.device_info = e.sent;
                                                                            case 20:
                                                                                return g = "".concat(m, "/user/initialize/?access_token=").concat(r.accessToken, "&client_id=").concat(r.appId), e.next = 23, r.sendNetWork(g, d);
                                                                            case 23:
                                                                                if (0 === (y = e.sent).code) {
                                                                                    e.next = 26;
                                                                                    break
                                                                                }
                                                                                return e.abrupt("return", o(y));
                                                                            case 26:
                                                                                return _ = H.properties, k = new Date, b = k.getFullYear(), w = ("0" + (k.getMonth() + 1)).slice(-2), S = ("0" + k.getDate()).slice(-2), P = ("0" + k.getHours()).slice(-2), I = ("0" + k.getMinutes()).slice(-2), O = ("0" + k.getSeconds()).slice(-2), A = "".concat(b, "-").concat(w, "-").concat(S, " ").concat(P, ":").concat(I, ":").concat(O), "Y" !== a && (r.userSetOnce({
                                                                                    $channel: f,
                                                                                    $manufacturer: _.$manufacturer,
                                                                                    $model: _.$model,
                                                                                    $brand: _.$brand,
                                                                                    $os: _.$os,
                                                                                    $first_visit_time: A,
                                                                                    $first_scene: String(null === (T = N.getAppOptions()) || void 0 === T ? void 0 : T.scene),
                                                                                    $gravity_referee_openid: (null == u ? void 0 : u.gravity_referee_openid) || void 0
                                                                                }), E = x.setQuery(r.getQuery()), r.track("GravityEngine_quick_mp" === v ? "$AppStart" : "$MPLaunch", {
                                                                                    $url_query: E
                                                                                }), r.track("$MPShow", {
                                                                                    $url_query: E
                                                                                })), N.setStorage("is_ge_registered", JSON.stringify("Y")), e.abrupt("return", s(y));
                                                                            case 38:
                                                                            case "end":
                                                                                return e.stop()
                                                                        }
                                                                    }), e)
                                                                })));
                                                                return function(t) {
                                                                    return e.apply(this, arguments)
                                                                }
                                                            }())
                                                        } catch (e) {
                                                            o(e)
                                                        }
                                                    case 1:
                                                    case "end":
                                                        return e.stop()
                                                }
                                            }), e)
                                        })));
                                        return function(t, n) {
                                            return e.apply(this, arguments)
                                        }
                                    }()));
                                case 3:
                                case "end":
                                    return e.stop()
                            }
                        }), e)
                    }))), function() {
                        return t.apply(this, arguments)
                    })
                }, {
                    key: "authorizeOpenID",
                    value: function(e) {
                        this.identify(e)
                    }
                }, {
                    key: "identify",
                    value: function(e) {
                        if (!this._hasDisabled()) {
                            if ("number" == typeof e) e = String(e);
                            else if ("string" != typeof e) return !1;
                            this.store.setDistinctId(e)
                        }
                    }
                }, {
                    key: "getDistinctId",
                    value: function() {
                        return this.store.getDistinctId()
                    }
                }, {
                    key: "login",
                    value: function(e) {
                        if (!this._hasDisabled()) {
                            if ("number" == typeof e) e = String(e);
                            else if ("string" != typeof e) return !1;
                            this.store.setAccountId(e)
                        }
                    }
                }, {
                    key: "getAccountId",
                    value: function() {
                        return this.store.getAccountId()
                    }
                }, {
                    key: "logout",
                    value: function() {
                        this._hasDisabled() || this.store.setAccountId(null)
                    }
                }, {
                    key: "setSuperProperties",
                    value: function(e) {
                        this._hasDisabled() || (J.propertiesMust(e) || !this.config.strict ? this.store.setSuperProperties(e) : j.warn("setSuperProperties parameter must be a valid property value"))
                    }
                }, {
                    key: "clearSuperProperties",
                    value: function() {
                        this._hasDisabled() || this.store.setSuperProperties({}, !0)
                    }
                }, {
                    key: "unsetSuperProperty",
                    value: function(e) {
                        if (!this._hasDisabled() && x.isString(e)) {
                            var t = this.getSuperProperties();
                            delete t[e], this.store.setSuperProperties(t, !0)
                        }
                    }
                }, {
                    key: "getSuperProperties",
                    value: function() {
                        return this.store.getSuperProperties()
                    }
                }, {
                    key: "getSendProperties",
                    value: function() {
                        try {
                            var e = x.extend({}, H.properties, this.autoTrackProperties, this.store.getSuperProperties(), this.dynamicProperties ? this.dynamicProperties() : {});
                            for (var t in e) "string" == typeof e[t] && (e[t] = e[t].substring(0, 8192));
                            return e
                        } catch (e) {
                            return {}
                        }
                    }
                }, {
                    key: "getPresetProperties",
                    value: function() {
                        var e = H.properties,
                            t = {},
                            n = e.$system_language;
                        t.system_language = x.isUndefined(n) ? "" : n;
                        var i = e.$os;
                        t.os = x.isUndefined(i) ? "" : i;
                        var r = e.$screen_width;
                        t.screenWidth = x.isUndefined(r) ? 0 : r;
                        var a = e.$screen_height;
                        t.screenHeight = x.isUndefined(a) ? 0 : a;
                        var s = e.$network_type;
                        t.networkType = x.isUndefined(s) ? "" : s;
                        var o = e.$model;
                        t.deviceModel = x.isUndefined(o) ? "" : o;
                        var c = e.$os_version;
                        t.osVersion = x.isUndefined(c) ? "" : c, t.deviceId = this.getDeviceId();
                        var u = 0 - (new Date).getTimezoneOffset() / 60;
                        t.zoneOffset = u;
                        var l = e.$manufacturer;
                        t.manufacturer = x.isUndefined(l) ? "" : l;
                        var p = e.$manufacturer;
                        return t.brand = x.isUndefined(p) ? "" : p, t.toEventPresetProperties = function() {
                            var e, n;
                            return {
                                $app_id: this.appId,
                                $model: t.deviceModel,
                                $screen_width: t.screenWidth,
                                $screen_height: t.screenHeight,
                                $system_language: t.system_language,
                                $os: t.os,
                                $os_version: t.osVersion,
                                $network_type: t.networkType,
                                $manufacturer: t.manufacturer,
                                $brand: t.manufacturer,
                                $scene: String((null === (e = N.getAppOptions()) || void 0 === e ? void 0 : e.scene) || (null === (n = N.getAppOptions()) || void 0 === n ? void 0 : n.from))
                            }
                        }, t
                    }
                }, {
                    key: "setDynamicSuperProperties",
                    value: function(e) {
                        this._hasDisabled() || ("function" == typeof e ? J.properties(e()) || !this.config.strict ? this.dynamicProperties = e : j.warn("A dynamic public property must return a valid property value") : j.warn("setDynamicSuperProperties parameter must be a function type"))
                    }
                }, {
                    key: "timeEvent",
                    value: function(e, t) {
                        this._hasDisabled() || (t = x.isDate(t) ? t : new Date, this._isReady() ? J.event(e) || !this.config.strict ? this.store.setEventTimer(e, t.getTime()) : j.warn("calling timeEvent failed due to invalid eventName: " + e) : this._queue.push(["timeEvent", [e, t]]))
                    }
                }, {
                    key: "getDeviceId",
                    value: function() {
                        return H.properties.$device_id
                    }
                }, {
                    key: "enableTracking",
                    value: function(e) {
                        this.enabled = e, this.store._set("ta_enabled", e)
                    }
                }, {
                    key: "optOutTracking",
                    value: function() {
                        this.store.setSuperProperties({}, !0), this.store.setDistinctId(x.UUID()), this.store.setAccountId(null), this._queue.splice(0, this._queue.length), this.isOptOut = !0, this.store._set("ge_isOptOut", !0)
                    }
                }, {
                    key: "optOutTrackingAndDeleteUser",
                    value: function() {
                        var e = new Date;
                        this._sendRequest({
                            type: "user_del"
                        }, e), this.optOutTracking()
                    }
                }, {
                    key: "optInTracking",
                    value: function() {
                        this.isOptOut = !1, this.store._set("ge_isOptOut", !1)
                    }
                }, {
                    key: "setTrackStatus",
                    value: function(e) {
                        switch (e) {
                            case "PAUSE":
                                this.eventSaveOnly = !1, this.optInTracking(), this.enableTracking(!1);
                                break;
                            case "STOP":
                                this.eventSaveOnly = !1, this.optOutTracking(!0);
                                break;
                            case "SAVE_ONLY":
                            case "NORMAL":
                            default:
                                this.eventSaveOnly = !1, this.optInTracking(), this.enableTracking(!0)
                        }
                    }
                }, {
                    key: "getCommonOpenId",
                    value: function(e, t) {
                        var i = this;
                        return new Promise(function() {
                            var r = a(n().mark((function r(a, s) {
                                var o, c, u;
                                return n().wrap((function(n) {
                                    for (;;) switch (n.prev = n.next) {
                                        case 0:
                                            if (n.prev = 0, e) {
                                                n.next = 3;
                                                break
                                            }
                                            return n.abrupt("return", s("code is required"));
                                        case 3:
                                            return c = "https://backend.gravity-engine.com/event_center/api/v1/base/".concat(t, "/code2Session/?access_token=").concat(i.accessToken), n.next = 6, i.sendNetWork(c, {
                                                code: e
                                            });
                                        case 6:
                                            return u = n.sent, n.abrupt("return", 0 === u.code && null != u && null !== (o = u.data) && void 0 !== o && o.resp ? a(u.data.resp) : s(u));
                                        case 10:
                                            return n.prev = 10, n.t0 = n.catch(0), n.abrupt("return", s(n.t0));
                                        case 13:
                                        case "end":
                                            return n.stop()
                                    }
                                }), r, null, [
                                    [0, 10]
                                ])
                            })));
                            return function(e, t) {
                                return r.apply(this, arguments)
                            }
                        }())
                    }
                }, {
                    key: "getWechatOpenId",
                    value: function(e) {
                        return this.getCommonOpenId(e, "wx")
                    }
                }, {
                    key: "getKuaishouOpenId",
                    value: function(e) {
                        return this.getCommonOpenId(e, "ks")
                    }
                }, {
                    key: "getDouyinOpenId",
                    value: function(e) {
                        return this.getCommonOpenId(e, "dy")
                    }
                }]), e
            }(),
            W = {
                name: "GravityEngine",
                enableLog: !0,
                enableNative: !1
            },
            Q = function() {
                function e(t) {
                    s(this, e), t.appId = x.checkAppId(t.clientId), t.accessToken = t.accessToken, t.appId ? t.accessToken || console.warn("GravityAnalytics: accessToken must be required") : console.warn("GravityAnalytics: clientId must be required"), t.serverUrl = "".concat(m, "/event/collect/?access_token=").concat(t.accessToken);
                    var n = x.extend({}, W);
                    x.isObject(t) ? this.config = x.extend(n, t) : this.config = n, this._init(this.config)
                }
                var t;
                return c(e, [{
                    key: "_isNativePlatform",
                    value: function() {
                        return !(x.isUndefined(this.nativeProxy) || !this._isIOS() && !this._isAndroid() || !this.config.enableNative)
                    }
                }, {
                    key: "_isIOS",
                    value: function() {
                        return "Conch-ios" === conchConfig.getOS()
                    }
                }, {
                    key: "_isAndroid",
                    value: function() {
                        return "Conch-android" === conchConfig.getOS()
                    }
                }, {
                    key: "_init",
                    value: function(e) {
                        this.name = e.name, this.appId = e.clientId, this.accessToken = e.accessToken;
                        var t = e.serverUrl || e.server_url;
                        this.serverUrl = t, this.serverDebugUrl = t + "/data_debug", this.configUrl = t + "/config";
                        try {
                            this._isIOS() ? this.nativeProxy = PlatformClass.createClass("LayaProxyApi") : this._isAndroid() && (this.nativeProxy = PlatformClass.createClass("demo.LayaProxyApi"))
                        } catch (e) {} finally {
                            this._isNativePlatform() ? (this.initInstanceForNative(this.name, e, this.appId), this._readStorage(e)) : this.geJs = new GravityAnalyticsAPIForJS(e)
                        }
                    }
                }, {
                    key: "_readStorage",
                    value: function(e) {
                        var t = this,
                            n = e.persistenceName,
                            i = e.persistenceNameOld;
                        e.isChildInstance && (n = e.persistenceName + "_" + e.name, i = e.persistenceNameOld + "_" + e.name), this._state = N.getStorage(n) || {}, x.isEmptyObject(this._state) && (this._state = N.getStorage(i) || {}), x.isEmptyObject(this._state) ? N.getStorage(n, !0, (function(e) {
                            x.isEmptyObject(e) ? N.getStorage(i, !0, (function(e) {
                                t._state = x.extend2Layers({}, e, t._state)
                            })) : t._state = x.extend2Layers({}, e, t._state), t._state.distinct_id && t.identifyForNative(t._state.distinct_id), t._state.account_id && t.loginForNative(t._state.account_id)
                        })) : (this._state.distinct_id && this.identifyForNative(this._state.distinct_id), this._state.account_id && this.loginForNative(this._state.account_id))
                    }
                }, {
                    key: "initInstance",
                    value: function(e, t) {
                        return this._isNativePlatform() ? (x.isUndefined(t) ? this[e] = new GravityAnalyticsAPI(this.config) : this[e] = new GravityAnalyticsAPI(t), this[e]) : (this[e] = this.geJs.initInstance(e, t), this[e])
                    }
                }, {
                    key: "lightInstance",
                    value: function(e) {
                        return this[e]
                    }
                }, {
                    key: "setupAndStart",
                    value: function() {
                        if (this._isNativePlatform()) {
                            var e = window,
                                t = this;
                            return e.__autoTrackCallback = function(e) {
                                if (x.isFunction(t.config.autoTrack.callback)) {
                                    var n = t.config.autoTrack.callback(e);
                                    return JSON.stringify(n)
                                }
                                return "{}"
                            }, void this.startGravityAnalyticsForNative()
                        }
                        this.geJs.setupAndStart()
                    }
                }, {
                    key: "track",
                    value: function(e, t, n, i) {
                        this._isNativePlatform() ? this.trackForNative(e, t, n, this.appId) : this.geJs.track(e, t, n, i)
                    }
                }, {
                    key: "initializeWithHistoryUserInfo",
                    value: (t = a(n().mark((function e() {
                        var t, i, r = arguments;
                        return n().wrap((function(e) {
                            for (;;) switch (e.prev = e.next) {
                                case 0:
                                    return t = r.length > 0 && void 0 !== r[0] ? r[0] : {}, i = r.length > 1 ? r[1] : void 0, e.abrupt("return", this.geJs.initializeWithHistoryUserInfo(t, i));
                                case 3:
                                case "end":
                                    return e.stop()
                            }
                        }), e, this)
                    }))), function() {
                        return t.apply(this, arguments)
                    })
                }, {
                    key: "initialize",
                    value: function() {
                        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                            t = arguments.length > 1 ? arguments[1] : void 0;
                        if (!this._isNativePlatform()) return this.geJs.initialize(e, t)
                    }
                }, {
                    key: "registerEvent",
                    value: function() {
                        if (!this._isNativePlatform()) return this.geJs.registerEvent()
                    }
                }, {
                    key: "loginEvent",
                    value: function() {
                        if (!this._isNativePlatform()) return this.geJs.loginEvent()
                    }
                }, {
                    key: "logoutEvent",
                    value: function() {
                        if (!this._isNativePlatform()) return this.geJs.logoutEvent()
                    }
                }, {
                    key: "payEvent",
                    value: function(e, t, n, i, r) {
                        if (!this._isNativePlatform()) return this.geJs.payEvent(e, t, n, i, r)
                    }
                }, {
                    key: "adShowEvent",
                    value: function(e, t, n) {
                        if (!this._isNativePlatform()) return this.geJs.adShowEvent(e, t, n)
                    }
                }, {
                    key: "bindTAThirdPlatform",
                    value: function(e, t) {
                        if (!this._isNativePlatform()) return this.geJs.bindTAThirdPlatform(e, t)
                    }
                }, {
                    key: "userSet",
                    value: function(e, t, n) {
                        this._isNativePlatform() ? this.userSetForNative(e, this.appId) : this.geJs.userSet(e, t, n)
                    }
                }, {
                    key: "userSetOnce",
                    value: function(e, t, n) {
                        this._isNativePlatform() ? this.userSetOnceForNative(e, this.appId) : this.geJs.userSetOnce(e, t, n)
                    }
                }, {
                    key: "userUnset",
                    value: function(e, t, n) {
                        this._isNativePlatform() ? this.userUnsetForNative(e, this.appId) : this.geJs.userUnset(e, t, n)
                    }
                }, {
                    key: "userDel",
                    value: function(e, t) {
                        this._isNativePlatform() ? this.userDelForNative(this.appId) : this.geJs.userDel(e, t)
                    }
                }, {
                    key: "userAdd",
                    value: function(e, t, n) {
                        this._isNativePlatform() ? this.userAddForNative(e, this.appId) : this.geJs.userAdd(e, t, n)
                    }
                }, {
                    key: "userNumberMax",
                    value: function(e, t, n) {
                        this._isNativePlatform() || this.geJs.userNumberMax(e, t, n)
                    }
                }, {
                    key: "userNumberMin",
                    value: function(e, t, n) {
                        this._isNativePlatform() || this.geJs.userNumberMin(e, t, n)
                    }
                }, {
                    key: "userAppend",
                    value: function(e, t, n) {
                        this._isNativePlatform() ? this.userAppendForNative(e, this.appId) : this.geJs.userAppend(e, t, n)
                    }
                }, {
                    key: "userUniqAppend",
                    value: function(e, t, n) {
                        this._isNativePlatform() ? this.userUniqAppendForNative(e, this.appId) : this.geJs.userUniqAppend(e, t, n)
                    }
                }, {
                    key: "authorizeOpenID",
                    value: function(e) {
                        this.identify(e)
                    }
                }, {
                    key: "identify",
                    value: function(e) {
                        this._isNativePlatform() ? this.identifyForNative(e, this.appId) : this.geJs.identify(e)
                    }
                }, {
                    key: "getDistinctId",
                    value: function(e) {
                        if (!x.isUndefined(e)) {
                            if (this._isNativePlatform()) return void this.getDistinctIdForNative(e, this.appId);
                            e(this.geJs.getDistinctId())
                        }
                        return this.geJs.getDistinctId()
                    }
                }, {
                    key: "login",
                    value: function(e) {
                        this._isNativePlatform() ? this.loginForNative(e, this.appId) : this.geJs.login(e)
                    }
                }, {
                    key: "getAccountId",
                    value: function(e) {
                        if (!x.isUndefined(e)) {
                            if (this._isNativePlatform()) return void this.getAccountIdForNative(e, this.appId);
                            e(this.geJs.getAccountId())
                        }
                        return this.geJs.getAccountId()
                    }
                }, {
                    key: "logout",
                    value: function() {
                        this._isNativePlatform() ? this.logoutForNative(this.appId) : this.geJs.logout()
                    }
                }, {
                    key: "setSuperProperties",
                    value: function(e) {
                        this._isNativePlatform() ? this.setSuperPropertiesForNative(e, this.appId) : this.geJs.setSuperProperties(e)
                    }
                }, {
                    key: "clearSuperProperties",
                    value: function() {
                        this._isNativePlatform() ? this.clearSuperPropertiesForNative(this.appId) : this.geJs.clearSuperProperties()
                    }
                }, {
                    key: "unsetSuperProperty",
                    value: function(e) {
                        this._isNativePlatform() ? this.unsetSuperPropertyForNative(e, this.appId) : this.geJs.unsetSuperProperty(e)
                    }
                }, {
                    key: "getSuperProperties",
                    value: function(e) {
                        if (!x.isUndefined(e)) {
                            if (this._isNativePlatform()) return void this.getSuperPropertiesForNative(e, this.appId);
                            e(this.geJs.getSuperProperties())
                        }
                        return this.geJs.getSuperProperties()
                    }
                }, {
                    key: "getPresetProperties",
                    value: function(e) {
                        if (!x.isUndefined(e)) {
                            if (this._isNativePlatform()) return void this.getPresetPropertiesForNative(e, this.appId);
                            e(this.geJs.getPresetProperties())
                        }
                        return this.geJs.getPresetProperties()
                    }
                }, {
                    key: "setDynamicSuperProperties",
                    value: function(e) {
                        this._isNativePlatform() ? "function" == typeof e ? this.dynamicProperties = e : j.warn("setDynamicSuperProperties parameter must be a function type") : this.geJs.setDynamicSuperProperties(e)
                    }
                }, {
                    key: "timeEvent",
                    value: function(e, t) {
                        return this._isNativePlatform() ? this.timeEventForNative(e, this.appId) : this.geJs.timeEvent(e, t)
                    }
                }, {
                    key: "getDeviceId",
                    value: function(e) {
                        if (!x.isUndefined(e)) {
                            if (this._isNativePlatform()) return void this.getDeviceIdForNative(e, this.appId);
                            e(this.geJs.getDeviceId())
                        }
                        return this.geJs.getDeviceId()
                    }
                }, {
                    key: "enableTracking",
                    value: function(e) {
                        this._isNativePlatform() ? this.enableTrackingForNative(e, this.appId) : this.geJs.enableTracking(e)
                    }
                }, {
                    key: "optOutTracking",
                    value: function() {
                        this._isNativePlatform() ? this.optOutTrackingForNative(this.appId) : this.geJs.optOutTracking()
                    }
                }, {
                    key: "optOutTrackingAndDeleteUser",
                    value: function() {
                        this._isNativePlatform() ? this.optOutTrackingAndDeleteUserForNative(this.appId) : this.geJs.optOutTrackingAndDeleteUser()
                    }
                }, {
                    key: "optInTracking",
                    value: function() {
                        this._isNativePlatform() ? this.optInTrackingForNative(this.appId) : this.geJs.optInTracking()
                    }
                }, {
                    key: "setTrackStatus",
                    value: function(e) {
                        this._isNativePlatform() ? this.setTrackStatusForNative(e, this.appId) : this.geJs.setTrackStatus(e)
                    }
                }, {
                    key: "trackForNative",
                    value: function(e, t, n, i) {
                        var r = x.isDate(n) ? x.formatDate(n) : "";
                        e = x.isUndefined(e) ? "" : e, t = x.isUndefined(t) ? {} : t, r = x.isUndefined(r) ? "" : r, i = x.isUndefined(i) ? "" : i;
                        var a = x.extend(t, this.dynamicProperties ? this.dynamicProperties() : {});
                        a = x.encodeDates(a), this._isIOS() ? this.nativeProxy.call("track:properties:time:appId:", e, JSON.stringify(a), r, i) : this._isAndroid() && this.nativeProxy.call("track", e, JSON.stringify(a), r, i)
                    }
                }, {
                    key: "timeEventForNative",
                    value: function(e, t) {
                        e = x.isUndefined(e) ? "" : e, t = x.isUndefined(t) ? "" : t, this._isIOS() ? this.nativeProxy.call("timeEvent:appId:", e, t) : this._isAndroid() && this.nativeProxy.call("timeEvent", e, t)
                    }
                }, {
                    key: "loginForNative",
                    value: function(e, t) {
                        e = x.isUndefined(e) ? "" : e, t = x.isUndefined(t) ? "" : t, this._isIOS() ? this.nativeProxy.call("login:appId:", e, t) : this._isAndroid() && this.nativeProxy.call("login", e, t)
                    }
                }, {
                    key: "logoutForNative",
                    value: function(e) {
                        e = x.isUndefined(e) ? "" : e, this._isIOS() ? this.nativeProxy.call("logout:", e) : this._isAndroid() && this.nativeProxy.call("logout", e)
                    }
                }, {
                    key: "setSuperPropertiesForNative",
                    value: function(e, t) {
                        e = x.isUndefined(e) ? {} : e, t = x.isUndefined(t) ? "" : t, e = x.encodeDates(e), this._isIOS() ? this.nativeProxy.call("setSuperProperties:appId:", JSON.stringify(e), t) : this._isAndroid() && this.nativeProxy.call("setSuperProperties", JSON.stringify(e), t)
                    }
                }, {
                    key: "getSuperPropertiesForNative",
                    value: function(e, t) {
                        t = x.isUndefined(t) ? "" : t, this._isIOS() ? this.nativeProxy.callWithBack((function(t) {
                            e(JSON.parse(t))
                        }), "getSuperProperties:", t) : this._isAndroid() && this.nativeProxy.callWithBack((function(t) {
                            e(JSON.parse(t))
                        }), "getSuperProperties", t)
                    }
                }, {
                    key: "unsetSuperPropertyForNative",
                    value: function(e, t) {
                        e = x.isUndefined(e) ? "" : e, t = x.isUndefined(t) ? "" : t, this._isIOS() ? this.nativeProxy.call("unsetSuperProperty:appId:", e, t) : this._isAndroid() && this.nativeProxy.call("unsetSuperProperty", e, t)
                    }
                }, {
                    key: "clearSuperPropertiesForNative",
                    value: function(e) {
                        e = x.isUndefined(e) ? "" : e, this._isIOS() ? this.nativeProxy.call("clearSuperProperties:", e) : this._isAndroid() && this.nativeProxy.call("clearSuperProperties", e)
                    }
                }, {
                    key: "userSetForNative",
                    value: function(e, t) {
                        e = x.isUndefined(e) ? {} : e, t = x.isUndefined(t) ? "" : t, e = x.encodeDates(e), this._isIOS() ? this.nativeProxy.call("userSet:appId:", JSON.stringify(e), t) : this._isAndroid() && this.nativeProxy.call("userSet", JSON.stringify(e), t)
                    }
                }, {
                    key: "userSetOnceForNative",
                    value: function(e, t) {
                        e = x.isUndefined(e) ? {} : e, t = x.isUndefined(t) ? "" : t, e = x.encodeDates(e), this._isIOS() ? this.nativeProxy.call("userSetOnce:appId:", JSON.stringify(e), t) : this._isAndroid() && this.nativeProxy.call("userSetOnce", JSON.stringify(e), t)
                    }
                }, {
                    key: "userAppendForNative",
                    value: function(e, t) {
                        e = x.isUndefined(e) ? {} : e, t = x.isUndefined(t) ? "" : t, e = x.encodeDates(e), this._isIOS() ? this.nativeProxy.call("userAppend:appId:", JSON.stringify(e), t) : this._isAndroid() && this.nativeProxy.call("userAppend", JSON.stringify(e), t)
                    }
                }, {
                    key: "userUniqAppendForNative",
                    value: function(e, t) {
                        e = x.isUndefined(e) ? {} : e, t = x.isUndefined(t) ? "" : t, e = x.encodeDates(e), this._isIOS() ? this.nativeProxy.call("userUniqAppend:appId:", JSON.stringify(e), t) : this._isAndroid() && this.nativeProxy.call("userUniqAppend", JSON.stringify(e), t)
                    }
                }, {
                    key: "userAddForNative",
                    value: function(e, t) {
                        e = x.isUndefined(e) ? {} : e, t = x.isUndefined(t) ? "" : t, e = x.encodeDates(e), this._isIOS() ? this.nativeProxy.call("userAdd:appId:", JSON.stringify(e), t) : this._isAndroid() && this.nativeProxy.call("userAdd", JSON.stringify(e), t)
                    }
                }, {
                    key: "userUnsetForNative",
                    value: function(e, t) {
                        e = x.isUndefined(e) ? "" : e, t = x.isUndefined(t) ? "" : t, this._isIOS() ? this.nativeProxy.call("userUnset:appId:", e, t) : this._isAndroid() && this.nativeProxy.call("userUnset", e, t)
                    }
                }, {
                    key: "userDelForNative",
                    value: function(e) {
                        e = x.isUndefined(e) ? "" : e, this._isIOS() ? this.nativeProxy.call("userDel:", e) : this._isAndroid() && this.nativeProxy.call("userDel", e)
                    }
                }, {
                    key: "authorizeOpenIDForNative",
                    value: function(e, t) {
                        this.identifyForNative(e, t)
                    }
                }, {
                    key: "identifyForNative",
                    value: function(e, t) {
                        e = x.isUndefined(e) ? "" : e, t = x.isUndefined(t) ? "" : t, this._isIOS() ? this.nativeProxy.call("identify:appId:", e, t) : this._isAndroid() && this.nativeProxy.call("identify", e, t)
                    }
                }, {
                    key: "initInstanceForNative",
                    value: function(e, t, n) {
                        e = x.isUndefined(e) ? "" : e, t = x.isUndefined(t) ? {} : t, n = x.isUndefined(n) ? "" : n, this._isIOS() ? (this.nativeProxy.call("setCustomerLibInfoWithLibName:libVersion:", v, d), x.isUndefined(t) ? this.nativeProxy.call("initInstance:appId:", e, n) : this.nativeProxy.call("initInstance:config:", e, JSON.stringify(t))) : this._isAndroid() && (this.nativeProxy.call("setCustomerLibInfo", v, d), x.isUndefined(t) ? this.nativeProxy.call("initInstanceAppId", e, n) : this.nativeProxy.call("initInstanceConfig", e, JSON.stringify(t)))
                    }
                }, {
                    key: "lightInstanceForNative",
                    value: function(e, t, n) {
                        e = x.isUndefined(e) ? "" : e, t = x.isUndefined(t) ? "" : t, this._isIOS() ? this.nativeProxy.callWithBack((function(e) {
                            n(e)
                        }), "lightInstance:appId:", e, t) : this._isAndroid() && this.nativeProxy.callWithBack((function(e) {
                            n(e)
                        }), "lightInstance", e, t)
                    }
                }, {
                    key: "startGravityAnalyticsForNative",
                    value: function(e) {
                        e = x.isUndefined(e) ? "" : e, this._isIOS() ? this.nativeProxy.call("startGravityAnalytics:", e) : this._isAndroid() && this.nativeProxy.call("startGravityAnalytics", e)
                    }
                }, {
                    key: "getDeviceIdForNative",
                    value: function(e, t) {
                        t = x.isUndefined(t) ? "" : t, this._isIOS() ? this.nativeProxy.callWithBack((function(t) {
                            e(t)
                        }), "getDeviceId:", t) : this._isAndroid() && this.nativeProxy.callWithBack((function(t) {
                            e(t)
                        }), "getDeviceId", t)
                    }
                }, {
                    key: "getDistinctIdForNative",
                    value: function(e, t) {
                        t = x.isUndefined(t) ? "" : t, this._isIOS() ? this.nativeProxy.callWithBack((function(t) {
                            e(t)
                        }), "getDistinctId:", t) : this._isAndroid() && this.nativeProxy.callWithBack((function(t) {
                            e(t)
                        }), "getDistinctId", t)
                    }
                }, {
                    key: "getAccountIdForNative",
                    value: function(e, t) {
                        t = x.isUndefined(t) ? "" : t, this._isIOS() ? this.nativeProxy.callWithBack((function(t) {
                            e(t)
                        }), "getAccountId:", t) : this._isAndroid() && this.nativeProxy.callWithBack((function(t) {
                            e(t)
                        }), "getAccountId", t)
                    }
                }, {
                    key: "getPresetPropertiesForNative",
                    value: function(e, t) {
                        function n(t) {
                            var n = JSON.parse(t),
                                i = {},
                                r = n.$system_language;
                            i.system_language = x.isUndefined(r) ? "" : r;
                            var a = n.$os;
                            i.os = x.isUndefined(a) ? "" : a;
                            var s = n.$screen_width;
                            i.screenWidth = x.isUndefined(s) ? 0 : s;
                            var o = n.$screen_height;
                            i.screenHeight = x.isUndefined(o) ? 0 : o;
                            var c = n.$network_type;
                            i.networkType = x.isUndefined(c) ? "" : c;
                            var u = n.$device_model;
                            i.deviceModel = x.isUndefined(u) ? "" : u;
                            var l = n.$os_version;
                            i.osVersion = x.isUndefined(l) ? "" : l;
                            var p = n.$device_id;
                            i.deviceId = x.isUndefined(p) ? "" : p;
                            var f = n.$zone_offset;
                            i.zoneOffset = x.isUndefined(f) ? "" : f;
                            var h = n.$manufacturer;
                            i.manufacturer = x.isUndefined(h) ? "" : h;
                            var d = n.$manufacturer;
                            i.brand = x.isUndefined(d) ? "" : d, i.toEventPresetProperties = function() {
                                return {
                                    $device_model: i.deviceModel,
                                    $device_id: i.deviceId,
                                    $screen_width: i.screenWidth,
                                    $screen_height: i.screenHeight,
                                    $system_language: i.system_language,
                                    $os: i.os,
                                    $os_version: i.osVersion,
                                    $network_type: i.networkType,
                                    $zone_offset: i.zoneOffset,
                                    $manufacturer: i.manufacturer,
                                    $brand: i.manufacturer
                                }
                            }, e(i)
                        }
                        t = x.isUndefined(t) ? "" : t, this._isIOS() ? this.nativeProxy.callWithBack(n, "getPresetProperties:", t) : this._isAndroid() && this.nativeProxy.callWithBack(n, "getPresetProperties", t)
                    }
                }, {
                    key: "enableTrackingForNative",
                    value: function(e, t) {
                        e = !x.isUndefined(e) && e, t = x.isUndefined(t) ? "" : t, this._isIOS() ? this.nativeProxy.call("enableTracking:appId:", e.toString(), t) : this._isAndroid() && this.nativeProxy.call("enableTracking", e.toString(), t)
                    }
                }, {
                    key: "optOutTrackingForNative",
                    value: function(e) {
                        e = x.isUndefined(e) ? "" : e, this._isIOS() ? this.nativeProxy.call("optOutTracking:", e) : this._isAndroid() && this.nativeProxy.call("optOutTracking", e)
                    }
                }, {
                    key: "optOutTrackingAndDeleteUserForNative",
                    value: function(e) {
                        e = x.isUndefined(e) ? "" : e, this._isIOS() ? this.nativeProxy.call("optOutTrackingAndDeleteUser:", e) : this._isAndroid() && this.nativeProxy.call("optOutTrackingAndDeleteUser", e)
                    }
                }, {
                    key: "optInTrackingForNative",
                    value: function(e) {
                        e = x.isUndefined(e) ? "" : e, this._isIOS() ? this.nativeProxy.call("optInTracking:", e) : this._isAndroid() && this.nativeProxy.call("optInTracking", e)
                    }
                }, {
                    key: "setTrackStatusForNative",
                    value: function(e, t) {
                        t = x.isUndefined(t) ? "" : t, this._isIOS() ? this.nativeProxy.call("setTrackStatus:appId:", e, t) : this._isAndroid() && this.nativeProxy.call("setTrackStatus", e, t)
                    }
                }, {
                    key: "getWechatOpenId",
                    value: function(e) {
                        return this._isNativePlatform() ? new Promise((function(e, t) {
                            t("方法暂时不支持原生")
                        })) : this.geJs.getWechatOpenId(e)
                    }
                }, {
                    key: "getKuaishouOpenId",
                    value: function(e) {
                        return this._isNativePlatform() ? new Promise((function(e, t) {
                            t("方法暂时不支持原生")
                        })) : this.geJs.getKuaishouOpenId(e)
                    }
                }, {
                    key: "getDouyinOpenId",
                    value: function(e) {
                        return this._isNativePlatform() ? new Promise((function(e, t) {
                            t("方法暂时不支持原生")
                        })) : this.geJs.getDouyinOpenId(e)
                    }
                }]), e
            }();
        return window.GravityAnalyticsAPI = Q, window.GravityAnalyticsAPIForJS = z, Q
    }, "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = e || self).gravityengine = t();

});
define("libs/min/laya.ani.min.js", function(require, module, exports) {
    ! function(t, e) {
        "use strict";
        class i {}
        i.Skeleton = null, i.AnimationTemplet = null, i.Templet = null;
        class a {}
        class r {}
        class s {}
        class n {
            static parse(t, n) {
                var h, l, o, u, _, p, d, c = n.__getBuffer(),
                    m = n.readUTFString();
                t._aniClassName = m;
                var x, y = n.readUTFString().split("\n"),
                    g = n.getUint8(),
                    f = n.getUint32(),
                    M = n.getUint32();
                f > 0 && (x = c.slice(f, M));
                var D = new e.Byte(x);
                for (M > 0 && (t._publicExtData = c.slice(M, c.byteLength)), t._useParent = !!n.getUint8(), t._anis.length = g, h = 0; h < g; h++) {
                    var v = t._anis[h] = new a;
                    v.nodes = [];
                    var I = v.name = y[n.getUint16()];
                    t._aniMap[I] = h, v.bone3DMap = {}, v.playTime = n.getFloat32();
                    var A = v.nodes.length = n.getUint8();
                    for (v.totalKeyframeDatasLength = 0, l = 0; l < A; l++) {
                        var T = v.nodes[l] = new r;
                        T.childs = [];
                        var S = n.getInt16();
                        S >= 0 && (T.name = y[S], v.bone3DMap[T.name] = l), T.keyFrame = [], T.parentIndex = n.getInt16(), -1 == T.parentIndex ? T.parent = null : T.parent = v.nodes[T.parentIndex], T.lerpType = n.getUint8();
                        var b = n.getUint32();
                        D.pos = b;
                        var C = T.keyframeWidth = D.getUint16();
                        if (v.totalKeyframeDatasLength += C, 0 === T.lerpType || 1 === T.lerpType)
                            for (T.interpolationMethod = [], T.interpolationMethod.length = C, o = 0; o < C; o++) T.interpolationMethod[o] = i.AnimationTemplet.interpolation[D.getUint8()];
                        null != T.parent && T.parent.childs.push(T);
                        var F = n.getUint16();
                        F > 0 && (T.extenData = c.slice(n.pos, n.pos + F), n.pos += F);
                        var w = n.getUint16();
                        T.keyFrame.length = w;
                        var k, P = 0;
                        for (o = 0, u = w; o < u; o++) {
                            if ((k = T.keyFrame[o] = new s).duration = n.getFloat32(), k.startTime = P, 2 === T.lerpType) {
                                k.interpolationData = [];
                                var L, U = n.getUint8();
                                switch (L = n.getFloat32()) {
                                    case 254:
                                        for (k.interpolationData.length = C, d = 0; d < C; d++) k.interpolationData[d] = 0;
                                        break;
                                    case 255:
                                        for (k.interpolationData.length = C, d = 0; d < C; d++) k.interpolationData[d] = 5;
                                        break;
                                    default:
                                        for (k.interpolationData.push(L), p = 1; p < U; p++) k.interpolationData.push(n.getFloat32())
                                }
                            }
                            for (k.data = new Float32Array(C), k.dData = new Float32Array(C), k.nextData = new Float32Array(C), _ = 0; _ < C; _++) k.data[_] = n.getFloat32(), k.data[_] > -1e-8 && k.data[_] < 1e-8 && (k.data[_] = 0);
                            P += k.duration
                        }
                        k.startTime = v.playTime, T.playTime = v.playTime, t._calculateKeyFrame(T, w, C)
                    }
                }
            }
        }
        class h {
            static READ_DATA() {
                h._DATA.offset = h._reader.getUint32(), h._DATA.size = h._reader.getUint32()
            }
            static READ_BLOCK() {
                for (var t = h._BLOCK.count = h._reader.getUint16(), e = h._BLOCK.blockStarts = [], i = h._BLOCK.blockLengths = [], a = 0; a < t; a++) e.push(h._reader.getUint32()), i.push(h._reader.getUint32())
            }
            static READ_STRINGS() {
                var t = h._reader.getUint32(),
                    e = h._reader.getUint16(),
                    i = h._reader.pos;
                h._reader.pos = t + h._DATA.offset;
                for (var a = 0; a < e; a++) h._strings[a] = h._reader.readUTFString();
                h._reader.pos = i
            }
            static parse(t, e) {
                h._templet = t, h._reader = e;
                e.__getBuffer();
                h.READ_DATA(), h.READ_BLOCK(), h.READ_STRINGS();
                for (var i = 0, a = h._BLOCK.count; i < a; i++) {
                    var r = e.getUint16(),
                        s = h._strings[r],
                        n = h["READ_" + s];
                    if (null == n) throw new Error("model file err,no this function:" + r + " " + s);
                    n.call(null)
                }
            }
            static READ_ANIMATIONS() {
                var t, e, n, l, o = h._reader,
                    u = o.__getBuffer(),
                    _ = o.getUint16(),
                    p = [];
                for (p.length = _, t = 0; t < _; t++) p[t] = i.AnimationTemplet.interpolation[o.getByte()];
                var d = o.getUint8();
                for (h._templet._anis.length = d, t = 0; t < d; t++) {
                    var c = h._templet._anis[t] = new a;
                    c.nodes = [];
                    var m = c.name = h._strings[o.getUint16()];
                    h._templet._aniMap[m] = t, c.bone3DMap = {}, c.playTime = o.getFloat32();
                    var x = c.nodes.length = o.getInt16();
                    for (c.totalKeyframeDatasLength = 0, e = 0; e < x; e++) {
                        var y = c.nodes[e] = new r;
                        y.keyframeWidth = _, y.childs = [];
                        var g = o.getUint16();
                        g >= 0 && (y.name = h._strings[g], c.bone3DMap[y.name] = e), y.keyFrame = [], y.parentIndex = o.getInt16(), -1 == y.parentIndex ? y.parent = null : y.parent = c.nodes[y.parentIndex], c.totalKeyframeDatasLength += _, y.interpolationMethod = p, null != y.parent && y.parent.childs.push(y);
                        var f = o.getUint16();
                        y.keyFrame.length = f;
                        var M = null,
                            D = null;
                        for (n = 0, l = f; n < l; n++) {
                            (M = y.keyFrame[n] = new s).startTime = o.getFloat32(), D && (D.duration = M.startTime - D.startTime), M.dData = new Float32Array(_), M.nextData = new Float32Array(_);
                            var v = h._DATA.offset,
                                I = o.getUint32(),
                                A = 4 * _,
                                T = u.slice(v + I, v + I + A);
                            M.data = new Float32Array(T), D = M
                        }
                        M.duration = 0, y.playTime = c.playTime, h._templet._calculateKeyFrame(y, f, _)
                    }
                }
            }
        }
        h._strings = [], h._BLOCK = {
            count: 0
        }, h._DATA = {
            offset: 0,
            size: 0
        };
        class l {
            constructor() {}
        }
        l.stopped = 0, l.paused = 1, l.playing = 2;
        class o extends e.EventDispatcher {
            constructor() {
                super(), this.isCache = !0, this.playbackRate = 1, this._destroyed = !1, this._currentAnimationClipIndex = -1, this._currentKeyframeIndex = -1, this._currentTime = 0, this._overallDuration = Number.MAX_VALUE, this._stopWhenCircleFinish = !1, this._elapsedPlaybackTime = 0, this._startUpdateLoopCount = -1, this._cachePlayRate = 1, this.cacheFrameRate = 60, this.returnToZeroStopped = !1
            }
            get templet() {
                return this._templet
            }
            set templet(t) {
                this.state !== l.stopped && this.stop(!0), this._templet !== t && (this._templet = t, this._computeFullKeyframeIndices())
            }
            get playStart() {
                return this._playStart
            }
            get playEnd() {
                return this._playEnd
            }
            get playDuration() {
                return this._playDuration
            }
            get overallDuration() {
                return this._overallDuration
            }
            get currentAnimationClipIndex() {
                return this._currentAnimationClipIndex
            }
            get currentKeyframeIndex() {
                return this._currentKeyframeIndex
            }
            get currentPlayTime() {
                return this._currentTime + this._playStart
            }
            get currentFrameTime() {
                return this._currentFrameTime
            }
            get cachePlayRate() {
                return this._cachePlayRate
            }
            set cachePlayRate(t) {
                this._cachePlayRate !== t && (this._cachePlayRate = t, this._templet && this._computeFullKeyframeIndices())
            }
            get cacheFrameRate() {
                return this._cacheFrameRate
            }
            set cacheFrameRate(t) {
                this._cacheFrameRate !== t && (this._cacheFrameRate = t, this._cacheFrameRateInterval = 1e3 / this._cacheFrameRate, this._templet && this._computeFullKeyframeIndices())
            }
            set currentTime(t) {
                if (-1 !== this._currentAnimationClipIndex && this._templet) {
                    if (t < this._playStart || t > this._playEnd) throw new Error("AnimationPlayer:value must large than playStartTime,small than playEndTime.");
                    this._startUpdateLoopCount = e.Stat.loopCount;
                    var i = this._cacheFrameRateInterval * this._cachePlayRate;
                    this._currentTime = t, this._currentKeyframeIndex = Math.floor(this.currentPlayTime / i), this._currentFrameTime = this._currentKeyframeIndex * i
                }
            }
            get paused() {
                return this._paused
            }
            set paused(t) {
                this._paused = t, t && this.event(e.Event.PAUSED)
            }
            get cacheFrameRateInterval() {
                return this._cacheFrameRateInterval
            }
            get state() {
                return -1 === this._currentAnimationClipIndex ? l.stopped : this._paused ? l.paused : l.playing
            }
            get destroyed() {
                return this._destroyed
            }
            _onTempletLoadedComputeFullKeyframeIndices(t, e, i) {
                this._templet === i && this._cachePlayRate === t && this._cacheFrameRate === e && this._computeFullKeyframeIndices()
            }
            _computeFullKeyframeIndices() {}
            _onAnimationTempletLoaded() {
                this.destroyed || this._calculatePlayDuration()
            }
            _calculatePlayDuration() {
                if (this.state !== l.stopped) {
                    var t = this._templet.getAniDuration(this._currentAnimationClipIndex);
                    0 === this._playEnd && (this._playEnd = t), this._playEnd > t && (this._playEnd = t), this._playDuration = this._playEnd - this._playStart
                }
            }
            _setPlayParams(t, e) {
                this._currentTime = t, this._currentKeyframeIndex = Math.floor(this.currentPlayTime / e + .01), this._currentFrameTime = this._currentKeyframeIndex * e
            }
            _setPlayParamsWhenStop(t, e, i = -1) {
                this._currentTime = t;
                var a = i > 0 ? i : t;
                this._currentKeyframeIndex = Math.floor(a / e + .01), this._currentKeyframeIndex = Math.floor(t / e + .01), this._currentFrameTime = this._currentKeyframeIndex * e, this._currentAnimationClipIndex = -1
            }
            _update(t) {
                if (-1 !== this._currentAnimationClipIndex && !this._paused && this._templet) {
                    var i = this._cacheFrameRateInterval * this._cachePlayRate,
                        a = 0;
                    this._startUpdateLoopCount !== e.Stat.loopCount && (a = t * this.playbackRate, this._elapsedPlaybackTime += a);
                    var r = this.playDuration;
                    if (a += this._currentTime, 0 !== this._overallDuration && this._elapsedPlaybackTime >= this._overallDuration || 0 === this._overallDuration && this._elapsedPlaybackTime >= r || 0 === this._overallDuration && a >= this.playEnd) return this._setPlayParamsWhenStop(r, i, this.playEnd), void this.event(e.Event.STOPPED);
                    if (r > 0) {
                        if (a >= r) return this._stopWhenCircleFinish ? (this._setPlayParamsWhenStop(r, i), this._stopWhenCircleFinish = !1, void this.event(e.Event.STOPPED)) : (a %= r, this._setPlayParams(a, i), void this.event(e.Event.COMPLETE));
                        this._setPlayParams(a, i)
                    } else {
                        if (this._stopWhenCircleFinish) return this._setPlayParamsWhenStop(r, i), this._stopWhenCircleFinish = !1, void this.event(e.Event.STOPPED);
                        this._currentTime = this._currentFrameTime = this._currentKeyframeIndex = 0, this.event(e.Event.COMPLETE)
                    }
                }
            }
            _destroy() {
                this.offAll(), this._templet = null, this._destroyed = !0
            }
            play(t = 0, i = 1, a = 2147483647, r = 0, s = 0) {
                if (!this._templet) throw new Error("AnimationPlayer:templet must not be null,maybe you need to set url.");
                if (a < 0 || r < 0 || s < 0) throw new Error("AnimationPlayer:overallDuration,playStart and playEnd must large than zero.");
                if (0 !== s && r > s) throw new Error("AnimationPlayer:start must less than end.");
                this._currentTime = 0, this._currentFrameTime = 0, this._elapsedPlaybackTime = 0, this.playbackRate = i, this._overallDuration = a, this._playStart = r, this._playEnd = s, this._paused = !1, this._currentAnimationClipIndex = t, this._currentKeyframeIndex = 0, this._startUpdateLoopCount = e.Stat.loopCount, this.event(e.Event.PLAYED), this._calculatePlayDuration(), this._update(0)
            }
            playByFrame(t = 0, e = 1, i = 2147483647, a = 0, r = 0, s = 30) {
                var n = 1e3 / s;
                this.play(t, e, i, a * n, r * n)
            }
            stop(t = !0) {
                t ? (this._currentTime = this._currentFrameTime = this._currentKeyframeIndex = 0, this._currentAnimationClipIndex = -1, this.event(e.Event.STOPPED)) : this._stopWhenCircleFinish = !0
            }
            destroy() {}
        }
        class u {
            constructor() {}
            static getBezierRate(t, e, i, a, r) {
                var s = u._getBezierParamKey(e, i, a, r),
                    n = 100 * s + t;
                if (u._bezierResultCache[n]) return u._bezierResultCache[n];
                var h, l, o = u._getBezierPoints(e, i, a, r, s);
                for (l = o.length, h = 0; h < l; h += 2)
                    if (t <= o[h]) return u._bezierResultCache[n] = o[h + 1], o[h + 1];
                return u._bezierResultCache[n] = 1, 1
            }
            static _getBezierParamKey(t, e, i, a) {
                return 100 * (100 * (100 * (100 * t + e) + i) + a)
            }
            static _getBezierPoints(t, i, a, r, s) {
                return u._bezierPointsCache[s] ? u._bezierPointsCache[s] : (n = [0, 0, t, i, a, r, 1, 1], h = (new e.Bezier).getBezierPoints(n, 100, 3), u._bezierPointsCache[s] = h, h);
                var n, h
            }
        }
        u._bezierResultCache = {}, u._bezierPointsCache = {};
        class _ extends e.Resource {
            constructor() {
                super(), this._anis = [], this._aniMap = {}, this.unfixedLastAniIndex = -1, this._fullFrames = null, this._boneCurKeyFrm = []
            }
            static _LinearInterpolation_0(t, e, i, a, r, s, n, h, l, o = null) {
                return i[a] = r[e] + s * n[e], 1
            }
            static _QuaternionInterpolation_1(t, i, a, r, s, n, h, l, o, u = null) {
                var _ = 0 === l ? 0 : n / l;
                return e.MathUtil.slerpQuaternionArray(s, i, o, i, _, a, r), 4
            }
            static _AngleInterpolation_2(t, e, i, a, r, s, n, h, l, o = null) {
                return 0
            }
            static _RadiansInterpolation_3(t, e, i, a, r, s, n, h, l, o = null) {
                return 0
            }
            static _Matrix4x4Interpolation_4(t, e, i, a, r, s, n, h, l, o = null) {
                for (var u = 0; u < 16; u++, e++) i[a + u] = r[e] + s * n[e];
                return 16
            }
            static _NoInterpolation_5(t, e, i, a, r, s, n, h, l, o = null) {
                return i[a] = r[e], 1
            }
            static _BezierInterpolation_6(t, e, i, a, r, s, n, h, l, o = null, _ = 0) {
                return i[a] = r[e] + (l[e] - r[e]) * u.getBezierRate(s / h, o[_], o[_ + 1], o[_ + 2], o[_ + 3]), 5
            }
            static _BezierInterpolation_7(t, e, i, a, r, s, n, h, l, o = null, _ = 0) {
                return i[a] = o[_ + 4] + o[_ + 5] * u.getBezierRate((.001 * s + o[_ + 6]) / o[_ + 7], o[_], o[_ + 1], o[_ + 2], o[_ + 3]), 9
            }
            parse(t) {
                var i = new e.Byte(t);
                this._aniVersion = i.readUTFString(), n.parse(this, i)
            }
            _calculateKeyFrame(t, e, i) {
                var a = t.keyFrame;
                a[e] = a[0];
                for (var r = 0; r < e; r++)
                    for (var s = a[r], n = 0; n < i; n++) s.dData[n] = 0 === s.duration ? 0 : (a[r + 1].data[n] - s.data[n]) / s.duration, s.nextData[n] = a[r + 1].data[n];
                a.length--
            }
            _onAsynLoaded(t, i = null) {
                var a = new e.Byte(t);
                if (this._aniVersion = a.readUTFString(), "LAYAANIMATION:02" === this._aniVersion) h.parse(this, a);
                else n.parse(this, a)
            }
            getAnimationCount() {
                return this._anis.length
            }
            getAnimation(t) {
                return this._anis[t]
            }
            getAniDuration(t) {
                return this._anis[t].playTime
            }
            getNodes(t) {
                return this._anis[t].nodes
            }
            getNodeIndexWithName(t, e) {
                return this._anis[t].bone3DMap[e]
            }
            getNodeCount(t) {
                return this._anis[t].nodes.length
            }
            getTotalkeyframesLength(t) {
                return this._anis[t].totalKeyframeDatasLength
            }
            getPublicExtData() {
                return this._publicExtData
            }
            getAnimationDataWithCache(t, e, i, a) {
                var r = e[i];
                if (r) {
                    var s = r[t];
                    return s ? s[a] : null
                }
                return null
            }
            setAnimationDataWithCache(t, e, i, a, r) {
                var s = e[i] || (e[i] = {});
                (s[t] || (s[t] = []))[a] = r
            }
            getNodeKeyFrame(t, e, i) {
                var a = this._boneCurKeyFrm[e],
                    r = t.length;
                (null == a || a >= r) && (a = this._boneCurKeyFrm[e] = 0);
                var s = t[a],
                    n = i - s.startTime;
                if (0 == n || n > 0 && s.duration > n) return a;
                var h = 0;
                if (n > 0) {
                    for (i += .01, h = a + 1; h < r; h++)
                        if ((s = t[h]).startTime <= i && s.startTime + s.duration > i) return this._boneCurKeyFrm[e] = h, h;
                    return r - 1
                }
                for (h = 0; h < a; h++)
                    if ((s = t[h]).startTime <= i && s.startTime + s.duration > i) return this._boneCurKeyFrm[e] = h, h;
                return a
            }
            getOriginalData(t, e, i, a, r) {
                var s = this._anis[t].nodes,
                    n = this._boneCurKeyFrm;
                n.length < s.length && (n.length = s.length);
                for (var h = 0, l = 0, o = s.length, u = 0; l < o; l++) {
                    var p, d = s[l],
                        c = d.keyFrame;
                    p = c[this.getNodeKeyFrame(c, l, r)], d.dataOffset = u;
                    var m = r - p.startTime,
                        x = d.lerpType;
                    if (x) switch (x) {
                        case 0:
                        case 1:
                            for (h = 0; h < d.keyframeWidth;) h += d.interpolationMethod[h](d, h, e, u + h, p.data, m, p.dData, p.duration, p.nextData);
                            break;
                        case 2:
                            var y = p.interpolationData,
                                g = y.length,
                                f = 0;
                            for (h = 0; h < g;) {
                                var M = y[h];
                                switch (M) {
                                    case 6:
                                    case 7:
                                        h += _.interpolation[M](d, f, e, u + f, p.data, m, p.dData, p.duration, p.nextData, y, h + 1);
                                        break;
                                    default:
                                        h += _.interpolation[M](d, f, e, u + f, p.data, m, p.dData, p.duration, p.nextData)
                                }
                                f++
                            }
                    } else
                        for (h = 0; h < d.keyframeWidth;) h += d.interpolationMethod[h](d, h, e, u + h, p.data, m, p.dData, p.duration, p.nextData);
                    u += d.keyframeWidth
                }
            }
            getNodesCurrentFrameIndex(t, e) {
                var i = this._anis[t].nodes;
                t !== this.unfixedLastAniIndex && (this.unfixedCurrentFrameIndexes = new Uint32Array(i.length), this.unfixedCurrentTimes = new Float32Array(i.length), this.unfixedLastAniIndex = t);
                for (var a = 0, r = i.length; a < r; a++) {
                    var s = i[a];
                    for (e < this.unfixedCurrentTimes[a] && (this.unfixedCurrentFrameIndexes[a] = 0), this.unfixedCurrentTimes[a] = e; this.unfixedCurrentFrameIndexes[a] < s.keyFrame.length && !(s.keyFrame[this.unfixedCurrentFrameIndexes[a]].startTime > this.unfixedCurrentTimes[a]);) this.unfixedCurrentFrameIndexes[a] ++;
                    this.unfixedCurrentFrameIndexes[a] --
                }
                return this.unfixedCurrentFrameIndexes
            }
            getOriginalDataUnfixedRate(t, e, i) {
                var a = this._anis[t].nodes;
                t !== this.unfixedLastAniIndex && (this.unfixedCurrentFrameIndexes = new Uint32Array(a.length), this.unfixedCurrentTimes = new Float32Array(a.length), this.unfixedKeyframes = [], this.unfixedLastAniIndex = t);
                for (var r = 0, s = 0, n = a.length, h = 0; s < n; s++) {
                    var l = a[s];
                    for (i < this.unfixedCurrentTimes[s] && (this.unfixedCurrentFrameIndexes[s] = 0), this.unfixedCurrentTimes[s] = i; this.unfixedCurrentFrameIndexes[s] < l.keyFrame.length && !(l.keyFrame[this.unfixedCurrentFrameIndexes[s]].startTime > this.unfixedCurrentTimes[s]);) this.unfixedKeyframes[s] = l.keyFrame[this.unfixedCurrentFrameIndexes[s]], this.unfixedCurrentFrameIndexes[s] ++;
                    var o = this.unfixedKeyframes[s];
                    l.dataOffset = h;
                    var u = i - o.startTime;
                    if (l.lerpType) switch (l.lerpType) {
                        case 0:
                        case 1:
                            for (r = 0; r < l.keyframeWidth;) r += l.interpolationMethod[r](l, r, e, h + r, o.data, u, o.dData, o.duration, o.nextData);
                            break;
                        case 2:
                            var p = o.interpolationData,
                                d = p.length,
                                c = 0;
                            for (r = 0; r < d;) {
                                var m = p[r];
                                switch (m) {
                                    case 6:
                                    case 7:
                                        r += _.interpolation[m](l, c, e, h + c, o.data, u, o.dData, o.duration, o.nextData, p, r + 1);
                                        break;
                                    default:
                                        r += _.interpolation[m](l, c, e, h + c, o.data, u, o.dData, o.duration, o.nextData)
                                }
                                c++
                            }
                    } else
                        for (r = 0; r < l.keyframeWidth;) r += l.interpolationMethod[r](l, r, e, h + r, o.data, u, o.dData, o.duration, o.nextData);
                    h += l.keyframeWidth
                }
            }
        }
        _.interpolation = [_._LinearInterpolation_0, _._QuaternionInterpolation_1, _._AngleInterpolation_2, _._RadiansInterpolation_3, _._Matrix4x4Interpolation_4, _._NoInterpolation_5, _._BezierInterpolation_6, _._BezierInterpolation_7], i.AnimationTemplet = _;
        class p extends e.Graphics {
            drawSkin(t, i) {
                this.drawTriangles(t.texture, 0, 0, t.vertices, t.uvs, t.indexes, t.transform || e.Matrix.EMPTY, i)
            }
            static create() {
                return p._caches.pop() || new p
            }
            static recycle(t) {
                t.clear(), p._caches.push(t)
            }
        }
        p._caches = [];
        class d {
            constructor() {
                this.skX = 0, this.skY = 0, this.scX = 1, this.scY = 1, this.x = 0, this.y = 0, this.skewX = 0, this.skewY = 0
            }
            initData(t) {
                null != t.x && (this.x = t.x), null != t.y && (this.y = t.y), null != t.skX && (this.skX = t.skX), null != t.skY && (this.skY = t.skY), null != t.scX && (this.scX = t.scX), null != t.scY && (this.scY = t.scY)
            }
            getMatrix() {
                var t;
                return (t = this.mMatrix ? this.mMatrix : this.mMatrix = new e.Matrix).identity(), t.scale(this.scX, this.scY), (this.skewX || this.skewY) && this.skew(t, this.skewX * Math.PI / 180, this.skewY * Math.PI / 180), t.rotate(this.skX * Math.PI / 180), t.translate(this.x, this.y), t
            }
            skew(t, e, i) {
                var a = Math.sin(i),
                    r = Math.cos(i),
                    s = Math.sin(e),
                    n = Math.cos(e);
                return t.setTo(t.a * n - t.b * a, t.a * s + t.b * r, t.c * n - t.d * a, t.c * s + t.d * r, t.tx * n - t.ty * a, t.tx * s + t.ty * r), t
            }
        }
        class c {
            constructor() {
                this.length = 10, this.resultTransform = new d, this.resultMatrix = new e.Matrix, this.inheritScale = !0, this.inheritRotation = !0, this.d = -1, this._children = []
            }
            setTempMatrix(t) {
                this._tempMatrix = t;
                var e, i = 0;
                for (i = 0, e = this._children.length; i < e; i++) this._children[i].setTempMatrix(this._tempMatrix)
            }
            update(t = null) {
                var i;
                if (this.rotation = this.transform.skX, t) i = this.resultTransform.getMatrix(), e.Matrix.mul(i, t, this.resultMatrix), this.resultRotation = this.rotation;
                else if (this.resultRotation = this.rotation + this.parentBone.resultRotation, this.parentBone)
                    if (this.inheritRotation && this.inheritScale) i = this.resultTransform.getMatrix(), e.Matrix.mul(i, this.parentBone.resultMatrix, this.resultMatrix);
                    else {
                        var a, r, s, n = this.parentBone,
                            h = this.parentBone.resultMatrix;
                        i = this.resultTransform.getMatrix();
                        var l = h.a * i.tx + h.c * i.ty + h.tx,
                            o = h.b * i.tx + h.d * i.ty + h.ty,
                            u = new e.Matrix;
                        this.inheritRotation ? (a = Math.atan2(n.resultMatrix.b, n.resultMatrix.a), r = Math.cos(a), s = Math.sin(a), u.setTo(r, s, -s, r, 0, 0), e.Matrix.mul(this._tempMatrix, u, e.Matrix.TEMP), e.Matrix.TEMP.copyTo(u), i = this.resultTransform.getMatrix(), e.Matrix.mul(i, u, this.resultMatrix), this.resultTransform.scX * this.resultTransform.scY < 0 && this.resultMatrix.rotate(.5 * Math.PI), this.resultMatrix.tx = l, this.resultMatrix.ty = o) : (this.inheritScale, i = this.resultTransform.getMatrix(), e.Matrix.TEMP.identity(), e.Matrix.TEMP.d = this.d, e.Matrix.mul(i, e.Matrix.TEMP, this.resultMatrix), this.resultMatrix.tx = l, this.resultMatrix.ty = o)
                    } else(i = this.resultTransform.getMatrix()).copyTo(this.resultMatrix);
                var _, p = 0;
                for (p = 0, _ = this._children.length; p < _; p++) this._children[p].update()
            }
            updateChild() {
                var t, e = 0;
                for (e = 0, t = this._children.length; e < t; e++) this._children[e].update()
            }
            setRotation(t) {
                this._sprite && (this._sprite.rotation = 180 * t / Math.PI)
            }
            updateDraw(t, i) {
                c.ShowBones && !c.ShowBones[this.name] || (this._sprite ? (this._sprite.x = t + this.resultMatrix.tx, this._sprite.y = i + this.resultMatrix.ty) : (this._sprite = new e.Sprite, this._sprite.graphics.drawCircle(0, 0, 5, "#ff0000"), this._sprite.graphics.drawLine(0, 0, this.length, 0, "#00ff00"), this._sprite.graphics.fillText(this.name, 0, 0, "20px Arial", "#00ff00", "center"), e.ILaya.stage.addChild(this._sprite), this._sprite.x = t + this.resultMatrix.tx, this._sprite.y = i + this.resultMatrix.ty));
                var a, r = 0;
                for (r = 0, a = this._children.length; r < a; r++) this._children[r].updateDraw(t, i)
            }
            addChild(t) {
                this._children.push(t), t.parentBone = this
            }
            findBone(t) {
                if (this.name == t) return this;
                var e, i, a;
                for (e = 0, i = this._children.length; e < i; e++)
                    if (a = this._children[e].findBone(t)) return a;
                return null
            }
            localToWorld(t) {
                var e = t[0],
                    i = t[1];
                t[0] = e * this.resultMatrix.a + i * this.resultMatrix.c + this.resultMatrix.tx, t[1] = e * this.resultMatrix.b + i * this.resultMatrix.d + this.resultMatrix.ty
            }
        }
        c.ShowBones = {};
        class m {
            constructor() {}
            static getRelativeUV(t, e, i = null) {
                var a, r, s = t[0],
                    n = t[2] - t[0],
                    h = t[1],
                    l = t[5] - t[1];
                i || (i = []), i.length = e.length, r = i.length;
                var o = 1 / n,
                    u = 1 / l;
                for (a = 0; a < r; a += 2) i[a] = (e[a] - s) * o, i[a + 1] = (e[a + 1] - h) * u;
                return i
            }
            static getAbsoluteUV(t, i, a = null) {
                if (0 == t[0] && 0 == t[1] && 1 == t[4] && 1 == t[5]) return a ? (e.Utils.copyArray(a, i), a) : i;
                var r, s, n = t[0],
                    h = t[2] - t[0],
                    l = t[1],
                    o = t[5] - t[1];
                for (a || (a = []), a.length = i.length, s = a.length, r = 0; r < s; r += 2) a[r] = i[r] * h + n, a[r + 1] = i[r + 1] * o + l;
                return a
            }
        }
        class x {
            constructor() {
                this.uvs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]), this.vertices = new Float32Array([0, 0, 100, 0, 100, 100, 0, 100]), this.indexes = new Uint16Array([0, 1, 3, 3, 1, 2]), this.useUvTransform = !1, this.canvasPadding = 1
            }
            getBounds() {
                return e.Rectangle._getWrapRec(this.vertices)
            }
        }
        class y extends x {
            constructor() {
                super()
            }
            init2(t, e, i, a) {
                this.transform && (this.transform = null);
                var r = e || [0, 1, 3, 3, 1, 2];
                this.texture = t, this.indexes = new Uint16Array(r), this.vertices = new Float32Array(i), this.uvs = new Float32Array(a)
            }
        }
        class g {
            constructor() {
                this.srcDisplayIndex = -1, this.type = "src", this.displayIndex = -1, this.originalIndex = -1, this._replaceDic = {}
            }
            showSlotData(t, e = !0) {
                this.currSlotData = t, e && (this.displayIndex = this.srcDisplayIndex), this.currDisplayData = null, this.currTexture = null
            }
            showDisplayByName(t) {
                this.currSlotData && this.showDisplayByIndex(this.currSlotData.getDisplayByName(t))
            }
            replaceDisplayByName(t, e) {
                var i, a;
                this.currSlotData && (i = this.currSlotData.getDisplayByName(t), a = this.currSlotData.getDisplayByName(e), this.replaceDisplayByIndex(i, a))
            }
            replaceDisplayByIndex(t, e) {
                this.currSlotData && (this._replaceDic[t] = e, this.originalIndex == t && this.showDisplayByIndex(t))
            }
            showDisplayByIndex(t) {
                if (this.originalIndex = t, null != this._replaceDic[t] && (t = this._replaceDic[t]), this.currSlotData && t > -1 && t < this.currSlotData.displayArr.length) {
                    if (this.displayIndex = t, this.currDisplayData = this.currSlotData.displayArr[t], this.currDisplayData) {
                        var e = this.currDisplayData.name;
                        this.currTexture = this.templet.getTexture(e), this.currTexture && 0 == this.currDisplayData.type && this.currDisplayData.uvs && (this.currTexture = this.currDisplayData.createTexture(this.currTexture))
                    }
                } else this.displayIndex = -1, this.currDisplayData = null, this.currTexture = null
            }
            replaceSkin(t) {
                this._diyTexture = t, this._curDiyUV && (this._curDiyUV.length = 0), this.currDisplayData && this._diyTexture == this.currDisplayData.texture && (this._diyTexture = null)
            }
            setParentMatrix(t) {
                this._parentMatrix = t
            }
            static createSkinMesh() {
                return new y
            }
            static isSameArr(t, e) {
                if (t.length != e.length) return !1;
                var i, a;
                for (a = t.length, i = 0; i < a; i++)
                    if (t[i] != e[i]) return !1;
                return !0
            }
            getSaveVerticle(t) {
                return g.useSameMatrixAndVerticle && this._preGraphicVerticle && g.isSameArr(t, this._preGraphicVerticle) ? t = this._preGraphicVerticle : (t = e.ILaya.Utils.copyArray([], t), this._preGraphicVerticle = t), t
            }
            static isSameMatrix(t, e) {
                return t.a == e.a && t.b == e.b && t.c == e.c && t.d == e.d && Math.abs(t.tx - e.tx) < 1e-5 && Math.abs(t.ty - e.ty) < 1e-5
            }
            getSaveMatrix(t) {
                if (g.useSameMatrixAndVerticle && this._preGraphicMatrix && g.isSameMatrix(t, this._preGraphicMatrix)) t = this._preGraphicMatrix;
                else {
                    var e = t.clone();
                    t = e, this._preGraphicMatrix = t
                }
                return t
            }
            draw(t, i, a = !1, r = 1) {
                if ((null != this._diyTexture || null != this.currTexture) && null != this.currDisplayData || this.currDisplayData && 3 == this.currDisplayData.type) {
                    var s, n = this.currTexture;
                    switch (this._diyTexture && (n = this._diyTexture), this.currDisplayData.type) {
                        case 0:
                            if (t) {
                                var h = this.getDisplayMatrix();
                                if (this._parentMatrix) {
                                    var l = !1;
                                    if (h) {
                                        var o;
                                        if (e.Matrix.mul(h, this._parentMatrix, e.Matrix.TEMP), a ? (null == this._resultMatrix && (this._resultMatrix = new e.Matrix), o = this._resultMatrix) : o = g._tempResultMatrix, this._diyTexture && this.currDisplayData.uvs) {
                                            var u = g._tempMatrix;
                                            u.identity(), this.currDisplayData.uvs[1] > this.currDisplayData.uvs[5] && (u.d = -1), this.currDisplayData.uvs[0] > this.currDisplayData.uvs[4] && this.currDisplayData.uvs[1] > this.currDisplayData.uvs[5] && (l = !0, u.rotate(-Math.PI / 2)), e.Matrix.mul(u, e.Matrix.TEMP, o)
                                        } else e.Matrix.TEMP.copyTo(o);
                                        a || (o = this.getSaveMatrix(o)), o._checkTransform(), l ? t.drawTexture(n, -this.currDisplayData.height / 2, -this.currDisplayData.width / 2, this.currDisplayData.height, this.currDisplayData.width, o, r) : t.drawTexture(n, -this.currDisplayData.width / 2, -this.currDisplayData.height / 2, this.currDisplayData.width, this.currDisplayData.height, o, r)
                                    }
                                }
                            }
                            break;
                        case 1:
                            if (a ? (null == this._skinSprite && (this._skinSprite = g.createSkinMesh()), s = this._skinSprite) : s = g.createSkinMesh(), null == s) return;
                            var _;
                            if (null == this.currDisplayData.bones) {
                                var p, d = this.currDisplayData.weights;
                                this.deformData && (d = this.deformData), this._diyTexture ? (this._curDiyUV || (this._curDiyUV = []), 0 == this._curDiyUV.length && (this._curDiyUV = m.getRelativeUV(this.currTexture.uv, this.currDisplayData.uvs, this._curDiyUV), this._curDiyUV = m.getAbsoluteUV(this._diyTexture.uv, this._curDiyUV, this._curDiyUV)), p = this._curDiyUV) : p = this.currDisplayData.uvs, this._mVerticleArr = d;
                                this.currDisplayData.triangles.length;
                                _ = this.currDisplayData.triangles, this.deformData && (a || (this._mVerticleArr = this.getSaveVerticle(this._mVerticleArr))), s.init2(n, _, this._mVerticleArr, p);
                                var c, x = this.getDisplayMatrix();
                                if (this._parentMatrix)
                                    if (x) e.Matrix.mul(x, this._parentMatrix, e.Matrix.TEMP), a ? (null == this._resultMatrix && (this._resultMatrix = new e.Matrix), c = this._resultMatrix) : c = g._tempResultMatrix, e.Matrix.TEMP.copyTo(c), a || (c = this.getSaveMatrix(c)), s.transform = c
                            } else this.skinMesh(i, s);
                            t.drawSkin(s, r);
                            break;
                        case 2:
                            if (a ? (null == this._skinSprite && (this._skinSprite = g.createSkinMesh()), s = this._skinSprite) : s = g.createSkinMesh(), null == s) return;
                            this.skinMesh(i, s), t.drawSkin(s, r)
                    }
                }
            }
            skinMesh(t, e) {
                var i, a = this.currTexture,
                    r = this.currDisplayData.bones;
                this._diyTexture ? (a = this._diyTexture, this._curDiyUV || (this._curDiyUV = []), 0 == this._curDiyUV.length && (this._curDiyUV = m.getRelativeUV(this.currTexture.uv, this.currDisplayData.uvs, this._curDiyUV), this._curDiyUV = m.getAbsoluteUV(this._diyTexture.uv, this._curDiyUV, this._curDiyUV)), i = this._curDiyUV) : i = this.currDisplayData.uvs;
                var s, n, h, l, o, u = this.currDisplayData.weights,
                    _ = this.currDisplayData.triangles,
                    p = 0,
                    d = 0,
                    c = 0,
                    x = 0,
                    y = 0,
                    f = 0,
                    M = 0;
                if (g._tempVerticleArr.length = 0, o = g._tempVerticleArr, this.deformData && this.deformData.length > 0) {
                    var D = 0;
                    for (f = 0, M = r.length; f < M;) {
                        for (c = r[f++] + f, p = 0, d = 0; f < c; f++) n = t[r[f]], h = u[x] + this.deformData[D++], l = u[x + 1] + this.deformData[D++], y = u[x + 2], p += (h * n.a + l * n.c + n.tx) * y, d += (h * n.b + l * n.d + n.ty) * y, x += 3;
                        o.push(p, d)
                    }
                } else
                    for (f = 0, M = r.length; f < M;) {
                        for (c = r[f++] + f, p = 0, d = 0; f < c; f++) n = t[r[f]], h = u[x], l = u[x + 1], y = u[x + 2], p += (h * n.a + l * n.c + n.tx) * y, d += (h * n.b + l * n.d + n.ty) * y, x += 3;
                        o.push(p, d)
                    }
                this._mVerticleArr = o, s = _, this._mVerticleArr = this.getSaveVerticle(this._mVerticleArr), e.init2(a, s, this._mVerticleArr, i)
            }
            drawBonePoint(t) {
                t && this._parentMatrix && t.drawCircle(this._parentMatrix.tx, this._parentMatrix.ty, 5, "#ff0000")
            }
            getDisplayMatrix() {
                return this.currDisplayData ? this.currDisplayData.transform.getMatrix() : null
            }
            getMatrix() {
                return this._resultMatrix
            }
            copy() {
                var t = new g;
                return t.type = "copy", t.name = this.name, t.attachmentName = this.attachmentName, t.srcDisplayIndex = this.srcDisplayIndex, t.parent = this.parent, t.displayIndex = this.displayIndex, t.templet = this.templet, t.currSlotData = this.currSlotData, t.currTexture = this.currTexture, t.currDisplayData = this.currDisplayData, t
            }
        }
        g._tempMatrix = new e.Matrix, g._tempResultMatrix = new e.Matrix, g.useSameMatrixAndVerticle = !0, g._tempVerticleArr = [];
        class f {
            constructor() {
                this.deformSlotDataList = []
            }
        }
        class M {
            constructor() {
                this.deformSlotDisplayList = []
            }
        }
        class D {
            constructor() {
                this.slotIndex = -1, this.timeList = [], this.vectices = [], this.tweenKeyList = [], this.frameIndex = 0
            }
            binarySearch1(t, e) {
                var i = 0,
                    a = t.length - 2;
                if (0 == a) return 1;
                for (var r = a >>> 1;;) {
                    if (t[Math.floor(r + 1)] <= e ? i = r + 1 : a = r, i == a) return i + 1;
                    r = i + a >>> 1
                }
                return 0
            }
            apply(t, e, i = 1) {
                if (t += .05, !(this.timeList.length <= 0)) {
                    var a = 0;
                    if (!(t < this.timeList[0])) {
                        var r = this.vectices[0].length,
                            s = [],
                            n = this.binarySearch1(this.timeList, t);
                        if (this.frameIndex = n, t >= this.timeList[this.timeList.length - 1]) {
                            var h = this.vectices[this.vectices.length - 1];
                            if (i < 1)
                                for (a = 0; a < r; a++) s[a] += (h[a] - s[a]) * i;
                            else
                                for (a = 0; a < r; a++) s[a] = h[a];
                            this.deformData = s
                        } else {
                            var l, o = this.vectices[this.frameIndex - 1],
                                u = this.vectices[this.frameIndex],
                                _ = this.timeList[this.frameIndex - 1],
                                p = this.timeList[this.frameIndex];
                            for (i = this.tweenKeyList[n - 1] ? (t - _) / (p - _) : 0, a = 0; a < r; a++) l = o[a], s[a] = l + (u[a] - l) * i;
                            this.deformData = s
                        }
                    }
                }
            }
        }
        class v {
            constructor() {
                this.drawOrder = []
            }
        }
        class I {
            constructor() {}
        }
        class A {
            constructor(t, e) {
                this.isSpine = !0, this.isDebug = !1, this._targetBone = e[t.targetBoneIndex], this.isSpine = t.isSpine, null == this._bones && (this._bones = []), this._bones.length = 0;
                for (var i = 0, a = t.boneIndexs.length; i < a; i++) this._bones.push(e[t.boneIndexs[i]]);
                this.name = t.name, this.mix = t.mix, this.bendDirection = t.bendDirection
            }
            apply() {
                switch (this._bones.length) {
                    case 1:
                        this._applyIk1(this._bones[0], this._targetBone.resultMatrix.tx, this._targetBone.resultMatrix.ty, this.mix);
                        break;
                    case 2:
                        this.isSpine ? this._applyIk2(this._bones[0], this._bones[1], this._targetBone.resultMatrix.tx, this._targetBone.resultMatrix.ty, this.bendDirection, this.mix) : this._applyIk3(this._bones[0], this._bones[1], this._targetBone.resultMatrix.tx, this._targetBone.resultMatrix.ty, this.bendDirection, this.mix)
                }
            }
            _applyIk1(t, e, i, a) {
                var r = t.parentBone,
                    s = 1 / (r.resultMatrix.a * r.resultMatrix.d - r.resultMatrix.b * r.resultMatrix.c),
                    n = e - r.resultMatrix.tx,
                    h = i - r.resultMatrix.ty,
                    l = (n * r.resultMatrix.d - h * r.resultMatrix.c) * s - t.transform.x,
                    o = (h * r.resultMatrix.a - n * r.resultMatrix.b) * s - t.transform.y,
                    u = Math.atan2(o, l) * A.radDeg - 0 - t.transform.skX;
                t.transform.scX < 0 && (u += 180), u > 180 ? u -= 360 : u < -180 && (u += 360), t.transform.skX = t.transform.skY = t.transform.skX + u * a, t.update()
            }
            updatePos(t, e) {
                this._sp && this._sp.pos(t, e)
            }
            _applyIk2(t, i, a, r, s, n) {
                if (0 != n) {
                    var h, l, o, u = t.resultTransform.x,
                        _ = t.resultTransform.y,
                        p = t.transform.scX,
                        d = t.transform.scY,
                        c = i.transform.scX;
                    p < 0 ? (p = -p, h = 180, o = -1) : (h = 0, o = 1), d < 0 && (d = -d, o = -o), c < 0 ? (c = -c, l = 180) : l = 0;
                    var m, x, y, g = i.resultTransform.x,
                        f = t.resultMatrix.a,
                        M = t.resultMatrix.c,
                        D = t.resultMatrix.b,
                        v = t.resultMatrix.d,
                        I = Math.abs(p - d) <= 1e-4;
                    I ? (x = f * g + M * (m = i.resultTransform.y) + t.resultMatrix.tx, y = D * g + v * m + t.resultMatrix.ty) : (m = 0, x = f * g + t.resultMatrix.tx, y = D * g + t.resultMatrix.ty), this.isDebug && (this._sp || (this._sp = new e.Sprite, e.ILaya.stage.addChild(this._sp)), this._sp.graphics.clear(), this._sp.graphics.drawCircle(a, r, 15, "#ffff00"), this._sp.graphics.drawCircle(x, y, 15, "#ff00ff")), t.setRotation(Math.atan2(y - t.resultMatrix.ty, x - t.resultMatrix.tx));
                    var T = t.parentBone;
                    f = T.resultMatrix.a, M = T.resultMatrix.c, D = T.resultMatrix.b;
                    var S, b, C = 1 / (f * (v = T.resultMatrix.d) - M * D),
                        F = a - T.resultMatrix.tx,
                        w = r - T.resultMatrix.ty,
                        k = (F * v - w * M) * C - u,
                        P = (w * f - F * D) * C - _,
                        L = ((F = x - T.resultMatrix.tx) * v - (w = y - T.resultMatrix.ty) * M) * C - u,
                        U = (w * f - F * D) * C - _,
                        B = Math.sqrt(L * L + U * U),
                        E = i.length * c;
                    if (I) {
                        var R = (k * k + P * P - B * B - (E *= p) * E) / (2 * B * E);
                        R < -1 ? R = -1 : R > 1 && (R = 1), b = Math.acos(R) * s, f = B + E * R, M = E * Math.sin(b), S = Math.atan2(P * f - k * M, k * f + P * M)
                    } else {
                        var N = (f = p * E) * f,
                            O = (M = d * E) * M,
                            V = k * k + P * P,
                            Y = Math.atan2(P, k),
                            K = -2 * O * B,
                            X = O - N;
                        if ((v = K * K - 4 * X * (D = O * B * B + N * V - N * O)) > 0) {
                            var W = Math.sqrt(v);
                            K < 0 && (W = -W);
                            var z = (W = -(K + W) / 2) / X,
                                G = D / W,
                                q = Math.abs(z) < Math.abs(G) ? z : G;
                            q * q <= V && (w = Math.sqrt(V - q * q) * s, S = Y - Math.atan2(w, q), b = Math.atan2(w / d, (q - B) / p))
                        }
                        var H = 0,
                            Q = Number.MAX_VALUE,
                            Z = 0,
                            j = 0,
                            J = 0,
                            $ = 0,
                            tt = 0,
                            et = 0;
                        (v = (F = B + f) * F) > $ && (J = 0, $ = v, tt = F), (v = (F = B - f) * F) < Q && (H = Math.PI, Q = v, Z = F);
                        var it = Math.acos(-f * B / (N - O));
                        (v = (F = f * Math.cos(it) + B) * F + (w = M * Math.sin(it)) * w) < Q && (H = it, Q = v, Z = F, j = w), v > $ && (J = it, $ = v, tt = F, et = w), V <= (Q + $) / 2 ? (S = Y - Math.atan2(j * s, Z), b = H * s) : (S = Y - Math.atan2(et * s, tt), b = J * s)
                    }
                    var at = Math.atan2(m, g) * o,
                        rt = t.resultTransform.skX;
                    (S = (S - at) * A.radDeg + h - rt) > 180 ? S -= 360 : S < -180 && (S += 360), t.resultTransform.x = u, t.resultTransform.y = _, t.resultTransform.skX = t.resultTransform.skY = rt + S * n, rt = i.resultTransform.skX, rt %= 360, (b = ((b + at) * A.radDeg - 0) * o + l - rt) > 180 ? b -= 360 : b < -180 && (b += 360), i.resultTransform.x = g, i.resultTransform.y = m, i.resultTransform.skX = i.resultTransform.skY = i.resultTransform.skY + b * n, t.update()
                }
            }
            _applyIk3(t, i, a, r, s, n) {
                if (0 == n) return;
                var h, l;
                const o = i.resultMatrix.a * i.length,
                    u = i.resultMatrix.b * i.length,
                    _ = o * o + u * u,
                    p = Math.sqrt(_);
                var d = t.resultMatrix.tx,
                    c = t.resultMatrix.ty,
                    m = i.resultMatrix.tx,
                    x = i.resultMatrix.ty,
                    y = m - d,
                    g = x - c;
                const f = y * y + g * g,
                    M = Math.sqrt(f),
                    D = (y = a - t.resultMatrix.tx) * y + (g = r - t.resultMatrix.ty) * g,
                    v = Math.sqrt(D);
                if (p + M <= v || v + p <= M || v + M <= p) {
                    var I;
                    m = d + (I = p + M <= v ? 1 : -1) * (a - d) * M / v, x = c + I * (r - c) * M / v
                } else {
                    const t = (f - _ + D) / (2 * D),
                        e = Math.sqrt(f - t * t * D) / v,
                        i = d + y * t,
                        a = c + g * t,
                        r = -g * e,
                        n = y * e;
                    s > 0 ? (m = i - r, x = a - n) : (m = i + r, x = a + n)
                }
                var T, S, b, C;
                h = m, l = x, this.isDebug && (this._sp || (this._sp = new e.Sprite, e.ILaya.stage.addChild(this._sp)), this._sp.graphics.clear(), this._sp.graphics.drawCircle(d, c, 15, "#ff00ff"), this._sp.graphics.drawCircle(a, r, 15, "#ffff00"), this._sp.graphics.drawCircle(h, l, 15, "#ff00ff")), T = Math.atan2(l - t.resultMatrix.ty, h - t.resultMatrix.tx), t.setRotation(T), (S = A._tempMatrix).identity(), S.rotate(T), S.scale(t.resultMatrix.getScaleX(), t.resultMatrix.getScaleY()), S.translate(t.resultMatrix.tx, t.resultMatrix.ty), S.copyTo(t.resultMatrix), t.updateChild(), b = Math.atan2(r - l, a - h), i.setRotation(b), (C = A._tempMatrix).identity(), C.rotate(b), C.scale(i.resultMatrix.getScaleX(), i.resultMatrix.getScaleY()), C.translate(h, l), S.copyTo(i.resultMatrix), i.updateChild()
            }
        }
        A.radDeg = 180 / Math.PI, A.degRad = Math.PI / 180, A._tempMatrix = new e.Matrix;
        class T {
            constructor() {
                this.boneNames = [], this.bendDirection = 1, this.mix = 1, this.isSpine = !0, this.targetBoneIndex = -1, this.boneIndexs = []
            }
        }
        class S {
            constructor(t, e) {
                this._debugKey = !1, this._segments = [], this._curves = [], this.data = t, this.position = t.position, this.spacing = t.spacing, this.rotateMix = t.rotateMix, this.translateMix = t.translateMix, this.bones = [];
                for (var i = this.data.bones, a = 0, r = i.length; a < r; a++) this.bones.push(e[i[a]])
            }
            apply(t, e) {
                if (this.target) {
                    var i = this.translateMix,
                        a = this.translateMix,
                        r = a > 0,
                        s = this.data.spacingMode,
                        n = "length" == s,
                        h = this.data.rotateMode,
                        l = "tangent" == h,
                        o = "chainScale" == h,
                        u = [],
                        _ = this.bones.length,
                        p = l ? _ : _ + 1,
                        d = [];
                    this._spaces = d, d[0] = this.position;
                    var c = this.spacing;
                    if (o || n)
                        for (var m = 0, x = p - 1; m < x;) {
                            var y = this.bones[m],
                                g = y.length,
                                f = g * y.resultMatrix.a,
                                M = g * y.resultMatrix.b;
                            g = Math.sqrt(f * f + M * M), o && (u[m] = g), d[++m] = n ? Math.max(0, g + c) : c
                        } else
                            for (m = 1; m < p; m++) d[m] = c;
                    var D = this.computeWorldPositions(this.target, t, e, p, l, "percent" == this.data.positionMode, "percent" == s);
                    if (this._debugKey) {
                        for (m = 0; m < D.length; m++) e.drawCircle(D[m++], D[m++], 5, "#00ff00");
                        var v = [];
                        for (m = 0; m < D.length; m++) v.push(D[m++], D[m++]);
                        e.drawLines(0, 0, v, "#ff0000")
                    }
                    var I, A = D[0],
                        T = D[1],
                        S = this.data.offsetRotation,
                        b = "chain" == h && 0 == S;
                    for (m = 0, I = 3; m < _; m++, I += 3) {
                        (y = this.bones[m]).resultMatrix.tx += (A - y.resultMatrix.tx) * i, y.resultMatrix.ty += (T - y.resultMatrix.ty) * i;
                        var C = (f = D[I]) - A,
                            F = (M = D[I + 1]) - T;
                        if (o && 0 != (g = u[m])) {
                            var w = (Math.sqrt(C * C + F * F) / g - 1) * a + 1;
                            y.resultMatrix.a *= w, y.resultMatrix.c *= w
                        }
                        if (A = f, T = M, r) {
                            var k, P, L, U = y.resultMatrix.a,
                                B = y.resultMatrix.c,
                                E = y.resultMatrix.b,
                                R = y.resultMatrix.d;
                            k = l ? D[I - 1] : 0 == d[m + 1] ? D[I + 2] : Math.atan2(F, C), k -= Math.atan2(E, U) - S / 180 * Math.PI, b && (P = Math.cos(k), L = Math.sin(k), A += ((g = y.length) * (P * U - L * E) - C) * a, T += (g * (L * U + P * E) - F) * a), k > Math.PI ? k -= 2 * Math.PI : k < -Math.PI && (k += 2 * Math.PI), k *= a, P = Math.cos(k), L = Math.sin(k), y.resultMatrix.a = P * U - L * E, y.resultMatrix.c = P * B - L * R, y.resultMatrix.b = L * U + P * E, y.resultMatrix.d = L * B + P * R
                        }
                    }
                }
            }
            computeWorldVertices2(t, e, i, a, r, s) {
                var n, h, l, o = t.currDisplayData.bones,
                    u = t.currDisplayData.weights,
                    _ = t.currDisplayData.triangles,
                    p = 0,
                    d = 0,
                    c = 0,
                    m = 0,
                    x = 0,
                    y = 0,
                    g = 0,
                    f = 0,
                    M = 0,
                    D = 0;
                if (null != o) {
                    for (p = 0; p < i; p += 2) d += (m = o[d]) + 1, c += m;
                    var v = e;
                    for (x = s, y = 3 * c; x < a; x += 2) {
                        for (g = 0, f = 0, m = o[d++], m += d; d < m; d++, y += 3) {
                            n = v[o[d]].resultMatrix, M = u[y], D = u[y + 1];
                            var I = u[y + 2];
                            g += (M * n.a + D * n.c + n.tx) * I, f += (M * n.b + D * n.d + n.ty) * I
                        }
                        r[x] = g, r[x + 1] = f
                    }
                } else {
                    var A, T;
                    if (_ || (_ = u), t.deformData && (_ = t.deformData), A = t.parent, e)
                        for (l = e.length, p = 0; p < l; p++)
                            if (e[p].name == A) {
                                h = e[p];
                                break
                            }
                    h && (T = h.resultMatrix), T || (T = S._tempMt);
                    var b = T.tx,
                        C = T.ty,
                        F = T.a,
                        w = T.b,
                        k = T.c,
                        P = T.d;
                    for (h && (P *= h.d), d = i, x = s; x < a; d += 2, x += 2) M = _[d], D = _[d + 1], r[x] = M * F + D * w + b, r[x + 1] = -(M * k + D * P + C)
                }
            }
            computeWorldPositions(t, e, i, a, r, s, n) {
                t.currDisplayData.bones, t.currDisplayData.weights, t.currDisplayData.triangles;
                var h, l, o, u, _, p, d, c, m = [],
                    x = 0,
                    y = t.currDisplayData.verLen,
                    g = this.position,
                    f = this._spaces,
                    M = [],
                    D = y / 6,
                    v = -1;
                if (D--, y -= 4, this.computeWorldVertices2(t, e, 2, y, m, 0), this._debugKey)
                    for (x = 0; x < m.length;) i.drawCircle(m[x++], m[x++], 10, "#ff0000");
                h = m, this._curves.length = D;
                var I = this._curves;
                l = 0;
                var A, T, S, b, C, F, w, k, P, L = h[0],
                    U = h[1],
                    B = 0,
                    E = 0,
                    R = 0,
                    N = 0,
                    O = 0,
                    V = 0;
                for (x = 0, P = 2; x < D; x++, P += 6) C = 2 * (A = .1875 * (L - 2 * (B = h[P]) + (R = h[P + 2]))) + (S = .09375 * (3 * (B - R) - L + (O = h[P + 4]))), F = 2 * (T = .1875 * (U - 2 * (E = h[P + 1]) + (N = h[P + 3]))) + (b = .09375 * (3 * (E - N) - U + (V = h[P + 5]))), w = .75 * (B - L) + A + .16666667 * S, k = .75 * (E - U) + T + .16666667 * b, l += Math.sqrt(w * w + k * k), w += C, k += F, C += S, F += b, l += Math.sqrt(w * w + k * k), w += C, k += F, l += Math.sqrt(w * w + k * k), w += C + S, k += F + b, l += Math.sqrt(w * w + k * k), I[x] = l, L = O, U = V;
                if (s && (g *= l), n)
                    for (x = 0; x < a; x++) f[x] *= l;
                var Y, K = this._segments,
                    X = 0;
                for (x = 0, o = 0, u = 0, Y = 0; x < a; x++, o += 3)
                    if ((_ = g += p = f[x]) < 0) this.addBeforePosition(_, h, 0, M, o);
                    else if (_ > l) this.addAfterPosition(_ - l, h, y - 4, M, o);
                else {
                    for (;; u++)
                        if (!(_ > (c = I[u]))) {
                            0 == u ? _ /= c : _ = (_ - (d = I[u - 1])) / (c - d);
                            break
                        }
                    if (u != v) {
                        v = u;
                        var W = 6 * u;
                        for (C = 2 * (A = .03 * ((L = h[W]) - 2 * (B = h[W + 2]) + (R = h[W + 4]))) + (S = .006 * (3 * (B - R) - L + (O = h[W + 6]))), F = 2 * (T = .03 * ((U = h[W + 1]) - 2 * (E = h[W + 3]) + (N = h[W + 5]))) + (b = .006 * (3 * (E - N) - U + (V = h[W + 7]))), w = .3 * (B - L) + A + .16666667 * S, k = .3 * (E - U) + T + .16666667 * b, X = Math.sqrt(w * w + k * k), K[0] = X, W = 1; W < 8; W++) w += C, k += F, C += S, F += b, X += Math.sqrt(w * w + k * k), K[W] = X;
                        w += C, k += F, X += Math.sqrt(w * w + k * k), K[8] = X, w += C + S, k += F + b, X += Math.sqrt(w * w + k * k), K[9] = X, Y = 0
                    }
                    for (_ *= X;; Y++)
                        if (!(_ > (c = K[Y]))) {
                            0 == Y ? _ /= c : _ = Y + (_ - (d = K[Y - 1])) / (c - d);
                            break
                        }
                    this.addCurvePosition(.1 * _, L, U, B, E, R, N, O, V, M, o, r || x > 0 && 0 == p)
                }
                return M
            }
            addBeforePosition(t, e, i, a, r) {
                var s = e[i],
                    n = e[i + 1],
                    h = e[i + 2] - s,
                    l = e[i + 3] - n,
                    o = Math.atan2(l, h);
                a[r] = s + t * Math.cos(o), a[r + 1] = n + t * Math.sin(o), a[r + 2] = o
            }
            addAfterPosition(t, e, i, a, r) {
                var s = e[i + 2],
                    n = e[i + 3],
                    h = s - e[i],
                    l = n - e[i + 1],
                    o = Math.atan2(l, h);
                a[r] = s + t * Math.cos(o), a[r + 1] = n + t * Math.sin(o), a[r + 2] = o
            }
            addCurvePosition(t, e, i, a, r, s, n, h, l, o, u, _) {
                0 == t && (t = 1e-4);
                var p = t * t,
                    d = p * t,
                    c = 1 - t,
                    m = c * c,
                    x = m * c,
                    y = c * t,
                    g = 3 * y,
                    f = c * g,
                    M = g * t,
                    D = e * x + a * f + s * M + h * d,
                    v = i * x + r * f + n * M + l * d;
                o[u] = D, o[u + 1] = v, o[u + 2] = _ ? Math.atan2(v - (i * m + r * y * 2 + n * p), D - (e * m + a * y * 2 + s * p)) : 0
            }
        }
        S.BEFORE = -2, S.AFTER = -3, S._tempMt = new e.Matrix;
        class b {
            constructor() {
                this.bones = []
            }
        }
        class C {
            constructor(t, e) {
                var i, a;
                for (this._temp = [], this._data = t, null == this._bones && (this._bones = []), this.target = e[t.targetIndex], i = 0, a = t.boneIndexs.length; i < a; i++) this._bones.push(e[t.boneIndexs[i]]);
                this.rotateMix = t.rotateMix, this.translateMix = t.translateMix, this.scaleMix = t.scaleMix, this.shearMix = t.shearMix
            }
            apply() {
                for (var t, e = this.target.resultMatrix.a, i = this.target.resultMatrix.b, a = this.target.resultMatrix.c, r = this.target.resultMatrix.d, s = 0, n = this._bones.length; s < n; s++) {
                    if (t = this._bones[s], this.rotateMix > 0) {
                        var h = t.resultMatrix.a,
                            l = t.resultMatrix.b,
                            o = t.resultMatrix.c,
                            u = t.resultMatrix.d,
                            _ = Math.atan2(a, e) - Math.atan2(o, h) + this._data.offsetRotation * Math.PI / 180;
                        _ > Math.PI ? _ -= 2 * Math.PI : _ < -Math.PI && (_ += 2 * Math.PI), _ *= this.rotateMix;
                        var p = Math.cos(_),
                            d = Math.sin(_);
                        t.resultMatrix.a = p * h - d * o, t.resultMatrix.b = p * l - d * u, t.resultMatrix.c = d * h + p * o, t.resultMatrix.d = d * l + p * u
                    }
                    if (this.translateMix && (this._temp[0] = this._data.offsetX, this._temp[1] = this._data.offsetY, this.target.localToWorld(this._temp), t.resultMatrix.tx += (this._temp[0] - t.resultMatrix.tx) * this.translateMix, t.resultMatrix.ty += (this._temp[1] - t.resultMatrix.ty) * this.translateMix, t.updateChild()), this.scaleMix > 0) {
                        var c = Math.sqrt(t.resultMatrix.a * t.resultMatrix.a + t.resultMatrix.c * t.resultMatrix.c),
                            m = Math.sqrt(e * e + a * a),
                            x = c > 1e-5 ? (c + (m - c + this._data.offsetScaleX) * this.scaleMix) / c : 0;
                        t.resultMatrix.a *= x, t.resultMatrix.c *= x, c = Math.sqrt(t.resultMatrix.b * t.resultMatrix.b + t.resultMatrix.d * t.resultMatrix.d), m = Math.sqrt(i * i + r * r), x = c > 1e-5 ? (c + (m - c + this._data.offsetScaleY) * this.scaleMix) / c : 0, t.resultMatrix.b *= x, t.resultMatrix.d *= x
                    }
                    if (this.shearMix > 0) {
                        l = t.resultMatrix.b, u = t.resultMatrix.d;
                        var y = Math.atan2(u, l);
                        (_ = Math.atan2(r, i) - Math.atan2(a, e) - (y - Math.atan2(t.resultMatrix.c, t.resultMatrix.a))) > Math.PI ? _ -= 2 * Math.PI : _ < -Math.PI && (_ += 2 * Math.PI), _ = y + (_ + this._data.offsetShearY * Math.PI / 180) * this.shearMix, x = Math.sqrt(l * l + u * u), t.resultMatrix.b = Math.cos(_) * x, t.resultMatrix.d = Math.sin(_) * x
                    }
                }
            }
        }
        class F extends e.Sprite {
            constructor(t = null, e = 0) {
                super(), this._boneMatrixArray = [], this._lastTime = 0, this._currAniIndex = -1, this._pause = !0, this._aniClipIndex = -1, this._clipIndex = -1, this._skinIndex = 0, this._skinName = "default", this._aniMode = 0, this._index = -1, this._total = -1, this._indexControl = !1, this._eventIndex = 0, this._drawOrderIndex = 0, this._drawOrder = null, this._lastAniClipIndex = -1, this._lastUpdateAniClipIndex = -1, this._playAudio = !0, this._soundChannelArr = [], t && this.init(t, e)
            }
            init(t, i = 0) {
                var a, r, s, n, h = 0;
                if (1 == i)
                    for (this._graphicsCache = [], h = 0, a = t.getAnimationCount(); h < a; h++) this._graphicsCache.push([]);
                if (this._yReverseMatrix = t.yReverseMatrix, this._aniMode = i, this._templet = t, this._templet._addReference(1), this._player = new o, this._player.cacheFrameRate = t.rate, this._player.templet = t, this._player.play(), this._parseSrcBoneMatrix(), this._boneList = t.mBoneArr, this._rootBone = t.mRootBone, this._aniSectionDic = t.aniSectionDic, t.ikArr.length > 0)
                    for (this._ikArr = [], h = 0, a = t.ikArr.length; h < a; h++) this._ikArr.push(new A(t.ikArr[h], this._boneList));
                if (t.pathArr.length > 0)
                    for (null == this._pathDic && (this._pathDic = {}), h = 0, a = t.pathArr.length; h < a; h++) r = t.pathArr[h], s = new S(r, this._boneList), (n = this._boneSlotDic[r.name]) && ((s = new S(r, this._boneList)).target = n), this._pathDic[r.name] = s;
                if (t.tfArr.length > 0)
                    for (this._tfArr = [], h = 0, a = t.tfArr.length; h < a; h++) this._tfArr.push(new C(t.tfArr[h], this._boneList));
                if (t.skinDataArray.length > 0) {
                    var l = this._templet.skinDataArray[this._skinIndex];
                    this._skinName = l.name
                }
                this._player.on(e.Event.PLAYED, this, this._onPlay), this._player.on(e.Event.STOPPED, this, this._onStop), this._player.on(e.Event.PAUSED, this, this._onPause)
            }
            get url() {
                return this._aniPath
            }
            set url(t) {
                this.load(t)
            }
            load(t, i = null, a = 0) {
                this._aniPath = t, this._complete = i, this._loadAniMode = a, e.ILaya.loader.load([{
                    url: t,
                    type: e.ILaya.Loader.BUFFER
                }], e.Handler.create(this, this._onLoaded))
            }
            _onLoaded() {
                var t, a = e.ILaya.Loader.getRes(this._aniPath);
                null != a && (null == i.Templet.TEMPLET_DICTIONARY && (i.Templet.TEMPLET_DICTIONARY = {}), (t = i.Templet.TEMPLET_DICTIONARY[this._aniPath]) ? t.isParseFail ? this._parseFail() : t.isParserComplete ? this._parseComplete() : (t.on(e.Event.COMPLETE, this, this._parseComplete), t.on(e.Event.ERROR, this, this._parseFail)) : ((t = new i.Templet)._setCreateURL(this._aniPath), i.Templet.TEMPLET_DICTIONARY[this._aniPath] = t, t.on(e.Event.COMPLETE, this, this._parseComplete), t.on(e.Event.ERROR, this, this._parseFail), t.isParserComplete = !1, t.parseData(null, a)))
            }
            _parseComplete() {
                var t = i.Templet.TEMPLET_DICTIONARY[this._aniPath];
                t && (this.init(t, this._loadAniMode), this.play(0, !0)), this._complete && this._complete.runWith(this)
            }
            _parseFail() {
                console.log("[Error]:" + this._aniPath + "解析失败")
            }
            _onPlay() {
                this.event(e.Event.PLAYED)
            }
            _onStop() {
                var t, i = this._templet.eventAniArr[this._aniClipIndex];
                if (i && this._eventIndex < i.length)
                    for (; this._eventIndex < i.length; this._eventIndex++)(t = i[this._eventIndex]).time >= this._player.playStart && t.time <= this._player.playEnd && this.event(e.Event.LABEL, t);
                this._drawOrder = null, this.event(e.Event.STOPPED)
            }
            _onPause() {
                this.event(e.Event.PAUSED)
            }
            _parseSrcBoneMatrix() {
                var t = 0,
                    i = 0;
                for (i = this._templet.srcBoneMatrixArr.length, t = 0; t < i; t++) this._boneMatrixArray.push(new e.Matrix);
                if (0 == this._aniMode) this._boneSlotDic = this._templet.boneSlotDic, this._bindBoneBoneSlotDic = this._templet.bindBoneBoneSlotDic, this._boneSlotArray = this._templet.boneSlotArray;
                else {
                    null == this._boneSlotDic && (this._boneSlotDic = {}), null == this._bindBoneBoneSlotDic && (this._bindBoneBoneSlotDic = {}), null == this._boneSlotArray && (this._boneSlotArray = []);
                    var a, r, s = this._templet.boneSlotArray;
                    for (t = 0, i = s.length; t < i; t++) a = s[t], null == (r = this._bindBoneBoneSlotDic[a.parent]) && (this._bindBoneBoneSlotDic[a.parent] = r = []), this._boneSlotDic[a.name] = a = a.copy(), r.push(a), this._boneSlotArray.push(a)
                }
            }
            _emitMissedEvents(t, i, a = 0) {
                var r = this._templet.eventAniArr[this._player.currentAnimationClipIndex];
                if (r) {
                    var s, n, h = 0;
                    for (s = r.length, h = a; h < s; h++)(n = r[h]).time >= this._player.playStart && n.time <= this._player.playEnd && this.event(e.Event.LABEL, n)
                }
            }
            _update(t = !0) {
                if (!(t && this._pause || t && this._indexControl)) {
                    var i = this.timer.currTimer,
                        a = this._player.currentKeyframeIndex,
                        r = i - this._lastTime;
                    if (t ? this._player._update(r) : a = -1, this._lastTime = i, this._player && (this._index = this._clipIndex = this._player.currentKeyframeIndex, !(this._index < 0 || r > 0 && this._clipIndex == a && this._lastUpdateAniClipIndex == this._aniClipIndex))) {
                        this._lastUpdateAniClipIndex = this._aniClipIndex, a > this._clipIndex && 0 != this._eventIndex && (this._emitMissedEvents(this._player.playStart, this._player.playEnd, this._eventIndex), this._eventIndex = 0);
                        var s, n, h = this._templet.eventAniArr[this._aniClipIndex];
                        if (h && this._eventIndex < h.length) {
                            var l = h[this._eventIndex];
                            l.time >= this._player.playStart && l.time <= this._player.playEnd ? this._player.currentPlayTime >= l.time && (this.event(e.Event.LABEL, l), this._eventIndex++, this._playAudio && l.audioValue && "null" !== l.audioValue && "undefined" !== l.audioValue && (s = e.SoundManager.playSound(this._player.templet._path + l.audioValue, 1, e.Handler.create(this, this._onAniSoundStoped)), e.SoundManager.playbackRate = this._player.playbackRate, s && this._soundChannelArr.push(s))) : l.time < this._player.playStart && this._playAudio && l.audioValue && "null" !== l.audioValue && "undefined" !== l.audioValue ? (this._eventIndex++, s = e.SoundManager.playSound(this._player.templet._path + l.audioValue, 1, e.Handler.create(this, this._onAniSoundStoped), null, (this._player.currentPlayTime - l.time) / 1e3), e.SoundManager.playbackRate = this._player.playbackRate, s && this._soundChannelArr.push(s)) : this._eventIndex++
                        }
                        0 == this._aniMode ? (n = this._templet.getGrahicsDataWithCache(this._aniClipIndex, this._clipIndex) || this._createGraphics()) && this.graphics != n && (this.graphics = n) : 1 == this._aniMode ? (n = this._getGrahicsDataWithCache(this._aniClipIndex, this._clipIndex) || this._createGraphics()) && this.graphics != n && (this.graphics = n) : this._createGraphics()
                    }
                }
            }
            _onAniSoundStoped(t) {
                for (var e, i = this._soundChannelArr.length, a = 0; a < i; a++)((e = this._soundChannelArr[a]).isStopped || t) && (!e.isStopped && e.stop(), this._soundChannelArr.splice(a, 1), i--, a--)
            }
            _createGraphics(t = -1) {
                -1 == t && (t = this._clipIndex);
                var i, a = t * this._player.cacheFrameRateInterval,
                    r = this._templet.drawOrderAniArr[this._aniClipIndex];
                if (r && r.length > 0)
                    for (this._drawOrderIndex = 0, i = r[this._drawOrderIndex]; a >= i.time && (this._drawOrder = i.drawOrder, this._drawOrderIndex++, !(this._drawOrderIndex >= r.length));) i = r[this._drawOrderIndex];
                0 == this._aniMode || 1 == this._aniMode ? this.graphics = p.create() : this.graphics instanceof p ? this.graphics.clear() : this.graphics = p.create();
                var s = this.graphics,
                    n = this._templet.getNodes(this._aniClipIndex),
                    h = 0 == this._player.state;
                this._templet.getOriginalData(this._aniClipIndex, this._curOriginalData, null, t, h ? a + this._player.cacheFrameRateInterval : a);
                var l, o, u, _, d = this._aniSectionDic[this._aniClipIndex],
                    c = 0,
                    m = 0,
                    x = 0,
                    y = 0,
                    g = 0,
                    f = this._templet.srcBoneMatrixArr.length,
                    M = this._curOriginalData;
                for (m = 0, g = d[0]; m < f; m++) {
                    var D = (_ = this._boneList[m]).resultTransform;
                    u = this._templet.srcBoneMatrixArr[m], D.scX = u.scX * M[c++], D.skX = u.skX + M[c++], D.skY = u.skY + M[c++], D.scY = u.scY * M[c++], D.x = u.x + M[c++], D.y = u.y + M[c++], 8 === this._templet.tMatrixDataLen && (D.skewX = u.skewX + M[c++], D.skewY = u.skewY + M[c++])
                }
                var v, I = {},
                    A = {};
                for (g += d[1]; m < g; m++) I[(v = n[m]).name] = M[c++], A[v.name] = M[c++], c += 4;
                var T, S, b = {},
                    C = {};
                for (g += d[2]; m < g; m++) b[(v = n[m]).name] = M[c++], C[v.name] = M[c++], c += 4;
                if (this._pathDic)
                    for (g += d[3]; m < g; m++) {
                        if (v = n[m], T = this._pathDic[v.name]) switch (new e.Byte(v.extenData).getByte()) {
                            case 1:
                                T.position = M[c++];
                                break;
                            case 2:
                                T.spacing = M[c++];
                                break;
                            case 3:
                                T.rotateMix = M[c++], T.translateMix = M[c++]
                        }
                    }
                if (this._rootBone.update(this._yReverseMatrix || e.Matrix.TEMP.identity()), this._ikArr)
                    for (m = 0, g = this._ikArr.length; m < g; m++)(S = this._ikArr[m]).name in b && (S.bendDirection = b[S.name]), S.name in C && (S.mix = C[S.name]), S.apply();
                if (this._pathDic)
                    for (var F in this._pathDic)(T = this._pathDic[F]).apply(this._boneList, s);
                if (this._tfArr)
                    for (m = 0, y = this._tfArr.length; m < y; m++) this._tfArr[m].apply();
                for (m = 0, y = this._boneList.length; m < y; m++)
                    if (_ = this._boneList[m], o = this._bindBoneBoneSlotDic[_.name], _.resultMatrix.copyTo(this._boneMatrixArray[m]), o)
                        for (x = 0, g = o.length; x < g; x++)(l = o[x]) && l.setParentMatrix(_.resultMatrix);
                var w, k, P, L, U = {},
                    B = this._templet.deformAniArr;
                if (B && B.length > 0) {
                    if (this._lastAniClipIndex != this._aniClipIndex)
                        for (this._lastAniClipIndex = this._aniClipIndex, m = 0, g = this._boneSlotArray.length; m < g; m++)(l = this._boneSlotArray[m]).deformData = null;
                    var E, R = B[this._aniClipIndex];
                    for (E in w = R.default, this._setDeform(w, U, this._boneSlotArray, a), R) "default" != E && E != this._skinName && (w = R[E], this._setDeform(w, U, this._boneSlotArray, a));
                    w = R[this._skinName], this._setDeform(w, U, this._boneSlotArray, a)
                }
                if (this._drawOrder)
                    for (m = 0, g = this._drawOrder.length; m < g; m++) k = I[(l = this._boneSlotArray[this._drawOrder[m]]).name], P = A[l.name], isNaN(k) || -2 == k || (this._templet.attachmentNames ? l.showDisplayByName(this._templet.attachmentNames[k]) : l.showDisplayByIndex(k)), U[this._drawOrder[m]] ? (L = U[this._drawOrder[m]], l.currDisplayData && L[l.currDisplayData.attachmentName] ? l.deformData = L[l.currDisplayData.attachmentName] : l.deformData = null) : l.deformData = null, isNaN(P) ? l.draw(s, this._boneMatrixArray, 2 == this._aniMode) : l.draw(s, this._boneMatrixArray, 2 == this._aniMode, P);
                else
                    for (m = 0, g = this._boneSlotArray.length; m < g; m++) k = I[(l = this._boneSlotArray[m]).name], P = A[l.name], isNaN(k) || -2 == k || (this._templet.attachmentNames ? l.showDisplayByName(this._templet.attachmentNames[k]) : l.showDisplayByIndex(k)), U[m] ? (L = U[m], l.currDisplayData && L[l.currDisplayData.attachmentName] ? l.deformData = L[l.currDisplayData.attachmentName] : l.deformData = null) : l.deformData = null, isNaN(P) ? l.draw(s, this._boneMatrixArray, 2 == this._aniMode) : l.draw(s, this._boneMatrixArray, 2 == this._aniMode, P);
                return 0 == this._aniMode ? (this._templet.setGrahicsDataWithCache(this._aniClipIndex, t, s), this._checkIsAllParsed(this._aniClipIndex)) : 1 == this._aniMode && this._setGrahicsDataWithCache(this._aniClipIndex, t, s), s
            }
            _checkIsAllParsed(t) {
                var e, i;
                for (i = Math.floor(.01 + this._templet.getAniDuration(t) / 1e3 * this._player.cacheFrameRate), e = 0; e < i; e++)
                    if (!this._templet.getGrahicsDataWithCache(t, e)) return;
                this._templet.getGrahicsDataWithCache(t, i) ? this._templet.deleteAniData(t) : this._createGraphics(i)
            }
            _setDeform(t, e, i, a) {
                var r, s, n, h, l, o;
                if (t && t)
                    for (h = 0, l = t.deformSlotDataList.length; h < l; h++)
                        for (r = t.deformSlotDataList[h], o = 0; o < r.deformSlotDisplayList.length; o++) n = i[(s = r.deformSlotDisplayList[o]).slotIndex], s.apply(a, n), e[s.slotIndex] || (e[s.slotIndex] = {}), e[s.slotIndex][s.attachment] = s.deformData
            }
            getAnimNum() {
                return this._templet.getAnimationCount()
            }
            getAniNameByIndex(t) {
                return this._templet.getAniNameByIndex(t)
            }
            getSlotByName(t) {
                return this._boneSlotDic[t]
            }
            showSkinByName(t, e = !0) {
                this.showSkinByIndex(this._templet.getSkinIndexByName(t), e)
            }
            showSkinByIndex(t, e = !0) {
                for (var i = 0; i < this._boneSlotArray.length; i++) this._boneSlotArray[i].showSlotData(null, e);
                if (this._templet.showSkinByIndex(this._boneSlotDic, t, e)) {
                    var a = this._templet.skinDataArray[t];
                    this._skinIndex = t, this._skinName = a.name
                }
                this._clearCache()
            }
            showSlotSkinByIndex(t, e) {
                if (0 != this._aniMode) {
                    var i = this.getSlotByName(t);
                    i && i.showDisplayByIndex(e), this._clearCache()
                }
            }
            showSlotSkinByName(t, e) {
                if (0 != this._aniMode) {
                    var i = this.getSlotByName(t);
                    i && i.showDisplayByName(e), this._clearCache()
                }
            }
            replaceSlotSkinName(t, e, i) {
                if (0 != this._aniMode) {
                    var a = this.getSlotByName(t);
                    a && a.replaceDisplayByName(e, i), this._clearCache()
                }
            }
            replaceSlotSkinByIndex(t, e, i) {
                if (0 != this._aniMode) {
                    var a = this.getSlotByName(t);
                    a && a.replaceDisplayByIndex(e, i), this._clearCache()
                }
            }
            setSlotSkin(t, e) {
                if (0 != this._aniMode) {
                    var i = this.getSlotByName(t);
                    i && i.replaceSkin(e), this._clearCache()
                }
            }
            _clearCache() {
                if (1 == this._aniMode)
                    for (var t = 0, e = this._graphicsCache.length; t < e; t++) {
                        for (var i = 0, a = this._graphicsCache[t].length; i < a; i++) {
                            var r = this._graphicsCache[t][i];
                            r && r != this.graphics && p.recycle(r)
                        }
                        this._graphicsCache[t].length = 0
                    }
            }
            play(t, i, a = !0, r = 0, s = 0, n = !0, h = !0) {
                this._playAudio = h, this._indexControl = !1;
                var l, o = -1;
                if (l = i ? 2147483647 : 0, "string" == typeof t)
                    for (var u = 0, _ = this._templet.getAnimationCount(); u < _; u++) {
                        var p = this._templet.getAnimation(u);
                        if (p && t == p.name) {
                            o = u;
                            break
                        }
                    } else o = t;
                o > -1 && o < this.getAnimNum() && (this._aniClipIndex = o, (a || this._pause || this._currAniIndex != o) && (this._currAniIndex = o, this._curOriginalData = new Float32Array(this._templet.getTotalkeyframesLength(o)), this._drawOrder = null, this._eventIndex = 0, this._player.play(o, this._player.playbackRate, l, r, s), n && this._templet.showSkinByIndex(this._boneSlotDic, this._skinIndex), this._pause && (this._pause = !1, this._lastTime = e.ILaya.Browser.now(), this.timer.frameLoop(1, this, this._update, null, !0)), this._update()))
            }
            stop() {
                this._pause || (this._pause = !0, this._player && this._player.stop(!0), this._soundChannelArr.length > 0 && this._onAniSoundStoped(!0), this.timer.clear(this, this._update))
            }
            playbackRate(t) {
                this._player && (this._player.playbackRate = t)
            }
            paused() {
                if (!this._pause) {
                    if (this._pause = !0, this._player && (this._player.paused = !0), this._soundChannelArr.length > 0)
                        for (var t, e = this._soundChannelArr.length, i = 0; i < e; i++)(t = this._soundChannelArr[i]).isStopped || t.pause();
                    this.timer.clear(this, this._update)
                }
            }
            resume() {
                if (this._indexControl = !1, this._pause) {
                    if (this._pause = !1, this._player && (this._player.paused = !1), this._soundChannelArr.length > 0)
                        for (var t, i = this._soundChannelArr.length, a = 0; a < i; a++)(t = this._soundChannelArr[a]).audioBuffer && t.resume();
                    this._lastTime = e.ILaya.Browser.now(), this.timer.frameLoop(1, this, this._update, null, !0)
                }
            }
            _getGrahicsDataWithCache(t, e) {
                return this._graphicsCache[t][e]
            }
            _setGrahicsDataWithCache(t, e, i) {
                this._graphicsCache[t][e] = i
            }
            destroy(t = !0) {
                super.destroy(t), this._templet && this._templet._removeReference(1), this._templet = null, this._player && this._player.offAll(), this._player = null, this._curOriginalData = null, this._boneMatrixArray.length = 0, this._lastTime = 0, this.timer.clear(this, this._update), this._soundChannelArr.length > 0 && this._onAniSoundStoped(!0)
            }
            get index() {
                return this._index
            }
            set index(t) {
                this.player && (this._index = t, this._player.currentTime = 1e3 * this._index / this._player.cacheFrameRate, this._indexControl = !0, (this._aniClipIndex < 0 || this._aniClipIndex >= this.getAnimNum()) && (this._aniClipIndex = 0, this._currAniIndex = 0, this._curOriginalData = new Float32Array(this._templet.getTotalkeyframesLength(this._currAniIndex)), this._drawOrder = null, this._eventIndex = 0), this._update(!1))
            }
            get total() {
                return this._templet && this._player ? this._total = Math.floor(this._templet.getAniDuration(this._player.currentAnimationClipIndex) / 1e3 * this._player.cacheFrameRate) : this._total = -1, this._total
            }
            get player() {
                return this._player
            }
            get templet() {
                return this._templet
            }
        }
        F.useSimpleMeshInCanvas = !1, i.Skeleton = F, e.ILaya.regClass(F), e.ClassUtils.regClass("laya.ani.bone.Skeleton", F), e.ClassUtils.regClass("Laya.Skeleton", F);
        class w {
            constructor() {
                this.slotArr = []
            }
        }
        class k {
            createTexture(t) {
                return this.texture || (this.texture = new e.Texture(t.bitmap, this.uvs), this.uvs[0] > this.uvs[4] && this.uvs[1] > this.uvs[5] ? (this.texture.width = t.height, this.texture.height = t.width, this.texture.offsetX = -t.offsetX, this.texture.offsetY = -t.offsetY, this.texture.sourceWidth = t.sourceHeight, this.texture.sourceHeight = t.sourceWidth) : (this.texture.width = t.width, this.texture.height = t.height, this.texture.offsetX = -t.offsetX, this.texture.offsetY = -t.offsetY, this.texture.sourceWidth = t.sourceWidth, this.texture.sourceHeight = t.sourceHeight)), this.texture
            }
            destory() {
                this.texture && this.texture.destroy()
            }
        }
        class P {
            constructor() {
                this.displayArr = []
            }
            getDisplayByName(t) {
                for (var e = 0, i = this.displayArr.length; e < i; e++)
                    if (this.displayArr[e].attachmentName == t) return e;
                return -1
            }
        }
        class L {
            constructor() {
                this.boneIndexs = []
            }
        }
        class U extends _ {
            constructor() {
                super(...arguments), this._graphicsCache = [], this.srcBoneMatrixArr = [], this.ikArr = [], this.tfArr = [], this.pathArr = [], this.boneSlotDic = {}, this.bindBoneBoneSlotDic = {}, this.boneSlotArray = [], this.skinDataArray = [], this.skinDic = {}, this.subTextureDic = {}, this.isParseFail = !1, this.drawOrderAniArr = [], this.eventAniArr = [], this.attachmentNames = null, this.deformAniArr = [], this.skinSlotDisplayDataArr = [], this._isParseAudio = !1, this._isDestroyed = !1, this._rate = 30, this.isParserComplete = !1, this.aniSectionDic = {}, this._textureDic = {}, this.mBoneArr = []
            }
            loadAni(t) {
                this._skBufferUrl = t, e.ILaya.loader.load(t, e.Handler.create(this, this.onComplete), null, e.ILaya.Loader.BUFFER)
            }
            onComplete(t = null) {
                if (this._isDestroyed) this.destroy();
                else {
                    var i = e.ILaya.Loader.getRes(this._skBufferUrl);
                    i ? (this._path = this._skBufferUrl.slice(0, this._skBufferUrl.lastIndexOf("/")) + "/", this.parseData(null, i)) : this.event(e.Event.ERROR, "load failed:" + this._skBufferUrl)
                }
            }
            parseData(t, e, i = 30) {
                if (!this._path) {
                    var a = this._relativeUrl || this.url;
                    if (a) {
                        var r = a.lastIndexOf("/");
                        this._path = r > 0 ? a.slice(0, r) + "/" : ""
                    }
                }
                this._mainTexture = t, this._rate = i, this.parse(e)
            }
            buildArmature(t = 0) {
                return new F(this, t)
            }
            parse(t) {
                super.parse(t), this.event(e.Event.LOADED, this), this._aniVersion === U.LAYA_ANIMATION_VISION ? this._isParseAudio = !0 : this._aniVersion != U.LAYA_ANIMATION_160_VISION && console.log("[Error] 版本不一致，请使用IDE版本配套的重新导出" + this._aniVersion + "->" + U.LAYA_ANIMATION_VISION), this._mainTexture ? this._parsePublicExtData() : this._parseTexturePath()
            }
            _parseTexturePath() {
                if (this._isDestroyed) this.destroy();
                else {
                    var t = 0;
                    this._loadList = [];
                    var i, a = new e.Byte(this.getPublicExtData()),
                        r = a.getInt32(),
                        s = a.readUTFString(),
                        n = s.split("\n");
                    for (t = 0; t < r; t++) i = this._path + n[2 * t], s = n[2 * t + 1], a.getFloat32(), a.getFloat32(), a.getFloat32(), a.getFloat32(), a.getFloat32(), a.getFloat32(), a.getFloat32(), a.getFloat32(), -1 == this._loadList.indexOf(i) && this._loadList.push(i);
                    e.ILaya.loader.load(this._loadList, e.Handler.create(this, this._textureComplete))
                }
            }
            _textureComplete() {
                for (var t, i = 0, a = this._loadList.length; i < a; i++) t = this._loadList[i], this._textureDic[t] = e.ILaya.Loader.getRes(t);
                this._parsePublicExtData()
            }
            _parsePublicExtData() {
                var t, i = 0,
                    a = 0,
                    r = 0,
                    s = 0,
                    n = 0;
                for (i = 0, n = this.getAnimationCount(); i < n; i++) this._graphicsCache.push([]);
                t = "Dragon" != this._aniClassName;
                var h, l, o = new e.Byte(this.getPublicExtData()),
                    u = 0,
                    _ = 0,
                    p = 0,
                    m = 0,
                    x = 0,
                    y = 0,
                    A = 0,
                    S = 0,
                    C = 0,
                    F = o.getInt32(),
                    U = o.readUTFString(),
                    B = U.split("\n");
                for (i = 0; i < F; i++) {
                    if (h = this._mainTexture, l = this._path + B[2 * i], U = B[2 * i + 1], null == this._mainTexture && (h = this._textureDic[l]), !h) return this.event(e.Event.ERROR, this), void(this.isParseFail = !0);
                    u = o.getFloat32(), _ = o.getFloat32(), p = o.getFloat32(), m = o.getFloat32(), C = o.getFloat32(), x = isNaN(C) ? 0 : C, C = o.getFloat32(), y = isNaN(C) ? 0 : C, C = o.getFloat32(), A = isNaN(C) ? p : C, C = o.getFloat32(), S = isNaN(C) ? m : C, this.subTextureDic[U] = e.Texture.create(h, u, _, p, m, -x, -y, A, S)
                }
                this._mainTexture = h;
                var E, R, N, O, V, Y = o.getUint16();
                for (i = 0; i < Y; i++)(E = []).push(o.getUint16()), E.push(o.getUint16()), E.push(o.getUint16()), E.push(o.getUint16()), this.aniSectionDic[i] = E;
                var K, X = o.getInt16(),
                    W = {};
                for (i = 0; i < X; i++) R = new c, 0 == i ? K = R : R.root = K, R.d = t ? -1 : 1, O = o.readUTFString(), V = o.readUTFString(), R.length = o.getFloat32(), 1 == o.getByte() && (R.inheritRotation = !1), 1 == o.getByte() && (R.inheritScale = !1), R.name = O, V && ((N = W[V]) ? N.addChild(R) : this.mRootBone = R), W[O] = R, this.mBoneArr.push(R);
                this.tMatrixDataLen = o.getUint16();
                var z, G, q = o.getUint16(),
                    H = Math.floor(q / this.tMatrixDataLen),
                    Q = this.srcBoneMatrixArr;
                for (i = 0; i < H; i++)(z = new d).scX = o.getFloat32(), z.skX = o.getFloat32(), z.skY = o.getFloat32(), z.scY = o.getFloat32(), z.x = o.getFloat32(), z.y = o.getFloat32(), 8 === this.tMatrixDataLen && (z.skewX = o.getFloat32(), z.skewY = o.getFloat32()), Q.push(z), (R = this.mBoneArr[i]).transform = z;
                var Z, j, J = o.getUint16();
                for (i = 0; i < J; i++) {
                    for (G = new T, Z = o.getUint16(), a = 0; a < Z; a++) G.boneNames.push(o.readUTFString()), G.boneIndexs.push(o.getInt16());
                    G.name = o.readUTFString(), G.targetBoneName = o.readUTFString(), G.targetBoneIndex = o.getInt16(), G.bendDirection = o.getFloat32(), G.mix = o.getFloat32(), G.isSpine = t, this.ikArr.push(G)
                }
                var $, tt, et = o.getUint16();
                for (i = 0; i < et; i++) {
                    for (j = new L, $ = o.getUint16(), a = 0; a < $; a++) j.boneIndexs.push(o.getInt16());
                    j.name = o.getUTFString(), j.targetIndex = o.getInt16(), j.rotateMix = o.getFloat32(), j.translateMix = o.getFloat32(), j.scaleMix = o.getFloat32(), j.shearMix = o.getFloat32(), j.offsetRotation = o.getFloat32(), j.offsetX = o.getFloat32(), j.offsetY = o.getFloat32(), j.offsetScaleX = o.getFloat32(), j.offsetScaleY = o.getFloat32(), j.offsetShearY = o.getFloat32(), this.tfArr.push(j)
                }
                var it, at, rt, st, nt, ht, lt, ot, ut, _t, pt = o.getUint16();
                for (i = 0; i < pt; i++) {
                    for ((tt = new b).name = o.readUTFString(), it = o.getUint16(), a = 0; a < it; a++) tt.bones.push(o.getInt16());
                    tt.target = o.readUTFString(), tt.positionMode = o.readUTFString(), tt.spacingMode = o.readUTFString(), tt.rotateMode = o.readUTFString(), tt.offsetRotation = o.getFloat32(), tt.position = o.getFloat32(), tt.spacing = o.getFloat32(), tt.rotateMix = o.getFloat32(), tt.translateMix = o.getFloat32(), this.pathArr.push(tt)
                }
                var dt, ct = o.getInt16();
                for (i = 0; i < ct; i++) {
                    var mt = o.getUint8(),
                        xt = {};
                    this.deformAniArr.push(xt);
                    for (var yt = 0; yt < mt; yt++)
                        for ((lt = new f).skinName = o.getUTFString(), xt[lt.skinName] = lt, at = o.getInt16(), a = 0; a < at; a++)
                            for (ot = new M, lt.deformSlotDataList.push(ot), rt = o.getInt16(), r = 0; r < rt; r++)
                                for (ut = new D, ot.deformSlotDisplayList.push(ut), ut.slotIndex = o.getInt16(), ut.attachment = o.getUTFString(), st = o.getInt16(), s = 0; s < st; s++)
                                    for (1 == o.getByte() ? ut.tweenKeyList.push(!0) : ut.tweenKeyList.push(!1), nt = o.getFloat32(), ut.timeList.push(nt), _t = [], ut.vectices.push(_t), ht = o.getInt16(), n = 0; n < ht; n++) _t.push(o.getFloat32())
                }
                var gt, ft, Mt, Dt, vt = o.getInt16();
                for (i = 0; i < vt; i++) {
                    for (gt = o.getInt16(), dt = [], a = 0; a < gt; a++) {
                        for ((ft = new v).time = o.getFloat32(), Mt = o.getInt16(), r = 0; r < Mt; r++) ft.drawOrder.push(o.getInt16());
                        dt.push(ft)
                    }
                    this.drawOrderAniArr.push(dt)
                }
                var It, At, Tt = o.getInt16();
                for (i = 0; i < Tt; i++) {
                    for (It = o.getInt16(), Dt = [], a = 0; a < It; a++)(At = new I).name = o.getUTFString(), this._isParseAudio && (At.audioValue = o.getUTFString()), At.intValue = o.getInt32(), At.floatValue = o.getFloat32(), At.stringValue = o.getUTFString(), At.time = o.getFloat32(), Dt.push(At);
                    this.eventAniArr.push(Dt)
                }
                var St = o.getInt16();
                if (St > 0)
                    for (this.attachmentNames = [], i = 0; i < St; i++) this.attachmentNames.push(o.getUTFString());
                var bt, Ct, Ft = o.getInt16();
                for (i = 0; i < Ft; i++)(bt = new g).name = o.readUTFString(), bt.parent = o.readUTFString(), bt.attachmentName = o.readUTFString(), bt.srcDisplayIndex = bt.displayIndex = o.getInt16(), bt.templet = this, this.boneSlotDic[bt.name] = bt, null == (Ct = this.bindBoneBoneSlotDic[bt.parent]) && (this.bindBoneBoneSlotDic[bt.parent] = Ct = []), Ct.push(bt), this.boneSlotArray.push(bt);
                var wt, kt, Pt, Lt, Ut, Bt, Et, Rt, Nt, Ot, Vt = o.readUTFString().split("\n"),
                    Yt = 0,
                    Kt = o.getUint8();
                for (i = 0; i < Kt; i++) {
                    for ((wt = new w).name = Vt[Yt++], Lt = o.getUint8(), a = 0; a < Lt; a++) {
                        for ((kt = new P).name = Vt[Yt++], bt = this.boneSlotDic[kt.name], Ut = o.getUint8(), r = 0; r < Ut; r++) {
                            if (Pt = new k, this.skinSlotDisplayDataArr.push(Pt), Pt.name = Vt[Yt++], Pt.attachmentName = Vt[Yt++], Pt.transform = new d, Pt.transform.scX = o.getFloat32(), Pt.transform.skX = o.getFloat32(), Pt.transform.skY = o.getFloat32(), Pt.transform.scY = o.getFloat32(), Pt.transform.x = o.getFloat32(), Pt.transform.y = o.getFloat32(), kt.displayArr.push(Pt), Pt.width = o.getFloat32(), Pt.height = o.getFloat32(), Pt.type = o.getUint8(), Pt.verLen = o.getUint16(), (X = o.getUint16()) > 0)
                                for (Pt.bones = [], s = 0; s < X; s++) {
                                    var Xt = o.getUint16();
                                    Pt.bones.push(Xt)
                                }
                            if ((Bt = o.getUint16()) > 0)
                                for (Pt.uvs = [], s = 0; s < Bt; s++) Pt.uvs.push(o.getFloat32());
                            if ((Et = o.getUint16()) > 0)
                                for (Pt.weights = [], s = 0; s < Et; s++) Pt.weights.push(o.getFloat32());
                            if ((Rt = o.getUint16()) > 0)
                                for (Pt.triangles = [], s = 0; s < Rt; s++) Pt.triangles.push(o.getUint16());
                            if ((Nt = o.getUint16()) > 0)
                                for (Pt.vertices = [], s = 0; s < Nt; s++) Pt.vertices.push(o.getFloat32());
                            if ((Ot = o.getUint16()) > 0)
                                for (Pt.lengths = [], s = 0; s < Ot; s++) Pt.lengths.push(o.getFloat32())
                        }
                        wt.slotArr.push(kt)
                    }
                    this.skinDic[wt.name] = wt, this.skinDataArray.push(wt)
                }
                1 == o.getUint8() ? (this.yReverseMatrix = new e.Matrix(1, 0, 0, -1, 0, 0), K && K.setTempMatrix(this.yReverseMatrix)) : K && K.setTempMatrix(new e.Matrix), this.showSkinByIndex(this.boneSlotDic, 0), this.isParserComplete = !0, this.event(e.Event.COMPLETE, this)
            }
            getTexture(t) {
                var e = this.subTextureDic[t];
                return e || (e = this.subTextureDic[t.substr(0, t.length - 1)]), null == e ? this._mainTexture : e
            }
            showSkinByIndex(t, e, i = !0) {
                if (e < 0 && e >= this.skinDataArray.length) return !1;
                var a, r, s, n, h = this.skinDataArray[e];
                if (h) {
                    for (a = 0, r = h.slotArr.length; a < r; a++)(n = h.slotArr[a]) && (s = t[n.name]) && (s.showSlotData(n, i), i && "undefined" != s.attachmentName && "null" != s.attachmentName ? s.showDisplayByName(s.attachmentName) : s.showDisplayByIndex(s.displayIndex));
                    return !0
                }
                return !1
            }
            getSkinIndexByName(t) {
                for (var e = 0, i = this.skinDataArray.length; e < i; e++)
                    if (this.skinDataArray[e].name == t) return e;
                return -1
            }
            getGrahicsDataWithCache(t, e) {
                return this._graphicsCache[t] && this._graphicsCache[t][e] ? this._graphicsCache[t][e] : null
            }
            _setCreateURL(t) {
                this._skBufferUrl = this._relativeUrl = t, super._setCreateURL(t)
            }
            setGrahicsDataWithCache(t, e, i) {
                this._graphicsCache[t][e] = i
            }
            deleteAniData(t) {
                if (this._anis[t]) {
                    var e = this._anis[t];
                    e.bone3DMap = null, e.nodes = null
                }
            }
            destroy() {
                var t;
                for (t in this._isDestroyed = !0, this.subTextureDic) t && this.subTextureDic[t].destroy();
                for (t in this._textureDic) t && this._textureDic[t].destroy();
                for (var i = 0, a = this.skinSlotDisplayDataArr.length; i < a; i++) this.skinSlotDisplayDataArr[i].destory();
                this.skinSlotDisplayDataArr.length = 0, this._relativeUrl && delete U.TEMPLET_DICTIONARY[this._relativeUrl], super.destroy(), e.ILaya.loader.clearRes(this._skBufferUrl)
            }
            getAniNameByIndex(t) {
                var e = this.getAnimation(t);
                return e ? e.name : null
            }
            get rate() {
                return this._rate
            }
            set rate(t) {
                this._rate = t
            }
        }
        U.LAYA_ANIMATION_160_VISION = "LAYAANIMATION:1.6.0", U.LAYA_ANIMATION_VISION = "LAYAANIMATION:1.7.0", i.Templet = U;
        class B extends e.Sprite {
            constructor(t = null) {
                super(), this._start = 0, this._Pos = 0, this._ended = !0, this._loadedImage = {}, this._endFrame = -1, this.interval = 30, this._ids = {}, this._idOfSprite = [], this._reset(), this._playing = !1, this._parentMovieClip = t, t ? (this._isRoot = !1, this._movieClipList = t._movieClipList, this._movieClipList.push(this)) : (this._movieClipList = [this], this._isRoot = !0, this._setBitUp(e.Const.DISPLAY))
            }
            destroy(t = !0) {
                this._clear(), super.destroy(t)
            }
            _setDisplay(t) {
                super._setDisplay(t), this._isRoot && this._onDisplay(t)
            }
            _onDisplay(t) {
                t ? this.timer.loop(this.interval, this, this.updates, null, !0) : this.timer.clear(this, this.updates)
            }
            updates() {
                var t, e;
                if (!this._parentMovieClip)
                    for (e = this._movieClipList.length, t = 0; t < e; t++) this._movieClipList[t] && this._movieClipList[t]._update()
            }
            get index() {
                return this._playIndex
            }
            set index(t) {
                this._playIndex = t, this._data && this._displayFrame(this._playIndex), this._labels && this._labels[t] && this.event(e.Event.LABEL, this._labels[t])
            }
            addLabel(t, e) {
                this._labels || (this._labels = {}), this._labels[e] = t
            }
            removeLabel(t) {
                if (t) {
                    if (!this._labels)
                        for (var e in this._labels)
                            if (this._labels[e] === t) {
                                delete this._labels[e];
                                break
                            }
                } else this._labels = null
            }
            get count() {
                return this._count
            }
            get playing() {
                return this._playing
            }
            _update() {
                if (this._data && this._playing) {
                    if (this._playIndex++, this._playIndex >= this._count) {
                        if (!this.loop) return this._playIndex--, void this.stop();
                        this._playIndex = 0
                    }
                    if (this._parseFrame(this._playIndex), this._labels && this._labels[this._playIndex] && this.event(e.Event.LABEL, this._labels[this._playIndex]), -1 != this._endFrame && this._endFrame == this._playIndex) {
                        if (this._endFrame = -1, null != this._completeHandler) {
                            var t = this._completeHandler;
                            this._completeHandler = null, t.run()
                        }
                        this.stop()
                    }
                }
            }
            stop() {
                this._playing = !1
            }
            gotoAndStop(t) {
                this.index = t, this.stop()
            }
            _clear() {
                if (this.stop(), this._idOfSprite.length = 0, !this._parentMovieClip) {
                    var t, i;
                    for (this.timer.clear(this, this.updates), i = this._movieClipList.length, t = 0; t < i; t++) this._movieClipList[t] != this && this._movieClipList[t]._clear();
                    this._movieClipList.length = 0
                }
                var a;
                for (a in this._atlasPath && e.ILaya.Loader.clearRes(this._atlasPath), this._loadedImage) this._loadedImage[a] && (e.ILaya.Loader.clearRes(a), this._loadedImage[a] = !1);
                this.removeChildren(), this.graphics = null, this._parentMovieClip = null
            }
            play(t = 0, e = !0) {
                this.loop = e, this._playing = !0, this._data && this._displayFrame(t)
            }
            _displayFrame(t = -1) {
                -1 != t && (this._curIndex > t && this._reset(), this._parseFrame(t))
            }
            _reset(t = !0) {
                t && 1 != this._curIndex && this.removeChildren(), this._preIndex = this._curIndex = -1, this._Pos = this._start
            }
            _parseFrame(t) {
                var i, a, r, s, n, h, l = !1,
                    o = this._idOfSprite,
                    u = this._data;
                for (this._ended && this._reset(), u.pos = this._Pos, this._ended = !1, this._playIndex = t, this._curIndex > t && t < this._preIndex && (this._reset(!0), u.pos = this._Pos); this._curIndex <= t && !this._ended;) switch (u.getUint16()) {
                    case 12:
                        if (r = u.getUint16(), s = this._ids[u.getUint16()], this._Pos = u.pos, u.pos = s, 0 == (n = u.getUint8())) {
                            var _ = u.getUint16();
                            if (!(a = o[r])) {
                                a = o[r] = new e.Sprite;
                                var p = new e.Sprite;
                                p.loadImage(this.basePath + _ + ".png"), this._loadedImage[this.basePath + _ + ".png"] = !0, a.addChild(p), p.size(u.getFloat32(), u.getFloat32());
                                var d = u._getMatrix();
                                p.transform = d
                            }
                            a.alpha = 1
                        } else 1 == n && ((i = o[r]) || (o[r] = i = new B(this), i.interval = this.interval, i._ids = this._ids, i.basePath = this.basePath, i._setData(u, s), i._initState(), i.play(0)), i.alpha = 1);
                        u.pos = this._Pos;
                        break;
                    case 3:
                        var c = o[u.getUint16()];
                        c && (this.addChild(c), c.zOrder = u.getUint16(), l = !0);
                        break;
                    case 4:
                        (c = o[u.getUint16()]) && c.removeSelf();
                        break;
                    case 5:
                        o[u.getUint16()][B._ValueList[u.getUint16()]] = u.getFloat32();
                        break;
                    case 6:
                        o[u.getUint16()].visible = u.getUint8() > 0;
                        break;
                    case 7:
                        var m = (a = o[u.getUint16()]).transform || e.Matrix.create();
                        m.setTo(u.getFloat32(), u.getFloat32(), u.getFloat32(), u.getFloat32(), u.getFloat32(), u.getFloat32()), a.transform = m;
                        break;
                    case 8:
                        o[u.getUint16()].setPos(u.getFloat32(), u.getFloat32());
                        break;
                    case 9:
                        o[u.getUint16()].setSize(u.getFloat32(), u.getFloat32());
                        break;
                    case 10:
                        o[u.getUint16()].alpha = u.getFloat32();
                        break;
                    case 11:
                        o[u.getUint16()].setScale(u.getFloat32(), u.getFloat32());
                        break;
                    case 98:
                        h = u.getString(), this.event(h), "stop" == h && this.stop();
                        break;
                    case 99:
                        this._curIndex = u.getUint16(), l && this.updateZOrder();
                        break;
                    case 100:
                        this._count = this._curIndex + 1, this._ended = !0, this._playing && (this.event(e.Event.FRAME), this.event(e.Event.END), this.event(e.Event.COMPLETE)), this._reset(!1)
                }
                this._playing && !this._ended && this.event(e.Event.FRAME), this._Pos = u.pos
            }
            _setData(t, e) {
                this._data = t, this._start = e + 3
            }
            set url(t) {
                this.load(t)
            }
            load(t, i = !1, a = null) {
                var r;
                this._url = t, i && (this._atlasPath = a || t.split(".swf")[0] + ".json"), this.stop(), this._clear(), this._movieClipList = [this], r = [{
                    url: t,
                    type: e.ILaya.Loader.BUFFER
                }], this._atlasPath && r.push({
                    url: this._atlasPath,
                    type: e.ILaya.Loader.ATLAS
                }), e.ILaya.loader.load(r, e.Handler.create(this, this._onLoaded))
            }
            _onLoaded() {
                var t;
                (t = e.ILaya.Loader.getRes(this._url)) ? !this._atlasPath || e.ILaya.Loader.getAtlas(this._atlasPath) ? (this.basePath = this._atlasPath ? e.ILaya.Loader.getAtlas(this._atlasPath).dir : this._url.split(".swf")[0] + "/image/", this._initData(t)) : this.event(e.Event.ERROR, "Atlas not find"): this.event(e.Event.ERROR, "file not find")
            }
            _initState() {
                this._reset(), this._ended = !1;
                var t = this._playing;
                for (this._playing = !1, this._curIndex = 0; !this._ended;) this._parseFrame(++this._curIndex);
                this._playing = t
            }
            _initData(t) {
                this._data = new e.Byte(t);
                var i, a = this._data.getUint16();
                for (i = 0; i < a; i++) this._ids[this._data.getInt16()] = this._data.getInt32();
                this.interval = 1e3 / this._data.getUint16(), this._setData(this._data, this._ids[32767]), this._initState(), this.play(0), this.event(e.Event.LOADED), this._parentMovieClip || this.timer.loop(this.interval, this, this.updates, null, !0)
            }
            playTo(t, e, i = null) {
                this._completeHandler = i, this._endFrame = e, this.play(t, !1)
            }
        }
        B._ValueList = ["x", "y", "width", "height", "scaleX", "scaleY", "rotation", "alpha"], t.AnimationContent = a, t.AnimationNodeContent = r, t.AnimationParser01 = n, t.AnimationParser02 = h, t.AnimationPlayer = o, t.AnimationState = l, t.AnimationTemplet = _, t.BezierLerp = u, t.Bone = c, t.BoneSlot = g, t.DeformAniData = f, t.DeformSlotData = M, t.DeformSlotDisplayData = D, t.DrawOrderData = v, t.EventData = I, t.GraphicsAni = p, t.IAniLib = i, t.IkConstraint = A, t.IkConstraintData = T, t.KeyFramesContent = s, t.MeshData = x, t.MovieClip = B, t.PathConstraint = S, t.PathConstraintData = b, t.Skeleton = F, t.SkinData = w, t.SkinMeshForGraphic = y, t.SkinSlotDisplayData = k, t.SlotData = P, t.Templet = U, t.TfConstraint = C, t.TfConstraintData = L, t.Transform = d, t.UVTools = m
    }(window.Laya = window.Laya || {}, Laya);
});
define("libs/min/laya.html.min.js", function(require, module, exports) {
    ! function(t, e) {
        "use strict";
        class s {
            constructor() {
                this.reset()
            }
            reset() {
                return this.stroke = 0, this.strokeColor = "#000000", this.leading = 0, this.lineHeight = 0, this.letterSpacing = 0, this.href = null, this
            }
            recover() {
                this != s.EMPTY && e.Pool.recover("HTMLExtendStyle", this.reset())
            }
            static create() {
                return e.Pool.getItemByClass("HTMLExtendStyle", s)
            }
        }
        s.EMPTY = new s, e.ClassUtils.regClass("laya.html.utils.HTMLExtendStyle", s), e.ClassUtils.regClass("Laya.HTMLExtendStyle", s);
        class i {
            constructor() {
                this.padding = i._PADDING, this.reset()
            }
            _getExtendStyle() {
                return this._extendStyle === s.EMPTY && (this._extendStyle = s.create()), this._extendStyle
            }
            get href() {
                return this._extendStyle.href
            }
            set href(t) {
                t !== this._extendStyle.href && (this._getExtendStyle().href = t)
            }
            get stroke() {
                return this._extendStyle.stroke
            }
            set stroke(t) {
                this._extendStyle.stroke !== t && (this._getExtendStyle().stroke = t)
            }
            get strokeColor() {
                return this._extendStyle.strokeColor
            }
            set strokeColor(t) {
                this._extendStyle.strokeColor !== t && (this._getExtendStyle().strokeColor = t)
            }
            get leading() {
                return this._extendStyle.leading
            }
            set leading(t) {
                this._extendStyle.leading !== t && (this._getExtendStyle().leading = t)
            }
            get lineHeight() {
                return this._extendStyle.lineHeight
            }
            set lineHeight(t) {
                this._extendStyle.lineHeight !== t && (this._getExtendStyle().lineHeight = t)
            }
            set align(t) {
                t in i.alignVDic && (this._type &= ~i._ALIGN, this._type |= i.alignVDic[t])
            }
            get align() {
                var t = this._type & i._ALIGN;
                return i.align_Value[t]
            }
            set valign(t) {
                t in i.alignVDic && (this._type &= ~i._VALIGN, this._type |= i.alignVDic[t])
            }
            get valign() {
                var t = this._type & i._VALIGN;
                return i.vAlign_Value[t]
            }
            set font(t) {
                for (var e = t.split(" "), s = 0, i = e.length; s < i; s++) {
                    var r = e[s];
                    switch (r) {
                        case "italic":
                            this.italic = !0;
                            continue;
                        case "bold":
                            this.bold = !0;
                            continue
                    }
                    r.indexOf("px") > 0 && (this.fontSize = parseInt(r), this.family = e[s + 1], s++)
                }
            }
            get font() {
                return (this.italic ? "italic " : "") + (this.bold ? "bold " : "") + this.fontSize + "px " + (e.ILaya.Browser.onIPhone && e.ILaya.Text.fontFamilyMap[this.family] || this.family)
            }
            set block(t) {
                t ? this._type |= i._CSS_BLOCK : this._type &= ~i._CSS_BLOCK
            }
            get block() {
                return 0 != (this._type & i._CSS_BLOCK)
            }
            reset() {
                return this.ower = null, this._type = 0, this.wordWrap = !0, this.fontSize = e.ILaya.Text.defaultFontSize, this.family = e.ILaya.Text.defaultFont, this.color = "#000000", this.valign = i.VALIGN_TOP, this.padding = i._PADDING, this.bold = !1, this.italic = !1, this.align = i.ALIGN_LEFT, this.textDecoration = null, this.bgColor = null, this.borderColor = null, this._extendStyle && this._extendStyle.recover(), this._extendStyle = s.EMPTY, this
            }
            recover() {
                e.Pool.recover("HTMLStyle", this.reset())
            }
            static create() {
                return e.Pool.getItemByClass("HTMLStyle", i)
            }
            inherit(t) {
                var e, s, r, h;
                for (s = (r = i._inheritProps).length, e = 0; e < s; e++) this[h = r[e]] = t[h]
            }
            get wordWrap() {
                return 0 == (this._type & i._NOWARP)
            }
            set wordWrap(t) {
                t ? this._type &= ~i._NOWARP : this._type |= i._NOWARP
            }
            get bold() {
                return 0 != (this._type & i._BOLD)
            }
            set bold(t) {
                t ? this._type |= i._BOLD : this._type &= ~i._BOLD
            }
            get fontWeight() {
                return this._type & i._BOLD ? "bold" : "none"
            }
            set fontWeight(t) {
                "bold" == t ? this._type |= i._BOLD : this._type &= ~i._BOLD
            }
            get italic() {
                return 0 != (this._type & i._ITALIC)
            }
            set italic(t) {
                t ? this._type |= i._ITALIC : this._type &= ~i._ITALIC
            }
            _widthAuto() {
                return 0 != (this._type & i._WIDTHAUTO)
            }
            widthed(t) {
                return 0 != (this._type & i._WIDTH_SET)
            }
            set whiteSpace(t) {
                "nowrap" === t && (this._type |= i._NOWARP), "none" === t && (this._type &= ~i._NOWARP)
            }
            get whiteSpace() {
                return this._type & i._NOWARP ? "nowrap" : ""
            }
            _calculation(t, e) {
                return !1
            }
            set width(t) {
                if (this._type |= i._WIDTH_SET, "string" == typeof t) {
                    var e = t.indexOf("auto");
                    if (e >= 0 && (this._type |= i._WIDTHAUTO, t = t.substr(0, e)), this._calculation("width", t)) return;
                    t = parseInt(t)
                }
                this.size(t, -1)
            }
            set height(t) {
                if (this._type |= i._HEIGHT_SET, "string" == typeof t) {
                    if (this._calculation("height", t)) return;
                    t = parseInt(t)
                }
                this.size(-1, t)
            }
            heighted(t) {
                return 0 != (this._type & i._HEIGHT_SET)
            }
            size(t, e) {
                var s = this.ower,
                    r = !1; - 1 !== t && t != s.width && (this._type |= i._WIDTH_SET, s.width = t, r = !0), -1 !== e && e != s.height && (this._type |= i._HEIGHT_SET, s.height = e, r = !0), r && s._layoutLater()
            }
            getLineElement() {
                return 0 != (this._type & i._LINE_ELEMENT)
            }
            setLineElement(t) {
                t ? this._type |= i._LINE_ELEMENT : this._type &= ~i._LINE_ELEMENT
            }
            _enableLayout() {
                return 0 == (this._type & i._DISPLAY_NONE) && 0 == (this._type & i._ABSOLUTE)
            }
            get letterSpacing() {
                return this._extendStyle.letterSpacing
            }
            set letterSpacing(t) {
                "string" == typeof t && (t = parseInt(t + "")), t != this._extendStyle.letterSpacing && (this._getExtendStyle().letterSpacing = t)
            }
            cssText(t) {
                this.attrs(i.parseOneCSS(t, ";"))
            }
            attrs(t) {
                if (t)
                    for (var e = 0, s = t.length; e < s; e++) {
                        var i = t[e];
                        this[i[0]] = i[1]
                    }
            }
            set position(t) {
                "absolute" === t ? this._type |= i._ABSOLUTE : this._type &= ~i._ABSOLUTE
            }
            get position() {
                return this._type & i._ABSOLUTE ? "absolute" : ""
            }
            get absolute() {
                return 0 != (this._type & i._ABSOLUTE)
            }
            get paddingLeft() {
                return this.padding[3]
            }
            get paddingTop() {
                return this.padding[0]
            }
            static parseOneCSS(t, e) {
                for (var s, r = [], h = t.split(e), l = 0, a = h.length; l < a; l++) {
                    var n = h[l],
                        o = n.indexOf(":"),
                        d = n.substr(0, o).replace(/^\s+|\s+$/g, "");
                    if (0 !== d.length) {
                        var _ = n.substr(o + 1).replace(/^\s+|\s+$/g, ""),
                            g = [d, _];
                        switch (d) {
                            case "italic":
                            case "bold":
                                g[1] = "true" == _;
                                break;
                            case "font-weight":
                                "bold" == _ && (g[1] = !0, g[0] = "bold");
                                break;
                            case "line-height":
                                g[0] = "lineHeight", g[1] = parseInt(_);
                                break;
                            case "font-size":
                                g[0] = "fontSize", g[1] = parseInt(_);
                                break;
                            case "stroke":
                                g[0] = "stroke", g[1] = parseInt(_);
                                break;
                            case "padding":
                                (s = _.split(" ")).length > 1 || (s[1] = s[2] = s[3] = s[0]), g[1] = [parseInt(s[0]), parseInt(s[1]), parseInt(s[2]), parseInt(s[3])];
                                break;
                            default:
                                (g[0] = i._CSSTOVALUE[d]) || (g[0] = d)
                        }
                        r.push(g)
                    }
                }
                return r
            }
            static parseCSS(t, e) {
                for (var s; null != (s = i._parseCSSRegExp.exec(t));) i.styleSheets[s[1]] = i.parseOneCSS(s[2], ";")
            }
        }
        i._CSSTOVALUE = {
            "letter-spacing": "letterSpacing",
            "white-space": "whiteSpace",
            "line-height": "lineHeight",
            "font-family": "family",
            "vertical-align": "valign",
            "text-decoration": "textDecoration",
            "background-color": "bgColor",
            "border-color": "borderColor"
        }, i._parseCSSRegExp = new RegExp("([.#]\\w+)\\s*{([\\s\\S]*?)}", "g"), i._inheritProps = ["italic", "align", "valign", "leading", "letterSpacing", "stroke", "strokeColor", "bold", "fontWeight", "fontSize", "lineHeight", "wordWrap", "color"], i.ALIGN_LEFT = "left", i.ALIGN_CENTER = "center", i.ALIGN_RIGHT = "right", i.VALIGN_TOP = "top", i.VALIGN_MIDDLE = "middle", i.VALIGN_BOTTOM = "bottom", i.styleSheets = {}, i.ADDLAYOUTED = 512, i._PADDING = [0, 0, 0, 0], i._HEIGHT_SET = 8192, i._LINE_ELEMENT = 65536, i._NOWARP = 131072, i._WIDTHAUTO = 262144, i._BOLD = 1024, i._ITALIC = 2048, i._CSS_BLOCK = 1, i._DISPLAY_NONE = 2, i._ABSOLUTE = 4, i._WIDTH_SET = 8, i.alignVDic = {
            left: 0,
            center: 16,
            right: 32,
            top: 0,
            middle: 64,
            bottom: 128
        }, i.align_Value = {
            0: "left",
            16: "center",
            32: "right"
        }, i.vAlign_Value = {
            0: "top",
            64: "middle",
            128: "bottom"
        }, i._ALIGN = 48, i._VALIGN = 192, e.ClassUtils.regClass("laya.html.utils.HTMLStyle", i), e.ClassUtils.regClass("Laya.HTMLStyle", i);
        class r {
            constructor() {
                this.all = {}, this.styleSheets = i.styleSheets
            }
            getElementById(t) {
                return this.all[t]
            }
            setElementById(t, e) {
                this.all[t] = e
            }
        }
        r.document = new r, e.ClassUtils.regClass("laya.html.dom.HTMLDocument", r), e.ClassUtils.regClass("Laya.HTMLDocument", r);
        class h {
            constructor() {
                this.rec = new e.Rectangle, this.reset()
            }
            reset() {
                return this.rec.reset(), this.href = null, this
            }
            recover() {
                e.Pool.recover("HTMLHitRect", this.reset())
            }
            static create() {
                return e.Pool.getItemByClass("HTMLHitRect", h)
            }
        }
        e.ClassUtils.regClass("laya.html.dom.HTMLHitRect", h), e.ClassUtils.regClass("Laya.HTMLHitRect", h);
        class l {}
        l.HTMLDivElement = null, l.HTMLImageElement = null, l.HTMLBrElement = null, l.HTMLDivParser = null, l.HTMLParse = null, l.HTMLElementType = null;
        class a {
            constructor() {
                this.elements = [], this.x = 0, this.y = 0, this.w = 0, this.h = 0, this.wordStartIndex = 0, this.minTextHeight = 99999, this.mWidth = 0
            }
            updatePos(t, e, s, r, h, a, n) {
                var o, d = 0;
                this.elements.length > 0 && (d = (o = this.elements[this.elements.length - 1]).x + o.width - this.elements[0].x), n = n || this.h;
                var _, g = 0;
                h === i.ALIGN_CENTER && (g = (e - d) / 2), h === i.ALIGN_RIGHT && (g = e - d);
                for (var c = 0, y = this.elements.length; c < y; c++) {
                    var u = (o = this.elements[c])._getCSSStyle();
                    switch (0 !== g && (o.x += g), u.valign) {
                        case "top":
                            o.y = r;
                            break;
                        case "middle":
                            var p = 0;
                            99999 != this.minTextHeight && (p = this.minTextHeight);
                            var L = (p + n) / 2;
                            L = Math.max(L, this.h), _ = (o.eletype, l.HTMLElementType.IMAGE, r + L - o.height), o.y = _;
                            break;
                        case "bottom":
                            o.y = r + (n - o.height)
                    }
                }
            }
        }
        e.ClassUtils.regClass("laya.html.utils.LayoutLine", a), e.ClassUtils.regClass("Laya.LayoutLine", a);
        class n {
            static later(t) {
                null == n._will && (n._will = [], e.ILaya.stage.frameLoop(1, null, (function() {
                    if (!(n._will.length < 1)) {
                        for (var t = 0; t < n._will.length; t++) n.layout(n._will[t]);
                        n._will.length = 0
                    }
                }))), n._will.push(t)
            }
            static layout(t) {
                return t && t._style ? 0 == (t._style._type & i.ADDLAYOUTED) ? null : (t.style._type &= ~i.ADDLAYOUTED, n._multiLineLayout(t)) : null
            }
            static _multiLineLayout(t) {
                var e = [];
                t._addChildsToLayout(e);
                var s, r, h, o, d, _, g, c = e.length,
                    y = t._getCSSStyle(),
                    u = y.letterSpacing,
                    p = y.leading,
                    L = y.lineHeight,
                    T = y._widthAuto() || !y.wordWrap,
                    m = T ? 999999 : t.width,
                    f = (t.height, t.width),
                    C = y.italic ? y.fontSize / 3 : 0,
                    S = y.align,
                    E = y.valign,
                    x = E !== i.VALIGN_TOP || S !== i.ALIGN_LEFT || 0 != L,
                    w = 0,
                    I = 0,
                    H = 0,
                    v = 0,
                    M = [],
                    U = M[0] = new a,
                    b = !1;
                U.h = 0, y.italic && (m -= y.fontSize / 3);
                var D = 0,
                    A = !0;

                function addLine() {
                    U.y = I, I += U.h + p, U.mWidth = D, D = 0, U = new a, M.push(U), U.h = 0, w = 0, A = !0, d = !1
                }
                for (s = 0; s < c; s++)
                    if (null != (r = e[s]))
                        if (A = !1, r instanceof l.HTMLBrElement) addLine(), U.y = I, U.h = L;
                        else {
                            if (r._isChar()) {
                                if (H = (_ = r).width + _.style.letterSpacing, v = _.height, _.isWord) d = b || "\n" === _.char, U.wordStartIndex = U.elements.length;
                                else {
                                    if (M.length > 0 && w + H > m && U.wordStartIndex > 0) {
                                        var R;
                                        R = U.elements.length - U.wordStartIndex + 1, U.elements.length = U.wordStartIndex, s -= R, addLine();
                                        continue
                                    }
                                    d = !1, D += _.width
                                }
                                b = !1, (d = d || w + H > m) && addLine(), U.minTextHeight = Math.min(U.minTextHeight, r.height)
                            } else h = r._getCSSStyle(), g = r, o = h.padding, d = b || h.getLineElement(), H = g.width + o[1] + o[3] + h.letterSpacing, v = g.height + o[0] + o[2], b = h.getLineElement(), (d = d || w + H > m && h.wordWrap) && addLine();
                            U.elements.push(r), U.h = Math.max(U.h, v), r.x = w, r.y = I, w += H, U.w = w - u, U.y = I, f = Math.max(w + C, f)
                        } else A || (w += n.DIV_ELEMENT_PADDING), U.wordStartIndex = U.elements.length;
                if (I = U.y + U.h, x) {
                    var P = 0,
                        O = m;
                    for (T && t.width > 0 && (O = t.width), s = 0, c = M.length; s < c; s++) M[s].updatePos(0, O, s, P, S, E, L), P += Math.max(L, M[s].h + p);
                    I = P
                }
                return T && (t.width = f), I > t.height && (t.height = I), [f, I]
            }
        }
        var o;
        n.DIV_ELEMENT_PADDING = 0, e.ClassUtils.regClass("laya.html.utils.Layout", n), e.ClassUtils.regClass("Laya.Layout", n), (o = t.HTMLElementType || (t.HTMLElementType = {}))[o.BASE = 0] = "BASE", o[o.IMAGE = 1] = "IMAGE";
        class d {
            constructor() {
                this.eletype = t.HTMLElementType.BASE, this._creates(), this.reset()
            }
            static formatURL1(t, s = null) {
                if (!t) return "null path";
                if (s || (s = e.URL.basePath), t.indexOf(":") > 0) return t;
                if (null != e.URL.customFormat && (t = e.URL.customFormat(t)), t.indexOf(":") > 0) return t;
                var i = t.charAt(0);
                if ("." === i) return e.URL._formatRelativePath(s + t);
                if ("~" === i) return e.URL.rootPath + t.substring(1);
                if ("d" === i) {
                    if (0 === t.indexOf("data:image")) return t
                } else if ("/" === i) return t;
                return s + t
            }
            _creates() {
                this._style = i.create()
            }
            reset() {
                if (this.URI = null, this.parent = null, this._style.reset(), this._style.ower = this, this._style.valign = "middle", this._text && this._text.words) {
                    var t, e, s, i = this._text.words;
                    for (e = i.length, t = 0; t < e; t++)(s = i[t]) && s.recover()
                }
                return this._text = d._EMPTYTEXT, this._children && (this._children.length = 0), this._x = this._y = this._width = this._height = 0, this
            }
            _getCSSStyle() {
                return this._style
            }
            _addChildsToLayout(t) {
                var e = this._getWords();
                if (null == e && (!this._children || 0 == this._children.length)) return !1;
                if (e)
                    for (var s = 0, i = e.length; s < i; s++) t.push(e[s]);
                return this._children && this._children.forEach((function(e, s, i) {
                    var r = e._style;
                    r._enableLayout && r._enableLayout() && e._addToLayout(t)
                })), !0
            }
            _addToLayout(t) {
                if (this._style) {
                    var e = this._style;
                    e.absolute || (e.block ? t.push(this) : this._addChildsToLayout(t) && (this.x = this.y = 0))
                }
            }
            set id(t) {
                r.document.setElementById(t, this)
            }
            repaint(t = !1) {
                this.parentRepaint(t)
            }
            parentRepaint(t = !1) {
                this.parent && this.parent.repaint(t)
            }
            set innerTEXT(t) {
                this._text === d._EMPTYTEXT ? this._text = {
                    text: t,
                    words: null
                } : (this._text.text = t, this._text.words && (this._text.words.length = 0)), this.repaint()
            }
            get innerTEXT() {
                return this._text.text
            }
            _setParent(t) {
                if (t instanceof d) {
                    var e = t;
                    this.URI || (this.URI = e.URI), this.style && this.style.inherit(e.style)
                }
            }
            appendChild(t) {
                return this.addChild(t)
            }
            addChild(t) {
                return t.parent && t.parent.removeChild(t), this._children || (this._children = []), this._children.push(t), t.parent = this, t._setParent(this), this.repaint(), t
            }
            removeChild(t) {
                if (!this._children) return null;
                var e, s;
                for (s = this._children.length, e = 0; e < s; e++)
                    if (this._children[e] == t) return this._children.splice(e, 1), t;
                return null
            }
            static getClassName(t) {
                return t instanceof Function ? t.name : t.constructor.name
            }
            destroy() {
                this._children && (this.destroyChildren(), this._children.length = 0), e.Pool.recover(d.getClassName(this), this.reset())
            }
            destroyChildren() {
                if (this._children) {
                    for (var t = this._children.length - 1; t > -1; t--) this._children[t].destroy();
                    this._children.length = 0
                }
            }
            get style() {
                return this._style
            }
            _getWords() {
                if (!this._text) return null;
                var t = this._text.text;
                if (!t || 0 === t.length) return null;
                var s, i = this._text.words;
                if (i && i.length === t.length) return i;
                null === i && (this._text.words = i = []), i.length = t.length;
                for (var r = this.style, h = r.font, l = 0, a = t.length; l < a; l++) s = e.ILaya.Browser.measureText(t.charAt(l), h), i[l] = e.HTMLChar.create().setData(t.charAt(l), s.width, s.height || r.fontSize, r);
                return i
            }
            _isChar() {
                return !1
            }
            _layoutLater() {
                var t = this.style;
                t._type & i.ADDLAYOUTED || (t.widthed(this) && (this._children && this._children.length > 0 || null != this._getWords()) && t.block ? (n.later(this), t._type |= i.ADDLAYOUTED) : this.parent && this.parent._layoutLater())
            }
            set x(t) {
                this._x != t && (this._x = t, this.parentRepaint())
            }
            get x() {
                return this._x
            }
            set y(t) {
                this._y != t && (this._y = t, this.parentRepaint())
            }
            get y() {
                return this._y
            }
            get width() {
                return this._width
            }
            set width(t) {
                this._width !== t && (this._width = t, this.repaint())
            }
            get height() {
                return this._height
            }
            set height(t) {
                this._height !== t && (this._height = t, this.repaint())
            }
            _setAttributes(t, e) {
                switch (t) {
                    case "style":
                        this.style.cssText(e);
                        break;
                    case "class":
                        this.className = e;
                        break;
                    case "x":
                        this.x = parseFloat(e);
                        break;
                    case "y":
                        this.y = parseFloat(e);
                        break;
                    case "width":
                        this.width = parseFloat(e);
                        break;
                    case "height":
                        this.height = parseFloat(e);
                        break;
                    default:
                        this[t] = e
                }
            }
            set href(t) {
                this._style && t != this._style.href && (this._style.href = t, this.repaint())
            }
            get href() {
                return this._style ? this._style.href : null
            }
            formatURL(t) {
                return this.URI ? d.formatURL1(t, this.URI ? this.URI.path : null) : t
            }
            set color(t) {
                this.style.color = t
            }
            set className(t) {
                this.style.attrs(r.document.styleSheets["." + t])
            }
            drawToGraphic(t, e, s, i) {
                e += this.x, s += this.y;
                var r, h, l, a = this.style;
                if (a.paddingLeft && (e += a.paddingLeft), a.paddingTop && (s += a.paddingTop), (null != a.bgColor || a.borderColor) && t.drawRect(e, s, this.width, this.height, a.bgColor, a.borderColor, 1), this.renderSelfToGraphic(t, e, s, i), this._children && this._children.length > 0)
                    for (h = this._children.length, r = 0; r < h; r++) null != (l = this._children[r]).drawToGraphic && l.drawToGraphic(t, e, s, i)
            }
            renderSelfToGraphic(t, e, s, i) {
                var r = this.style,
                    l = this._getWords();
                if (l && (l.length, r)) {
                    var a = r.font,
                        n = r.color;
                    if (r.stroke) {
                        var o = r.stroke;
                        o = parseInt(o);
                        var d = r.strokeColor;
                        t.fillBorderWords(l, e, s, a, n, d, o)
                    } else t.fillWords(l, e, s, a, n);
                    if (this.href) {
                        var _ = l[l.length - 1],
                            g = _.y + _.height;
                        if (_.y == l[0].y) {
                            "none" != r.textDecoration && t.drawLine(l[0].x, g, _.x + _.width, g, n, 1);
                            var c = h.create();
                            c.rec.setTo(l[0].x, _.y, _.x + _.width - l[0].x, _.height), c.href = this.href, i.push(c)
                        } else this.workLines(l, t, i)
                    }
                }
            }
            workLines(t, e, s) {
                var i;
                i = "none" != this.style.textDecoration;
                var r, h, l, a = 0;
                if (r = t.length, l = h = t[a], h) {
                    var n;
                    for (a = 1; a < r; a++)(n = t[a]).y != h.y ? (this.createOneLine(h, l, i, e, s), h = n, l = n) : l = n;
                    this.createOneLine(h, l, i, e, s)
                }
            }
            createOneLine(t, e, s, i, r) {
                var l = e.y + e.height;
                s && i.drawLine(t.x, l, e.x + e.width, l, this.style.color, 1);
                var a = h.create();
                a.rec.setTo(t.x, e.y, e.x + e.width - t.x, e.height), a.href = this.href, r.push(a)
            }
        }
        d._EMPTYTEXT = {
            text: null,
            words: null
        }, e.ILaya.regClass(d), l.HTMLElementType = t.HTMLElementType, e.ClassUtils.regClass("laya.html.dom.HTMLElement", d), e.ClassUtils.regClass("Laya.HTMLElement", d);
        class _ extends d {
            _addToLayout(t) {
                t.push(this)
            }
            reset() {
                return this
            }
            destroy() {
                e.Pool.recover(d.getClassName(this), this.reset())
            }
            _setParent(t) {}
            set parent(t) {}
            set URI(t) {}
            set href(t) {}
            _getCSSStyle() {
                return _.brStyle || (_.brStyle = new i, _.brStyle.setLineElement(!0), _.brStyle.block = !0), _.brStyle
            }
            renderSelfToGraphic(t, e, s, i) {}
        }
        l.HTMLBrElement = _, e.ILaya.regClass(_), e.ClassUtils.regClass("laya.html.dom.HTMLBrElement", _), e.ClassUtils.regClass("Laya.HTMLBrElement", _);
        class g extends d {
            _creates() {}
            drawToGraphic(t, e, s, i) {}
            reset() {
                return this
            }
            set innerTEXT(t) {
                i.parseCSS(t, null)
            }
            get innerTEXT() {
                return super.innerTEXT
            }
        }
        e.ILaya.regClass(g), e.ClassUtils.regClass("laya.html.dom.HTMLStyleElement", g), e.ClassUtils.regClass("Laya.HTMLStyleElement", g);
        class c extends d {
            _creates() {}
            drawToGraphic(t, e, s, i) {}
            reset() {
                return this._loader && this._loader.off(e.Event.COMPLETE, this, this._onload), this._loader = null, this
            }
            _onload(t) {
                if (this._loader && (this._loader = null), "text/css" === this.type) i.parseCSS(t, this.URI);
                this.repaint(!0)
            }
            set href(t) {
                t && (t = this.formatURL(t), this.URI = new e.URL(t), this._loader && this._loader.off(e.Event.COMPLETE, this, this._onload), e.Loader.getRes(t) ? "text/css" == this.type && i.parseCSS(e.Loader.getRes(t), this.URI) : (this._loader = new e.Loader, this._loader.once(e.Event.COMPLETE, this, this._onload), this._loader.load(t, e.Loader.TEXT)))
            }
            get href() {
                return super.href
            }
        }
        c._cuttingStyle = new RegExp("((@keyframes[\\s\\t]+|)(.+))[\\t\\n\\r\\s]*{", "g"), e.ILaya.regClass(c), e.ClassUtils.regClass("laya.html.dom.HTMLLinkElement", c), e.ClassUtils.regClass("Laya.HTMLLinkElement", c);
        class y extends d {
            constructor() {
                super(...arguments), this.repaintHandler = null
            }
            reset() {
                return super.reset(), this._style.block = !0, this._style.setLineElement(!0), this._style.width = 200, this._style.height = 200, this.repaintHandler = null, this.contextHeight = 0, this.contextWidth = 0, this
            }
            set innerHTML(t) {
                this.destroyChildren(), this.appendHTML(t)
            }
            set width(t) {
                var e;
                e = 0 === t ? t != this._width : t != this.width, super.width = t, e && this.layout()
            }
            appendHTML(t) {
                l.HTMLParse.parse(this, t, this.URI), this.layout()
            }
            _addChildsToLayout(t) {
                var e = this._getWords();
                if (null == e && (!this._children || 0 == this._children.length)) return !1;
                e && e.forEach((function(e) {
                    t.push(e)
                }));
                for (var s = !0, i = 0, r = this._children.length; i < r; i++) {
                    var h = this._children[i];
                    s ? s = !1 : t.push(null), h._addToLayout(t)
                }
                return !0
            }
            _addToLayout(t) {
                this.layout(), !this.style.absolute && t.push(this)
            }
            getBounds() {
                return this._htmlBounds ? (this._boundsRec || (this._boundsRec = e.Rectangle.create()), this._boundsRec.copyFrom(this._htmlBounds)) : null
            }
            parentRepaint(t = !1) {
                super.parentRepaint(), this.repaintHandler && this.repaintHandler.runWith(t)
            }
            layout() {
                this.style._type |= i.ADDLAYOUTED;
                var t = n.layout(this);
                if (t) {
                    this._htmlBounds || (this._htmlBounds = e.Rectangle.create());
                    var s = this._htmlBounds;
                    s.x = s.y = 0, s.width = this.contextWidth = t[0], s.height = this.contextHeight = t[1]
                }
            }
            get height() {
                return this._height ? this._height : this.contextHeight
            }
            set height(t) {
                super.height = t
            }
            get width() {
                return this._width ? this._width : this.contextWidth
            }
        }
        l.HTMLDivParser = y, e.ILaya.regClass(y), e.ClassUtils.regClass("laya.html.dom.HTMLDivParser", y), e.ClassUtils.regClass("Laya.HTMLDivParser", y);
        class u extends d {
            constructor() {
                super(), this.eletype = t.HTMLElementType.IMAGE
            }
            reset() {
                return super.reset(), this._tex && this._tex.off(e.Event.LOADED, this, this.onloaded), this._tex = null, this._url = null, this
            }
            set src(t) {
                if (t = this.formatURL(t), this._url !== t) {
                    this._url = t;
                    var s = this._tex = e.Loader.getRes(t);
                    s || (this._tex = s = new e.Texture, s.load(t), e.Loader.cacheTexture(t, s)), s.getIsReady() ? this.onloaded(s) : s.once(e.Event.READY, this, this.onloaded)
                }
            }
            onloaded(t) {
                if (this._style) {
                    this._tex = t;
                    var e = this._style;
                    e.widthed(this) || this._tex.width, e.heighted(this) || this._tex.height;
                    e.widthed(this) || this._width == this._tex.width || (this.width = this._tex.width, this.parent && this.parent._layoutLater()), e.heighted(this) || this._height == this._tex.height || (this.height = this._tex.height, this.parent && this.parent._layoutLater()), this.repaint()
                }
            }
            _addToLayout(t) {
                !this._style.absolute && t.push(this)
            }
            renderSelfToGraphic(t, e, s, i) {
                this._tex && t.drawImage(this._tex, e, s, this.width || this._tex.width, this.height || this._tex.height)
            }
        }
        l.HTMLImageElement = u, e.ILaya.regClass(u), e.ClassUtils.regClass("laya.html.dom.HTMLImageElement", u), e.ClassUtils.regClass("Laya.HTMLImageElement", u);
        class p {
            static getInstance(t) {
                var s = e.Pool.getItem(p._htmlClassMapShort[t]);
                return s || (s = e.ClassUtils.getInstance(t)), s
            }
            static parse(t, s, i) {
                s = (s = "<root>" + (s = s.replace(/<br>/g, "<br/>")) + "</root>").replace(p.spacePattern, p.char255);
                var r = e.Utils.parseXMLFromString(s);
                p._parseXML(t, r.childNodes[0].childNodes, i)
            }
            static _parseXML(t, e, s, i = null) {
                var r, h;
                if (e.join || e.item)
                    for (r = 0, h = e.length; r < h; ++r) p._parseXML(t, e[r], s, i);
                else {
                    var a, n;
                    if (3 == e.nodeType) {
                        var o;
                        if (t instanceof l.HTMLDivParser) null == e.nodeName && (e.nodeName = "#text"), n = e.nodeName.toLowerCase(), (o = e.textContent.replace(/^\s+|\s+$/g, "")).length > 0 && (a = p.getInstance(n)) && (t.addChild(a), a.innerTEXT = o.replace(p.char255AndOneSpacePattern, " "));
                        else if ((o = e.textContent.replace(/^\s+|\s+$/g, "")).length > 0) {
                            var _ = t;
                            if (t instanceof d && t.innerTEXT && t.innerTEXT.length > 0) {
                                let e = p.getInstance("p");
                                e && (t.addChild(e), _ = e)
                            }
                            _.innerTEXT = o.replace(p.char255AndOneSpacePattern, " ")
                        }
                        return
                    }
                    if ("#comment" == (n = e.nodeName.toLowerCase())) return;
                    if (a = p.getInstance(n)) {
                        "p" == n ? (t.addChild(p.getInstance("br")), a = t.addChild(a), t.addChild(p.getInstance("br"))) : a = t.addChild(a), a.URI = s, a.href = i;
                        var g = e.attributes;
                        if (g && g.length > 0)
                            for (r = 0, h = g.length; r < h; ++r) {
                                var c = g[r],
                                    y = c.nodeName,
                                    u = c.value;
                                a._setAttributes(y, u)
                            }
                        p._parseXML(a, e.childNodes, s, a.href)
                    } else p._parseXML(t, e.childNodes, s, i)
                }
            }
        }
        p.char255 = String.fromCharCode(255), p.spacePattern = /&nbsp;|&#160;/g, p.char255AndOneSpacePattern = new RegExp(String.fromCharCode(255) + "|(\\s+)", "g"), p._htmlClassMapShort = {
            div: y,
            p: d,
            img: u,
            span: d,
            br: _,
            style: g,
            font: d,
            a: d,
            "#text": d,
            link: c
        }, l.HTMLParse = p, e.ClassUtils.regClass("div", y), e.ClassUtils.regClass("p", d), e.ClassUtils.regClass("img", u), e.ClassUtils.regClass("span", d), e.ClassUtils.regClass("br", _), e.ClassUtils.regClass("style", g), e.ClassUtils.regClass("font", d), e.ClassUtils.regClass("a", d), e.ClassUtils.regClass("#text", d), e.ClassUtils.regClass("link", c), e.ClassUtils.regClass("laya.html.utils.HTMLParse", p), e.ClassUtils.regClass("Laya.HTMLParse", p);
        class L extends e.Sprite {
            constructor() {
                super(), this._recList = [], this._repaintState = 0, this._element = new y, this._element.repaintHandler = new e.Handler(this, this._htmlDivRepaint), this.mouseEnabled = !0, this.on(e.Event.CLICK, this, this._onMouseClick)
            }
            destroy(t = !0) {
                this._element && this._element.reset(), this._element = null, this._doClears(), super.destroy(t)
            }
            _htmlDivRepaint(t = !1) {
                t ? this._repaintState < 2 && (this._repaintState = 2) : this._repaintState < 1 && (this._repaintState = 1), this._repaintState > 0 && this._setGraphicDirty()
            }
            _updateGraphicWork() {
                switch (this._repaintState) {
                    case 1:
                        this._updateGraphic();
                        break;
                    case 2:
                        this._refresh()
                }
            }
            _setGraphicDirty() {
                this.callLater(this._updateGraphicWork)
            }
            _doClears() {
                if (this._recList) {
                    var t, e = this._recList.length;
                    for (t = 0; t < e; t++) this._recList[t].recover();
                    this._recList.length = 0
                }
            }
            _updateGraphic() {
                this._doClears(), this.graphics.clear(!0), this._repaintState = 0, this._element.drawToGraphic(this.graphics, -this._element.x, -this._element.y, this._recList);
                var t = this._element.getBounds();
                t && this.setSelfBounds(t), this.size(t.width, t.height)
            }
            get style() {
                return this._element.style
            }
            set innerHTML(t) {
                this._innerHTML != t && (this._repaintState = 1, this._innerHTML = t, this._element.innerHTML = t, this._setGraphicDirty())
            }
            _refresh() {
                this._repaintState = 1, this._innerHTML && (this._element.innerHTML = this._innerHTML), this._setGraphicDirty()
            }
            set width(t) {
                this._element.width = t
            }
            get width() {
                return this._element.width
            }
            set height(t) {
                this._element.height = t
            }
            get height() {
                return this._element.height
            }
            get contextWidth() {
                return this._element.contextWidth
            }
            get contextHeight() {
                return this._element.contextHeight
            }
            _onMouseClick() {
                var t, e, s, i = this.mouseX,
                    r = this.mouseY;
                for (e = this._recList.length, t = 0; t < e; t++)(s = this._recList[t]).rec.contains(i, r) && this._eventLink(s.href)
            }
            _eventLink(t) {
                this.event(e.Event.LINK, [t])
            }
        }
        l.HTMLDivElement = L, l.HTMLParse = p, e.ClassUtils.regClass("laya.html.dom.HTMLDivElement", L), e.ClassUtils.regClass("Laya.HTMLDivElement", L);
        class T extends L {
            constructor() {
                super(), this._element._getCSSStyle().valign = "middle"
            }
            set href(t) {
                t = this._element.formatURL(t);
                var s = new e.Loader;
                s.once(e.Event.COMPLETE, null, (s => {
                    var i = this._element.URI;
                    this._element.URI = new e.URL(t), this.innerHTML = s, !i || (this._element.URI = i)
                })), s.load(t, e.Loader.TEXT)
            }
        }
        e.ClassUtils.regClass("laya.html.dom.HTMLIframeElement", T), e.ClassUtils.regClass("Laya.HTMLIframeElement", T), t.HTMLBrElement = _, t.HTMLDivElement = L, t.HTMLDivParser = y, t.HTMLDocument = r, t.HTMLElement = d, t.HTMLExtendStyle = s, t.HTMLHitRect = h, t.HTMLIframeElement = T, t.HTMLImageElement = u, t.HTMLLinkElement = c, t.HTMLParse = p, t.HTMLStyle = i, t.HTMLStyleElement = g, t.IHtml = l, t.Layout = n, t.LayoutLine = a
    }(window.Laya = window.Laya || {}, Laya);
});
define("libs/min/laya.particle.min.js", function(require, module, exports) {
    ! function(t, e) {
        "use strict";
        class i {
            constructor() {
                this.textureName = null, this.textureCount = 1, this.maxPartices = 100, this.duration = 1, this.ageAddScale = 0, this.emitterVelocitySensitivity = 1, this.minStartSize = 100, this.maxStartSize = 100, this.minEndSize = 100, this.maxEndSize = 100, this.minHorizontalVelocity = 0, this.maxHorizontalVelocity = 0, this.minVerticalVelocity = 0, this.maxVerticalVelocity = 0, this.endVelocity = 1, this.gravity = new Float32Array([0, 0, 0]), this.minRotateSpeed = 0, this.maxRotateSpeed = 0, this.minStartRadius = 0, this.maxStartRadius = 0, this.minEndRadius = 0, this.maxEndRadius = 0, this.minHorizontalStartRadian = 0, this.maxHorizontalStartRadian = 0, this.minVerticalStartRadian = 0, this.maxVerticalStartRadian = 0, this.useEndRadian = !0, this.minHorizontalEndRadian = 0, this.maxHorizontalEndRadian = 0, this.minVerticalEndRadian = 0, this.maxVerticalEndRadian = 0, this.minStartColor = new Float32Array([1, 1, 1, 1]), this.maxStartColor = new Float32Array([1, 1, 1, 1]), this.minEndColor = new Float32Array([1, 1, 1, 1]), this.maxEndColor = new Float32Array([1, 1, 1, 1]), this.colorComponentInter = !1, this.disableColor = !1, this.blendState = 0, this.emitterType = "null", this.emissionRate = 0, this.pointEmitterPosition = new Float32Array([0, 0, 0]), this.pointEmitterPositionVariance = new Float32Array([0, 0, 0]), this.pointEmitterVelocity = new Float32Array([0, 0, 0]), this.pointEmitterVelocityAddVariance = new Float32Array([0, 0, 0]), this.boxEmitterCenterPosition = new Float32Array([0, 0, 0]), this.boxEmitterSize = new Float32Array([0, 0, 0]), this.boxEmitterVelocity = new Float32Array([0, 0, 0]), this.boxEmitterVelocityAddVariance = new Float32Array([0, 0, 0]), this.sphereEmitterCenterPosition = new Float32Array([0, 0, 0]), this.sphereEmitterRadius = 1, this.sphereEmitterVelocity = 0, this.sphereEmitterVelocityAddVariance = 0, this.ringEmitterCenterPosition = new Float32Array([0, 0, 0]), this.ringEmitterRadius = 30, this.ringEmitterVelocity = 0, this.ringEmitterVelocityAddVariance = 0, this.ringEmitterUp = 2, this.positionVariance = new Float32Array([0, 0, 0])
            }
            static checkSetting(t) {
                var e;
                for (e in i._defaultSetting) e in t || (t[e] = i._defaultSetting[e]);
                t.endVelocity = +t.endVelocity, t.gravity[0] = +t.gravity[0], t.gravity[1] = +t.gravity[1], t.gravity[2] = +t.gravity[2]
            }
        }
        i._defaultSetting = new i;
        class r {
            constructor() {}
            addParticleArray(t, e) {}
        }
        class a {
            constructor() {}
            static Create(t, i, r, s) {
                var n = new a;
                n.position = i, e.MathUtil.scaleVector3(r, t.emitterVelocitySensitivity, a._tempVelocity);
                var o, l = e.MathUtil.lerp(t.minHorizontalVelocity, t.maxHorizontalVelocity, Math.random()),
                    h = Math.random() * Math.PI * 2;
                if (a._tempVelocity[0] += l * Math.cos(h), a._tempVelocity[2] += l * Math.sin(h), a._tempVelocity[1] += e.MathUtil.lerp(t.minVerticalVelocity, t.maxVerticalVelocity, Math.random()), n.velocity = a._tempVelocity, n.startColor = a._tempStartColor, n.endColor = a._tempEndColor, t.disableColor) {
                    for (o = 0; o < 3; o++) n.startColor[o] = 1, n.endColor[o] = 1;
                    n.startColor[o] = e.MathUtil.lerp(t.minStartColor[o], t.maxStartColor[o], Math.random()), n.endColor[o] = e.MathUtil.lerp(t.minEndColor[o], t.maxEndColor[o], Math.random())
                } else if (t.colorComponentInter)
                    for (o = 0; o < 4; o++) n.startColor[o] = e.MathUtil.lerp(t.minStartColor[o], t.maxStartColor[o], Math.random()), n.endColor[o] = e.MathUtil.lerp(t.minEndColor[o], t.maxEndColor[o], Math.random());
                else e.MathUtil.lerpVector4(t.minStartColor, t.maxStartColor, Math.random(), n.startColor), e.MathUtil.lerpVector4(t.minEndColor, t.maxEndColor, Math.random(), n.endColor);
                n.sizeRotation = a._tempSizeRotation;
                var m = Math.random();
                n.sizeRotation[0] = e.MathUtil.lerp(t.minStartSize, t.maxStartSize, m), n.sizeRotation[1] = e.MathUtil.lerp(t.minEndSize, t.maxEndSize, m), n.sizeRotation[2] = e.MathUtil.lerp(t.minRotateSpeed, t.maxRotateSpeed, Math.random()), n.radius = a._tempRadius;
                var d = Math.random();
                n.radius[0] = e.MathUtil.lerp(t.minStartRadius, t.maxStartRadius, d), n.radius[1] = e.MathUtil.lerp(t.minEndRadius, t.maxEndRadius, d), n.radian = a._tempRadian, n.radian[0] = e.MathUtil.lerp(t.minHorizontalStartRadian, t.maxHorizontalStartRadian, Math.random()), n.radian[1] = e.MathUtil.lerp(t.minVerticalStartRadian, t.maxVerticalStartRadian, Math.random());
                var c = t.useEndRadian;
                return n.radian[2] = c ? e.MathUtil.lerp(t.minHorizontalEndRadian, t.maxHorizontalEndRadian, Math.random()) : n.radian[0], n.radian[3] = c ? e.MathUtil.lerp(t.minVerticalEndRadian, t.maxVerticalEndRadian, Math.random()) : n.radian[1], n.durationAddScale = t.ageAddScale * Math.random(), n.time = s, n
            }
        }
        a._tempVelocity = new Float32Array(3), a._tempStartColor = new Float32Array(4), a._tempEndColor = new Float32Array(4), a._tempSizeRotation = new Float32Array(3), a._tempRadius = new Float32Array(2), a._tempRadian = new Float32Array(4);
        class s extends r {
            constructor(t) {
                super(), this._floatCountPerVertex = 29, this._firstActiveElement = 0, this._firstNewElement = 0, this._firstFreeElement = 0, this._firstRetiredElement = 0, this._currentTime = 0, this.settings = t
            }
            reUse(t, e) {
                return 0
            }
            initialize() {
                var t;
                this._vertices = this._mesh._vb.getFloat32Array(), t = this._mesh._stride / 4;
                for (var e = 0, i = 0, r = 0; r < this.settings.maxPartices; r++) {
                    var a, s = Math.random(),
                        n = this.settings.textureCount ? 1 / this.settings.textureCount : 1;
                    for (a = 0; a < this.settings.textureCount && !(s < a + n); a += n);
                    this._vertices[e++] = -1, this._vertices[e++] = -1, this._vertices[e++] = 0, this._vertices[e++] = a, e = i += t, this._vertices[e++] = 1, this._vertices[e++] = -1, this._vertices[e++] = 1, this._vertices[e++] = a, e = i += t, this._vertices[e++] = 1, this._vertices[e++] = 1, this._vertices[e++] = 1, this._vertices[e++] = a + n, e = i += t, this._vertices[e++] = -1, this._vertices[e++] = 1, this._vertices[e++] = 0, this._vertices[e++] = a + n, e = i += t
                }
            }
            update(t) {
                this._currentTime += t / 1e3, this.retireActiveParticles(), this.freeRetiredParticles(), this._firstActiveElement == this._firstFreeElement && (this._currentTime = 0), this._firstRetiredElement == this._firstActiveElement && (this._drawCounter = 0)
            }
            retireActiveParticles() {
                for (var t = this.settings.duration; this._firstActiveElement != this._firstNewElement;) {
                    var e = this._firstActiveElement * this._floatCountPerVertex * 4,
                        i = e + 28,
                        r = this._currentTime - this._vertices[i];
                    if ((r *= 1 + this._vertices[e + 27]) + 1e-4 < t) break;
                    this._vertices[i] = this._drawCounter, this._firstActiveElement++, this._firstActiveElement >= this.settings.maxPartices && (this._firstActiveElement = 0)
                }
            }
            freeRetiredParticles() {
                for (; this._firstRetiredElement != this._firstActiveElement;) {
                    if (this._drawCounter - this._vertices[this._firstRetiredElement * this._floatCountPerVertex * 4 + 28] < 3) break;
                    this._firstRetiredElement++, this._firstRetiredElement >= this.settings.maxPartices && (this._firstRetiredElement = 0)
                }
            }
            addNewParticlesToVertexBuffer() {}
            addParticleArray(t, e) {
                var i = this._firstFreeElement + 1;
                if (i >= this.settings.maxPartices && (i = 0), i !== this._firstRetiredElement) {
                    for (var r = a.Create(this.settings, t, e, this._currentTime), s = this._firstFreeElement * this._floatCountPerVertex * 4, n = 0; n < 4; n++) {
                        var o, l;
                        for (o = 0, l = 4; o < 3; o++) this._vertices[s + n * this._floatCountPerVertex + l + o] = r.position[o];
                        for (o = 0, l = 7; o < 3; o++) this._vertices[s + n * this._floatCountPerVertex + l + o] = r.velocity[o];
                        for (o = 0, l = 10; o < 4; o++) this._vertices[s + n * this._floatCountPerVertex + l + o] = r.startColor[o];
                        for (o = 0, l = 14; o < 4; o++) this._vertices[s + n * this._floatCountPerVertex + l + o] = r.endColor[o];
                        for (o = 0, l = 18; o < 3; o++) this._vertices[s + n * this._floatCountPerVertex + l + o] = r.sizeRotation[o];
                        for (o = 0, l = 21; o < 2; o++) this._vertices[s + n * this._floatCountPerVertex + l + o] = r.radius[o];
                        for (o = 0, l = 23; o < 4; o++) this._vertices[s + n * this._floatCountPerVertex + l + o] = r.radian[o];
                        this._vertices[s + n * this._floatCountPerVertex + 27] = r.durationAddScale, this._vertices[s + n * this._floatCountPerVertex + 28] = r.time
                    }
                    this._firstFreeElement = i
                }
            }
        }
        var n = "attribute vec4 a_CornerTextureCoordinate;\r\nattribute vec3 a_Position;\r\nattribute vec3 a_Velocity;\r\nattribute vec4 a_StartColor;\r\nattribute vec4 a_EndColor;\r\nattribute vec3 a_SizeRotation;\r\nattribute vec2 a_Radius;\r\nattribute vec4 a_Radian;\r\nattribute float a_AgeAddScale;\r\nattribute float a_Time;\r\n\r\nvarying vec4 v_Color;\r\nvarying vec2 v_TextureCoordinate;\r\n\r\nuniform float u_CurrentTime;\r\nuniform float u_Duration;\r\nuniform float u_EndVelocity;\r\nuniform vec3 u_Gravity;\r\n\r\nuniform vec2 size;\r\nuniform mat4 u_mmat;\r\n\r\nvec4 ComputeParticlePosition(in vec3 position, in vec3 velocity,in float age,in float normalizedAge)\r\n{\r\n\r\n   float startVelocity = length(velocity);//起始标量速度\r\n   float endVelocity = startVelocity * u_EndVelocity;//结束标量速度\r\n\r\n   float velocityIntegral = startVelocity * normalizedAge +(endVelocity - startVelocity) * normalizedAge *normalizedAge/2.0;//计算当前速度的标量（单位空间），vt=v0*t+(1/2)*a*(t^2)\r\n   \r\n   vec3 addPosition = normalize(velocity) * velocityIntegral * u_Duration;//计算受自身速度影响的位置，转换标量到矢量    \r\n   addPosition += u_Gravity * age * normalizedAge;//计算受重力影响的位置\r\n   \r\n   float radius=mix(a_Radius.x, a_Radius.y, normalizedAge); //计算粒子受半径和角度影响（无需计算角度和半径时，可用宏定义优化屏蔽此计算）\r\n   float radianHorizontal =mix(a_Radian.x,a_Radian.z,normalizedAge);\r\n   float radianVertical =mix(a_Radian.y,a_Radian.w,normalizedAge);\r\n   \r\n   float r =cos(radianVertical)* radius;\r\n   addPosition.y += sin(radianVertical) * radius;\r\n\t\r\n   addPosition.x += cos(radianHorizontal) *r;\r\n   addPosition.z += sin(radianHorizontal) *r;\r\n  \r\n   addPosition.y=-addPosition.y;//2D粒子位置更新需要取负，2D粒子坐标系Y轴正向朝上\r\n   position+=addPosition;\r\n   return  vec4(position,1.0);\r\n}\r\n\r\nfloat ComputeParticleSize(in float startSize,in float endSize, in float normalizedAge)\r\n{    \r\n    float size = mix(startSize, endSize, normalizedAge);\r\n    return size;\r\n}\r\n\r\nmat2 ComputeParticleRotation(in float rot,in float age)\r\n{    \r\n    float rotation =rot * age;\r\n    //计算2x2旋转矩阵.\r\n    float c = cos(rotation);\r\n    float s = sin(rotation);\r\n    return mat2(c, -s, s, c);\r\n}\r\n\r\nvec4 ComputeParticleColor(in vec4 startColor,in vec4 endColor,in float normalizedAge)\r\n{\r\n\tvec4 color=mix(startColor,endColor,normalizedAge);\r\n    //硬编码设置，使粒子淡入很快，淡出很慢,6.7的缩放因子把置归一在0到1之间，可以谷歌x*(1-x)*(1-x)*6.7的制图表\r\n    color.a *= normalizedAge * (1.0-normalizedAge) * (1.0-normalizedAge) * 6.7;\r\n   \r\n    return color;\r\n}\r\n\r\nvoid main()\r\n{\r\n   float age = u_CurrentTime - a_Time;\r\n   age *= 1.0 + a_AgeAddScale;\r\n   float normalizedAge = clamp(age / u_Duration,0.0,1.0);\r\n   gl_Position = ComputeParticlePosition(a_Position, a_Velocity, age, normalizedAge);//计算粒子位置\r\n   float pSize = ComputeParticleSize(a_SizeRotation.x,a_SizeRotation.y, normalizedAge);\r\n   mat2 rotation = ComputeParticleRotation(a_SizeRotation.z, age);\r\n\t\r\n    mat4 mat=u_mmat;\r\n    gl_Position=vec4((mat*gl_Position).xy,0.0,1.0);\r\n    gl_Position.xy += (rotation*a_CornerTextureCoordinate.xy) * pSize*vec2(mat[0][0],mat[1][1]);\r\n    gl_Position=vec4((gl_Position.x/size.x-0.5)*2.0,(0.5-gl_Position.y/size.y)*2.0,0.0,1.0);\r\n   \r\n   v_Color = ComputeParticleColor(a_StartColor,a_EndColor, normalizedAge);\r\n   v_TextureCoordinate =a_CornerTextureCoordinate.zw;\r\n}\r\n\r\n",
            o = "#if defined(GL_FRAGMENT_PRECISION_HIGH)\r\nprecision highp float;\r\n#else\r\nprecision mediump float;\r\n#endif\r\n\r\nvarying vec4 v_Color;\r\nvarying vec2 v_TextureCoordinate;\r\nuniform sampler2D u_texture;\r\n\r\nvoid main()\r\n{\t\r\n\tgl_FragColor=texture2D(u_texture,v_TextureCoordinate)*v_Color;\r\n\tgl_FragColor.xyz *= v_Color.w;\r\n}";
        class l extends e.Shader {
            constructor() {
                super(n, o, "ParticleShader", null, ["a_CornerTextureCoordinate", 0, "a_Position", 1, "a_Velocity", 2, "a_StartColor", 3, "a_EndColor", 4, "a_SizeRotation", 5, "a_Radius", 6, "a_Radian", 7, "a_AgeAddScale", 8, "a_Time", 9])
            }
        }
        l.vs = n, l.ps = o;
        class h extends e.Value2D {
            constructor() {
                super(0, 0), h.pShader || (h.pShader = new l)
            }
            upload() {
                var t = this.size;
                t[0] = e.RenderState2D.width, t[1] = e.RenderState2D.height, this.alpha = this.ALPHA * e.RenderState2D.worldAlpha, h.pShader.upload(this)
            }
        }
        h.pShader = null;
        class m extends s {
            constructor(t) {
                super(t), this.x = 0, this.y = 0, this.sv = new h, this._key = {};
                var i = this;
                e.ILaya.loader.load(this.settings.textureName, e.Handler.create(null, (function(t) {
                    i.texture = t
                })), null, e.Loader.IMAGE), this.sv.u_Duration = this.settings.duration, this.sv.u_Gravity = this.settings.gravity, this.sv.u_EndVelocity = this.settings.endVelocity, this._blendFn = e.BlendMode.fns[t.blendState], this._mesh = e.MeshParticle2D.getAMesh(this.settings.maxPartices), this.initialize()
            }
            getRenderType() {
                return -111
            }
            releaseRender() {}
            addParticleArray(t, e) {
                t[0] += this.x, t[1] += this.y, super.addParticleArray(t, e)
            }
            addNewParticlesToVertexBuffer() {
                var t, e = this._mesh._vb;
                e.clear(), e.append(this._vertices), this._firstNewElement < this._firstFreeElement ? (t = 4 * this._firstNewElement * this._floatCountPerVertex * 4, e.subUpload(t, t, t + 4 * (this._firstFreeElement - this._firstNewElement) * this._floatCountPerVertex * 4)) : (t = 4 * this._firstNewElement * this._floatCountPerVertex * 4, e.subUpload(t, t, t + 4 * (this.settings.maxPartices - this._firstNewElement) * this._floatCountPerVertex * 4), this._firstFreeElement > 0 && (e.setNeedUpload(), e.subUpload(0, 0, 4 * this._firstFreeElement * this._floatCountPerVertex * 4))), this._firstNewElement = this._firstFreeElement
            }
            renderSubmit() {
                if (this.texture && this.texture.getIsReady()) {
                    if (this.update(e.ILaya.timer._delta), this.sv.u_CurrentTime = this._currentTime, this._firstNewElement != this._firstFreeElement && this.addNewParticlesToVertexBuffer(), this.blend(), this._firstActiveElement != this._firstFreeElement) {
                        var t = e.WebGLContext.mainContext;
                        this._mesh.useMesh(t), this.sv.u_texture = this.texture._getSource(), this.sv.upload(), this._firstActiveElement < this._firstFreeElement ? t.drawElements(t.TRIANGLES, 6 * (this._firstFreeElement - this._firstActiveElement), t.UNSIGNED_SHORT, 6 * this._firstActiveElement * 2) : (e.WebGLContext.mainContext.drawElements(t.TRIANGLES, 6 * (this.settings.maxPartices - this._firstActiveElement), t.UNSIGNED_SHORT, 6 * this._firstActiveElement * 2), this._firstFreeElement > 0 && t.drawElements(t.TRIANGLES, 6 * this._firstFreeElement, t.UNSIGNED_SHORT, 0)), e.Stat.renderBatches++
                    }
                    this._drawCounter++
                }
                return 1
            }
            updateParticleForNative() {
                this.texture && this.texture.getIsReady() && (this.update(e.ILaya.timer._delta), this.sv.u_CurrentTime = this._currentTime, this._firstNewElement != this._firstFreeElement && (this._firstNewElement = this._firstFreeElement))
            }
            getMesh() {
                return this._mesh
            }
            getConchMesh() {
                return this._conchMesh
            }
            getFirstNewElement() {
                return this._firstNewElement
            }
            getFirstFreeElement() {
                return this._firstFreeElement
            }
            getFirstActiveElement() {
                return this._firstActiveElement
            }
            getFirstRetiredElement() {
                return this._firstRetiredElement
            }
            setFirstFreeElement(t) {
                this._firstFreeElement = t
            }
            setFirstNewElement(t) {
                this._firstNewElement = t
            }
            addDrawCounter() {
                this._drawCounter++
            }
            blend() {
                if (e.BlendMode.activeBlendFunction !== this._blendFn) {
                    var t = e.WebGLContext.mainContext;
                    t.enable(t.BLEND), this._blendFn(t), e.BlendMode.activeBlendFunction = this._blendFn
                }
            }
            dispose() {
                this._mesh.releaseMesh()
            }
        }
        m.activeBlendType = -1;
        class d {
            constructor() {
                this._frameTime = 0, this._emissionRate = 60, this._emissionTime = 0, this.minEmissionTime = 1 / 60
            }
            set particleTemplate(t) {
                this._particleTemplate = t
            }
            set emissionRate(t) {
                t <= 0 || (this._emissionRate = t, t > 0 && (this.minEmissionTime = 1 / t))
            }
            get emissionRate() {
                return this._emissionRate
            }
            start(t = Number.MAX_VALUE) {
                0 != this._emissionRate && (this._emissionTime = t)
            }
            stop() {
                this._emissionTime = 0
            }
            clear() {
                this._emissionTime = 0
            }
            emit() {}
            advanceTime(t = 1) {
                if (this._emissionTime -= t, !(this._emissionTime < 0 || (this._frameTime += t, this._frameTime < this.minEmissionTime)))
                    for (; this._frameTime > this.minEmissionTime;) this._frameTime -= this.minEmissionTime, this.emit()
            }
        }
        class c extends d {
            constructor(t) {
                super(), this.template = t
            }
            set template(t) {
                this._particleTemplate = t, t || (this._emitFun = null, this.setting = null, this._posRange = null), this.setting = t.settings, this._posRange = this.setting.positionVariance, this._particleTemplate instanceof m && (this._emitFun = this.webGLEmit)
            }
            get template() {
                return this._particleTemplate
            }
            emit() {
                super.emit(), null != this._emitFun && this._emitFun()
            }
            getRandom(t) {
                return (2 * Math.random() - 1) * t
            }
            webGLEmit() {
                var t = new Float32Array(3);
                t[0] = this.getRandom(this._posRange[0]), t[1] = this.getRandom(this._posRange[1]), t[2] = this.getRandom(this._posRange[2]);
                var e = new Float32Array(3);
                e[0] = 0, e[1] = 0, e[2] = 0, this._particleTemplate.addParticleArray(t, e)
            }
            canvasEmit() {
                var t = new Float32Array(3);
                t[0] = this.getRandom(this._posRange[0]), t[1] = this.getRandom(this._posRange[1]), t[2] = this.getRandom(this._posRange[2]);
                var e = new Float32Array(3);
                e[0] = 0, e[1] = 0, e[2] = 0, this._particleTemplate.addParticleArray(t, e)
            }
        }
        class _ extends e.Sprite {
            constructor(t) {
                super(), this._matrix4 = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]), this.autoPlay = !0, this.customRenderEnable = !0, t && this.setParticleSetting(t)
            }
            set url(t) {
                this.load(t)
            }
            load(t) {
                e.ILaya.loader.load(t, e.Handler.create(this, this.setParticleSetting), null, e.ILaya.Loader.JSON)
            }
            setParticleSetting(t) {
                if (!t) return this.stop();
                i.checkSetting(t), this.customRenderEnable = !0, this._particleTemplate = new m(t), this.graphics._saveToCmd(null, e.DrawParticleCmd.create(this._particleTemplate)), this._emitter ? this._emitter.template = this._particleTemplate : this._emitter = new c(this._particleTemplate), this.autoPlay && (this.emitter.start(), this.play())
            }
            get emitter() {
                return this._emitter
            }
            play() {
                e.ILaya.timer.frameLoop(1, this, this._loop)
            }
            stop() {
                e.ILaya.timer.clear(this, this._loop)
            }
            _loop() {
                this.advanceTime(1 / 60)
            }
            advanceTime(t = 1) {
                this._canvasTemplate && this._canvasTemplate.advanceTime(t), this._emitter && this._emitter.advanceTime(t)
            }
            customRender(t, e, i) {
                (this._matrix4[0] = t._curMat.a, this._matrix4[1] = t._curMat.b, this._matrix4[4] = t._curMat.c, this._matrix4[5] = t._curMat.d, this._matrix4[12] = t._curMat.tx, this._matrix4[13] = t._curMat.ty, this._particleTemplate) && (this._particleTemplate.sv.u_mmat = this._matrix4, this._canvasTemplate && this._canvasTemplate.render(t, e, i))
            }
            destroy(t = !0) {
                this._particleTemplate instanceof m && this._particleTemplate.dispose(), super.destroy(t)
            }
        }
        e.ClassUtils.regClass("laya.particle.Particle2D", _), e.ClassUtils.regClass("Laya.Particle2D", _), e.ILaya.regClass(_);
        t.Emitter2D = c, t.EmitterBase = d, t.Particle2D = _, t.ParticleData = a, t.ParticleEmitter = class {
            constructor(t, e, i) {
                this._timeLeftOver = 0, this._tempVelocity = new Float32Array([0, 0, 0]), this._tempPosition = new Float32Array([0, 0, 0]), this._templet = t, this._timeBetweenParticles = 1 / e, this._previousPosition = i
            }
            update(t, i) {
                if ((t /= 1e3) > 0) {
                    e.MathUtil.subtractVector3(i, this._previousPosition, this._tempVelocity), e.MathUtil.scaleVector3(this._tempVelocity, 1 / t, this._tempVelocity);
                    for (var r = this._timeLeftOver + t, a = -this._timeLeftOver; r > this._timeBetweenParticles;) a += this._timeBetweenParticles, r -= this._timeBetweenParticles, e.MathUtil.lerpVector3(this._previousPosition, i, a / t, this._tempPosition), this._templet.addParticleArray(this._tempPosition, this._tempVelocity);
                    this._timeLeftOver = r
                }
                this._previousPosition[0] = i[0], this._previousPosition[1] = i[1], this._previousPosition[2] = i[2]
            }
        }, t.ParticleSetting = i, t.ParticleShader = l, t.ParticleShaderValue = h, t.ParticleTemplate2D = m, t.ParticleTemplateBase = r, t.ParticleTemplateWebGL = s
    }(window.Laya = window.Laya || {}, Laya);
});
define("libs/min/laya.spine.min.js", function(require, module, exports) {
    ! function(e, t) {
        "use strict";
        class s extends t.Texture {
            constructor(e) {
                super(e)
            }
            getImage() {
                return {
                    width: this.sourceWidth,
                    height: this.sourceHeight
                }
            }
            setFilters(e, t) {}
            setWraps(e, t) {}
        }
        class i extends spine.AssetManager {
            constructor(e = "", t, i) {
                super(((e, t) => i[t] = new s(e.bitmap)), e, t)
            }
        }
        var n = spine.Color,
            a = spine.SkeletonClipping,
            r = spine.Vector2,
            l = spine.Utils,
            h = spine.RegionAttachment,
            o = spine.MeshAttachment,
            p = spine.ClippingAttachment;
        class u {
            constructor(e, t, s) {
                this.vertices = e, this.numVertices = t, this.numFloats = s
            }
        }
        class d {
            constructor(e = !0) {
                this.vertexEffect = null, this.tempColor = new n, this.tempColor2 = new n, this.vertexSize = 8, this.twoColorTint = !1, this.renderable = new u(null, 0, 0), this.clipper = new a, this.temp = new r, this.temp2 = new r, this.temp3 = new n, this.temp4 = new n, this.twoColorTint = e, e && (this.vertexSize += 4), this.vertices = l.newFloatArray(1024 * this.vertexSize)
            }
            draw(e, s = -1, i = -1, n, a) {
                let r = this.clipper,
                    u = this.premultipliedAlpha,
                    m = this.temp,
                    c = this.temp2,
                    g = this.temp3,
                    _ = this.temp4,
                    y = this.renderable,
                    k = null,
                    S = null,
                    A = e.drawOrder,
                    f = null,
                    x = e.color,
                    w = !1; - 1 == s && (w = !0);
                for (let e = 0, v = A.length; e < v; e++) {
                    let v = r.isClipping() ? 2 : 8,
                        b = A[e];
                    if (s >= 0 && s == b.data.index && (w = !0), !w) {
                        r.clipEndWithSlot(b);
                        continue
                    }
                    i >= 0 && i == b.data.index && (w = !1);
                    let E, M = b.getAttachment(),
                        D = null;
                    if (M instanceof h) {
                        let e = M;
                        y.vertices = this.vertices, y.numVertices = 4, y.numFloats = v << 2, e.computeWorldVertices(b.bone, y.vertices, 0, v), S = d.QUAD_TRIANGLES, k = e.uvs, D = e.region.renderObject.page.name, E = a[D], f = e.color
                    } else {
                        if (!(M instanceof o)) {
                            if (M instanceof p) {
                                let e = M;
                                r.clipStart(b, e);
                                continue
                            }
                            r.clipEndWithSlot(b);
                            continue
                        } {
                            let e = M;
                            y.vertices = this.vertices, y.numVertices = e.worldVerticesLength >> 1, y.numFloats = y.numVertices * v, y.numFloats > y.vertices.length && (y.vertices = this.vertices = l.newFloatArray(y.numFloats)), e.computeWorldVertices(b, 0, e.worldVerticesLength, y.vertices, 0, v), S = e.triangles, D = e.region.renderObject.page.name, E = a[D], k = e.uvs, f = e.color
                        }
                    }
                    if (null != E) {
                        let e = b.color,
                            s = this.tempColor;
                        s.r = x.r * e.r * f.r, s.g = x.g * e.g * f.g, s.b = x.b * e.b * f.b, s.a = x.a * e.a * f.a, u && (s.r *= s.a, s.g *= s.a, s.b *= s.a);
                        let i = b.data.blendMode;
                        if (r.isClipping()) {
                            r.clipTriangles(y.vertices, y.numFloats, S, S.length, k, s, null, false);
                            let e = new Float32Array(r.clippedVertices),
                                a = r.clippedTriangles,
                                l = [],
                                h = [],
                                o = [];
                            if (null != this.vertexEffect) {
                                let t = this.vertexEffect,
                                    s = e;
                                for (let i = 0, n = e.length; i < n; i += 8) m.x = s[i], m.y = s[i + 1], g.set(s[i + 2], s[i + 3], s[i + 4], s[i + 5]), c.x = s[i + 6], c.y = s[i + 7], _.set(0, 0, 0, 0), t.transform(m, c, g, _), s[i] = m.x, s[i + 1] = m.y, s[i + 2] = g.r, s[i + 3] = g.g, s[i + 4] = g.b, s[i + 5] = g.a, s[i + 6] = c.x, s[i + 7] = c.y, l.push(s[i], -s[i + 1]), o.push(s[i + 2], s[i + 3], s[i + 4], s[i + 5]), h.push(s[i + 6], s[i + 7])
                            } else {
                                let t = 0;
                                for (; Number.isFinite(e[t + 6]) && Number.isFinite(e[t + 7]);) l.push(e[t]), l.push(-e[t + 1]), o.push(e[t + 2]), o.push(e[t + 3]), o.push(e[t + 4]), o.push(e[t + 5]), h.push(e[t + 6]), h.push(e[t + 7]), t += this.vertexSize
                            }
                            let p, u = null,
                                d = null;
                            switch (i) {
                                case 1:
                                    p = "light";
                                    break;
                                case 2:
                                    p = "multiply";
                                    break;
                                case 3:
                                    p = "screen";
                                    break;
                                default:
                                    p = "normal"
                            }
                            d = (255 << 24) + 255 * o[0] | 0 + (255 * o[1] << 8) + (255 * o[2] << 16), n.graphics.drawTriangles(E, 0, 0, l, h, new Uint16Array(a), t.Matrix.EMPTY, o[3], u, p, d)
                        } else {
                            let e = y.vertices,
                                a = [],
                                r = [],
                                l = [];
                            if (null != this.vertexEffect) {
                                let t = this.vertexEffect;
                                for (let i = 0, n = 0, h = y.numFloats; i < h; i += 8, n += 2) m.x = e[i], m.y = e[i + 1], c.x = k[n], c.y = k[n + 1], g.setFromColor(s), _.set(0, 0, 0, 0), t.transform(m, c, g, _), e[i] = m.x, e[i + 1] = m.y, e[i + 2] = g.r, e[i + 3] = g.g, e[i + 4] = g.b, e[i + 5] = g.a, e[i + 6] = c.x, e[i + 7] = c.y, a.push(e[i], -e[i + 1]), l.push(e[i + 2], e[i + 3], e[i + 4], e[i + 5]), r.push(e[i + 6], e[i + 7])
                            } else
                                for (let t = 2, i = 0, n = y.numFloats; t < n; t += 8, i += 2) e[t] = s.r, e[t + 1] = s.g, e[t + 2] = s.b, e[t + 3] = s.a, e[t + 4] = k[i], e[t + 5] = k[i + 1], a.push(e[t - 2], -e[t - 1]), l.push(e[t], e[t + 1], e[t + 2], e[t + 3]), r.push(e[t + 4], e[t + 5]);
                            let h, o = null,
                                p = null;
                            switch (i) {
                                case 1:
                                    h = "light";
                                    break;
                                case 2:
                                    h = "multiply";
                                    break;
                                case 3:
                                    h = "screen";
                                    break;
                                default:
                                    h = "normal"
                            }
                            p = (255 << 24) + 255 * l[0] | 0 + (255 * l[1] << 8) + (255 * l[2] << 16), n.graphics.drawTriangles(E, 0, 0, a, r, new Uint16Array(S), t.Matrix.EMPTY, l[3], o, h, p)
                        }
                    }
                    r.clipEndWithSlot(b)
                }
                r.clipEnd()
            }
        }
        d.QUAD_TRIANGLES = [0, 1, 2, 2, 3, 0];
        var m = spine.TimeKeeper,
            c = spine.Skeleton,
            g = spine.AnimationState,
            _ = spine.AnimationStateData;
        class y extends t.Sprite {
            constructor(e = null) {
                super(), this.currentPlayTime = 0, this._pause = !0, this._currAniName = null, this._playbackRate = 1, this._playAudio = !0, this._soundChannelArr = [], this.trackIndex = 0, e && this.init(e), this._ins = this
            }
            init(e) {
                let s = this;
                this._templet = e, this._templet._addReference(1), this.skeleton = new c(this._templet.skeletonData), this.stateData = new _(this.skeleton.data), this.state = new g(this.stateData), this.skeletonRenderer = new d(!1), this.timeKeeper = new m, this.skeletonRenderer.premultipliedAlpha = this._templet.spinePremultipliedAlpha, this.state.addListener({
                    start: function(e) {},
                    interrupt: function(e) {},
                    end: function(e) {},
                    dispose: function(e) {},
                    complete: function(e) {
                        e.loop ? s.event(t.Event.COMPLETE) : (s._currAniName = null, s.event(t.Event.STOPPED))
                    },
                    event: function(i, n) {
                        let a, r = {
                            audioValue: n.data.audioPath,
                            audioPath: n.data.audioPath,
                            floatValue: n.floatValue,
                            intValue: n.intValue,
                            name: n.data.name,
                            stringValue: n.stringValue,
                            time: 1e3 * n.time,
                            balance: n.balance,
                            volume: n.volume
                        };
                        s.event(t.Event.LABEL, r), s._playAudio && r.audioValue && (a = t.SoundManager.playSound(e._textureDic.root + r.audioValue, 1, t.Handler.create(s, s._onAniSoundStoped), null, (1e3 * s.currentPlayTime - r.time) / 1e3), t.SoundManager.playbackRate = s._playbackRate, a && s._soundChannelArr.push(a))
                    }
                })
            }
            play(e, s, i = !0, n = 0, a = 0, r = !0, l = !0) {
                if (this.worker) {
                    if (!this.initWorker) {
                        this.initWorker = !0;
                        let e = {},
                            s = this._templet.assetManager.get(this._templet.atlasUrl);
                        for (const t of s.pages) e[t.name] = {
                            width: t.width,
                            height: t.height
                        };
                        let i = this._templet.assetManager.pathPrefix + this._templet.atlasUrl,
                            n = t.loader.getRes(i);
                        this.worker.postMessage({
                            msg: "init_skeleton",
                            params: {
                                id: this.gid,
                                skeletonDataStr: this._templet.assetManager.get(this._templet.jsonOrSkelUrl),
                                isSkel: this._templet.jsonOrSkelUrl.endsWith(".bin"),
                                atlasStr: n,
                                atlasTexs: e
                            }
                        })
                    }
                    this.worker.postMessage({
                        msg: "play_skeleton",
                        params: {
                            id: this.gid,
                            nameOrIndex: e,
                            loop: s,
                            force: i,
                            start: n,
                            end: a,
                            freshSkin: r,
                            playAudio: l
                        }
                    })
                }
                this._playAudio = l, a /= 1e3;
                let h = e;
                if ((n /= 1e3) < 0 || a < 0) throw new Error("SpineSkeleton: start and end must large than zero.");
                if (0 !== a && n > a) throw new Error("SpineSkeleton: start must less than end.");
                if ("number" == typeof h && (h = this.getAniNameByIndex(e)), i || this._pause || this._currAniName != h) {
                    this._currAniName = h, this.state.setAnimation(this.trackIndex, h, s);
                    let e = this.state.getCurrent(this.trackIndex);
                    e.animationStart = n, a && a < e.animationEnd && (e.animationEnd = a);
                    let t = e.animation.duration;
                    this._duration = t, this._playStart = n, this._playEnd = a <= t ? a : t, this._pause && (this._pause = !1, this.timer.frameLoop(1, this, this._update, null, !0)), this._update()
                }
            }
            _update() {
                if (this.worker) return;
                let e = this.state.getCurrent(this.trackIndex);
                if (!e) return;
                this.timeKeeper.update();
                let t = this.timeKeeper.delta * this._playbackRate;
                this.state.update(t), this.state.apply(this.skeleton);
                let s = e.animationLast;
                this.currentPlayTime = Math.max(0, s), this.state && this.skeleton && (this.skeleton.updateWorldTransform(), this._ins.graphics.clear(), this.skeletonRenderer.draw(this.skeleton, -1, -1, this._ins, this._templet._textureDic))
            }
            drawNow(e) {
                this._ins.graphics.clear();
                for (const s of e) {
                    let e = this._templet._textureDic[s.name];
                    this._ins.graphics.drawTriangles(e, 0, 0, s.mVertices, s.mUVs, new Uint16Array(s.triangles), t.Matrix.EMPTY, s.colors[3], s.color, s.blendMode, s.colorNum)
                }
            }
            getAnimNum() {
                return this._templet.skeletonData.animations.length
            }
            getAniNameByIndex(e) {
                return this._templet.getAniNameByIndex(e)
            }
            getSlotByName(e) {
                return this.skeleton.findSlot(e)
            }
            playbackRate(e) {
                this._playbackRate = e
            }
            get speed() {
                return this._playbackRate
            }
            set speed(e) {
                this.playbackRate(e)
            }
            findAnimation(e) {
                return this.state.data.skeletonData.findAnimation(e)
            }
            showSkinByName(e) {
                this.showSkinByIndex(this._templet.getSkinIndexByName(e))
            }
            showSkinByIndex(e) {
                let t = this.skeleton.data.skins[e];
                this.skeleton.setSkin(t), this.skeleton.setSlotsToSetupPose()
            }
            stop() {
                this._pause || (this._pause = !0, this._currAniName = null, this.timer.clear(this, this._update), this.state.update(-this.currentPlayTime), this.currentPlayTime = 0, this.event(t.Event.STOPPED), this._soundChannelArr.length > 0 && this._onAniSoundStoped(!0))
            }
            paused() {
                if (!this._pause && (this._pause = !0, this.timer.clear(this, this._update), this.event(t.Event.PAUSED), this._soundChannelArr.length > 0)) {
                    let e;
                    for (let t = this._soundChannelArr.length, s = 0; s < t; s++) e = this._soundChannelArr[s], e.isStopped || e.pause()
                }
            }
            resume() {
                if (this._pause && (this._pause = !1, this.timer.frameLoop(1, this, this._update, null, !0), this._soundChannelArr.length > 0)) {
                    let e;
                    for (let t = this._soundChannelArr.length, s = 0; s < t; s++) e = this._soundChannelArr[s], e.audioBuffer && e.resume()
                }
            }
            _onAniSoundStoped(e) {
                let t;
                for (let s = this._soundChannelArr.length, i = 0; i < s; i++) t = this._soundChannelArr[i], (t.isStopped || e) && (!t.isStopped && t.stop(), this._soundChannelArr.splice(i, 1), s--, i--)
            }
            destroy(e = !0) {
                super.destroy(e), this._templet._removeReference(1), this._templet = null, this.timeKeeper = null, this.skeleton = null, this.state.clearListeners(), this.state = null, this.skeletonRenderer = null, this.timer.clear(this, this._update), this._soundChannelArr.length > 0 && this._onAniSoundStoped(!0)
            }
            get templet() {
                return this._templet
            }
            addAnimation(e, t = !1, s = 0) {
                s /= 1e3;
                let i = e;
                "number" == typeof i && (i = this.getAniNameByIndex(i)), this._currAniName = i, this.state.addAnimation(this.trackIndex, i, t, s)
            }
            setMix(e, t, s) {
                s /= 1e3;
                let i = e;
                "number" == typeof i && (i = this.getAniNameByIndex(i));
                let n = t;
                "number" == typeof n && (n = this.getAniNameByIndex(n)), this.stateData.setMix(i, n, s)
            }
            getBoneByName(e) {
                return this.skeleton.findBone(e)
            }
            getSkeleton() {
                return this.skeleton
            }
            setSlotAttachment(e, t) {
                this.skeleton.setAttachment(e, t)
            }
            set currentTime(e) {
                if (this._currAniName && this._templet) {
                    if ((e /= 1e3) < this._playStart || this._playEnd && e > this._playEnd || e > this._duration) throw new Error("AnimationPlayer: value must large than playStartTime,small than playEndTime.");
                    this.state.update(e - this.currentPlayTime), this.currentPlayTime = e
                }
            }
            get playState() {
                return this._currAniName ? this._pause ? y.paused : y.playing : y.stopped
            }
        }
        y.stopped = 0, y.paused = 1, y.playing = 2, t.ILaya.regClass(y), t.ClassUtils.regClass("laya.layaspine.SpineSkeleton", y), t.ClassUtils.regClass("Laya.SpineSkeleton", y);
        class k extends t.Resource {
            constructor() {
                super(), this._isDestroyed = !1, this._textureDic = {}, this._layaPremultipliedAlpha = !0, this._spinePremultipliedAlpha = !1
            }
            get templet() {
                return this._templet
            }
            set templet(e) {
                this._templet = e
            }
            get isDestroyed() {
                return this._isDestroyed
            }
            set isDestroyed(e) {
                this._isDestroyed = e
            }
            get spinePremultipliedAlpha() {
                return this._spinePremultipliedAlpha
            }
            set spinePremultipliedAlpha(e) {
                this._spinePremultipliedAlpha = e
            }
            buildArmature() {
                return new y(this)
            }
            getAniNameByIndex(e) {
                let t = this.skeletonData.animations[e];
                return t ? t.name : null
            }
            getSkinIndexByName(e) {
                let t, s = this.skeletonData.skins;
                for (let i = 0, n = s.length; i < n; i++)
                    if (t = s[i], t.name == e) return i;
                return -1
            }
            destroy() {
                let e;
                for (e in this.isDestroyed = !0, this._textureDic) "root" != e && e && this._textureDic[e].destroy();
                super.destroy()
            }
        }
        var S = spine.AssetManager,
            A = spine.AtlasAttachmentLoader,
            f = spine.SkeletonJson,
            x = spine.SkeletonBinary;
        class w extends k {
            constructor() {
                super(), this._textureDic = {}
            }
            loadAni(e, s) {
                let i = e.lastIndexOf("/") + 1,
                    n = e.slice(0, i);
                e = e.slice(i), s = s || e.replace(".json", ".atlas").replace(".bin", ".atlas"), this._textureDic.root = n, this.clientId = n, this.atlasUrl = s, this.jsonOrSkelUrl = e, this.assetManager = new S(this._textureLoader.bind(this), n), this.assetManager.loadTextureAtlas(s), e.endsWith(".bin") ? this.assetManager.loadBinary(e) : this.assetManager.loadText(e), t.Laya.timer.frameOnce(1, this, this.loop)
            }
            _textureLoader(e) {
                let t = e.url.replace(this.clientId, "");
                return this._textureDic[t] = new s(e.bitmap)
            }
            loop() {
                this.assetManager.isLoadingComplete() ? this.parseSpineAni() : this.assetManager.hasErrors() ? this.event(t.Event.ERROR, "load failed:" + this.assetManager.getErrors()) : t.Laya.timer.frameOnce(1, this, this.loop)
            }
            parseSpineAni() {
                if (this.isDestroyed) return void this.destroy();
                let e = this.assetManager.get(this.atlasUrl),
                    s = new A(e);
                this.jsonOrSkelUrl.endsWith(".bin") ? (this.skeletonBinary = new x(s), this.skeletonData = this.skeletonBinary.readSkeletonData(this.assetManager.get(this.jsonOrSkelUrl))) : (this.skeletonJson = new f(s), this.skeletonData = this.skeletonJson.readSkeletonData(this.assetManager.get(this.jsonOrSkelUrl))), this.event(t.Event.COMPLETE, this)
            }
            buildArmature() {
                return super.buildArmature()
            }
            getAniNameByIndex(e) {
                return super.getAniNameByIndex(e)
            }
            getSkinIndexByName(e) {
                return super.getSkinIndexByName(e)
            }
            destroy() {
                super.destroy()
            }
        }
        var v, b, E = spine.AtlasAttachmentLoader,
            M = spine.SkeletonJson,
            D = spine.SkeletonBinary;
        class T extends k {
            constructor() {
                super(), this._textureDic = {}
            }
            loadAni(e, s) {
                let n = e.lastIndexOf("/") + 1,
                    a = e.slice(0, n);
                s |= (e = e.slice(n)).replace(".json", ".atlas").replace(".bin", ".atlas"), this._textureDic.root = a, this.pathPrefix = a, this.atlasUrl = s, this.jsonOrSkelUrl = e, this.assetManager = new i(a, new spine.Downloader, this._textureDic), this.assetManager.loadTextureAtlas(s), e.endsWith(".bin") ? this.assetManager.loadBinary(e) : this.assetManager.loadJson(e), t.Laya.timer.frameOnce(1, this, this.loop)
            }
            loop() {
                this.assetManager.isLoadingComplete() ? this.parseSpineAni() : this.assetManager.hasErrors() ? this.event(t.Event.ERROR, "load failed:" + this.assetManager.getErrors()) : t.Laya.timer.frameOnce(1, this, this.loop)
            }
            parseSpineAni() {
                if (this.isDestroyed) return void this.destroy();
                let e = this.assetManager.get(this.atlasUrl),
                    s = new E(e);
                this.jsonOrSkelUrl.endsWith(".bin") ? (this.skeletonBinary = new D(s), this.skeletonData = this.skeletonBinary.readSkeletonData(this.assetManager.get(this.jsonOrSkelUrl))) : (this.skeletonJson = new M(s), this.skeletonData = this.skeletonJson.readSkeletonData(this.assetManager.get(this.jsonOrSkelUrl))), this.event(t.Event.COMPLETE, this)
            }
            buildArmature() {
                return super.buildArmature()
            }
            getAniNameByIndex(e) {
                return super.getAniNameByIndex(e)
            }
            getSkinIndexByName(e) {
                return super.getSkinIndexByName(e)
            }
            destroy() {
                super.destroy()
            }
        }(v = e.SpineVersion || (e.SpineVersion = {})).v3_7 = "v3_7", v.v3_8 = "v3_8", v.v4_0 = "v4_0", (b = e.SpineFormat || (e.SpineFormat = {})).json = "json", b.binary = "binary", e.SpineAssetManager = i, e.SpineGLTexture = s, e.SpineSkeleton = y, e.SpineSkeletonRenderer = d, e.SpineTemplet = class extends k {
            constructor(t) {
                let s;
                if (super(), t === e.SpineVersion.v3_7 || t === e.SpineVersion.v3_8) s = new w;
                else {
                    if (t !== e.SpineVersion.v4_0) throw new Error("传入参数错误，请与服务提供商联系");
                    s = new T
                }
                return s
            }
            loadAni(e) {}
            buildArmature() {
                return null
            }
            getAniNameByIndex(e) {
                return null
            }
            getSkinIndexByName(e) {
                return null
            }
            destroy() {}
        }, e.SpineTempletBase = k, e.SpineTemplet_3_x = w, e.SpineTemplet_4_0 = T
    }(window.Laya = window.Laya || {}, Laya);
});
define("libs/min/laya.ui.min.js", function(require, module, exports) {
    ! function(t, e) {
        "use strict";
        class s {}
        s.touchScrollEnable = !0, s.mouseWheelEnable = !0, s.showButtons = !0, s.popupBgColor = "#000000", s.popupBgAlpha = .5, s.closeDialogOnSide = !0, window.UIConfig = s;
        class i {}
        i.defaultSizeGrid = [4, 4, 4, 4, 0], i.labelColor = "#000000", i.labelPadding = [2, 2, 2, 2], i.inputLabelPadding = [1, 1, 1, 3], i.buttonStateNum = 3, i.buttonLabelColors = ["#32556b", "#32cc6b", "#ff0000", "#C0C0C0"], i.comboBoxItemColors = ["#5e95b6", "#ffffff", "#000000", "#8fa4b1", "#ffffff"], i.scrollBarMinNum = 15, i.scrollBarDelayTime = 500;
        class h extends e.Graphics {
            constructor() {
                super(...arguments), this.autoCacheCmd = !0, this._width = 0, this._height = 0, this.uv = null
            }
            destroy() {
                super.destroy(), this._source = null, this._sizeGrid = null, this._offset = null
            }
            get sizeGrid() {
                return this._sizeGrid
            }
            set sizeGrid(t) {
                this._sizeGrid = t.map((t => +t)), this._setChanged()
            }
            get width() {
                return this._width ? this._width : this._source ? this._source.sourceWidth : 0
            }
            set width(t) {
                this._width != t && (this._width = t, this._setChanged())
            }
            get height() {
                return this._height ? this._height : this._source ? this._source.sourceHeight : 0
            }
            set height(t) {
                this._height != t && (this._height = t, this._setChanged())
            }
            get source() {
                return this._source
            }
            set source(t) {
                if (t) this._source = t, this._setChanged();
                else if (this._source = null, this._drawGridCmd) {
                    this._one && this._one == this._drawGridCmd && this.clear();
                    let t = this.cmds;
                    t && t.length > 0 && t[0] == this._drawGridCmd && t.splice(0, 1)
                }
            }
            _setChanged() {
                this._isChanged || (this._isChanged = !0, e.ILaya.timer.callLater(this, this.changeSource))
            }
            _createDrawTexture(t, s = 0, i = 0, h = 0, a = 0, r = null, l = 1, n = null, o = null, _) {
                if (!t || l < .01) return null;
                if (!t.getIsReady()) return null;
                if (h || (h = t.sourceWidth), a || (a = t.sourceHeight), t.getIsReady()) {
                    var c = h / t.sourceWidth,
                        d = a / t.sourceHeight;
                    if (h = t.width * c, a = t.height * d, h <= 0 || a <= 0) return null;
                    s += t.offsetX * c, i += t.offsetY * d
                }
                return this._sp && (this._sp._renderType |= e.SpriteConst.GRAPHICS, this._sp._setRenderType(this._sp._renderType)), e.DrawTextureCmd.create.call(this, t, s, i, h, a, r, l, n, o, _)
            }
            changeSource() {
                this._isChanged = !1;
                var t = this._source;
                if (t && t.bitmap) {
                    var s = this.width,
                        i = this.height,
                        h = this._sizeGrid,
                        a = t.sourceWidth,
                        r = t.sourceHeight;
                    if (!h || a === s && r === i) {
                        let e = this._createDrawTexture(t, this._offset ? this._offset[0] : 0, this._offset ? this._offset[1] : 0, s, i, null, 1, null, null, this.uv);
                        e && this._setDrawGridCmd(e)
                    } else {
                        let a = e.Draw9GridTexture.create(t, 0, 0, s, i, h);
                        this._setDrawGridCmd(a)
                    }
                    this._repaint()
                }
            }
            drawBitmap(t, e, s, i, h = 0, a = 0) {
                h < .1 || a < .1 || (!t || e.width == h && e.height == a ? this.drawImage(e, s, i, h, a) : this.fillTexture(e, s, i, h, a))
            }
            static getTexture(t, s, i, h, a) {
                var r;
                return h <= 0 && (h = 1), a <= 0 && (a = 1), t.$_GID || (t.$_GID = e.Utils.getGID()), r && r._getSource() || (r = e.Texture.createFromTexture(t, s, i, h, a)), r
            }
            _setDrawGridCmd(t) {
                var e = this._source;
                if (!e || !e.bitmap) return;
                let s = this.cmds;
                if (this._one || s && !(s.length <= 0)) {
                    let e = this._one;
                    e ? e == this._drawGridCmd ? (e.recover(), this._one = t) : (this.clear(), this._saveToCmd(null, t), this._saveToCmd(null, e)) : s.splice(0, 0, t)
                } else this._saveToCmd(null, t);
                this._drawGridCmd = t
            }
        }
        e.ClassUtils.regClass("laya.ui.AutoBitmap", h), e.ClassUtils.regClass("Laya.AutoBitmap", h);
        class a extends e.Component {
            constructor() {
                super(...arguments), this._top = NaN, this._bottom = NaN, this._left = NaN, this._right = NaN, this._centerX = NaN, this._centerY = NaN
            }
            onReset() {
                this._top = this._bottom = this._left = this._right = this._centerX = this._centerY = NaN
            }
            _onEnable() {
                this.owner.parent ? this._onAdded() : this.owner.once(e.Event.ADDED, this, this._onAdded)
            }
            _onDisable() {
                this.owner.off(e.Event.ADDED, this, this._onAdded), this.owner.parent && this.owner.parent.off(e.Event.RESIZE, this, this._onParentResize)
            }
            _onAdded() {
                this.owner.parent && this.owner.parent.on(e.Event.RESIZE, this, this._onParentResize), this.resetLayoutX(), this.resetLayoutY()
            }
            _onParentResize() {
                var t = this.resetLayoutX(),
                    s = this.resetLayoutY();
                (t || s) && this.owner.event(e.Event.RESIZE)
            }
            resetLayoutX() {
                var t = this.owner;
                if (!t) return !1;
                var e = t.parent;
                if (e)
                    if (isNaN(this.centerX)) {
                        if (isNaN(this.left)) isNaN(this.right) || (t.x = Math.round(e.width - t.displayWidth - this.right + t.pivotX * t.scaleX));
                        else if (t.x = Math.round(this.left + t.pivotX * t.scaleX), !isNaN(this.right)) {
                            if (!e._width) return !1;
                            var s = (e._width - this.left - this.right) / (t.scaleX || .01);
                            if (s != t._width) return t.width = s, !0
                        }
                    } else t.x = Math.round(.5 * (e.width - t.displayWidth) + this.centerX + t.pivotX * t.scaleX);
                return !1
            }
            resetLayoutY() {
                var t = this.owner;
                if (!t) return !1;
                var e = t.parent;
                if (e)
                    if (isNaN(this.centerY)) {
                        if (isNaN(this.top)) isNaN(this.bottom) || (t.y = Math.round(e.height - t.displayHeight - this.bottom + t.pivotY * t.scaleY));
                        else if (t.y = Math.round(this.top + t.pivotY * t.scaleY), !isNaN(this.bottom)) {
                            if (!e._height) return !1;
                            var s = (e._height - this.top - this.bottom) / (t.scaleY || .01);
                            if (s != t._height) return t.height = s, !0
                        }
                    } else t.y = Math.round(.5 * (e.height - t.displayHeight) + this.centerY + t.pivotY * t.scaleY);
                return !1
            }
            resetLayout() {
                this.owner && (this.resetLayoutX(), this.resetLayoutY())
            }
            get top() {
                return this._top
            }
            set top(t) {
                this._top != t && (this._top = t, this.resetLayoutY())
            }
            get bottom() {
                return this._bottom
            }
            set bottom(t) {
                this._bottom != t && (this._bottom = t, this.resetLayoutY())
            }
            get left() {
                return this._left
            }
            set left(t) {
                this._left != t && (this._left = t, this.resetLayoutX())
            }
            get right() {
                return this._right
            }
            set right(t) {
                this._right != t && (this._right = t, this.resetLayoutX())
            }
            get centerX() {
                return this._centerX
            }
            set centerX(t) {
                this._centerX != t && (this._centerX = t, this.resetLayoutX())
            }
            get centerY() {
                return this._centerY
            }
            set centerY(t) {
                this._centerY != t && (this._centerY = t, this.resetLayoutY())
            }
        }
        a.EMPTY = null, e.ILaya.regClass(a), a.EMPTY = new a, e.ClassUtils.regClass("laya.ui.Widget", a), e.ClassUtils.regClass("Laya.Widget", a);
        class r extends e.Event {}
        r.SHOW_TIP = "showtip", r.HIDE_TIP = "hidetip", e.ILaya.regClass(r), e.ClassUtils.regClass("laya.ui.UIEvent", r), e.ClassUtils.regClass("Laya.UIEvent", r);
        class l {
            static fillArray(t, e, s = null) {
                var i = t.concat();
                if (e)
                    for (var h = e.split(","), a = 0, r = Math.min(i.length, h.length); a < r; a++) {
                        var l = h[a];
                        i[a] = "true" == l || "false" != l && l, null != s && (i[a] = s(l))
                    }
                return i
            }
            static toColor(t) {
                return e.Utils.toHexColor(t)
            }
            static gray(t, s = !0) {
                s ? l.addFilter(t, l.grayFilter) : l.clearFilter(t, e.ColorFilter)
            }
            static addFilter(t, e) {
                var s = t.filters || [];
                s.push(e), t.filters = s
            }
            static clearFilter(t, e) {
                var s = t.filters;
                if (null != s && s.length > 0) {
                    for (var i = s.length - 1; i > -1; i--) {
                        s[i] instanceof e && s.splice(i, 1)
                    }
                    t.filters = s
                }
            }
            static _getReplaceStr(t) {
                return l.escapeSequence[t]
            }
            static adptString(t) {
                return t.replace(/\\(\w)/g, l._getReplaceStr)
            }
            static getBindFun(t) {
                l._funMap || (l._funMap = new e.WeakObject);
                var s = l._funMap.get(t);
                if (null == s) {
                    var i = '"' + t + '"',
                        h = "(function(data){if(data==null)return;with(data){try{\nreturn " + (i = i.replace(/^"\${|}"$/g, "").replace(/\${/g, '"+').replace(/}/g, '+"')) + "\n}catch(e){}}})";
                    s = window.Laya._runScript(h), l._funMap.set(t, s)
                }
                return s
            }
        }
        l.grayFilter = new e.ColorFilter([.3086, .6094, .082, 0, 0, .3086, .6094, .082, 0, 0, .3086, .6094, .082, 0, 0, 0, 0, 0, 1, 0]), l.escapeSequence = {
            "\\n": "\n",
            "\\t": "\t"
        }, l._funMap = null, e.ClassUtils.regClass("laya.ui.UIUtils", l), e.ClassUtils.regClass("Laya.UIUtils", l);
        class n extends e.Sprite {
            constructor(t = !0) {
                super(), this._anchorX = NaN, this._anchorY = NaN, this._widget = a.EMPTY, t && (this.preinitialize(), this.createChildren(), this.initialize())
            }
            destroy(t = !0) {
                super.destroy(t), this._dataSource = null, this._tag = null, this._toolTip = null
            }
            preinitialize() {}
            createChildren() {}
            initialize() {}
            get width() {
                return this.get_width()
            }
            get_width() {
                return this._width ? this._width : this.measureWidth()
            }
            measureWidth() {
                var t = 0;
                this.commitMeasure();
                for (var e = this.numChildren - 1; e > -1; e--) {
                    var s = this.getChildAt(e);
                    s._visible && (t = Math.max(s._x + s.width * s.scaleX, t))
                }
                return t
            }
            commitMeasure() {}
            get height() {
                return this.get_height()
            }
            get_height() {
                return this._height ? this._height : this.measureHeight()
            }
            measureHeight() {
                var t = 0;
                this.commitMeasure();
                for (var e = this.numChildren - 1; e > -1; e--) {
                    var s = this.getChildAt(e);
                    s._visible && (t = Math.max(s._y + s.height * s.scaleY, t))
                }
                return t
            }
            get dataSource() {
                return this.get_dataSource()
            }
            get_dataSource() {
                return this._dataSource
            }
            set dataSource(t) {
                this.set_dataSource(t)
            }
            set_dataSource(t) {
                for (var e in this._dataSource = t, this._dataSource) e in this && "function" != typeof this[e] && (this[e] = this._dataSource[e])
            }
            get top() {
                return this.get_top()
            }
            get_top() {
                return this._widget.top
            }
            set top(t) {
                this.set_top(t)
            }
            set_top(t) {
                t != this._widget.top && (this._getWidget().top = t)
            }
            get bottom() {
                return this.get_bottom()
            }
            get_bottom() {
                return this._widget.bottom
            }
            set bottom(t) {
                this.set_bottom(t)
            }
            set_bottom(t) {
                t != this._widget.bottom && (this._getWidget().bottom = t)
            }
            get left() {
                return this._widget.left
            }
            set left(t) {
                t != this._widget.left && (this._getWidget().left = t)
            }
            get right() {
                return this._widget.right
            }
            set right(t) {
                t != this._widget.right && (this._getWidget().right = t)
            }
            get centerX() {
                return this._widget.centerX
            }
            set centerX(t) {
                t != this._widget.centerX && (this._getWidget().centerX = t)
            }
            get centerY() {
                return this._widget.centerY
            }
            set centerY(t) {
                t != this._widget.centerY && (this._getWidget().centerY = t)
            }
            _sizeChanged() {
                isNaN(this._anchorX) || (this.pivotX = this.anchorX * this.width), isNaN(this._anchorY) || (this.pivotY = this.anchorY * this.height), this.event(e.Event.RESIZE), this._widget !== a.EMPTY && this._widget.resetLayout()
            }
            get tag() {
                return this._tag
            }
            set tag(t) {
                this._tag = t
            }
            get toolTip() {
                return this._toolTip
            }
            set toolTip(t) {
                this._toolTip != t && (this._toolTip = t, null != t ? (this.on(e.Event.MOUSE_OVER, this, this.onMouseOver), this.on(e.Event.MOUSE_OUT, this, this.onMouseOut)) : (this.off(e.Event.MOUSE_OVER, this, this.onMouseOver), this.off(e.Event.MOUSE_OUT, this, this.onMouseOut)))
            }
            onMouseOver(t) {
                e.ILaya.stage.event(r.SHOW_TIP, this._toolTip)
            }
            onMouseOut(t) {
                e.ILaya.stage.event(r.HIDE_TIP, this._toolTip)
            }
            get gray() {
                return this._gray
            }
            set gray(t) {
                t !== this._gray && (this._gray = t, l.gray(this, t))
            }
            get disabled() {
                return this._disabled
            }
            set disabled(t) {
                t !== this._disabled && (this.gray = this._disabled = t, this.mouseEnabled = !t)
            }
            _getWidget() {
                return this._widget === a.EMPTY && (this._widget = this.addComponent(a)), this._widget
            }
            set scaleX(t) {
                this.set_scaleX(t)
            }
            set_scaleX(t) {
                super.get_scaleX() != t && (super.set_scaleX(t), this.callLater(this._sizeChanged))
            }
            get scaleX() {
                return super.scaleX
            }
            set scaleY(t) {
                this.set_scaleY(t)
            }
            set_scaleY(t) {
                super.get_scaleY() != t && (super.set_scaleY(t), this.callLater(this._sizeChanged))
            }
            get scaleY() {
                return super.scaleY
            }
            onCompResize() {
                this._sizeChanged()
            }
            set width(t) {
                this.set_width(t)
            }
            set_width(t) {
                super.get_width() != t && (super.set_width(t), this.callLater(this._sizeChanged))
            }
            set height(t) {
                this.set_height(t)
            }
            set_height(t) {
                super.get_height() != t && (super.set_height(t), this.callLater(this._sizeChanged))
            }
            get anchorX() {
                return this.get_anchorX()
            }
            get_anchorX() {
                return this._anchorX
            }
            set anchorX(t) {
                this.set_anchorX(t)
            }
            set_anchorX(t) {
                this._anchorX != t && (this._anchorX = t, this.callLater(this._sizeChanged))
            }
            get anchorY() {
                return this.get_anchorY()
            }
            get_anchorY() {
                return this._anchorY
            }
            set anchorY(t) {
                this.set_anchorY(t)
            }
            set_anchorY(t) {
                this._anchorY != t && (this._anchorY = t, this.callLater(this._sizeChanged))
            }
            _childChanged(t = null) {
                this.callLater(this._sizeChanged), super._childChanged(t)
            }
        }
        e.ILaya.regClass(n), e.ClassUtils.regClass("laya.ui.UIComponent", n), e.ClassUtils.regClass("Laya.UIComponent", n);
        class o extends n {
            constructor(t = null) {
                super(), this.skin = t
            }
            destroy(t = !0) {
                super.destroy(t), this._bitmap && this._bitmap.destroy(), this._bitmap = null
            }
            dispose() {
                this.destroy(!0), e.ILaya.loader.clearRes(this._skin)
            }
            createChildren() {
                this.graphics = this._bitmap = new h, this._bitmap.autoCacheCmd = !1
            }
            get skin() {
                return this._skin
            }
            set skin(t) {
                if (this._skin != t)
                    if (this._skin = t, t) {
                        var s = e.Loader.getRes(t);
                        s ? (this.source = s, this.onCompResize()) : e.ILaya.loader.load(this._skin, e.Handler.create(this, this.setSource, [this._skin]), null, e.Loader.IMAGE, 1, !0, this._group)
                    } else this.source = null
            }
            get source() {
                return this._bitmap.source
            }
            set source(t) {
                this._bitmap && (this._bitmap.source = t, this.event(e.Event.LOADED), this.repaint())
            }
            get group() {
                return this._group
            }
            set group(t) {
                t && this._skin && e.Loader.setGroup(this._skin, t), this._group = t
            }
            setSource(t, e = null) {
                this.destroyed || t === this._skin && e && (this.source = e, this.onCompResize())
            }
            measureWidth() {
                return this._bitmap.width
            }
            measureHeight() {
                return this._bitmap.height
            }
            set width(t) {
                super.width = t, this._bitmap.width = 0 == t ? 1e-7 : t
            }
            get width() {
                return super.width
            }
            set height(t) {
                super.height = t, this._bitmap.height = 0 == t ? 1e-7 : t
            }
            get height() {
                return super.height
            }
            get sizeGrid() {
                return this._bitmap.sizeGrid ? this._bitmap.sizeGrid.join(",") : null
            }
            set sizeGrid(t) {
                this._bitmap.sizeGrid = l.fillArray(i.defaultSizeGrid, t, Number)
            }
            set dataSource(t) {
                this._dataSource = t, "string" == typeof t ? this.skin = t : super.dataSource = t
            }
            get dataSource() {
                return super.dataSource
            }
        }
        e.ILaya.regClass(o), e.ClassUtils.regClass("laya.ui.Image", o), e.ClassUtils.regClass("Laya.Image", o);
        class _ extends o {
            constructor(t = null) {
                super(), this.advsListArr = [], this.resUrl = "https://unioncdn.layabox.com/config/iconlist.json", this._http = new e.Browser.window.XMLHttpRequest, this._data = [], this._resquestTime = 36e4, this._playIndex = 0, this._lunboTime = 5e3, this.skin = t, this.setLoadUrl(), this.init(), this.size(120, 120)
            }
            setLoadUrl() {}
            init() {
                this.isSupportJump() ? ((e.Browser.onMiniGame || e.Browser.onBDMiniGame) && e.ILaya.timer.loop(this._resquestTime, this, this.onGetAdvsListData), this.onGetAdvsListData(), this.initEvent()) : this.visible = !1
            }
            initEvent() {
                this.on(e.Event.CLICK, this, this.onAdvsImgClick)
            }
            onAdvsImgClick() {
                this.getCurrentAppidObj() && this.jumptoGame()
            }
            revertAdvsData() {
                this.advsListArr[this._playIndex] && (this.visible = !0, this.skin = this.advsListArr[this._playIndex])
            }
            isSupportJump() {
                return e.Browser.onMiniGame ? window.wx.navigateToMiniProgram instanceof Function : !!e.Browser.onBDMiniGame
            }
            jumptoGame() {
                var t = this.advsListArr[this._playIndex];
                parseInt(t.gameid), t.extendInfo, t.path;
                e.Browser.onMiniGame ? this.isSupportJump() && window.wx.navigateToMiniProgram({
                    appId: this._appid,
                    path: "",
                    extraData: "",
                    envVersion: "release",
                    success: () => {
                        console.log("-------------跳转成功--------------")
                    },
                    fail: () => {
                        console.log("-------------跳转失败--------------")
                    },
                    complete: () => {
                        console.log("-------------跳转接口调用成功--------------"), this.updateAdvsInfo()
                    }
                }) : e.Browser.onBDMiniGame || (this.visible = !1)
            }
            updateAdvsInfo() {
                this.visible = !1, this.onLunbo(), e.ILaya.timer.loop(this._lunboTime, this, this.onLunbo)
            }
            onLunbo() {
                this._playIndex >= this.advsListArr.length - 1 ? this._playIndex = 0 : this._playIndex += 1, this.visible = !0, this.revertAdvsData()
            }
            getCurrentAppidObj() {
                return this.advsListArr[this._playIndex]
            }
            onGetAdvsListData() {
                var t = this,
                    e = _.randRange(1e4, 1e6),
                    s = this.resUrl + "?" + e;
                this._http.open("get", s, !0), this._http.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"), this._http.responseType = "text", this._http.onerror = function(e) {
                    t._onError(e)
                }, this._http.onload = function(e) {
                    t._onLoad(e)
                }, this._http.send(null)
            }
            static randRange(t, e) {
                return Math.floor(Math.random() * (e - t + 1)) + t
            }
            _onError(t) {
                this.error("Request failed Status:" + this._http.status + " text:" + this._http.statusText)
            }
            _onLoad(t) {
                var e = this._http,
                    s = void 0 !== e.status ? e.status : 200;
                200 === s || 204 === s || 0 === s ? this.complete() : this.error("[" + e.status + "]" + e.statusText + ":" + e.responseURL)
            }
            error(t) {
                this.event(e.Event.ERROR, t)
            }
            complete() {
                try {
                    this._data = this._http.response || this._http.responseText, this._data = JSON.parse(this._data), this.advsListArr = this._data.list, this._appid = this._data.appid, this.updateAdvsInfo(), this.revertAdvsData()
                } catch (t) {
                    this.error(t.message)
                }
            }
            getAdvsQArr(t) {
                var s = [],
                    i = e.LocalStorage.getJSON("gameObj");
                for (var h in t) {
                    var a = t[h];
                    i && i[a.gameid] && !a.isQiangZhi || s.push(a)
                }
                return s
            }
            clear() {
                var t = this._http;
                t.onerror = t.onabort = t.onprogress = t.onload = null
            }
            destroy(t = !0) {
                e.ILaya.timer.clear(this, this.onLunbo), super.destroy(!0), this.clear(), e.ILaya.timer.clear(this, this.onGetAdvsListData)
            }
        }
        e.ClassUtils.regClass("laya.ui.AdvImage", _), e.ClassUtils.regClass("Laya.AdvImage", _);
        class c extends n {set dataSource(t) {
                for (var e in this._dataSource = t, t) {
                    var s = this.getChildByName(e);
                    s ? s.dataSource = t[e] : !(e in this) || this[e] instanceof Function || (this[e] = t[e])
                }
            }
            get dataSource() {
                return super.dataSource
            }get bgColor() {
                return this._bgColor
            }
            set bgColor(t) {
                this._bgColor = t, t ? (this._onResize(null), this.on(e.Event.RESIZE, this, this._onResize)) : (this.graphics.clear(), this.off(e.Event.RESIZE, this, this._onResize))
            }
            _onResize(t) {
                this.graphics.clear(), this.graphics.drawRect(0, 0, this.width, this.height, this._bgColor)
            }
        }
        e.ILaya.regClass(c), e.ClassUtils.regClass("laya.ui.Box", c), e.ClassUtils.regClass("Laya.Box", c);
        class d extends n {
            constructor(t = null, e = "") {
                super(), this._labelColors = i.buttonLabelColors, this._state = 0, this._autoSize = !0, this._stateNum = i.buttonStateNum, this._stateChanged = !1, this.skin = t, this.label = e
            }
            destroy(t = !0) {
                super.destroy(t), this._bitmap && this._bitmap.destroy(), this._text && this._text.destroy(t), this._bitmap = null, this._text = null, this._clickHandler = null, this._labelColors = this._sources = this._strokeColors = null
            }
            createChildren() {
                this.graphics = this._bitmap = new h
            }
            createText() {
                this._text || (this._text = new e.Text, this._text.overflow = e.Text.HIDDEN, this._text.align = "center", this._text.valign = "middle", this._text.width = this._width, this._text.height = this._height)
            }
            initialize() {
                1 !== this._mouseState && (this.mouseEnabled = !0, this._setBit(e.Const.HAS_MOUSE, !0)), this._createListener(e.Event.MOUSE_OVER, this, this.onMouse, null, !1, !1), this._createListener(e.Event.MOUSE_OUT, this, this.onMouse, null, !1, !1), this._createListener(e.Event.MOUSE_DOWN, this, this.onMouse, null, !1, !1), this._createListener(e.Event.MOUSE_UP, this, this.onMouse, null, !1, !1), this._createListener(e.Event.CLICK, this, this.onMouse, null, !1, !1)
            }
            onMouse(t) {
                if (!1 !== this.toggle || !this._selected) return t.type === e.Event.CLICK ? (this.toggle && (this.selected = !this._selected), void(this._clickHandler && this._clickHandler.run())) : void(!this._selected && (this.state = d.stateMap[t.type]))
            }
            get skin() {
                return this._skin
            }
            set skin(t) {
                this._skin != t && (this._skin = t, t ? e.Loader.getRes(t) ? this._skinLoaded() : e.ILaya.loader.load(this._skin, e.Handler.create(this, this._skinLoaded), null, e.Loader.IMAGE, 1) : this._skinLoaded())
            }
            _skinLoaded() {
                this.callLater(this.changeClips), this._setStateChanged(), this._sizeChanged(), this.event(e.Event.LOADED)
            }
            get stateNum() {
                return this._stateNum
            }
            set stateNum(t) {
                "string" == typeof t && (t = parseInt(t)), this._stateNum != t && (this._stateNum = t < 1 ? 1 : t > 3 ? 3 : t, this.callLater(this.changeClips))
            }
            changeClips() {
                var t = e.Loader.getRes(this._skin);
                if (t) {
                    var s = t.sourceWidth,
                        i = t.sourceHeight / this._stateNum;
                    t.$_GID || (t.$_GID = e.Utils.getGID());
                    var h = t.$_GID + "-" + this._stateNum,
                        a = e.WeakObject.I.get(h);
                    if (e.Utils.isOkTextureList(a) || (a = null), a) this._sources = a;
                    else {
                        if (this._sources = [], 1 === this._stateNum) this._sources.push(t);
                        else
                            for (var r = 0; r < this._stateNum; r++) this._sources.push(e.Texture.createFromTexture(t, 0, i * r, s, i));
                        e.WeakObject.I.set(h, this._sources)
                    }
                    this._autoSize ? (this._bitmap.width = this._width || s, this._bitmap.height = this._height || i, this._text && (this._text.width = this._bitmap.width, this._text.height = this._bitmap.height)) : this._text && (this._text.x = s)
                } else console.log("lose skin", this._skin)
            }
            measureWidth() {
                return this.runCallLater(this.changeClips), this._autoSize ? this._bitmap.width : (this.runCallLater(this.changeState), this._bitmap.width + (this._text ? this._text.width : 0))
            }
            measureHeight() {
                return this.runCallLater(this.changeClips), this._text ? Math.max(this._bitmap.height, this._text.height) : this._bitmap.height
            }
            get label() {
                return this._text ? this._text.text : null
            }
            set label(t) {
                (this._text || t) && (this.createText(), this._text.text != t && (t && !this._text.parent && this.addChild(this._text), this._text.text = (t + "").replace(/\\n/g, "\n"), this._setStateChanged()))
            }
            get selected() {
                return this._selected
            }
            set selected(t) {
                this._selected != t && (this._selected = t, this.state = this._selected ? 2 : 0, this.event(e.Event.CHANGE))
            }
            get state() {
                return this._state
            }
            set state(t) {
                this._state != t && (this._state = t, this._setStateChanged())
            }
            changeState() {
                this._stateChanged = !1, this.runCallLater(this.changeClips);
                var t = this._state < this._stateNum ? this._state : this._stateNum - 1;
                this._sources && (this._bitmap.source = this._sources[t]), this.label && (this._text.color = this._labelColors[t], this._strokeColors && (this._text.strokeColor = this._strokeColors[t]))
            }
            get labelColors() {
                return this._labelColors.join(",")
            }
            set labelColors(t) {
                this._labelColors = l.fillArray(i.buttonLabelColors, t, String), this._setStateChanged()
            }
            get strokeColors() {
                return this._strokeColors ? this._strokeColors.join(",") : ""
            }
            set strokeColors(t) {
                this._strokeColors = l.fillArray(i.buttonLabelColors, t, String), this._setStateChanged()
            }
            get labelPadding() {
                return this.createText(), this._text.padding.join(",")
            }
            set labelPadding(t) {
                this.createText(), this._text.padding = l.fillArray(i.labelPadding, t, Number)
            }
            get labelSize() {
                return this.createText(), this._text.fontSize
            }
            set labelSize(t) {
                this.createText(), this._text.fontSize = t
            }
            get labelStroke() {
                return this.createText(), this._text.stroke
            }
            set labelStroke(t) {
                this.createText(), this._text.stroke = t
            }
            get labelStrokeColor() {
                return this.createText(), this._text.strokeColor
            }
            set labelStrokeColor(t) {
                this.createText(), this._text.strokeColor = t
            }
            get labelBold() {
                return this.createText(), this._text.bold
            }
            set labelBold(t) {
                this.createText(), this._text.bold = t
            }
            get labelFont() {
                return this.createText(), this._text.font
            }
            set labelFont(t) {
                this.createText(), this._text.font = t
            }
            get labelAlign() {
                return this.createText(), this._text.align
            }
            set labelAlign(t) {
                this.createText(), this._text.align = t
            }
            get clickHandler() {
                return this._clickHandler
            }
            set clickHandler(t) {
                this._clickHandler = t
            }
            get text() {
                return this.createText(), this._text
            }
            get sizeGrid() {
                return this._bitmap.sizeGrid ? this._bitmap.sizeGrid.join(",") : null
            }
            set sizeGrid(t) {
                this._bitmap.sizeGrid = l.fillArray(i.defaultSizeGrid, t, Number)
            }
            set width(t) {
                super.set_width(t), this._autoSize && (this._bitmap.width = t, this._text && (this._text.width = t))
            }
            get width() {
                return super.get_width()
            }
            set height(t) {
                super.set_height(t), this._autoSize && (this._bitmap.height = t, this._text && (this._text.height = t))
            }
            get height() {
                return super.get_height()
            }
            set dataSource(t) {
                this._dataSource = t, "number" == typeof t || "string" == typeof t ? this.label = t + "" : super.set_dataSource(t)
            }
            get dataSource() {
                return super.get_dataSource()
            }
            get iconOffset() {
                return this._bitmap._offset ? this._bitmap._offset.join(",") : null
            }
            set iconOffset(t) {
                this._bitmap._offset = t ? l.fillArray([1, 1], t, Number) : []
            }
            _setStateChanged() {
                this._stateChanged || (this._stateChanged = !0, this.callLater(this.changeState))
            }
        }
        d.stateMap = {
            mouseup: 0,
            mouseover: 1,
            mousedown: 2,
            mouseout: 0
        }, e.ILaya.regClass(d), e.ClassUtils.regClass("laya.ui.Button", d), e.ClassUtils.regClass("Laya.Button", d);
        class u extends d {
            constructor(t = null, e = "") {
                super(t, e), this.toggle = !0, this._autoSize = !1
            }
            preinitialize() {
                super.preinitialize(), this.toggle = !0, this._autoSize = !1
            }
            initialize() {
                super.initialize(), this.createText(), this._text.align = "left", this._text.valign = "top", this._text.width = 0
            }
            set dataSource(t) {
                this._dataSource = t, t instanceof Boolean ? this.selected = t : "string" == typeof t ? this.selected = "true" === t : super.dataSource = t
            }
            get dataSource() {
                return super.dataSource
            }
        }
        e.ILaya.regClass(u), e.ClassUtils.regClass("laya.ui.CheckBox", u), e.ClassUtils.regClass("Laya.CheckBox", u);
        class g extends n {
            constructor(t = null, e = 1, s = 1) {
                super(), this._clipX = 1, this._clipY = 1, this._clipWidth = 0, this._clipHeight = 0, this._interval = 50, this._index = 0, this._toIndex = -1, this._clipX = e, this._clipY = s, this.skin = t
            }
            destroy(t = !0) {
                super.destroy(!0), this._bitmap && this._bitmap.destroy(), this._bitmap = null, this._sources = null
            }
            dispose() {
                this.destroy(!0), e.ILaya.loader.clearRes(this._skin)
            }
            createChildren() {
                this.graphics = this._bitmap = new h
            }
            _onDisplay(t) {
                this._isPlaying ? this._getBit(e.Const.DISPLAYED_INSTAGE) ? this.play() : this.stop() : this._autoPlay && this.play()
            }
            get skin() {
                return this._skin
            }
            set skin(t) {
                this._skin != t && (this._skin = t, t ? e.Loader.getRes(t) ? this._skinLoaded() : e.ILaya.loader.load(this._skin, e.Handler.create(this, this._skinLoaded), null, e.Loader.IMAGE, 1) : this._bitmap.source = null)
            }
            _skinLoaded() {
                this._setClipChanged(), this._sizeChanged(), this.event(e.Event.LOADED)
            }
            get clipX() {
                return this._clipX
            }
            set clipX(t) {
                this._clipX = t || 1, this._setClipChanged()
            }
            get clipY() {
                return this._clipY
            }
            set clipY(t) {
                this._clipY = t || 1, this._setClipChanged()
            }
            get clipWidth() {
                return this._clipWidth
            }
            set clipWidth(t) {
                this._clipWidth = t, this._setClipChanged()
            }
            get clipHeight() {
                return this._clipHeight
            }
            set clipHeight(t) {
                this._clipHeight = t, this._setClipChanged()
            }
            changeClip() {
                if (this._clipChanged = !1, this._skin && !this.destroyed) {
                    var t = e.Loader.getRes(this._skin);
                    t ? this.loadComplete(this._skin, t) : e.ILaya.loader.load(this._skin, e.Handler.create(this, this.loadComplete, [this._skin]))
                }
            }
            loadComplete(t, s) {
                if (t === this._skin && s) {
                    var i = this._clipWidth || Math.ceil(s.sourceWidth / this._clipX),
                        h = this._clipHeight || Math.ceil(s.sourceHeight / this._clipY),
                        a = this._skin + i + h,
                        r = e.WeakObject.I.get(a);
                    if (e.Utils.isOkTextureList(r) || (r = null), r) this._sources = r;
                    else {
                        this._sources = [];
                        for (var l = 0; l < this._clipY; l++)
                            for (var n = 0; n < this._clipX; n++) this._sources.push(e.Texture.createFromTexture(s, i * n, h * l, i, h));
                        e.WeakObject.I.set(a, this._sources)
                    }
                    this.index = this._index, this.event(e.Event.LOADED), this.onCompResize()
                }
            }
            get sources() {
                return this._sources
            }
            set sources(t) {
                this._sources = t, this.index = this._index, this.event(e.Event.LOADED)
            }
            get group() {
                return this._group
            }
            set group(t) {
                t && this._skin && e.Loader.setGroup(this._skin, t), this._group = t
            }
            set width(t) {
                super.width = t, this._bitmap.width = t
            }
            get width() {
                return super.width
            }
            set height(t) {
                super.height = t, this._bitmap.height = t
            }
            get height() {
                return super.height
            }
            measureWidth() {
                return this.runCallLater(this.changeClip), this._bitmap.width
            }
            measureHeight() {
                return this.runCallLater(this.changeClip), this._bitmap.height
            }
            get sizeGrid() {
                return this._bitmap.sizeGrid ? this._bitmap.sizeGrid.join(",") : null
            }
            set sizeGrid(t) {
                this._bitmap.sizeGrid = l.fillArray(i.defaultSizeGrid, t, Number)
            }
            get index() {
                return this._index
            }
            set index(t) {
                this._index = t, this._bitmap && this._sources && (this._bitmap.source = this._sources[t]), this.event(e.Event.CHANGE)
            }
            get total() {
                return this.runCallLater(this.changeClip), this._sources ? this._sources.length : 0
            }
            get autoPlay() {
                return this._autoPlay
            }
            set autoPlay(t) {
                this._autoPlay != t && (this._autoPlay = t, t ? this.play() : this.stop())
            }
            get interval() {
                return this._interval
            }
            set interval(t) {
                this._interval != t && (this._interval = t, this._isPlaying && this.play())
            }
            get isPlaying() {
                return this._isPlaying
            }
            set isPlaying(t) {
                this._isPlaying = t
            }
            play(t = 0, s = -1) {
                this._setClipChanged(), this._isPlaying = !0, this.index = t, this._toIndex = s, e.ILaya.timer.loop(this.interval, this, this._loop), this.on(e.Event.DISPLAY, this, this._onDisplay), this.on(e.Event.UNDISPLAY, this, this._onDisplay)
            }
            _loop() {
                this._visible && this._sources && (this._index++, this._toIndex > -1 && this._index >= this._toIndex ? this.stop() : this._index >= this._sources.length && (this._index = 0), this.index = this._index)
            }
            stop() {
                this._isPlaying = !1, e.ILaya.timer.clear(this, this._loop), this.event(e.Event.COMPLETE)
            }
            set dataSource(t) {
                this._dataSource = t, "number" == typeof t || "string" == typeof t ? this.index = parseInt(t) : super.dataSource = t
            }
            get dataSource() {
                return super.dataSource
            }
            get bitmap() {
                return this._bitmap
            }
            _setClipChanged() {
                this._clipChanged || (this._clipChanged = !0, this.callLater(this.changeClip))
            }
        }
        e.ILaya.regClass(g), e.ClassUtils.regClass("laya.ui.Clip", g), e.ClassUtils.regClass("Laya.Clip", g);
        class p extends n {
            constructor(t = !0) {
                super(!1), this._gridSize = 11, this._bgColor = "#ffffff", this._borderColor = "#000000", this._inputColor = "#000000", this._inputBgColor = "#efefef", this._colors = [], this._selectedColor = "#000000", t && (this.preinitialize(), this.createChildren(), this.initialize())
            }
            destroy(t = !0) {
                e.ILaya.stage.off(e.Event.MOUSE_DOWN, this, this.removeColorBox), super.destroy(t), this._colorPanel && this._colorPanel.destroy(t), this._colorButton && this._colorButton.destroy(t), this._colorPanel = null, this._colorTiles = null, this._colorBlock = null, this._colorInput = null, this._colorButton = null, this._colors = null, this.changeHandler = null
            }
            createChildren() {
                this.addChild(this._colorButton = new d), this._colorPanel = new c, this._colorPanel.size(230, 166), this._colorPanel.addChild(this._colorTiles = new e.Sprite), this._colorPanel.addChild(this._colorBlock = new e.Sprite), this._colorPanel.addChild(this._colorInput = new e.Input)
            }
            initialize() {
                this._colorButton.on(e.Event.CLICK, this, this.onColorButtonClick), this._colorBlock.pos(5, 5), this._colorInput.pos(60, 5), this._colorInput.size(60, 20), this._colorInput.on(e.Event.CHANGE, this, this.onColorInputChange), this._colorInput.on(e.Event.KEY_DOWN, this, this.onColorFieldKeyDown), this._colorTiles.pos(5, 30), this._colorTiles.on(e.Event.MOUSE_MOVE, this, this.onColorTilesMouseMove), this._colorTiles.on(e.Event.CLICK, this, this.onColorTilesClick), this._colorTiles.size(20 * this._gridSize, 12 * this._gridSize), this._colorPanel.on(e.Event.MOUSE_DOWN, this, this.onPanelMouseDown), this.bgColor = this._bgColor
            }
            onPanelMouseDown(t) {
                t.stopPropagation()
            }
            changePanel() {
                this._panelChanged = !1;
                var t = this._colorPanel.graphics;
                t.clear(!0), t.drawRect(0, 0, 230, 166, this._bgColor, this._borderColor), this.drawBlock(this._selectedColor), this._colorInput.borderColor = this._borderColor, this._colorInput.bgColor = this._inputBgColor, this._colorInput.color = this._inputColor, (t = this._colorTiles.graphics).clear(!0);
                for (var e = [0, 3355443, 6710886, 10066329, 13421772, 16777215, 16711680, 65280, 255, 16776960, 65535, 16711935], s = 0; s < 12; s++)
                    for (var i = 0; i < 20; i++) {
                        var h;
                        h = 0 === i ? e[s] : 1 === i ? 0 : 51 * (((3 * s + i / 6) % 3 << 0) + 3 * (s / 6 << 0)) << 16 | i % 6 * 51 << 8 | (s << 0) % 6 * 51;
                        var a = l.toColor(h);
                        this._colors.push(a);
                        var r = i * this._gridSize,
                            n = s * this._gridSize;
                        t.drawRect(r, n, this._gridSize, this._gridSize, a, "#000000")
                    }
            }
            onColorButtonClick(t) {
                this._colorPanel.parent ? this.close() : this.open()
            }
            open() {
                let t = e.ILaya.stage;
                var s = this.localToGlobal(new e.Point),
                    i = s.x + this._colorPanel.width <= t.width ? s.x : t.width - this._colorPanel.width,
                    h = s.y + this._colorButton.height;
                h = h + this._colorPanel.height <= t.height ? h : s.y - this._colorPanel.height, this._colorPanel.pos(i, h), this._colorPanel.zOrder = 1001, t.addChild(this._colorPanel), t.on(e.Event.MOUSE_DOWN, this, this.removeColorBox)
            }
            close() {
                e.ILaya.stage.off(e.Event.MOUSE_DOWN, this, this.removeColorBox), this._colorPanel.removeSelf()
            }
            removeColorBox(t = null) {
                this.close()
            }
            onColorFieldKeyDown(t) {
                13 == t.keyCode && (this._colorInput.text ? this.selectedColor = this._colorInput.text : this.selectedColor = null, this.close(), t.stopPropagation())
            }
            onColorInputChange(t = null) {
                this._colorInput.text ? this.drawBlock(this._colorInput.text) : this.drawBlock("#FFFFFF")
            }
            onColorTilesClick(t) {
                this.selectedColor = this.getColorByMouse(), this.close()
            }
            onColorTilesMouseMove(t) {
                this._colorInput.focus = !1;
                var e = this.getColorByMouse();
                this._colorInput.text = e, this.drawBlock(e)
            }
            getColorByMouse() {
                var t = this._colorTiles.getMousePoint(),
                    e = Math.floor(t.x / this._gridSize),
                    s = Math.floor(t.y / this._gridSize);
                return this._colors[20 * s + e]
            }
            drawBlock(t) {
                var e = this._colorBlock.graphics;
                e.clear(!0);
                var s = t || "#ffffff";
                e.drawRect(0, 0, 50, 20, s, this._borderColor), t || e.drawLine(0, 0, 50, 20, "#ff0000")
            }
            get selectedColor() {
                return this._selectedColor
            }
            set selectedColor(t) {
                this._selectedColor != t && (this._selectedColor = this._colorInput.text = t, this.drawBlock(t), this.changeColor(), this.changeHandler && this.changeHandler.runWith(this._selectedColor), this.event(e.Event.CHANGE, e.Event.EMPTY.setTo(e.Event.CHANGE, this, this)))
            }
            get skin() {
                return this._colorButton.skin
            }
            set skin(t) {
                this._colorButton.once(e.Event.LOADED, this, this.changeColor), this._colorButton.skin = t
            }
            changeColor() {
                var t = this.graphics;
                t.clear(!0);
                var e = this._selectedColor || "#000000";
                t.drawRect(0, 0, this._colorButton.width, this._colorButton.height, e)
            }
            get bgColor() {
                return this._bgColor
            }
            set bgColor(t) {
                this._bgColor = t, this._setPanelChanged()
            }
            get borderColor() {
                return this._borderColor
            }
            set borderColor(t) {
                this._borderColor = t, this._setPanelChanged()
            }
            get inputColor() {
                return this._inputColor
            }
            set inputColor(t) {
                this._inputColor = t, this._setPanelChanged()
            }
            get inputBgColor() {
                return this._inputBgColor
            }
            set inputBgColor(t) {
                this._inputBgColor = t, this._setPanelChanged()
            }
            _setPanelChanged() {
                this._panelChanged || (this._panelChanged = !0, this.callLater(this.changePanel))
            }
        }
        e.ILaya.regClass(p), e.ClassUtils.regClass("laya.ui.ColorPicker", p), e.ClassUtils.regClass("Laya.ColorPicker", p);
        class C extends n {
            constructor(t = "") {
                super(), this.text = t
            }
            destroy(t = !0) {
                super.destroy(t), this._tf = null
            }
            createChildren() {
                this.addChild(this._tf = new e.Text)
            }
            get text() {
                return this._tf.text
            }
            set text(t) {
                this._tf.text != t && (t && (t = l.adptString(t + "")), this._tf.text = t, this.event(e.Event.CHANGE), this._width && this._height || this.onCompResize())
            }
            changeText(t) {
                this._tf.changeText(t)
            }
            get wordWrap() {
                return this._tf.wordWrap
            }
            set wordWrap(t) {
                this._tf.wordWrap = t
            }
            get color() {
                return this._tf.color
            }
            set color(t) {
                this._tf.color = t
            }
            get font() {
                return this._tf.font
            }
            set font(t) {
                this._tf.font = t
            }
            get align() {
                return this._tf.align
            }
            set align(t) {
                this._tf.align = t
            }
            get valign() {
                return this._tf.valign
            }
            set valign(t) {
                this._tf.valign = t
            }
            get bold() {
                return this._tf.bold
            }
            set bold(t) {
                this._tf.bold = t
            }
            get italic() {
                return this._tf.italic
            }
            set italic(t) {
                this._tf.italic = t
            }
            get leading() {
                return this._tf.leading
            }
            set leading(t) {
                this._tf.leading = t
            }
            get fontSize() {
                return this._tf.fontSize
            }
            set fontSize(t) {
                this._tf.fontSize = t
            }
            get padding() {
                return this._tf.padding.join(",")
            }
            set padding(t) {
                this._tf.padding = l.fillArray(i.labelPadding, t, Number)
            }
            get bgColor() {
                return this._tf.bgColor
            }
            set bgColor(t) {
                this._tf.bgColor = t
            }
            get borderColor() {
                return this._tf.borderColor
            }
            set borderColor(t) {
                this._tf.borderColor = t
            }
            get stroke() {
                return this._tf.stroke
            }
            set stroke(t) {
                this._tf.stroke = t
            }
            get strokeColor() {
                return this._tf.strokeColor
            }
            set strokeColor(t) {
                this._tf.strokeColor = t
            }
            get textField() {
                return this._tf
            }
            measureWidth() {
                return this._tf.width
            }
            measureHeight() {
                return this._tf.height
            }
            get width() {
                return this._width || this._tf.text ? super.width : 0
            }
            set width(t) {
                super.width = t, this._tf.width = t
            }
            get height() {
                return this._height || this._tf.text ? super.height : 0
            }
            set height(t) {
                super.height = t, this._tf.height = t
            }
            set dataSource(t) {
                this._dataSource = t, "number" == typeof t || "string" == typeof t ? this.text = t + "" : super.dataSource = t
            }
            get dataSource() {
                return super.dataSource
            }
            get overflow() {
                return this._tf.overflow
            }
            set overflow(t) {
                this._tf.overflow = t
            }
            get underline() {
                return this._tf.underline
            }
            set underline(t) {
                this._tf.underline = t
            }
            get underlineColor() {
                return this._tf.underlineColor
            }
            set underlineColor(t) {
                this._tf.underlineColor = t
            }
        }
        e.ILaya.regClass(C), e.ClassUtils.regClass("laya.ui.Label", C), e.ClassUtils.regClass("Laya.Label", C);
        class m extends n {
            constructor(t = null) {
                super(), this.isVertical = !0, this.showLabel = !0, this._max = 100, this._min = 0, this._tick = 1, this._value = 0, m.label || (m.label = new C), this.skin = t
            }
            destroy(t = !0) {
                super.destroy(t), this._bg && this._bg.destroy(t), this._bar && this._bar.destroy(t), this._progress && this._progress.destroy(t), this._bg = null, this._bar = null, this._progress = null, this.changeHandler = null
            }
            createChildren() {
                this.addChild(this._bg = new o), this.addChild(this._bar = new d)
            }
            initialize() {
                this._bar.on(e.Event.MOUSE_DOWN, this, this.onBarMouseDown), this._bg.sizeGrid = this._bar.sizeGrid = "4,4,4,4,0", this._progress && (this._progress.sizeGrid = this._bar.sizeGrid), this.allowClickBack = !0
            }
            onBarMouseDown(t) {
                var s = e.ILaya;
                this._globalSacle || (this._globalSacle = new e.Point), this._globalSacle.setTo(this.globalScaleX || .01, this.globalScaleY || .01), this._maxMove = this.isVertical ? this.height - this._bar.height : this.width - this._bar.width, this._tx = s.stage.mouseX, this._ty = s.stage.mouseY, s.stage.on(e.Event.MOUSE_MOVE, this, this.mouseMove), s.stage.once(e.Event.MOUSE_UP, this, this.mouseUp), s.stage.once(e.Event.MOUSE_OUT, this, this.mouseUp), this.showValueText()
            }
            showValueText() {
                if (this.showLabel) {
                    var t = m.label;
                    this.addChild(t), t.textField.changeText(this._value + ""), this.isVertical ? (t.x = this._bar._x + 20, t.y = .5 * (this._bar.height - t.height) + this._bar._y) : (t.y = this._bar._y - 20, t.x = .5 * (this._bar.width - t.width) + this._bar._x)
                }
            }
            hideValueText() {
                m.label && m.label.removeSelf()
            }
            mouseUp(t) {
                let s = e.ILaya.stage;
                s.off(e.Event.MOUSE_MOVE, this, this.mouseMove), s.off(e.Event.MOUSE_UP, this, this.mouseUp), s.off(e.Event.MOUSE_OUT, this, this.mouseUp), this.sendChangeEvent(e.Event.CHANGED), this.hideValueText(), this.callLater(this._sizeChanged)
            }
            mouseMove(t) {
                let s = e.ILaya.stage;
                var i = this._value;
                if (this.isVertical ? (this._bar.y += (s.mouseY - this._ty) / this._globalSacle.y, this._bar._y > this._maxMove ? this._bar.y = this._maxMove : this._bar._y < 0 && (this._bar.y = 0), this._value = this._bar._y / this._maxMove * (this._max - this._min) + this._min, this._progress && (this._progress.height = this._bar._y + .5 * this._bar.height)) : (this._bar.x += (s.mouseX - this._tx) / this._globalSacle.x, this._bar._x > this._maxMove ? this._bar.x = this._maxMove : this._bar._x < 0 && (this._bar.x = 0), this._value = this._bar._x / this._maxMove * (this._max - this._min) + this._min, this._progress && (this._progress.width = this._bar._x + .5 * this._bar.width)), this._tx = s.mouseX, this._ty = s.mouseY, 0 != this._tick) {
                    var h = Math.pow(10, (this._tick + "").length - 1);
                    this._value = Math.round(Math.round(this._value / this._tick) * this._tick * h) / h
                }
                this._value != i && this.sendChangeEvent(), this.showValueText()
            }
            sendChangeEvent(t = e.Event.CHANGE) {
                this.event(t), this.changeHandler && this.changeHandler.runWith(this._value)
            }
            get skin() {
                return this._skin
            }
            set skin(t) {
                this._skin != t && (this._skin = t, this._skin && !e.Loader.getRes(this._skin) ? e.ILaya.loader.load([this._skin, this._skin.replace(".png", "$bar.png")], e.Handler.create(this, this._skinLoaded)) : this._skinLoaded())
            }
            _skinLoaded() {
                this._bg.skin = this._skin, this._bar.skin = this._skin.replace(".png", "$bar.png");
                var t = this._skin.replace(".png", "$progress.png");
                e.Loader.getRes(t) && (this._progress || (this.addChild(this._progress = new o), this._progress.sizeGrid = this._bar.sizeGrid, this.setChildIndex(this._progress, 1)), this._progress.skin = t), this.setBarPoint(), this.callLater(this.changeValue), this._sizeChanged(), this.event(e.Event.LOADED)
            }
            setBarPoint() {
                this.isVertical ? this._bar.x = Math.round(.5 * (this._bg.width - this._bar.width)) : this._bar.y = Math.round(.5 * (this._bg.height - this._bar.height))
            }
            measureWidth() {
                return Math.max(this._bg.width, this._bar.width)
            }
            measureHeight() {
                return Math.max(this._bg.height, this._bar.height)
            }
            _sizeChanged() {
                super._sizeChanged(), this.isVertical ? this._bg.height = this.height : this._bg.width = this.width, this.setBarPoint(), this.changeValue()
            }
            get sizeGrid() {
                return this._bg.sizeGrid
            }
            set sizeGrid(t) {
                this._bg.sizeGrid = t, this._bar.sizeGrid = t, this._progress && (this._progress.sizeGrid = this._bar.sizeGrid)
            }
            setSlider(t, e, s) {
                this._value = -1, this._min = t, this._max = e > t ? e : t, this.value = s < t ? t : s > e ? e : s
            }
            get tick() {
                return this._tick
            }
            set tick(t) {
                this._tick != t && (this._tick = t, this.callLater(this.changeValue))
            }
            changeValue() {
                if (0 != this.tick) {
                    var t = Math.pow(10, (this._tick + "").length - 1);
                    this._value = Math.round(Math.round(this._value / this._tick) * this._tick * t) / t
                }
                this._max >= this._max ? this._value = this._value > this._max ? this._max : this._value < this._min ? this._min : this._value : this._value = this._value > this._min ? this._min : this._value < this._max ? this._max : this._value;
                var e = this._max - this._min;
                0 === e && (e = 1), this.isVertical ? (this._bar.y = (this._value - this._min) / e * (this.height - this._bar.height), this._progress && (this._progress.height = this._bar._y + .5 * this._bar.height)) : (this._bar.x = (this._value - this._min) / e * (this.width - this._bar.width), this._progress && (this._progress.width = this._bar._x + .5 * this._bar.width))
            }
            get max() {
                return this._max
            }
            set max(t) {
                this._max != t && (this._max = t, this.callLater(this.changeValue))
            }
            get min() {
                return this._min
            }
            set min(t) {
                this._min != t && (this._min = t, this.callLater(this.changeValue))
            }
            get value() {
                return this._value
            }
            set value(t) {
                if (this._value != t) {
                    var e = this._value;
                    this._value = t, this.changeValue(), this._value != e && this.sendChangeEvent()
                }
            }
            get allowClickBack() {
                return this._allowClickBack
            }
            set allowClickBack(t) {
                this._allowClickBack != t && (this._allowClickBack = t, t ? this._bg.on(e.Event.MOUSE_DOWN, this, this.onBgMouseDown) : this._bg.off(e.Event.MOUSE_DOWN, this, this.onBgMouseDown))
            }
            onBgMouseDown(t) {
                var e = this._bg.getMousePoint();
                this.isVertical ? this.value = e.y / (this.height - this._bar.height) * (this._max - this._min) + this._min : this.value = e.x / (this.width - this._bar.width) * (this._max - this._min) + this._min
            }
            set dataSource(t) {
                this._dataSource = t, "number" == typeof t || "string" == typeof t ? this.value = Number(t) : super.dataSource = t
            }
            get dataSource() {
                return super.dataSource
            }
            get bar() {
                return this._bar
            }
        }
        m.label = null, e.ILaya.regClass(m), e.ClassUtils.regClass("laya.ui.Slider", m), e.ClassUtils.regClass("Laya.Slider", m);
        class v extends n {
            constructor(t = null) {
                super(), this.rollRatio = .97, this.scaleBar = !0, this.autoHide = !1, this.elasticDistance = 0, this.elasticBackTime = 500, this.topMoveLimit = 0, this.bottomMoveLimit = 0, this.disableDrag = !1, this._showButtons = s.showButtons, this._scrollSize = 1, this._thumbPercent = 1, this._lastOffset = 0, this._checkElastic = !1, this._isElastic = !1, this._hide = !1, this._clickOnly = !0, this._touchScrollEnable = s.touchScrollEnable, this._mouseWheelEnable = s.mouseWheelEnable, this.skin = t, this.max = 1
            }
            destroy(t = !0) {
                this.stopScroll(), this.target = null, super.destroy(t), this.upButton && this.upButton.destroy(t), this.downButton && this.downButton.destroy(t), this.slider && this.slider.destroy(t), this.upButton = this.downButton = null, this.slider = null, this.changeHandler = null, this._offsets = null
            }
            createChildren() {
                this.addChild(this.slider = new m), this.addChild(this.upButton = new d), this.addChild(this.downButton = new d)
            }
            initialize() {
                this.slider.showLabel = !1, this.slider.tick = 0, this.slider.on(e.Event.CHANGE, this, this.onSliderChange), this.slider.setSlider(0, 0, 0), this.upButton.on(e.Event.MOUSE_DOWN, this, this.onButtonMouseDown), this.downButton.on(e.Event.MOUSE_DOWN, this, this.onButtonMouseDown)
            }
            onSliderChange() {
                this._value != this.slider.value && (this.value = this.slider.value)
            }
            onButtonMouseDown(t) {
                var s = t.currentTarget === this.upButton;
                this.slide(s), e.ILaya.timer.once(i.scrollBarDelayTime, this, this.startLoop, [s]), e.ILaya.stage.once(e.Event.MOUSE_UP, this, this.onStageMouseUp)
            }
            startLoop(t) {
                e.ILaya.timer.frameLoop(1, this, this.slide, [t])
            }
            slide(t) {
                t ? this.value -= this._scrollSize : this.value += this._scrollSize
            }
            onStageMouseUp(t) {
                e.ILaya.timer.clear(this, this.startLoop), e.ILaya.timer.clear(this, this.slide)
            }
            get skin() {
                return this._skin
            }
            set skin(t) {
                " " != t && this._skin != t && (this._skin = t, this._skin && !e.Loader.getRes(this._skin) ? e.ILaya.loader.load([this._skin, this._skin.replace(".png", "$up.png"), this._skin.replace(".png", "$down.png"), this._skin.replace(".png", "$bar.png")], e.Handler.create(this, this._skinLoaded)) : this._skinLoaded())
            }
            _skinLoaded() {
                this.destroyed || (this.slider.skin = this._skin, this.callLater(this.changeScrollBar), this._sizeChanged(), this.event(e.Event.LOADED))
            }
            changeScrollBar() {
                this.upButton.visible = this._showButtons, this.downButton.visible = this._showButtons, this._showButtons && (this.upButton.skin = this._skin.replace(".png", "$up.png"), this.downButton.skin = this._skin.replace(".png", "$down.png")), this.slider.isVertical ? this.slider.y = this._showButtons ? this.upButton.height : 0 : this.slider.x = this._showButtons ? this.upButton.width : 0, this.resetPositions(), this.repaint()
            }
            _sizeChanged() {
                super._sizeChanged(), this.repaint(), this.resetPositions(), this.event(e.Event.CHANGE), this.changeHandler && this.changeHandler.runWith(this.value)
            }
            resetPositions() {
                this.slider.isVertical ? this.slider.height = this.height - (this._showButtons ? this.upButton.height + this.downButton.height : 0) : this.slider.width = this.width - (this._showButtons ? this.upButton.width + this.downButton.width : 0), this.resetButtonPosition()
            }
            resetButtonPosition() {
                this.slider.isVertical ? this.downButton.y = this.slider._y + this.slider.height : this.downButton.x = this.slider._x + this.slider.width
            }
            measureWidth() {
                return this.slider.isVertical ? this.slider.width : 100
            }
            measureHeight() {
                return this.slider.isVertical ? 100 : this.slider.height
            }
            setScroll(t, e, s) {
                this.runCallLater(this._sizeChanged), this.slider.setSlider(t, e, s), this.slider.bar.visible = e > 0, !this._hide && this.autoHide && (this.visible = !1)
            }
            get max() {
                return this.slider.max
            }
            set max(t) {
                this.slider.max = t
            }
            get min() {
                return this.slider.min
            }
            set min(t) {
                this.slider.min = t
            }
            get value() {
                return this._value
            }
            set value(t) {
                t !== this._value && (this._value = t, this._isElastic || (this.slider._value != t && (this.slider._value = t, this.slider.changeValue()), this._value = this.slider._value), this.event(e.Event.CHANGE), this.changeHandler && this.changeHandler.runWith(this._value))
            }
            get isVertical() {
                return this.slider.isVertical
            }
            set isVertical(t) {
                this.slider.isVertical = t
            }
            get sizeGrid() {
                return this.slider.sizeGrid
            }
            set sizeGrid(t) {
                this.slider.sizeGrid = t
            }
            get scrollSize() {
                return this._scrollSize
            }
            set scrollSize(t) {
                this._scrollSize = t
            }
            set dataSource(t) {
                this._dataSource = t, "number" == typeof t || "string" == typeof t ? this.value = Number(t) : super.dataSource = t
            }
            get dataSource() {
                return super.dataSource
            }
            get thumbPercent() {
                return this._thumbPercent
            }
            set thumbPercent(t) {
                this.runCallLater(this.changeScrollBar), this.runCallLater(this._sizeChanged), t = t >= 1 ? .99 : t, this._thumbPercent = t, this.scaleBar && (this.slider.isVertical ? this.slider.bar.height = Math.max(this.slider.height * t, i.scrollBarMinNum) : this.slider.bar.width = Math.max(this.slider.width * t, i.scrollBarMinNum))
            }
            get target() {
                return this._target
            }
            set target(t) {
                this._target && (this._target.off(e.Event.MOUSE_WHEEL, this, this.onTargetMouseWheel), this._target.off(e.Event.MOUSE_DOWN, this, this.onTargetMouseDown)), this._target = t, t && (this._mouseWheelEnable && this._target.on(e.Event.MOUSE_WHEEL, this, this.onTargetMouseWheel), this._touchScrollEnable && this._target.on(e.Event.MOUSE_DOWN, this, this.onTargetMouseDown))
            }
            get hide() {
                return this._hide
            }
            set hide(t) {
                this._hide = t, this.visible = !t
            }
            get showButtons() {
                return this._showButtons
            }
            set showButtons(t) {
                this._showButtons = t, this.callLater(this.changeScrollBar)
            }
            get touchScrollEnable() {
                return this._touchScrollEnable
            }
            set touchScrollEnable(t) {
                this._touchScrollEnable = t, this.target = this._target
            }
            get mouseWheelEnable() {
                return this._mouseWheelEnable
            }
            set mouseWheelEnable(t) {
                this._mouseWheelEnable = t, this.target = this._target
            }
            onTargetMouseWheel(t) {
                this.value -= t.delta * this._scrollSize, this.target = this._target
            }
            onTargetMouseDown(t) {
                this.isLockedFun && !this.isLockedFun(t) || (this.event(e.Event.END), this._clickOnly = !0, this._lastOffset = 0, this._checkElastic = !1, this._lastPoint || (this._lastPoint = new e.Point), this._lastPoint.setTo(e.ILaya.stage.mouseX, e.ILaya.stage.mouseY), e.ILaya.timer.clear(this, this.tweenMove), e.Tween.clearTween(this), e.ILaya.stage.once(e.Event.MOUSE_UP, this, this.onStageMouseUp2), e.ILaya.stage.once(e.Event.MOUSE_OUT, this, this.onStageMouseUp2), e.ILaya.timer.frameLoop(1, this, this.loop))
            }
            startDragForce() {
                this._clickOnly = !0, this._lastOffset = 0, this._checkElastic = !1, this._lastPoint || (this._lastPoint = new e.Point), this._lastPoint.setTo(e.ILaya.stage.mouseX, e.ILaya.stage.mouseY), e.ILaya.timer.clear(this, this.tweenMove), e.Tween.clearTween(this), e.ILaya.stage.once(e.Event.MOUSE_UP, this, this.onStageMouseUp2), e.ILaya.stage.once(e.Event.MOUSE_OUT, this, this.onStageMouseUp2), e.ILaya.timer.frameLoop(1, this, this.loop)
            }
            cancelDragOp() {
                e.ILaya.stage.off(e.Event.MOUSE_UP, this, this.onStageMouseUp2), e.ILaya.stage.off(e.Event.MOUSE_OUT, this, this.onStageMouseUp2), e.ILaya.timer.clear(this, this.tweenMove), e.ILaya.timer.clear(this, this.loop), this._target.mouseEnabled = !0
            }
            checkTriggers(t = !1) {
                return this.value >= 0 && this.value - this._lastOffset <= 0 && this.triggerDownDragLimit && this.triggerDownDragLimit(t) ? (this.cancelDragOp(), this.value = 0, !0) : !!(this.value <= this.max && this.value - this._lastOffset >= this.max && this.triggerUpDragLimit && this.triggerUpDragLimit(t)) && (this.cancelDragOp(), this.value = this.max, !0)
            }
            get lastOffset() {
                return this._lastOffset
            }
            startTweenMoveForce(t) {
                this._lastOffset = t, e.ILaya.timer.frameLoop(1, this, this.tweenMove, [200])
            }
            loop() {
                if (!this.disableDrag) {
                    var t = e.ILaya.stage.mouseY,
                        s = e.ILaya.stage.mouseX;
                    if (this._lastOffset = this.isVertical ? t - this._lastPoint.y : s - this._lastPoint.x, this._clickOnly) {
                        if (!(Math.abs(this._lastOffset * (this.isVertical ? e.ILaya.stage._canvasTransform.getScaleY() : e.ILaya.stage._canvasTransform.getScaleX())) > 1)) return;
                        if (this._clickOnly = !1, this.checkTriggers()) return;
                        this._offsets || (this._offsets = []), this._offsets.length = 0, this._target.mouseEnabled = !1, !this.hide && this.autoHide && (this.alpha = 1, this.visible = !0), this.event(e.Event.START)
                    } else if (this.checkTriggers()) return;
                    this._offsets.push(this._lastOffset), this._lastPoint.x = s, this._lastPoint.y = t, 0 !== this._lastOffset && (this._checkElastic || (this.elasticDistance > 0 ? this._checkElastic || 0 == this._lastOffset || (this._lastOffset > 0 && this._value <= this.min || this._lastOffset < 0 && this._value >= this.max ? (this._isElastic = !0, this._checkElastic = !0) : this._isElastic = !1) : this._checkElastic = !0), this._isElastic ? this._value <= this.min ? this._lastOffset > 0 ? this.value -= this._lastOffset * Math.max(0, 1 - (this.min - this._value) / this.elasticDistance) : (this.value -= .5 * this._lastOffset, this._value >= this.min && (this._checkElastic = !1)) : this._value >= this.max && (this._lastOffset < 0 ? this.value -= this._lastOffset * Math.max(0, 1 - (this._value - this.max) / this.elasticDistance) : (this.value -= .5 * this._lastOffset, this._value <= this.max && (this._checkElastic = !1))) : this.value -= this._lastOffset)
                }
            }
            onStageMouseUp2(t) {
                if (e.ILaya.stage.off(e.Event.MOUSE_UP, this, this.onStageMouseUp2), e.ILaya.stage.off(e.Event.MOUSE_OUT, this, this.onStageMouseUp2), e.ILaya.timer.clear(this, this.loop), !(this._clickOnly && this._value >= this.min && this._value <= this.max))
                    if (this._target.mouseEnabled = !0, this._isElastic) {
                        if (this._value < this.min) {
                            this.event("dragTopLimit");
                            var s = this.stopMoveLimit && this.stopMoveLimit() ? this.min - this.topMoveLimit : this.min;
                            e.Tween.to(this, {
                                value: s
                            }, this.elasticBackTime, e.Ease.sineOut, e.Handler.create(this, this.elasticOver))
                        } else if (this._value > this.max) {
                            this.event("dragBottomLimit");
                            s = this.stopMoveLimit && this.stopMoveLimit() ? this.max + this.bottomMoveLimit : this.max;
                            e.Tween.to(this, {
                                value: s
                            }, this.elasticBackTime, e.Ease.sineOut, e.Handler.create(this, this.elasticOver))
                        }
                    } else {
                        if (!this._offsets) return;
                        this._offsets.length < 1 && (this._offsets[0] = this.isVertical ? e.ILaya.stage.mouseY - this._lastPoint.y : e.ILaya.stage.mouseX - this._lastPoint.x);
                        for (var i = 0, h = Math.min(this._offsets.length, 3), a = 0; a < h; a++) i += this._offsets[this._offsets.length - 1 - a];
                        if (this._lastOffset = i / h, (i = Math.abs(this._lastOffset)) < 2) return void this.event(e.Event.END);
                        i > 250 && (this._lastOffset = this._lastOffset > 0 ? 250 : -250);
                        var r = Math.round(Math.abs(this.elasticDistance * (this._lastOffset / 150)));
                        e.ILaya.timer.frameLoop(1, this, this.tweenMove, [r])
                    }
            }
            elasticOver() {
                this._isElastic = !1, !this.hide && this.autoHide && e.Tween.to(this, {
                    alpha: 0
                }, 500), this.event(e.Event.END)
            }
            tweenMove(t) {
                var s;
                if ((this._lastOffset *= this.rollRatio, !this.checkTriggers(!0)) && (t > 0 && (this._lastOffset > 0 && this.value <= this.min ? (this._isElastic = !0, s = .5 * -(this.min - t - this.value), this._lastOffset > s && (this._lastOffset = s)) : this._lastOffset < 0 && this.value >= this.max && (this._isElastic = !0, s = .5 * -(this.max + t - this.value), this._lastOffset < s && (this._lastOffset = s))), this.value -= this._lastOffset, Math.abs(this._lastOffset) < .1)) {
                    if (e.ILaya.timer.clear(this, this.tweenMove), this._isElastic) return void(this._value < this.min ? e.Tween.to(this, {
                        value: this.min
                    }, this.elasticBackTime, e.Ease.sineOut, e.Handler.create(this, this.elasticOver)) : this._value > this.max ? e.Tween.to(this, {
                        value: this.max
                    }, this.elasticBackTime, e.Ease.sineOut, e.Handler.create(this, this.elasticOver)) : this.elasticOver());
                    this.event(e.Event.END), !this.hide && this.autoHide && e.Tween.to(this, {
                        alpha: 0
                    }, 500)
                }
            }
            stopScroll() {
                this.onStageMouseUp2(null), e.ILaya.timer.clear(this, this.tweenMove), e.Tween.clearTween(this)
            }
            get tick() {
                return this.slider.tick
            }
            set tick(t) {
                this.slider.tick = t
            }
            backToNormal() {
                this._value < this.min ? e.Tween.to(this, {
                    value: this.min
                }, this.elasticBackTime, e.Ease.sineOut, e.Handler.create(this, this.elasticOver)) : this._value > this.max && e.Tween.to(this, {
                    value: this.max
                }, this.elasticBackTime, e.Ease.sineOut, e.Handler.create(this, this.elasticOver))
            }
        }
        e.ILaya.regClass(v), e.ClassUtils.regClass("laya.ui.ScrollBar", v), e.ClassUtils.regClass("Laya.ScrollBar", v);
        class f extends v {}
        e.ILaya.regClass(f), e.ClassUtils.regClass("laya.ui.VScrollBar", f), e.ClassUtils.regClass("Laya.VScrollBar", f);
        class S extends v {
            initialize() {
                super.initialize(), this.slider.isVertical = !1
            }
        }
        e.ILaya.regClass(S), e.ClassUtils.regClass("laya.ui.HScrollBar", S), e.ClassUtils.regClass("Laya.HScrollBar", S);
        class y extends c {
            constructor() {
                super(...arguments), this.selectEnable = !1, this.totalPage = 0, this._$componentType = "List", this._repeatX = 0, this._repeatY = 0, this._repeatX2 = 0, this._repeatY2 = 0, this._spaceX = 0, this._spaceY = 0, this._cells = [], this._startIndex = 0, this._selectedIndex = -1, this._page = 0, this._isVertical = !0, this._cellSize = 20, this._cellOffset = 0, this._createdLine = 0, this._offset = new e.Point, this._usedCache = null, this._elasticEnabled = !1, this._preLen = 0
            }
            destroy(t = !0) {
                this._content && this._content.destroy(t), this._scrollBar && this._scrollBar.destroy(t), super.destroy(t), this._content = null, this._scrollBar = null, this._itemRender = null, this._cells = null, this._array = null, this.selectHandler = this.renderHandler = this.mouseHandler = null
            }
            createChildren() {
                this.addChild(this._content = new c)
            }
            set cacheAs(t) {
                super.cacheAs = t, this._scrollBar && (this._usedCache = null, "none" !== t ? this._scrollBar.on(e.Event.START, this, this.onScrollStart) : this._scrollBar.off(e.Event.START, this, this.onScrollStart))
            }
            get cacheAs() {
                return super.cacheAs
            }
            onScrollStart() {
                this._usedCache || (this._usedCache = super.cacheAs), super.cacheAs = "none", this._scrollBar.once(e.Event.END, this, this.onScrollEnd)
            }
            onScrollEnd() {
                super.cacheAs = this._usedCache || "none"
            }
            get content() {
                return this._content
            }
            get vScrollBarSkin() {
                return this._scrollBar ? this._scrollBar.skin : null
            }
            set vScrollBarSkin(t) {
                this._removePreScrollBar();
                var e = new f;
                e.name = "scrollBar", e.right = 0, e.skin = t, e.elasticDistance = this._elasticEnabled ? 200 : 0, this.scrollBar = e, this.addChild(e), this._setCellChanged()
            }
            _removePreScrollBar() {
                var t = this.removeChildByName("scrollBar");
                t && t.destroy(!0)
            }
            get hScrollBarSkin() {
                return this._scrollBar ? this._scrollBar.skin : null
            }
            set hScrollBarSkin(t) {
                this._removePreScrollBar();
                var e = new S;
                e.name = "scrollBar", e.bottom = 0, e.skin = t, e.elasticDistance = this._elasticEnabled ? 200 : 0, this.scrollBar = e, this.addChild(e), this._setCellChanged()
            }
            get scrollBar() {
                return this._scrollBar
            }
            set scrollBar(t) {
                this._scrollBar != t && (this._scrollBar = t, t && (this._isVertical = this._scrollBar.isVertical, this.addChild(this._scrollBar), this._scrollBar.on(e.Event.CHANGE, this, this.onScrollBarChange)))
            }
            get itemRender() {
                return this._itemRender
            }
            set itemRender(t) {
                if (this._itemRender != t) {
                    this._itemRender = t;
                    for (var e = this._cells.length - 1; e > -1; e--) this._cells[e].destroy();
                    this._cells.length = 0, this._setCellChanged()
                }
            }
            set width(t) {
                t != this._width && (super.width = t, this._setCellChanged())
            }
            get width() {
                return super.width
            }
            set height(t) {
                t != this._height && (super.height = t, this._setCellChanged())
            }
            get height() {
                return super.height
            }
            get repeatX() {
                return this._repeatX > 0 ? this._repeatX : this._repeatX2 > 0 ? this._repeatX2 : 1
            }
            set repeatX(t) {
                this._repeatX = t, this._setCellChanged()
            }
            get repeatY() {
                return this._repeatY > 0 ? this._repeatY : this._repeatY2 > 0 ? this._repeatY2 : 1
            }
            set repeatY(t) {
                this._repeatY = t, this._setCellChanged()
            }
            get spaceX() {
                return this._spaceX
            }
            set spaceX(t) {
                this._spaceX = t, this._setCellChanged()
            }
            get spaceY() {
                return this._spaceY
            }
            set spaceY(t) {
                this._spaceY = t, this._setCellChanged()
            }
            changeCells() {
                if (this._cellChanged = !1, this._itemRender) {
                    this.scrollBar = this.getChildByName("scrollBar");
                    var t = this._getOneCell(),
                        e = t.width + this._spaceX || 1,
                        s = t.height + this._spaceY || 1;
                    this._width > 0 && (this._repeatX2 = this._isVertical ? Math.round(this._width / e) : Math.ceil(this._width / e)), this._height > 0 && (this._repeatY2 = this._isVertical ? Math.ceil(this._height / s) : Math.round(this._height / s));
                    var i = this._width ? this._width : e * this.repeatX - this._spaceX,
                        h = this._height ? this._height : s * this.repeatY - this._spaceY;
                    this._cellSize = this._isVertical ? s : e, this._cellOffset = this._isVertical ? s * Math.max(this._repeatY2, this._repeatY) - h - this._spaceY : e * Math.max(this._repeatX2, this._repeatX) - i - this._spaceX, this._isVertical && this.vScrollBarSkin ? this._scrollBar.height = h : !this._isVertical && this.hScrollBarSkin && (this._scrollBar.width = i), this.setContentSize(i, h);
                    var a = this._isVertical ? this.repeatX : this.repeatY,
                        r = (this._isVertical ? this.repeatY : this.repeatX) + (this._scrollBar ? 1 : 0);
                    this._createItems(0, a, r), this._createdLine = r, this._array && (this.array = this._array, this.runCallLater(this.renderItems))
                }
            }
            _getOneCell() {
                if (0 === this._cells.length) {
                    var t = this.createItem();
                    if (this._offset.setTo(t._x, t._y), this.cacheContent) return t;
                    this._cells.push(t)
                }
                return this._cells[0]
            }
            _createItems(t, e, s) {
                var i = this._content,
                    h = this._getOneCell(),
                    a = h.width + this._spaceX,
                    r = h.height + this._spaceY;
                if (this.cacheContent) {
                    var l = new c;
                    l.cacheAs = "normal", l.pos((this._isVertical ? 0 : t) * a, (this._isVertical ? t : 0) * r), this._content.addChild(l), i = l
                } else {
                    for (var n = [], o = this._cells.length - 1; o > -1; o--) {
                        var _ = this._cells[o];
                        _.removeSelf(), n.push(_)
                    }
                    this._cells.length = 0
                }
                for (var d = t; d < s; d++)
                    for (var u = 0; u < e; u++)(h = n && n.length ? n.pop() : this.createItem()).x = (this._isVertical ? u : d) * a - i._x, h.y = (this._isVertical ? d : u) * r - i._y, h.name = "item" + (d * e + u), i.addChild(h), this.addCell(h);
                for (let t = n.length - 1; t >= 0; --t) n[t].destroy()
            }
            createItem() {
                var t = [];
                if ("function" == typeof this._itemRender) var s = new this._itemRender;
                else s = e.SceneUtils.createComp(this._itemRender, null, null, t);
                if (0 == t.length && s._watchMap) {
                    var i = s._watchMap;
                    for (var h in i)
                        for (var a = i[h], r = 0; r < a.length; r++) {
                            var l = a[r];
                            t.push(l.comp, l.prop, l.value)
                        }
                }
                return t.length && (s._$bindData = t), s
            }
            addCell(t) {
                t.on(e.Event.CLICK, this, this.onCellMouse), t.on(e.Event.RIGHT_CLICK, this, this.onCellMouse), t.on(e.Event.MOUSE_OVER, this, this.onCellMouse), t.on(e.Event.MOUSE_OUT, this, this.onCellMouse), t.on(e.Event.MOUSE_DOWN, this, this.onCellMouse), t.on(e.Event.MOUSE_UP, this, this.onCellMouse), this._cells.push(t)
            }
            _afterInited() {
                this.initItems()
            }
            initItems() {
                if (!this._itemRender && null != this.getChildByName("item0")) {
                    var t;
                    this.repeatX = 1, t = 0;
                    for (var e = 0; e < 1e4; e++) {
                        var s = this.getChildByName("item" + e);
                        if (!s) break;
                        this.addCell(s), t++
                    }
                    this.repeatY = t
                }
            }
            setContentSize(t, s) {
                this._content.width = t, this._content.height = s, (this._scrollBar || 0 != this._offset.x || 0 != this._offset.y) && (this._content._style.scrollRect || (this._content.scrollRect = e.Rectangle.create()), this._content._style.scrollRect.setTo(-this._offset.x, -this._offset.y, t, s), this._content.scrollRect = this._content.scrollRect), this.event(e.Event.RESIZE)
            }
            onCellMouse(t) {
                t.type === e.Event.MOUSE_DOWN && (this._isMoved = !1);
                var s = t.currentTarget,
                    i = this._startIndex + this._cells.indexOf(s);
                i < 0 || (t.type === e.Event.CLICK || t.type === e.Event.RIGHT_CLICK ? this.selectEnable && !this._isMoved ? this.selectedIndex = i : this.changeCellState(s, !0, 0) : t.type !== e.Event.MOUSE_OVER && t.type !== e.Event.MOUSE_OUT || this._selectedIndex === i || this.changeCellState(s, t.type === e.Event.MOUSE_OVER, 0), this.mouseHandler && this.mouseHandler.runWith([t, i]))
            }
            changeCellState(t, e, s) {
                var i = t.getChildByName("selectBox");
                i && (this.selectEnable = !0, i.visible = e, i.index = s)
            }
            _sizeChanged() {
                super._sizeChanged(), this.setContentSize(this.width, this.height), this._scrollBar && this.callLater(this.onScrollBarChange)
            }
            onScrollBarChange(t = null) {
                this.runCallLater(this.changeCells);
                var e = this._scrollBar.value,
                    s = this._isVertical ? this.repeatX : this.repeatY,
                    i = this._isVertical ? this.repeatY : this.repeatX,
                    h = Math.floor(e / this._cellSize);
                if (this.cacheContent) r = i + 1, this._createdLine - h < r && (this._createItems(this._createdLine, s, this._createdLine + r), this.renderItems(this._createdLine * s, 0), this._createdLine += r);
                else {
                    var a = h * s,
                        r = 0;
                    let t = !0;
                    var l = 0;
                    a > this._startIndex ? (r = a - this._startIndex, l = this._startIndex + s * (i + 1), this._isMoved = !0) : a < this._startIndex && (r = this._startIndex - a, t = !1, l = this._startIndex - 1, this._isMoved = !0);
                    for (var n = 0; n < r; n++) {
                        if (t) {
                            var o = this._cells.shift();
                            this._cells[this._cells.length] = o;
                            var _ = l + n
                        } else o = this._cells.pop(), this._cells.unshift(o), _ = l - n;
                        var c = Math.floor(_ / s) * this._cellSize;
                        this._isVertical ? o.y = c : o.x = c, this.renderItem(o, _)
                    }
                    this._startIndex = a, this.changeSelectStatus()
                }
                var d = this._content._style.scrollRect;
                this._isVertical ? (d.y = e - this._offset.y, d.x = -this._offset.x) : (d.y = -this._offset.y, d.x = e - this._offset.x), this._content.scrollRect = d
            }
            posCell(t, e) {
                if (this._scrollBar) {
                    var s = this._isVertical ? this.repeatX : this.repeatY,
                        i = Math.floor(e / s) * this._cellSize;
                    this._isVertical ? t._y = i : t.x = i
                }
            }
            get selectedIndex() {
                return this._selectedIndex
            }
            set selectedIndex(t) {
                this._selectedIndex != t && (this._selectedIndex = t, this.changeSelectStatus(), this.event(e.Event.CHANGE), this.selectHandler && this.selectHandler.runWith(t), this.startIndex = this._startIndex)
            }
            changeSelectStatus() {
                for (var t = 0, e = this._cells.length; t < e; t++) this.changeCellState(this._cells[t], this._selectedIndex === this._startIndex + t, 1)
            }
            get selectedItem() {
                return this._array && -1 != this._selectedIndex ? this._array[this._selectedIndex] : null
            }
            set selectedItem(t) {
                this._array && (this.selectedIndex = this._array.indexOf(t))
            }
            get selection() {
                return this.getCell(this._selectedIndex)
            }
            set selection(t) {
                this.selectedIndex = this._startIndex + this._cells.indexOf(t)
            }
            get startIndex() {
                return this._startIndex
            }
            set startIndex(t) {
                this._startIndex = t > 0 ? t : 0, this.callLater(this.renderItems)
            }
            renderItems(t = 0, s = 0) {
                for (var i = t, h = s || this._cells.length; i < h; i++) this.renderItem(this._cells[i], this._startIndex + i);
                this.changeSelectStatus(), this.event(e.Event.LIST_ITEMS_CHANGED)
            }
            renderItem(t, s) {
                this._array && s >= 0 && s < this._array.length ? (t.visible = !0, t._$bindData ? (t._dataSource = this._array[s], this._bindData(t, this._array[s])) : t.dataSource = this._array[s], this.cacheContent || this.posCell(t, s), this.hasListener(e.Event.RENDER) && this.event(e.Event.RENDER, [t, s]), this.renderHandler && this.renderHandler.runWith([t, s])) : (t.visible = !1, t.dataSource = null)
            }
            _bindData(t, e) {
                for (var s = t._$bindData, i = 0, h = s.length; i < h; i++) {
                    var a = s[i++],
                        r = s[i++],
                        n = s[i],
                        o = l.getBindFun(n);
                    a[r] = o.call(this, e)
                }
            }
            get array() {
                return this._array
            }
            set array(t) {
                this.runCallLater(this.changeCells), this._array = t || [], this._preLen = this._array.length;
                var e = this._array.length;
                if (this.totalPage = Math.ceil(e / (this.repeatX * this.repeatY)), this._selectedIndex = this._selectedIndex < e ? this._selectedIndex : e - 1, this.startIndex = this._startIndex, this._scrollBar) {
                    this._scrollBar.stopScroll();
                    var s = this._isVertical ? this.repeatX : this.repeatY,
                        i = this._isVertical ? this.repeatY : this.repeatX,
                        h = Math.ceil(e / s);
                    (this._cellOffset > 0 ? this.totalPage + 1 : this.totalPage) > 1 && h >= i ? (this._scrollBar.scrollSize = this._cellSize, this._scrollBar.thumbPercent = i / h, this._scrollBar.setScroll(0, (h - i) * this._cellSize + this._cellOffset, this._scrollBar.value), this._scrollBar.target = this._content) : (this._scrollBar.setScroll(0, 0, 0), this._scrollBar.target = this._content)
                }
            }
            updateArray(t) {
                if (this._array = t, this._array) {
                    let t = this._preLen - this._startIndex;
                    t >= 0 && this.renderItems(t), this._preLen = this._array.length
                }
                if (this._scrollBar) {
                    var e = t.length,
                        s = this._isVertical ? this.repeatX : this.repeatY,
                        i = this._isVertical ? this.repeatY : this.repeatX,
                        h = Math.ceil(e / s);
                    h >= i && (this._scrollBar.thumbPercent = i / h, this._scrollBar.slider._max = (h - i) * this._cellSize + this._cellOffset)
                }
            }
            get page() {
                return this._page
            }
            set page(t) {
                this._page = t, this._array && (this._page = t > 0 ? t : 0, this._page = this._page < this.totalPage ? this._page : this.totalPage - 1, this.startIndex = this._page * this.repeatX * this.repeatY)
            }
            get length() {
                return this._array ? this._array.length : 0
            }
            set dataSource(t) {
                this._dataSource = t, "number" == typeof t || "string" == typeof t ? this.selectedIndex = parseInt(t) : t instanceof Array ? this.array = t : super.dataSource = t
            }
            get dataSource() {
                return super.dataSource
            }
            get cells() {
                return this.runCallLater(this.changeCells), this._cells
            }
            get elasticEnabled() {
                return this._elasticEnabled
            }
            set elasticEnabled(t) {
                this._elasticEnabled = t, this._scrollBar && (this._scrollBar.elasticDistance = t ? 200 : 0)
            }
            refresh() {
                this.array = this._array
            }
            getItem(t) {
                return this._array && t > -1 && t < this._array.length ? this._array[t] : null
            }
            changeItem(t, e) {
                t > -1 && this._array && t < this._array.length && (this._array[t] = e, t >= this._startIndex && t < this._startIndex + this._cells.length && this.renderItem(this.getCell(t), t))
            }
            setItem(t, e) {
                this.changeItem(t, e)
            }
            addItem(t) {
                this.array ? this._array.push(t) : this.array = [t], this.array = this._array
            }
            addItemAt(t, e) {
                this._array.splice(e, 0, t), this.array = this._array
            }
            deleteItem(t) {
                this._array && (this._array.splice(t, 1), this.array = this._array)
            }
            getCell(t) {
                return this.runCallLater(this.changeCells), t > -1 && this._cells ? this._cells[(t - this._startIndex) % this._cells.length] : null
            }
            scrollTo(t) {
                if (this._scrollBar) {
                    var e = this._isVertical ? this.repeatX : this.repeatY;
                    this._scrollBar.value = Math.floor(t / e) * this._cellSize
                } else this.startIndex = t
            }
            tweenTo(t, s = 200, i = null) {
                if (this._scrollBar) {
                    this._scrollBar.stopScroll();
                    var h = this._isVertical ? this.repeatX : this.repeatY;
                    e.Tween.to(this._scrollBar, {
                        value: Math.floor(t / h) * this._cellSize
                    }, s, null, i, 0, !0)
                } else this.startIndex = t, i && i.run()
            }
            _setCellChanged() {
                this._cellChanged || (this._cellChanged = !0, this.callLater(this.changeCells))
            }
            commitMeasure() {
                this.runCallLater(this.changeCells)
            }
        }
        e.ILaya.regClass(y), e.ClassUtils.regClass("laya.ui.List", y), e.ClassUtils.regClass("Laya.List", y);
        class b extends n {
            constructor(t = null, e = null) {
                super(), this._visibleNum = 6, this._itemColors = i.comboBoxItemColors, this._itemSize = 12, this._labels = [], this._selectedIndex = -1, this.itemRender = null, this.skin = t, this.labels = e
            }
            destroy(t = !0) {
                e.ILaya.stage.off(e.Event.MOUSE_DOWN, this, this.removeList), e.ILaya.stage.off(e.Event.MOUSE_WHEEL, this, this._onStageMouseWheel), super.destroy(t), this._button && this._button.destroy(t), this._list && this._list.destroy(t), this._button = null, this._list = null, this._itemColors = null, this._labels = null, this._selectHandler = null
            }
            createChildren() {
                this.addChild(this._button = new d), this._button.text.align = "left", this._button.labelPadding = "0,0,0,5", this._button.on(e.Event.MOUSE_DOWN, this, this.onButtonMouseDown)
            }
            _createList() {
                this._list = new y, this._scrollBarSkin && (this._list.vScrollBarSkin = this._scrollBarSkin), this._setListEvent(this._list)
            }
            _setListEvent(t) {
                this._list.selectEnable = !0, this._list.on(e.Event.MOUSE_DOWN, this, this.onListDown), this._list.mouseHandler = e.Handler.create(this, this.onlistItemMouse, null, !1), this._list.scrollBar && this._list.scrollBar.on(e.Event.MOUSE_DOWN, this, this.onScrollBarDown)
            }
            onListDown(t) {
                t.stopPropagation()
            }
            onScrollBarDown(t) {
                t.stopPropagation()
            }
            onButtonMouseDown(t) {
                this.callLater(this.switchTo, [!this._isOpen])
            }
            get skin() {
                return this._button.skin
            }
            set skin(t) {
                this._button.skin != t && (this._button.skin = t, this._listChanged = !0)
            }
            measureWidth() {
                return this._button.width
            }
            measureHeight() {
                return this._button.height
            }
            changeList() {
                this._listChanged = !1;
                var t = this.width - 2,
                    e = this._itemColors[2];
                this._itemHeight = this._itemSize + 6, this._list.itemRender = this.itemRender || {
                    type: "Box",
                    child: [{
                        type: "Label",
                        props: {
                            name: "label",
                            x: 1,
                            padding: "3,3,3,3",
                            width: t,
                            height: this._itemHeight,
                            fontSize: this._itemSize,
                            color: e
                        }
                    }]
                }, this._list.repeatY = this._visibleNum, this._list.refresh()
            }
            onlistItemMouse(t, s) {
                var i = t.type;
                if (i === e.Event.MOUSE_OVER || i === e.Event.MOUSE_OUT) {
                    if (this._isCustomList) return;
                    var h = this._list.getCell(s);
                    if (!h) return;
                    var a = h.getChildByName("label");
                    a && (i === e.Event.ROLL_OVER ? (a.bgColor = this._itemColors[0], a.color = this._itemColors[1]) : (a.bgColor = null, a.color = this._itemColors[2]))
                } else i === e.Event.CLICK && (this.selectedIndex = s, this.isOpen = !1)
            }
            switchTo(t) {
                this.isOpen = t
            }
            changeOpen() {
                this.isOpen = !this._isOpen
            }
            set width(t) {
                super.width = t, this._button.width = this._width, this._itemChanged = !0, this._listChanged = !0
            }
            get width() {
                return super.width
            }
            set height(t) {
                super.height = t, this._button.height = this._height
            }
            get height() {
                return super.height
            }
            get labels() {
                return this._labels.join(",")
            }
            set labels(t) {
                this._labels.length > 0 && (this.selectedIndex = -1), t ? this._labels = t.split(",") : this._labels.length = 0, this._itemChanged = !0
            }
            changeItem() {
                if (this._itemChanged = !1, this._listHeight = this._labels.length > 0 ? Math.min(this._visibleNum, this._labels.length) * this._itemHeight : this._itemHeight, !this._isCustomList) {
                    var t = this._list.graphics;
                    t.clear(!0), t.drawRect(0, 0, this.width - 1, this._listHeight, this._itemColors[4], this._itemColors[3])
                }
                var e = this._list.array || [];
                e.length = 0;
                for (var s = 0, i = this._labels.length; s < i; s++) e.push({
                    label: this._labels[s]
                });
                this._list.height = this._listHeight, this._list.array = e
            }
            get selectedIndex() {
                return this._selectedIndex
            }
            set selectedIndex(t) {
                this._selectedIndex != t && (this._selectedIndex = t, this._labels.length > 0 ? this.changeSelected() : this.callLater(this.changeSelected), this.event(e.Event.CHANGE, [e.Event.EMPTY.setTo(e.Event.CHANGE, this, this)]), this._selectHandler && this._selectHandler.runWith(this._selectedIndex))
            }
            changeSelected() {
                this._button.label = this.selectedLabel
            }
            get selectHandler() {
                return this._selectHandler
            }
            set selectHandler(t) {
                this._selectHandler = t
            }
            get selectedLabel() {
                return this._selectedIndex > -1 && this._selectedIndex < this._labels.length ? this._labels[this._selectedIndex] : null
            }
            set selectedLabel(t) {
                this.selectedIndex = this._labels.indexOf(t)
            }
            get visibleNum() {
                return this._visibleNum
            }
            set visibleNum(t) {
                this._visibleNum = t, this._listChanged = !0
            }
            get itemColors() {
                return String(this._itemColors)
            }
            set itemColors(t) {
                this._itemColors = l.fillArray(this._itemColors, t, String), this._listChanged = !0
            }
            get itemSize() {
                return this._itemSize
            }
            set itemSize(t) {
                this._itemSize = t, this._listChanged = !0
            }
            get isOpen() {
                return this._isOpen
            }
            set isOpen(t) {
                if (this._isOpen != t)
                    if (this._isOpen = t, this._button.selected = this._isOpen, this._isOpen) {
                        this._list || this._createList(), this._listChanged && !this._isCustomList && this.changeList(), this._itemChanged && this.changeItem();
                        var s = this.localToGlobal(e.Point.TEMP.setTo(0, 0)),
                            i = s.y + this._button.height;
                        i = i + this._listHeight <= e.ILaya.stage.height ? i : s.y - this._listHeight, this._list.pos(s.x, i), this._list.zOrder = 1001, e.ILaya.stage.addChild(this._list), e.ILaya.stage.once(e.Event.MOUSE_DOWN, this, this.removeList), e.ILaya.stage.on(e.Event.MOUSE_WHEEL, this, this._onStageMouseWheel), this._list.selectedIndex = this._selectedIndex
                    } else this._list && this._list.removeSelf()
            }
            _onStageMouseWheel(t) {
                this._list && !this._list.contains(t.target) && this.removeList(null)
            }
            removeList(t) {
                e.ILaya.stage.off(e.Event.MOUSE_DOWN, this, this.removeList), e.ILaya.stage.off(e.Event.MOUSE_WHEEL, this, this._onStageMouseWheel), this.isOpen = !1
            }
            get scrollBarSkin() {
                return this._scrollBarSkin
            }
            set scrollBarSkin(t) {
                this._scrollBarSkin = t
            }
            get sizeGrid() {
                return this._button.sizeGrid
            }
            set sizeGrid(t) {
                this._button.sizeGrid = t
            }
            get scrollBar() {
                return this.list.scrollBar
            }
            get button() {
                return this._button
            }
            get list() {
                return this._list || this._createList(), this._list
            }
            set list(t) {
                t && (t.removeSelf(), this._isCustomList = !0, this._list = t, this._setListEvent(t), this._itemHeight = t.getCell(0).height + t.spaceY)
            }
            set dataSource(t) {
                this._dataSource = t, "number" == typeof t || "string" == typeof t ? this.selectedIndex = parseInt(t) : t instanceof Array ? this.labels = t.join(",") : super.dataSource = t
            }
            get dataSource() {
                return super.dataSource
            }
            get labelColors() {
                return this._button.labelColors
            }
            set labelColors(t) {
                this._button.labelColors != t && (this._button.labelColors = t)
            }
            get labelPadding() {
                return this._button.text.padding.join(",")
            }
            set labelPadding(t) {
                this._button.text.padding = l.fillArray(i.labelPadding, t, Number)
            }
            get labelSize() {
                return this._button.text.fontSize
            }
            set labelSize(t) {
                this._button.text.fontSize = t
            }
            get labelBold() {
                return this._button.text.bold
            }
            set labelBold(t) {
                this._button.text.bold = t
            }
            get labelFont() {
                return this._button.text.font
            }
            set labelFont(t) {
                this._button.text.font = t
            }
            get stateNum() {
                return this._button.stateNum
            }
            set stateNum(t) {
                this._button.stateNum = t
            }
        }
        e.ILaya.regClass(b), e.ClassUtils.regClass("laya.ui.ComboBox", b), e.ClassUtils.regClass("Laya.ComboBox", b);
        class w extends n {
            constructor(t = null) {
                super(), this._value = .5, this.skin = t
            }
            destroy(t = !0) {
                super.destroy(t), this._bg && this._bg.destroy(t), this._bar && this._bar.destroy(t), this._bg = this._bar = null, this.changeHandler = null
            }
            createChildren() {
                this.addChild(this._bg = new o), this.addChild(this._bar = new o), this._bar._bitmap.autoCacheCmd = !1
            }
            get skin() {
                return this._skin
            }
            set skin(t) {
                this._skin != t && (this._skin = t, this._skin && !e.Loader.getRes(this._skin) ? e.ILaya.loader.load(this._skin, e.Handler.create(this, this._skinLoaded), null, e.Loader.IMAGE, 1) : this._skinLoaded())
            }
            _skinLoaded() {
                this.destroyed || (this._bg.skin = this._skin, this._bar.skin = this._skin.replace(".png", "$bar.png"), this.callLater(this.changeValue), this._sizeChanged(), this.event(e.Event.LOADED))
            }
            measureWidth() {
                return this._bg.width
            }
            measureHeight() {
                return this._bg.height
            }
            get value() {
                return this._value
            }
            set value(t) {
                this._value != t && (t = t > 1 ? 1 : t < 0 ? 0 : t, this._value = t, this.callLater(this.changeValue), this.event(e.Event.CHANGE), this.changeHandler && this.changeHandler.runWith(t))
            }
            changeValue() {
                if (this.sizeGrid) {
                    var t = this.sizeGrid.split(","),
                        e = Number(t[3]),
                        s = Number(t[1]),
                        i = (this.width - e - s) * this._value;
                    this._bar.width = e + s + i, this._bar.visible = this._bar.width > e + s
                } else this._bar.width = this.width * this._value
            }
            get bar() {
                return this._bar
            }
            get bg() {
                return this._bg
            }
            get sizeGrid() {
                return this._bg.sizeGrid
            }
            set sizeGrid(t) {
                this._bg.sizeGrid = this._bar.sizeGrid = t
            }
            set width(t) {
                super.width = t, this._bg.width = this._width, this.callLater(this.changeValue)
            }
            get width() {
                return super.width
            }
            set height(t) {
                super.height = t, this._bg.height = this._height, this._bar.height = this._height
            }
            get height() {
                return super.height
            }
            set dataSource(t) {
                this._dataSource = t, "number" == typeof t || "string" == typeof t ? this.value = Number(t) : super.dataSource = t
            }
            get dataSource() {
                return super.dataSource
            }
        }
        e.ILaya.regClass(w), e.ClassUtils.regClass("laya.ui.ProgressBar", w), e.ClassUtils.regClass("Laya.ProgressBar", w);
        class x extends d {
            constructor(t = null, e = "") {
                super(t, e), this.toggle = !1, this._autoSize = !1
            }
            destroy(t = !0) {
                super.destroy(t), this._value = null
            }
            preinitialize() {
                super.preinitialize(), this.toggle = !1, this._autoSize = !1
            }
            initialize() {
                super.initialize(), this.createText(), this._text.align = "left", this._text.valign = "top", this._text.width = 0, this.on(e.Event.CLICK, this, this.onClick)
            }
            onClick(t) {
                this.selected = !0
            }
            get value() {
                return null != this._value ? this._value : this.label
            }
            set value(t) {
                this._value = t
            }
        }
        e.ILaya.regClass(x), e.ClassUtils.regClass("laya.ui.Radio", x), e.ClassUtils.regClass("Laya.Radio", x);
        class L extends c {
            constructor(t = null, e = null) {
                super(), this._selectedIndex = -1, this._direction = "horizontal", this._space = 0, this.skin = e, this.labels = t
            }
            preinitialize() {
                this.mouseEnabled = !0
            }
            destroy(t = !0) {
                super.destroy(t), this._items && (this._items.length = 0), this._items = null, this.selectHandler = null
            }
            addItem(t, e = !0) {
                var s = t,
                    i = this._items.length;
                if (s.name = "item" + i, this.addChild(s), this.initItems(), e && i > 0) {
                    var h = this._items[i - 1];
                    "horizontal" == this._direction ? s.x = h._x + h.width + this._space : s.y = h._y + h.height + this._space
                } else e && (s.x = 0, s.y = 0);
                return i
            }
            delItem(t, e = !0) {
                var s = this._items.indexOf(t);
                if (-1 != s) {
                    var i, h = t;
                    this.removeChild(h);
                    for (var a = s + 1, r = this._items.length; a < r; a++) {
                        var l = this._items[a];
                        l.name = "item" + (a - 1), e && ("horizontal" == this._direction ? l.x -= h.width + this._space : l.y -= h.height + this._space)
                    }
                    if (this.initItems(), this._selectedIndex > -1) i = this._selectedIndex < this._items.length ? this._selectedIndex : this._selectedIndex - 1, this._selectedIndex = -1, this.selectedIndex = i
                }
            }
            _afterInited() {
                this.initItems()
            }
            initItems() {
                this._items || (this._items = []), this._items.length = 0;
                for (var t = 0; t < 1e4; t++) {
                    var s = this.getChildByName("item" + t);
                    if (null == s) break;
                    this._items.push(s), s.selected = t === this._selectedIndex, s.clickHandler = e.Handler.create(this, this.itemClick, [t], !1)
                }
            }
            itemClick(t) {
                this.selectedIndex = t
            }
            get selectedIndex() {
                return this._selectedIndex
            }
            set selectedIndex(t) {
                this._selectedIndex != t && (this.setSelect(this._selectedIndex, !1), this._selectedIndex = t, this.setSelect(t, !0), this.event(e.Event.CHANGE), this.selectHandler && this.selectHandler.runWith(this._selectedIndex))
            }
            setSelect(t, e) {
                this._items && t > -1 && t < this._items.length && (this._items[t].selected = e)
            }
            get skin() {
                return this._skin
            }
            set skin(t) {
                this._skin != t && (this._skin = t, this._skin && !e.Loader.getRes(this._skin) ? e.ILaya.loader.load(this._skin, e.Handler.create(this, this._skinLoaded), null, e.Loader.IMAGE, 1) : this._skinLoaded())
            }
            _skinLoaded() {
                this._setLabelChanged(), this.event(e.Event.LOADED)
            }
            get labels() {
                return this._labels
            }
            set labels(t) {
                if (this._labels != t) {
                    if (this._labels = t, this.removeChildren(), this._setLabelChanged(), this._labels)
                        for (var e = this._labels.split(","), s = 0, i = e.length; s < i; s++) {
                            var h = this.createItem(this._skin, e[s]);
                            h.name = "item" + s, this.addChild(h)
                        }
                    this.initItems()
                }
            }
            createItem(t, e) {
                return null
            }
            get labelColors() {
                return this._labelColors
            }
            set labelColors(t) {
                this._labelColors != t && (this._labelColors = t, this._setLabelChanged())
            }
            get labelStroke() {
                return this._labelStroke
            }
            set labelStroke(t) {
                this._labelStroke != t && (this._labelStroke = t, this._setLabelChanged())
            }
            get labelStrokeColor() {
                return this._labelStrokeColor
            }
            set labelStrokeColor(t) {
                this._labelStrokeColor != t && (this._labelStrokeColor = t, this._setLabelChanged())
            }
            get strokeColors() {
                return this._strokeColors
            }
            set strokeColors(t) {
                this._strokeColors != t && (this._strokeColors = t, this._setLabelChanged())
            }
            get labelSize() {
                return this._labelSize
            }
            set labelSize(t) {
                this._labelSize != t && (this._labelSize = t, this._setLabelChanged())
            }
            get stateNum() {
                return this._stateNum
            }
            set stateNum(t) {
                this._stateNum != t && (this._stateNum = t, this._setLabelChanged())
            }
            get labelBold() {
                return this._labelBold
            }
            set labelBold(t) {
                this._labelBold != t && (this._labelBold = t, this._setLabelChanged())
            }
            get labelFont() {
                return this._labelFont
            }
            set labelFont(t) {
                this._labelFont != t && (this._labelFont = t, this._setLabelChanged())
            }
            get labelPadding() {
                return this._labelPadding
            }
            set labelPadding(t) {
                this._labelPadding != t && (this._labelPadding = t, this._setLabelChanged())
            }
            get direction() {
                return this._direction
            }
            set direction(t) {
                this._direction = t, this._setLabelChanged()
            }
            get space() {
                return this._space
            }
            set space(t) {
                this._space = t, this._setLabelChanged()
            }
            changeLabels() {
                if (this._labelChanged = !1, this._items)
                    for (var t = 0, e = 0, s = this._items.length; e < s; e++) {
                        var i = this._items[e];
                        this._skin && (i.skin = this._skin), this._labelColors && (i.labelColors = this._labelColors), this._labelSize && (i.labelSize = this._labelSize), this._labelStroke && (i.labelStroke = this._labelStroke), this._labelStrokeColor && (i.labelStrokeColor = this._labelStrokeColor), this._strokeColors && (i.strokeColors = this._strokeColors), this._labelBold && (i.labelBold = this._labelBold), this._labelPadding && (i.labelPadding = this._labelPadding), this._labelAlign && (i.labelAlign = this._labelAlign), this._stateNum && (i.stateNum = this._stateNum), this._labelFont && (i.labelFont = this._labelFont), "horizontal" === this._direction ? (i.y = 0, i.x = t, t += i.width + this._space) : (i.x = 0, i.y = t, t += i.height + this._space)
                    }
                this._sizeChanged()
            }
            commitMeasure() {
                this.runCallLater(this.changeLabels)
            }
            get items() {
                return this._items
            }
            get selection() {
                return this._selectedIndex > -1 && this._selectedIndex < this._items.length ? this._items[this._selectedIndex] : null
            }
            set selection(t) {
                this.selectedIndex = this._items.indexOf(t)
            }
            set dataSource(t) {
                this._dataSource = t, "number" == typeof t || "string" == typeof t ? this.selectedIndex = parseInt(t) : t instanceof Array ? this.labels = t.join(",") : super.dataSource = t
            }
            get dataSource() {
                return super.dataSource
            }
            _setLabelChanged() {
                this._labelChanged || (this._labelChanged = !0, this.callLater(this.changeLabels))
            }
        }
        e.ILaya.regClass(L), e.ClassUtils.regClass("laya.ui.UIGroup", L), e.ClassUtils.regClass("Laya.UIGroup", L);
        class E extends L {
            createItem(t, e) {
                return new x(t, e)
            }
        }
        e.ILaya.regClass(E), e.ClassUtils.regClass("laya.ui.RadioGroup", E), e.ClassUtils.regClass("Laya.RadioGroup", E);
        class I extends L {
            createItem(t, e) {
                return new d(t, e)
            }
        }
        e.ILaya.regClass(I), e.ClassUtils.regClass("laya.ui.Tab", I), e.ClassUtils.regClass("Laya.Tab", I);
        class B extends c {
            constructor() {
                super(...arguments), this._setIndexHandler = e.Handler.create(this, this.setIndex, null, !1)
            }
            setItems(t) {
                this.removeChildren();
                for (var e = 0, s = 0, i = t.length; s < i; s++) {
                    var h = t[s];
                    h && (h.name = "item" + e, this.addChild(h), e++)
                }
                this.initItems()
            }
            addItem(t) {
                t.name = "item" + this._items.length, this.addChild(t), this.initItems()
            }
            _afterInited() {
                this.initItems()
            }
            initItems() {
                this._items = [];
                for (var t = 0; t < 1e4; t++) {
                    var e = this.getChildByName("item" + t);
                    if (null == e) break;
                    this._items.push(e), e.visible = t == this._selectedIndex
                }
            }
            get selectedIndex() {
                return this._selectedIndex
            }
            set selectedIndex(t) {
                this._selectedIndex != t && (this.setSelect(this._selectedIndex, !1), this._selectedIndex = t, this.setSelect(this._selectedIndex, !0))
            }
            setSelect(t, e) {
                this._items && t > -1 && t < this._items.length && (this._items[t].visible = e)
            }
            get selection() {
                return this._selectedIndex > -1 && this._selectedIndex < this._items.length ? this._items[this._selectedIndex] : null
            }
            set selection(t) {
                this.selectedIndex = this._items.indexOf(t)
            }
            get setIndexHandler() {
                return this._setIndexHandler
            }
            set setIndexHandler(t) {
                this._setIndexHandler = t
            }
            setIndex(t) {
                this.selectedIndex = t
            }
            get items() {
                return this._items
            }
            set dataSource(t) {
                if (this._dataSource = t, "number" == typeof t || "string" == typeof t) this.selectedIndex = parseInt(t);
                else
                    for (var e in this._dataSource) e in this && (this[e] = this._dataSource[e])
            }
            get dataSource() {
                return super.dataSource
            }
        }
        e.ILaya.regClass(B), e.ClassUtils.regClass("laya.ui.ViewStack", B), e.ClassUtils.regClass("Laya.ViewStack", B);
        class k extends C {
            constructor(t = "") {
                super(), this.text = t, this.skin = this.skin
            }
            preinitialize() {
                this.mouseEnabled = !0
            }
            destroy(t = !0) {
                super.destroy(t), this._bg && this._bg.destroy(), this._bg = null
            }
            createChildren() {
                this.addChild(this._tf = new e.Input), this._tf.padding = i.inputLabelPadding, this._tf.on(e.Event.INPUT, this, this._onInput), this._tf.on(e.Event.ENTER, this, this._onEnter), this._tf.on(e.Event.BLUR, this, this._onBlur), this._tf.on(e.Event.FOCUS, this, this._onFocus)
            }
            _onFocus() {
                this.event(e.Event.FOCUS, this)
            }
            _onBlur() {
                this.event(e.Event.BLUR, this)
            }
            _onInput() {
                this.event(e.Event.INPUT, this)
            }
            _onEnter() {
                this.event(e.Event.ENTER, this)
            }
            initialize() {
                this.width = 128, this.height = 22
            }
            get bg() {
                return this._bg
            }
            set bg(t) {
                this.graphics = this._bg = t
            }
            get skin() {
                return this._skin
            }
            set skin(t) {
                this._skin != t && (this._skin = t, this._skin && !e.Loader.getRes(this._skin) ? e.ILaya.loader.load(this._skin, e.Handler.create(this, this._skinLoaded), null, e.Loader.IMAGE, 1) : this._skinLoaded())
            }
            _skinLoaded() {
                this._bg || (this.graphics = this._bg = new h), this._bg.source = e.Loader.getRes(this._skin), this._width && (this._bg.width = this._width), this._height && (this._bg.height = this._height), this._sizeChanged(), this.event(e.Event.LOADED)
            }
            get sizeGrid() {
                return this._bg && this._bg.sizeGrid ? this._bg.sizeGrid.join(",") : null
            }
            set sizeGrid(t) {
                this._bg || (this.graphics = this._bg = new h), this._bg.sizeGrid = l.fillArray(i.defaultSizeGrid, t, Number)
            }
            set text(t) {
                this._tf.text != t && (t += "", this._tf.text = t, this.event(e.Event.CHANGE))
            }
            get text() {
                return super.text
            }
            set width(t) {
                super.width = t, this._bg && (this._bg.width = t)
            }
            get width() {
                return super.width
            }
            set height(t) {
                super.height = t, this._bg && (this._bg.height = t)
            }
            get height() {
                return super.height
            }
            get multiline() {
                return this._tf.multiline
            }
            set multiline(t) {
                this._tf.multiline = t
            }
            set editable(t) {
                this._tf.editable = t
            }
            get editable() {
                return this._tf.editable
            }
            select() {
                this._tf.select()
            }
            get restrict() {
                return this._tf.restrict
            }
            set restrict(t) {
                this._tf.restrict = t
            }
            get prompt() {
                return this._tf.prompt
            }
            set prompt(t) {
                this._tf.prompt = t
            }
            get promptColor() {
                return this._tf.promptColor
            }
            set promptColor(t) {
                this._tf.promptColor = t
            }
            get maxChars() {
                return this._tf.maxChars
            }
            set maxChars(t) {
                this._tf.maxChars = t
            }
            get focus() {
                return this._tf.focus
            }
            set focus(t) {
                this._tf.focus = t
            }
            get type() {
                return this._tf.type
            }
            set type(t) {
                this._tf.type = t
            }
            setSelection(t, e) {
                this._tf.setSelection(t, e)
            }
        }
        e.ILaya.regClass(k), e.ClassUtils.regClass("laya.ui.TextInput", k), e.ClassUtils.regClass("Laya.TextInput", k);
        class M extends k {
            constructor(t = "") {
                super(t), this.on(e.Event.CHANGE, this, this._onTextChange)
            }
            _onTextChange() {
                this.callLater(this.changeScroll)
            }
            destroy(t = !0) {
                this._vScrollBar && this._vScrollBar.destroy(), this._hScrollBar && this._hScrollBar.destroy(), this._vScrollBar = null, this._hScrollBar = null, super.destroy(t)
            }
            initialize() {
                this.width = 180, this.height = 150, this._tf.wordWrap = !0, this.multiline = !0
            }
            set width(t) {
                super.width = t, this.callLater(this.changeScroll)
            }
            get width() {
                return super.width
            }
            set height(t) {
                super.height = t, this.callLater(this.changeScroll)
            }
            get height() {
                return super.height
            }
            get vScrollBarSkin() {
                return this._vScrollBar ? this._vScrollBar.skin : null
            }
            set vScrollBarSkin(t) {
                null == this._vScrollBar && (this.addChild(this._vScrollBar = new f), this._vScrollBar.on(e.Event.CHANGE, this, this.onVBarChanged), this._vScrollBar.target = this._tf, this.callLater(this.changeScroll)), this._vScrollBar.skin = t
            }
            get hScrollBarSkin() {
                return this._hScrollBar ? this._hScrollBar.skin : null
            }
            set hScrollBarSkin(t) {
                null == this._hScrollBar && (this.addChild(this._hScrollBar = new S), this._hScrollBar.on(e.Event.CHANGE, this, this.onHBarChanged), this._hScrollBar.mouseWheelEnable = !1, this._hScrollBar.target = this._tf, this.callLater(this.changeScroll)), this._hScrollBar.skin = t
            }
            onVBarChanged(t) {
                this._tf.scrollY != this._vScrollBar.value && (this._tf.scrollY = this._vScrollBar.value)
            }
            onHBarChanged(t) {
                this._tf.scrollX != this._hScrollBar.value && (this._tf.scrollX = this._hScrollBar.value)
            }
            get vScrollBar() {
                return this._vScrollBar
            }
            get hScrollBar() {
                return this._hScrollBar
            }
            get maxScrollY() {
                return this._tf.maxScrollY
            }
            get scrollY() {
                return this._tf.scrollY
            }
            get maxScrollX() {
                return this._tf.maxScrollX
            }
            get scrollX() {
                return this._tf.scrollX
            }
            changeScroll() {
                var t = this._vScrollBar && this._tf.maxScrollY > 0,
                    e = this._hScrollBar && this._tf.maxScrollX > 0,
                    s = t ? this._width - this._vScrollBar.width : this._width,
                    h = e ? this._height - this._hScrollBar.height : this._height,
                    a = this._tf.padding || i.labelPadding;
                this._tf.width = s, this._tf.height = h, this._vScrollBar && (this._vScrollBar.x = this._width - this._vScrollBar.width - a[2], this._vScrollBar.y = a[1], this._vScrollBar.height = this._height - (e ? this._hScrollBar.height : 0) - a[1] - a[3], this._vScrollBar.scrollSize = 1, this._vScrollBar.thumbPercent = h / Math.max(this._tf.textHeight, h), this._vScrollBar.setScroll(1, this._tf.maxScrollY, this._tf.scrollY), this._vScrollBar.visible = t), this._hScrollBar && (this._hScrollBar.x = a[0], this._hScrollBar.y = this._height - this._hScrollBar.height - a[3], this._hScrollBar.width = this._width - (t ? this._vScrollBar.width : 0) - a[0] - a[2], this._hScrollBar.scrollSize = Math.max(.033 * s, 1), this._hScrollBar.thumbPercent = s / Math.max(this._tf.textWidth, s), this._hScrollBar.setScroll(0, this.maxScrollX, this.scrollX), this._hScrollBar.visible = e)
            }
            scrollTo(t) {
                this.commitMeasure(), this._tf.scrollY = t
            }
        }
        e.ILaya.regClass(M), e.ClassUtils.regClass("laya.ui.TextArea", M), e.ClassUtils.regClass("Laya.TextArea", M);
        class O extends c {
            constructor() {
                super(...arguments), this._oldW = 0, this._oldH = 0
            }
            onEnable() {
                e.ILaya.stage.on("resize", this, this.onResize), this.onResize()
            }
            onDisable() {
                e.ILaya.stage.off("resize", this, this.onResize)
            }
            onResize() {
                let t = e.ILaya.stage;
                if (this.width > 0 && this.height > 0) {
                    var s = Math.min(t.width / this._oldW, t.height / this._oldH);
                    super.width = t.width, super.height = t.height, this.scale(s, s)
                }
            }
            set width(t) {
                super.width = t, this._oldW = t
            }
            get width() {
                return super.width
            }
            set height(t) {
                super.height = t, this._oldH = t
            }
            get height() {
                return super.height
            }
        }
        e.ILaya.regClass(O), e.ClassUtils.regClass("laya.ui.ScaleBox", O), e.ClassUtils.regClass("Laya.ScaleBox", O);
        class T extends m {
            constructor(t = null) {
                super(t), this.isVertical = !1
            }
        }
        e.ILaya.regClass(T), e.ClassUtils.regClass("laya.ui.HSlider", T), e.ClassUtils.regClass("Laya.HSlider", T);
        class z extends c {
            constructor() {
                super(), this._usedCache = null, this._elasticEnabled = !1, this.width = this.height = 100
            }
            destroy(t = !0) {
                super.destroy(t), this._content && this._content.destroy(t), this._vScrollBar && this._vScrollBar.destroy(t), this._hScrollBar && this._hScrollBar.destroy(t), this._vScrollBar = null, this._hScrollBar = null, this._content = null
            }
            destroyChildren() {
                this._content.destroyChildren()
            }
            createChildren() {
                super.addChild(this._content = new c)
            }
            addChild(t) {
                return t.on(e.Event.RESIZE, this, this.onResize), this._setScrollChanged(), this._content.addChild(t)
            }
            onResize() {
                this._setScrollChanged()
            }
            addChildAt(t, s) {
                return t.on(e.Event.RESIZE, this, this.onResize), this._setScrollChanged(), this._content.addChildAt(t, s)
            }
            removeChild(t) {
                return t.off(e.Event.RESIZE, this, this.onResize), this._setScrollChanged(), this._content.removeChild(t)
            }
            removeChildAt(t) {
                return this.getChildAt(t).off(e.Event.RESIZE, this, this.onResize), this._setScrollChanged(), this._content.removeChildAt(t)
            }
            removeChildren(t = 0, e = 2147483647) {
                return this._content.removeChildren(t, e), this._setScrollChanged(), this
            }
            getChildAt(t) {
                return this._content.getChildAt(t)
            }
            getChildByName(t) {
                return this._content.getChildByName(t)
            }
            getChildIndex(t) {
                return this._content.getChildIndex(t)
            }
            get numChildren() {
                return this._content.numChildren
            }
            changeScroll() {
                this._scrollChanged = !1;
                var t = this.contentWidth || 1,
                    e = this.contentHeight || 1,
                    s = this._vScrollBar,
                    i = this._hScrollBar,
                    h = s && e > this._height,
                    a = i && t > this._width,
                    r = h ? this._width - s.width : this._width,
                    l = a ? this._height - i.height : this._height;
                s && (s.x = this._width - s.width, s.y = 0, s.height = this._height - (a ? i.height : 0), s.scrollSize = Math.max(.033 * this._height, 1), s.thumbPercent = l / e, s.setScroll(0, e - l, s.value)), i && (i.x = 0, i.y = this._height - i.height, i.width = this._width - (h ? s.width : 0), i.scrollSize = Math.max(.033 * this._width, 1), i.thumbPercent = r / t, i.setScroll(0, t - r, i.value))
            }
            _sizeChanged() {
                super._sizeChanged(), this.setContentSize(this._width, this._height)
            }
            get contentWidth() {
                for (var t = 0, e = this._content.numChildren - 1; e > -1; e--) {
                    var s = this._content.getChildAt(e);
                    t = Math.max(s._x + s.width * s.scaleX - s.pivotX, t)
                }
                return t
            }
            get contentHeight() {
                for (var t = 0, e = this._content.numChildren - 1; e > -1; e--) {
                    var s = this._content.getChildAt(e);
                    t = Math.max(s._y + s.height * s.scaleY - s.pivotY, t)
                }
                return t
            }
            setContentSize(t, s) {
                var i = this._content;
                i.width = t, i.height = s, i._style.scrollRect || (i.scrollRect = e.Rectangle.create()), i._style.scrollRect.setTo(0, 0, t, s), i.scrollRect = i.scrollRect
            }
            set width(t) {
                super.width = t, this._setScrollChanged()
            }
            get width() {
                return super.width
            }
            set height(t) {
                super.height = t, this._setScrollChanged()
            }
            get height() {
                return super.height
            }
            get vScrollBarSkin() {
                return this._vScrollBar ? this._vScrollBar.skin : null
            }
            set vScrollBarSkin(t) {
                null == this._vScrollBar && (super.addChild(this._vScrollBar = new f), this._vScrollBar.on(e.Event.CHANGE, this, this.onScrollBarChange, [this._vScrollBar]), this._vScrollBar.target = this._content, this._vScrollBar.elasticDistance = this._elasticEnabled ? 200 : 0, this._setScrollChanged()), this._vScrollBar.skin = t
            }
            get hScrollBarSkin() {
                return this._hScrollBar ? this._hScrollBar.skin : null
            }
            set hScrollBarSkin(t) {
                null == this._hScrollBar && (super.addChild(this._hScrollBar = new S), this._hScrollBar.on(e.Event.CHANGE, this, this.onScrollBarChange, [this._hScrollBar]), this._hScrollBar.target = this._content, this._hScrollBar.elasticDistance = this._elasticEnabled ? 200 : 0, this._setScrollChanged()), this._hScrollBar.skin = t
            }
            get vScrollBar() {
                return this._vScrollBar
            }
            get hScrollBar() {
                return this._hScrollBar
            }
            get content() {
                return this._content
            }
            onScrollBarChange(t) {
                var e = this._content._style.scrollRect;
                if (e) {
                    var s = Math.round(t.value);
                    t.isVertical ? e.y = s : e.x = s, this._content.scrollRect = e
                }
            }
            scrollTo(t = 0, e = 0) {
                this.vScrollBar && (this.vScrollBar.value = e), this.hScrollBar && (this.hScrollBar.value = t)
            }
            refresh() {
                this.changeScroll()
            }
            set cacheAs(t) {
                super.cacheAs = t, this._usedCache = null, "none" !== t ? (this._hScrollBar && this._hScrollBar.on(e.Event.START, this, this.onScrollStart), this._vScrollBar && this._vScrollBar.on(e.Event.START, this, this.onScrollStart)) : (this._hScrollBar && this._hScrollBar.off(e.Event.START, this, this.onScrollStart), this._vScrollBar && this._vScrollBar.off(e.Event.START, this, this.onScrollStart))
            }
            get cacheAs() {
                return super.cacheAs
            }
            get elasticEnabled() {
                return this._elasticEnabled
            }
            set elasticEnabled(t) {
                this._elasticEnabled = t, this._vScrollBar && (this._vScrollBar.elasticDistance = t ? 200 : 0), this._hScrollBar && (this._hScrollBar.elasticDistance = t ? 200 : 0)
            }
            onScrollStart() {
                this._usedCache || (this._usedCache = super.cacheAs), super.cacheAs = "none", this._hScrollBar && this._hScrollBar.once(e.Event.END, this, this.onScrollEnd), this._vScrollBar && this._vScrollBar.once(e.Event.END, this, this.onScrollEnd)
            }
            onScrollEnd() {
                super.cacheAs = this._usedCache
            }
            _setScrollChanged() {
                this._scrollChanged || (this._scrollChanged = !0, this.callLater(this.changeScroll))
            }
        }
        e.ILaya.regClass(z), e.ClassUtils.regClass("laya.ui.Panel", z), e.ClassUtils.regClass("Laya.Panel", z);
        class U extends m {}
        e.ILaya.regClass(U), e.ClassUtils.regClass("laya.ui.VSlider", U), e.ClassUtils.regClass("Laya.VSlider", U);
        class D extends c {
            constructor() {
                super(), this._spaceLeft = 10, this._spaceBottom = 0, this._keepStatus = !0, this.width = this.height = 200
            }
            destroy(t = !0) {
                super.destroy(t), this._list && this._list.destroy(t), this._list = null, this._source = null, this._renderHandler = null
            }
            createChildren() {
                this.addChild(this._list = new y), this._list.renderHandler = e.Handler.create(this, this.renderItem, null, !1), this._list.repeatX = 1, this._list.on(e.Event.CHANGE, this, this.onListChange)
            }
            onListChange(t = null) {
                this.event(e.Event.CHANGE)
            }
            get keepStatus() {
                return this._keepStatus
            }
            set keepStatus(t) {
                this._keepStatus = t
            }
            get array() {
                return this._list.array
            }
            set array(t) {
                this._keepStatus && this._list.array && t && this.parseOpenStatus(this._list.array, t), this._source = t, this._list.array = this.getArray()
            }
            get source() {
                return this._source
            }
            get list() {
                return this._list
            }
            get itemRender() {
                return this._list.itemRender
            }
            set itemRender(t) {
                this._list.itemRender = t
            }
            get scrollBarSkin() {
                return this._list.vScrollBarSkin
            }
            set scrollBarSkin(t) {
                this._list.vScrollBarSkin = t
            }
            get scrollBar() {
                return this._list.scrollBar
            }
            get mouseHandler() {
                return this._list.mouseHandler
            }
            set mouseHandler(t) {
                this._list.mouseHandler = t
            }
            get renderHandler() {
                return this._renderHandler
            }
            set renderHandler(t) {
                this._renderHandler = t
            }
            get spaceLeft() {
                return this._spaceLeft
            }
            set spaceLeft(t) {
                this._spaceLeft = t
            }
            get spaceBottom() {
                return this._list.spaceY
            }
            set spaceBottom(t) {
                this._list.spaceY = t
            }
            get selectedIndex() {
                return this._list.selectedIndex
            }
            set selectedIndex(t) {
                this._list.selectedIndex = t
            }
            get selectedItem() {
                return this._list.selectedItem
            }
            set selectedItem(t) {
                this._list.selectedItem = t
            }
            set width(t) {
                super.width = t, this._list.width = t
            }
            get width() {
                return super.width
            }
            set height(t) {
                super.height = t, this._list.height = t
            }
            get height() {
                return super.height
            }
            getArray() {
                var t = [];
                for (let e in this._source) {
                    let s = this._source[e];
                    this.getParentOpenStatus(s) && (s.x = this._spaceLeft * this.getDepth(s), t.push(s))
                }
                return t
            }
            getDepth(t, e = 0) {
                return null == t.nodeParent ? e : this.getDepth(t.nodeParent, e + 1)
            }
            getParentOpenStatus(t) {
                var e = t.nodeParent;
                return null == e || !!e.isOpen && (null == e.nodeParent || this.getParentOpenStatus(e))
            }
            renderItem(t, s) {
                var i = t.dataSource;
                if (i) {
                    t.left = i.x;
                    var h = t.getChildByName("arrow");
                    h && (i.hasChild ? (h.visible = !0, h.index = i.isOpen ? 1 : 0, h.tag = s, h.off(e.Event.CLICK, this, this.onArrowClick), h.on(e.Event.CLICK, this, this.onArrowClick)) : h.visible = !1);
                    var a = t.getChildByName("folder");
                    a && (2 == a.clipY ? a.index = i.isDirectory ? 0 : 1 : a.index = i.isDirectory ? i.isOpen ? 1 : 0 : 2), this._renderHandler && this._renderHandler.runWith([t, s])
                }
            }
            onArrowClick(t) {
                var s = t.currentTarget.tag;
                this._list.array[s].isOpen = !this._list.array[s].isOpen, this.event(e.Event.OPEN), this._list.array = this.getArray()
            }
            setItemState(t, e) {
                this._list.array[t] && (this._list.array[t].isOpen = e, this._list.array = this.getArray())
            }
            fresh() {
                this._list.array = this.getArray(), this.repaint()
            }
            set dataSource(t) {
                this._dataSource = t, super.dataSource = t
            }
            get dataSource() {
                return super.dataSource
            }
            set xml(t) {
                var e = [];
                this.parseXml(t.childNodes[0], e, null, !0), this.array = e
            }
            parseXml(t, e, s, i) {
                var h, a = t.childNodes,
                    r = a.length;
                if (!i) {
                    h = {};
                    var l = t.attributes;
                    for (let t in l) {
                        var n = l[t],
                            o = n.nodeName,
                            _ = n.nodeValue;
                        h[o] = "true" == _ || "false" != _ && _
                    }
                    h.nodeParent = s, r > 0 && (h.isDirectory = !0), h.hasChild = r > 0, e.push(h)
                }
                for (var c = 0; c < r; c++) {
                    var d = a[c];
                    this.parseXml(d, e, h, !1)
                }
            }
            parseOpenStatus(t, e) {
                for (var s = 0, i = e.length; s < i; s++) {
                    var h = e[s];
                    if (h.isDirectory)
                        for (var a = 0, r = t.length; a < r; a++) {
                            var l = t[a];
                            if (l.isDirectory && this.isSameParent(l, h) && h.label == l.label) {
                                h.isOpen = l.isOpen;
                                break
                            }
                        }
                }
            }
            isSameParent(t, e) {
                return null == t.nodeParent && null == e.nodeParent || null != t.nodeParent && null != e.nodeParent && (t.nodeParent.label == e.nodeParent.label && this.isSameParent(t.nodeParent, e.nodeParent))
            }
            get selectedPath() {
                return this._list.selectedItem ? this._list.selectedItem.path : null
            }
            filter(t) {
                if (Boolean(t)) {
                    var e = [];
                    this.getFilterSource(this._source, e, t), this._list.array = e
                } else this._list.array = this.getArray()
            }
            getFilterSource(t, e, s) {
                s = s.toLocaleLowerCase();
                for (let i of t) !i.isDirectory && String(i.label).toLowerCase().indexOf(s) > -1 && (i.x = 0, e.push(i)), i.child && i.child.length > 0 && this.getFilterSource(i.child, e, s)
            }
        }
        e.ILaya.regClass(D), e.ClassUtils.regClass("laya.ui.Tree", D), e.ClassUtils.regClass("Laya.Tree", D);
        class H extends c {
            constructor() {
                super(...arguments), this._space = 0, this._align = "none", this._itemChanged = !1
            }
            addChild(t) {
                return t.on(e.Event.RESIZE, this, this.onResize), t.on(e.Event.VISIBLE, this, this.onResize), this._setItemChanged(), super.addChild(t)
            }
            onResize(t) {
                this._setItemChanged()
            }
            addChildAt(t, s) {
                return t.on(e.Event.RESIZE, this, this.onResize), t.on(e.Event.VISIBLE, this, this.onResize), this._setItemChanged(), super.addChildAt(t, s)
            }
            removeChildAt(t) {
                let s = this.getChildAt(t);
                return s.off(e.Event.RESIZE, this, this.onResize), s.off(e.Event.VISIBLE, this, this.onResize), this._setItemChanged(), super.removeChildAt(t)
            }
            refresh() {
                this._setItemChanged()
            }
            changeItems() {
                this._itemChanged = !1
            }
            get space() {
                return this._space
            }
            set space(t) {
                this._space = t, this._setItemChanged()
            }
            get align() {
                return this._align
            }
            set align(t) {
                this._align = t, this._setItemChanged()
            }
            sortItem(t) {
                t && t.sort((function(t, e) {
                    return t.y - e.y
                }))
            }
            _setItemChanged() {
                this._itemChanged || (this._itemChanged = !0, this.callLater(this.changeItems))
            }
        }
        e.ILaya.regClass(H), e.ClassUtils.regClass("laya.ui.LayoutBox", H), e.ClassUtils.regClass("Laya.LayoutBox", H);
        class A extends H {
            sortItem(t) {
                t && t.sort((function(t, e) {
                    return t.x - e.x
                }))
            }
            set height(t) {
                this._height != t && (super.height = t, this.callLater(this.changeItems))
            }
            get height() {
                return super.height
            }
            changeItems() {
                this._itemChanged = !1;
                for (var t = [], e = 0, s = 0, i = this.numChildren; s < i; s++) {
                    var h = this.getChildAt(s);
                    if (h) {
                        if (null != h.visible && 0 == h.visible) continue;
                        t.push(h), e = Math.max(e, h.height * h.scaleY)
                    }
                }
                this.sortItem(t);
                var a = 0;
                for (s = 0, i = t.length; s < i; s++) h = t[s], s && (a += t[s - 1].width * t[s - 1].scaleX + this._space), h.left = a, this._align == A.TOP ? h.y = 0 : this._align == A.MIDDLE ? h.y = .5 * (e - h.height * h.scaleY) : this._align == A.BOTTOM && (h.y = e - h.height * h.scaleY), h.pivotY && (h.y += h.pivotY * h.scaleY);
                this._sizeChanged()
            }
        }
        A.NONE = "none", A.TOP = "top", A.MIDDLE = "middle", A.BOTTOM = "bottom", e.ILaya.regClass(A), e.ClassUtils.regClass("laya.ui.HBox", A), e.ClassUtils.regClass("Laya.HBox", A);
        class N extends H {
            constructor() {
                super(...arguments), this.isSortItem = !1
            }
            set width(t) {
                this._width != t && (super.width = t, this.callLater(this.changeItems))
            }
            get width() {
                return super.width
            }
            changeItems() {
                this._itemChanged = !1;
                for (var t = [], e = 0, s = 0, i = this.numChildren; s < i; s++) {
                    var h = this.getChildAt(s);
                    h && (t.push(h), e = Math.max(e, h.width * h.scaleX))
                }
                this.isSortItem && this.sortItem(t);
                var a = 0;
                for (s = 0, i = t.length; s < i; s++) h = t[s], s && (a += t[s - 1].height * t[s - 1].scaleX + this._space), h.top = a, this._align == N.LEFT ? h.x = 0 : this._align == N.CENTER ? h.x = .5 * (e - h.width * h.scaleX) : this._align == N.RIGHT && (h.x = e - h.width * h.scaleX), h.pivotX && (h.x += h.pivotX * h.scaleX);
                this._sizeChanged()
            }
        }
        N.NONE = "none", N.LEFT = "left", N.CENTER = "center", N.RIGHT = "right", e.ILaya.regClass(N), e.ClassUtils.regClass("laya.ui.VBox", N), e.ClassUtils.regClass("Laya.VBox", N);
        class P extends g {
            constructor(t = null, e = null) {
                super(), this._valueArr = "", this._indexMap = null, this._sheet = null, this._direction = "horizontal", this._spaceX = 0, this._spaceY = 0, this._align = "left", this._wordsW = 0, this._wordsH = 0, t && (this.skin = t), e && (this.sheet = e)
            }
            createChildren() {
                this._bitmap = new h, this.on(e.Event.LOADED, this, this._onClipLoaded)
            }
            _onClipLoaded() {
                this.callLater(this.changeValue)
            }
            get sheet() {
                return this._sheet
            }
            set sheet(t) {
                t += "", this._sheet = t;
                var e = t.split(" ");
                this._clipX = String(e[0]).length, this.clipY = e.length, this._indexMap = {};
                for (var s = 0; s < this._clipY; s++)
                    for (var i = e[s].split(""), h = 0, a = i.length; h < a; h++) this._indexMap[i[h]] = s * this._clipX + h
            }
            get value() {
                return this._valueArr ? this._valueArr : ""
            }
            set value(t) {
                t += "", this._valueArr = t, this.callLater(this.changeValue)
            }
            get direction() {
                return this._direction
            }
            set direction(t) {
                this._direction = t, this.callLater(this.changeValue)
            }
            get spaceX() {
                return this._spaceX
            }
            set spaceX(t) {
                this._spaceX = t, "horizontal" === this._direction && this.callLater(this.changeValue)
            }
            get spaceY() {
                return this._spaceY
            }
            set spaceY(t) {
                this._spaceY = t, "horizontal" !== this._direction && this.callLater(this.changeValue)
            }
            set align(t) {
                this._align = t, this.callLater(this.changeValue)
            }
            get align() {
                return this._align
            }
            changeValue() {
                var t;
                if (this._sources && (this._valueArr && (this.graphics.clear(!0), t = this._sources[0]))) {
                    var e = "horizontal" === this._direction;
                    e ? (this._wordsW = this._valueArr.length * (t.sourceWidth + this.spaceX), this._wordsH = t.sourceHeight) : (this._wordsW = t.sourceWidth, this._wordsH = (t.sourceHeight + this.spaceY) * this._valueArr.length);
                    var s = 0;
                    if (this._width) switch (this._align) {
                        case "center":
                            s = .5 * (this._width - this._wordsW);
                            break;
                        case "right":
                            s = this._width - this._wordsW;
                            break;
                        default:
                            s = 0
                    }
                    for (var i = 0, h = this._valueArr.length; i < h; i++) {
                        var a = this._indexMap[this._valueArr.charAt(i)];
                        this.sources[a] && (t = this.sources[a], e ? this.graphics.drawImage(t, s + i * (t.sourceWidth + this.spaceX), 0, t.sourceWidth, t.sourceHeight) : this.graphics.drawImage(t, 0 + s, i * (t.sourceHeight + this.spaceY), t.sourceWidth, t.sourceHeight))
                    }
                    this._width || (this._widget.resetLayoutX(), this.callLater(this._sizeChanged)), this._height || (this._widget.resetLayoutY(), this.callLater(this._sizeChanged))
                }
            }
            set width(t) {
                super.width = t, this.callLater(this.changeValue)
            }
            get width() {
                return super.width
            }
            set height(t) {
                super.height = t, this.callLater(this.changeValue)
            }
            get height() {
                return super.height
            }
            measureWidth() {
                return this._wordsW
            }
            measureHeight() {
                return this._wordsH
            }
            destroy(t = !0) {
                this._valueArr = null, this._indexMap = null, this.graphics.clear(!0), this.removeSelf(), this.off(e.Event.LOADED, this, this._onClipLoaded), super.destroy(t)
            }
        }
        e.ILaya.regClass(P), e.ClassUtils.regClass("laya.ui.FontClip", P), e.ClassUtils.regClass("Laya.FontClip", P);
        class Y extends e.Scene {
            constructor() {
                super(!1), this._watchMap = {}, this._anchorX = NaN, this._anchorY = NaN, this._widget = a.EMPTY, this.createChildren()
            }
            static __init__() {
                e.ILaya.ClassUtils.regShortClassName([B, d, M, p, c, O, u, g, b, n, S, T, o, C, y, z, w, x, E, v, m, I, k, Y, f, U, D, A, N, e.Animation, e.Text, P])
            }
            static regComponent(t, s) {
                e.ILaya.ClassUtils.regClass(t, s)
            }
            static regViewRuntime(t, s) {
                e.ILaya.ClassUtils.regClass(t, s)
            }
            static regUI(t, s) {
                e.ILaya.loader.cacheRes(t, s)
            }
            destroy(t = !0) {
                this._watchMap = null, super.destroy(t)
            }
            changeData(t) {
                var e = this._watchMap[t];
                if (e)
                    for (var s = 0, i = e.length; s < i; s++) {
                        e[s].exe(this)
                    }
            }
            get top() {
                return this._widget.top
            }
            set top(t) {
                t != this._widget.top && (this._getWidget().top = t)
            }
            get bottom() {
                return this._widget.bottom
            }
            set bottom(t) {
                t != this._widget.bottom && (this._getWidget().bottom = t)
            }
            get left() {
                return this._widget.left
            }
            set left(t) {
                t != this._widget.left && (this._getWidget().left = t)
            }
            get right() {
                return this._widget.right
            }
            set right(t) {
                t != this._widget.right && (this._getWidget().right = t)
            }
            get centerX() {
                return this._widget.centerX
            }
            set centerX(t) {
                t != this._widget.centerX && (this._getWidget().centerX = t)
            }
            get centerY() {
                return this._widget.centerY
            }
            set centerY(t) {
                t != this._widget.centerY && (this._getWidget().centerY = t)
            }
            get anchorX() {
                return this._anchorX
            }
            set anchorX(t) {
                this._anchorX != t && (this._anchorX = t, this.callLater(this._sizeChanged))
            }
            get anchorY() {
                return this._anchorY
            }
            set anchorY(t) {
                this._anchorY != t && (this._anchorY = t, this.callLater(this._sizeChanged))
            }
            _sizeChanged() {
                isNaN(this._anchorX) || (this.pivotX = this.anchorX * this.width), isNaN(this._anchorY) || (this.pivotY = this.anchorY * this.height), this.event(e.Event.RESIZE)
            }
            _getWidget() {
                return this._widget === a.EMPTY && (this._widget = this.addComponent(a)), this._widget
            }
            loadUI(t) {
                var e = Y.uiMap[t];
                Y.uiMap && this.createView(e)
            }
            get dataSource() {
                return this._dataSource
            }
            set dataSource(t) {
                for (var e in this._dataSource = t, t) {
                    var s = this.getChildByName(e);
                    s instanceof n ? s.dataSource = t[e] : !(e in this) || this[e] instanceof Function || (this[e] = t[e])
                }
            }
        }
        Y.uiMap = {}, e.ILaya.regClass(Y), e.ClassUtils.regClass("laya.ui.View", Y), e.ClassUtils.regClass("Laya.View", Y);
        class X {}
        class R extends e.Sprite {
            constructor() {
                super(), this.maskLayer = new e.Sprite, this.popupEffect = t => {
                    t.scale(1, 1), t._effectTween = e.Tween.from(t, {
                        x: e.ILaya.stage.width / 2,
                        y: e.ILaya.stage.height / 2,
                        scaleX: 0,
                        scaleY: 0
                    }, 300, e.Ease.backOut, e.Handler.create(this, this.doOpen, [t]), 0, !1, !1)
                }, this.closeEffect = t => {
                    t._effectTween = e.Tween.to(t, {
                        x: e.ILaya.stage.width / 2,
                        y: e.ILaya.stage.height / 2,
                        scaleX: 0,
                        scaleY: 0
                    }, 300, e.Ease.strongOut, e.Handler.create(this, this.doClose, [t]), 0, !1, !1)
                }, this.popupEffectHandler = new e.Handler(this, this.popupEffect), this.closeEffectHandler = new e.Handler(this, this.closeEffect), this.mouseEnabled = this.maskLayer.mouseEnabled = !0, this.zOrder = 1e3, e.ILaya.stage.addChild(this), e.ILaya.stage.on(e.Event.RESIZE, this, this._onResize), s.closeDialogOnSide && this.maskLayer.on("click", this, this._closeOnSide), this._onResize(null)
            }
            _closeOnSide() {
                var t = this.getChildAt(this.numChildren - 1);
                t instanceof X.Dialog && t.close("closeOnSide")
            }
            setLockView(t) {
                this.lockLayer || (this.lockLayer = new c, this.lockLayer.mouseEnabled = !0, this.lockLayer.size(e.ILaya.stage.width, e.ILaya.stage.height)), this.lockLayer.removeChildren(), t && (t.centerX = t.centerY = 0, this.lockLayer.addChild(t))
            }
            _onResize(t = null) {
                var i = this.maskLayer.width = e.ILaya.stage.width,
                    h = this.maskLayer.height = e.ILaya.stage.height;
                this.lockLayer && this.lockLayer.size(i, h), this.maskLayer.graphics.clear(!0), this.maskLayer.graphics.drawRect(0, 0, i, h, s.popupBgColor), this.maskLayer.alpha = s.popupBgAlpha;
                for (var a = this.numChildren - 1; a > -1; a--) {
                    var r = this.getChildAt(a);
                    r.isPopupCenter && this._centerDialog(r)
                }
            }
            _centerDialog(t) {
                t.x = Math.round((e.ILaya.stage.width - t.width >> 1) + t.pivotX), t.y = Math.round((e.ILaya.stage.height - t.height >> 1) + t.pivotY)
            }
            open(t, s = !1, i = !1) {
                s && this._closeAll(), this._clearDialogEffect(t), t.isPopupCenter && this._centerDialog(t), this.addChild(t), e.ILaya.timer.callLater(this, this._checkMask), i && null != t.popupEffect ? t.popupEffect.runWith(t) : this.doOpen(t), this.event(e.Event.OPEN)
            }
            _clearDialogEffect(t) {
                t._effectTween && (e.Tween.clear(t._effectTween), t._effectTween = null)
            }
            doOpen(t) {
                t.onOpened(t._param)
            }
            lock(t) {
                this.lockLayer && (t ? this.addChild(this.lockLayer) : this.lockLayer.removeSelf())
            }
            close(t) {
                this._clearDialogEffect(t), t.isShowEffect && null != t.closeEffect ? t.closeEffect.runWith([t]) : this.doClose(t), this.event(e.Event.CLOSE)
            }
            doClose(t) {
                t.removeSelf(), this._checkMask(), t.closeHandler && t.closeHandler.runWith(t.closeType), t.onClosed(t.closeType), t.autoDestroyAtClosed && t.destroy()
            }
            closeAll() {
                this._closeAll(), this.event(e.Event.CLOSE)
            }
            _closeAll() {
                for (var t = this.numChildren - 1; t > -1; t--) {
                    var e = this.getChildAt(t);
                    e && null != e.close && (e instanceof X.Dialog ? e.close("closeOnSide") : this.doClose(e))
                }
            }
            getDialogsByGroup(t) {
                for (var e = [], s = this.numChildren - 1; s > -1; s--) {
                    var i = this.getChildAt(s);
                    i && i.group === t && e.push(i)
                }
                return e
            }
            closeByGroup(t) {
                for (var e = [], s = this.numChildren - 1; s > -1; s--) {
                    var i = this.getChildAt(s);
                    i && i.group === t && (i.close(), e.push(i))
                }
                return e
            }
            _checkMask() {
                this.maskLayer.removeSelf();
                for (var t = this.numChildren - 1; t > -1; t--) {
                    if (this.getChildAt(t)) return void this.addChildAt(this.maskLayer, t)
                }
            }
        }
        e.ClassUtils.regClass("laya.ui.DialogManager", R), e.ClassUtils.regClass("Laya.DialogManager", R);
        class G extends Y {
            constructor() {
                super(), this.isShowEffect = !0, this.isPopupCenter = !0, this.popupEffect = G.manager.popupEffectHandler, this.closeEffect = G.manager.closeEffectHandler, this._dealDragArea(), this.on(e.Event.CLICK, this, this._onClick)
            }
            static get manager() {
                return G._manager = G._manager || new R
            }
            static set manager(t) {
                G._manager = t
            }
            _dealDragArea() {
                var t = this.getChildByName("drag");
                t && (this.dragArea = t._x + "," + t._y + "," + t.width + "," + t.height, t.removeSelf())
            }
            get dragArea() {
                return this._dragArea ? this._dragArea.toString() : null
            }
            set dragArea(t) {
                if (t) {
                    var s = l.fillArray([0, 0, 0, 0], t, Number);
                    this._dragArea = new e.Rectangle(s[0], s[1], s[2], s[3]), this.on(e.Event.MOUSE_DOWN, this, this._onMouseDown)
                } else this._dragArea = null, this.off(e.Event.MOUSE_DOWN, this, this._onMouseDown)
            }
            _onMouseDown(t) {
                var e = this.getMousePoint();
                this._dragArea.contains(e.x, e.y) ? this.startDrag() : this.stopDrag()
            }
            _onClick(t) {
                var e = t.target;
                if (e) switch (e.name) {
                    case G.CLOSE:
                    case G.CANCEL:
                    case G.SURE:
                    case G.NO:
                    case G.OK:
                    case G.YES:
                        return void this.close(e.name)
                }
            }
            open(t = !0, e = null) {
                this._dealDragArea(), this._param = e, G.manager.open(this, t, this.isShowEffect), G.manager.lock(!1)
            }
            close(t = null) {
                this.closeType = t, G.manager.close(this)
            }
            destroy(t = !0) {
                this.closeHandler = null, this.popupEffect = null, this.closeEffect = null, this._dragArea = null, super.destroy(t)
            }
            show(t = !1, e = !0) {
                this._open(!1, t, e)
            }
            popup(t = !1, e = !0) {
                this._open(!0, t, e)
            }
            _open(t, e, s) {
                this.isModal = t, this.isShowEffect = s, G.manager.lock(!0), this.open(e)
            }
            get isPopup() {
                return null != this.parent
            }
            set zOrder(t) {
                super.zOrder = t, G.manager._checkMask()
            }
            get zOrder() {
                return super.zOrder
            }
            static setLockView(t) {
                G.manager.setLockView(t)
            }
            static lock(t) {
                G.manager.lock(t)
            }
            static closeAll() {
                G.manager.closeAll()
            }
            static getDialogsByGroup(t) {
                return G.manager.getDialogsByGroup(t)
            }
            static closeByGroup(t) {
                return G.manager.closeByGroup(t)
            }
        }
        G.CLOSE = "close", G.CANCEL = "cancel", G.SURE = "sure", G.NO = "no", G.YES = "yes", G.OK = "ok", X.Dialog = G, e.ILaya.regClass(G), e.ClassUtils.regClass("laya.ui.Dialog", G), e.ClassUtils.regClass("Laya.Dialog", G);
        class W extends n {
            constructor() {
                super(), this._tipBox = new n, this._tipBox.addChild(this._tipText = new e.Text), this._tipText.x = this._tipText.y = 5, this._tipText.color = W.tipTextColor, this._defaultTipHandler = this._showDefaultTip, e.ILaya.stage.on(r.SHOW_TIP, this, this._onStageShowTip), e.ILaya.stage.on(r.HIDE_TIP, this, this._onStageHideTip), this.zOrder = 1100
            }
            _onStageHideTip(t) {
                e.ILaya.timer.clear(this, this._showTip), this.closeAll(), this.removeSelf()
            }
            _onStageShowTip(t) {
                e.ILaya.timer.once(W.tipDelay, this, this._showTip, [t], !0)
            }
            _showTip(t) {
                if ("string" == typeof t) {
                    var s = String(t);
                    Boolean(s) && this._defaultTipHandler(s)
                } else t instanceof e.Handler ? t.run() : t instanceof Function && t.apply();
                e.ILaya.stage.on(e.Event.MOUSE_MOVE, this, this._onStageMouseMove), e.ILaya.stage.on(e.Event.MOUSE_DOWN, this, this._onStageMouseDown), this._onStageMouseMove(null)
            }
            _onStageMouseDown(t) {
                this.closeAll()
            }
            _onStageMouseMove(t) {
                this._showToStage(this, W.offsetX, W.offsetY)
            }
            _showToStage(t, s = 0, i = 0) {
                var h = t.getBounds();
                t.x = e.ILaya.stage.mouseX + s, t.y = e.ILaya.stage.mouseY + i, t._x + h.width > e.ILaya.stage.width && (t.x -= h.width + s), t._y + h.height > e.ILaya.stage.height && (t.y -= h.height + i)
            }
            closeAll() {
                e.ILaya.timer.clear(this, this._showTip), e.ILaya.stage.off(e.Event.MOUSE_MOVE, this, this._onStageMouseMove), e.ILaya.stage.off(e.Event.MOUSE_DOWN, this, this._onStageMouseDown), this.removeChildren()
            }
            showDislayTip(t) {
                this.addChild(t), this._showToStage(this), e.ILaya.stage.addChild(this)
            }
            _showDefaultTip(t) {
                this._tipText.text = t;
                var s = this._tipBox.graphics;
                s.clear(!0), s.drawRect(0, 0, this._tipText.width + 10, this._tipText.height + 10, W.tipBackColor), this.addChild(this._tipBox), this._showToStage(this), e.ILaya.stage.addChild(this)
            }
            get defaultTipHandler() {
                return this._defaultTipHandler
            }
            set defaultTipHandler(t) {
                this._defaultTipHandler = t
            }
        }
        W.offsetX = 10, W.offsetY = 15, W.tipTextColor = "#ffffff", W.tipBackColor = "#111111", W.tipDelay = 200, e.ILaya.regClass(W), e.ClassUtils.regClass("laya.ui.TipManager", W), e.ClassUtils.regClass("Laya.TipManager", W);
        class V extends n {
            constructor() {
                super(), this._width = this._height = 200;
                var t = new e.Texture;
                t.bitmap = new e.Texture2D, this.texture = t
            }
            onEnable() {
                this.postMsg({
                    type: "display",
                    rate: e.Laya.stage.frameRate
                }), window.wx && window.sharedCanvas && e.Laya.timer.frameLoop(1, this, this._onLoop)
            }
            onDisable() {
                this.postMsg({
                    type: "undisplay"
                }), e.Laya.timer.clear(this, this._onLoop)
            }
            _onLoop() {
                let t = window.sharedCanvas;
                this.texture.sourceWidth = t.width, this.texture.sourceHeight = t.height, this.texture.bitmap.loadImageSource(t, !0)
            }
            set width(t) {
                super.width = t, window.sharedCanvas && (window.sharedCanvas.width = t), this.callLater(this._postMsg)
            }
            get width() {
                return super.width
            }
            set height(t) {
                super.height = t, window.sharedCanvas && (window.sharedCanvas.height = t), this.callLater(this._postMsg)
            }
            get height() {
                return super.height
            }
            set x(t) {
                super.x = t, this.callLater(this._postMsg)
            }
            get x() {
                return super.x
            }
            set y(t) {
                super.y = t, this.callLater(this._postMsg)
            }
            get y() {
                return super.y
            }
            _postMsg() {
                var t = new e.Matrix;
                t.translate(this.x, this.y);
                var s = e.Laya.stage;
                t.scale(s._canvasTransform.getScaleX() * this.globalScaleX * s.transform.getScaleX(), s._canvasTransform.getScaleY() * this.globalScaleY * s.transform.getScaleY()), this.postMsg({
                    type: "changeMatrix",
                    a: t.a,
                    b: t.b,
                    c: t.c,
                    d: t.d,
                    tx: t.tx,
                    ty: t.ty,
                    w: this.width,
                    h: this.height
                })
            }
            postMsg(t) {
                window.wx && window.wx.getOpenDataContext && window.wx.getOpenDataContext().postMessage(t)
            }
        }
        e.ILaya.regClass(V), e.ClassUtils.regClass("laya.ui.WXOpenDataViewer", V), e.ClassUtils.regClass("Laya.WXOpenDataViewer", V), t.AdvImage = _, t.AutoBitmap = h, t.Box = c, t.Button = d, t.CheckBox = u, t.Clip = g, t.ColorPicker = p, t.ComboBox = b, t.Dialog = G, t.DialogManager = R, t.FontClip = P, t.HBox = A, t.HScrollBar = S, t.HSlider = T, t.IUI = X, t.Image = o, t.Label = C, t.LayoutBox = H, t.List = y, t.Panel = z, t.ProgressBar = w, t.Radio = x, t.RadioGroup = E, t.ScaleBox = O, t.ScrollBar = v, t.Slider = m, t.Styles = i, t.Tab = I, t.TextArea = M, t.TextInput = k, t.TipManager = W, t.Tree = D, t.UIComponent = n, t.UIConfig = s, t.UIEvent = r, t.UIGroup = L, t.UILib = class {
            static __init__() {}
        }, t.UIUtils = l, t.VBox = N, t.VScrollBar = f, t.VSlider = U, t.View = Y, t.ViewStack = B, t.WXOpenDataViewer = V, t.Widget = a
    }(window.Laya = window.Laya || {}, Laya);
});
define("libs/min/matter.min.js", function(require, module, exports) {
    /*!
     * matter-js 0.18.0 by @liabru
     * http://brm.io/matter-js/
     * License MIT
     *
     * The MIT License (MIT)
     *
     * Copyright (c) Liam Brummitt and contributors.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    ! function(e, t) {
        "object" == typeof exports && "object" == typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define("Matter", [], t) : "object" == typeof exports ? exports.Matter = t() : e.Matter = t()
    }(this, (function() {
        return function(e) {
            var t = {};

            function __webpack_require__(n) {
                if (t[n]) return t[n].exports;
                var i = t[n] = {
                    i: n,
                    l: !1,
                    exports: {}
                };
                return e[n].call(i.exports, i, i.exports, __webpack_require__), i.l = !0, i.exports
            }
            return __webpack_require__.m = e, __webpack_require__.c = t, __webpack_require__.d = function(e, t, n) {
                __webpack_require__.o(e, t) || Object.defineProperty(e, t, {
                    enumerable: !0,
                    get: n
                })
            }, __webpack_require__.r = function(e) {
                "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
                    value: "Module"
                }), Object.defineProperty(e, "__esModule", {
                    value: !0
                })
            }, __webpack_require__.t = function(e, t) {
                if (1 & t && (e = __webpack_require__(e)), 8 & t) return e;
                if (4 & t && "object" == typeof e && e && e.__esModule) return e;
                var n = Object.create(null);
                if (__webpack_require__.r(n), Object.defineProperty(n, "default", {
                        enumerable: !0,
                        value: e
                    }), 2 & t && "string" != typeof e)
                    for (var i in e) __webpack_require__.d(n, i, function(t) {
                        return e[t]
                    }.bind(null, i));
                return n
            }, __webpack_require__.n = function(e) {
                var t = e && e.__esModule ? function() {
                    return e.default
                } : function() {
                    return e
                };
                return __webpack_require__.d(t, "a", t), t
            }, __webpack_require__.o = function(e, t) {
                return Object.prototype.hasOwnProperty.call(e, t)
            }, __webpack_require__.p = "", __webpack_require__(__webpack_require__.s = 21)
        }([function(e, t) {
            var n = {};
            e.exports = n,
                function() {
                    n._nextId = 0, n._seed = 0, n._nowStartTime = +new Date, n._warnedOnce = {}, n._decomp = null, n.extend = function(e, t) {
                        var i, o;
                        "boolean" == typeof t ? (i = 2, o = t) : (i = 1, o = !0);
                        for (var r = i; r < arguments.length; r++) {
                            var a = arguments[r];
                            if (a)
                                for (var s in a) o && a[s] && a[s].constructor === Object ? e[s] && e[s].constructor !== Object ? e[s] = a[s] : (e[s] = e[s] || {}, n.extend(e[s], o, a[s])) : e[s] = a[s]
                        }
                        return e
                    }, n.clone = function(e, t) {
                        return n.extend({}, t, e)
                    }, n.keys = function(e) {
                        if (Object.keys) return Object.keys(e);
                        var t = [];
                        for (var n in e) t.push(n);
                        return t
                    }, n.values = function(e) {
                        var t = [];
                        if (Object.keys) {
                            for (var n = Object.keys(e), i = 0; i < n.length; i++) t.push(e[n[i]]);
                            return t
                        }
                        for (var o in e) t.push(e[o]);
                        return t
                    }, n.get = function(e, t, n, i) {
                        t = t.split(".").slice(n, i);
                        for (var o = 0; o < t.length; o += 1) e = e[t[o]];
                        return e
                    }, n.set = function(e, t, i, o, r) {
                        var a = t.split(".").slice(o, r);
                        return n.get(e, t, 0, -1)[a[a.length - 1]] = i, i
                    }, n.shuffle = function(e) {
                        for (var t = e.length - 1; t > 0; t--) {
                            var i = Math.floor(n.random() * (t + 1)),
                                o = e[t];
                            e[t] = e[i], e[i] = o
                        }
                        return e
                    }, n.choose = function(e) {
                        return e[Math.floor(n.random() * e.length)]
                    }, n.isElement = function(e) {
                        return "undefined" != typeof HTMLElement ? e instanceof HTMLElement : !!(e && e.nodeType && e.nodeName)
                    }, n.isArray = function(e) {
                        return "[object Array]" === Object.prototype.toString.call(e)
                    }, n.isFunction = function(e) {
                        return "function" == typeof e
                    }, n.isPlainObject = function(e) {
                        return "object" == typeof e && e.constructor === Object
                    }, n.isString = function(e) {
                        return "[object String]" === toString.call(e)
                    }, n.clamp = function(e, t, n) {
                        return e < t ? t : e > n ? n : e
                    }, n.sign = function(e) {
                        return e < 0 ? -1 : 1
                    }, n.now = function() {
                        if ("undefined" != typeof window && window.performance) {
                            if (window.performance.now) return window.performance.now();
                            if (window.performance.webkitNow) return window.performance.webkitNow()
                        }
                        return Date.now ? Date.now() : new Date - n._nowStartTime
                    }, n.random = function(e, t) {
                        return t = void 0 !== t ? t : 1, (e = void 0 !== e ? e : 0) + _seededRandom() * (t - e)
                    };
                    var _seededRandom = function() {
                        return n._seed = (9301 * n._seed + 49297) % 233280, n._seed / 233280
                    };
                    n.colorToNumber = function(e) {
                        return 3 == (e = e.replace("#", "")).length && (e = e.charAt(0) + e.charAt(0) + e.charAt(1) + e.charAt(1) + e.charAt(2) + e.charAt(2)), parseInt(e, 16)
                    }, n.logLevel = 1, n.log = function() {
                        console && n.logLevel > 0 && n.logLevel <= 3 && console.log.apply(console, ["matter-js:"].concat(Array.prototype.slice.call(arguments)))
                    }, n.info = function() {
                        console && n.logLevel > 0 && n.logLevel <= 2 && console.info.apply(console, ["matter-js:"].concat(Array.prototype.slice.call(arguments)))
                    }, n.warn = function() {
                        console && n.logLevel > 0 && n.logLevel <= 3 && console.warn.apply(console, ["matter-js:"].concat(Array.prototype.slice.call(arguments)))
                    }, n.warnOnce = function() {
                        var e = Array.prototype.slice.call(arguments).join(" ");
                        n._warnedOnce[e] || (n.warn(e), n._warnedOnce[e] = !0)
                    }, n.deprecated = function(e, t, i) {
                        e[t] = n.chain((function() {
                            n.warnOnce("🔅 deprecated 🔅", i)
                        }), e[t])
                    }, n.nextId = function() {
                        return n._nextId++
                    }, n.indexOf = function(e, t) {
                        if (e.indexOf) return e.indexOf(t);
                        for (var n = 0; n < e.length; n++)
                            if (e[n] === t) return n;
                        return -1
                    }, n.map = function(e, t) {
                        if (e.map) return e.map(t);
                        for (var n = [], i = 0; i < e.length; i += 1) n.push(t(e[i]));
                        return n
                    }, n.topologicalSort = function(e) {
                        var t = [],
                            i = [],
                            o = [];
                        for (var r in e) i[r] || o[r] || n._topologicalSort(r, i, o, e, t);
                        return t
                    }, n._topologicalSort = function(e, t, i, o, r) {
                        var a = o[e] || [];
                        i[e] = !0;
                        for (var s = 0; s < a.length; s += 1) {
                            var l = a[s];
                            i[l] || (t[l] || n._topologicalSort(l, t, i, o, r))
                        }
                        i[e] = !1, t[e] = !0, r.push(e)
                    }, n.chain = function() {
                        for (var e = [], t = 0; t < arguments.length; t += 1) {
                            var n = arguments[t];
                            n._chained ? e.push.apply(e, n._chained) : e.push(n)
                        }
                        var chain = function() {
                            for (var t, n = new Array(arguments.length), i = 0, o = arguments.length; i < o; i++) n[i] = arguments[i];
                            for (i = 0; i < e.length; i += 1) {
                                var r = e[i].apply(t, n);
                                void 0 !== r && (t = r)
                            }
                            return t
                        };
                        return chain._chained = e, chain
                    }, n.chainPathBefore = function(e, t, i) {
                        return n.set(e, t, n.chain(i, n.get(e, t)))
                    }, n.chainPathAfter = function(e, t, i) {
                        return n.set(e, t, n.chain(n.get(e, t), i))
                    }, n.setDecomp = function(e) {
                        n._decomp = e
                    }, n.getDecomp = function() {
                        var e = n._decomp;
                        try {
                            e || "undefined" == typeof window || (e = window.decomp), e || "undefined" == typeof global || (e = global.decomp)
                        } catch (t) {
                            e = null
                        }
                        return e
                    }
                }()
        }, function(e, t) {
            var n = {};
            e.exports = n, n.create = function(e) {
                var t = {
                    min: {
                        x: 0,
                        y: 0
                    },
                    max: {
                        x: 0,
                        y: 0
                    }
                };
                return e && n.update(t, e), t
            }, n.update = function(e, t, n) {
                e.min.x = 1 / 0, e.max.x = -1 / 0, e.min.y = 1 / 0, e.max.y = -1 / 0;
                for (var i = 0; i < t.length; i++) {
                    var o = t[i];
                    o.x > e.max.x && (e.max.x = o.x), o.x < e.min.x && (e.min.x = o.x), o.y > e.max.y && (e.max.y = o.y), o.y < e.min.y && (e.min.y = o.y)
                }
                n && (n.x > 0 ? e.max.x += n.x : e.min.x += n.x, n.y > 0 ? e.max.y += n.y : e.min.y += n.y)
            }, n.contains = function(e, t) {
                return t.x >= e.min.x && t.x <= e.max.x && t.y >= e.min.y && t.y <= e.max.y
            }, n.overlaps = function(e, t) {
                return e.min.x <= t.max.x && e.max.x >= t.min.x && e.max.y >= t.min.y && e.min.y <= t.max.y
            }, n.translate = function(e, t) {
                e.min.x += t.x, e.max.x += t.x, e.min.y += t.y, e.max.y += t.y
            }, n.shift = function(e, t) {
                var n = e.max.x - e.min.x,
                    i = e.max.y - e.min.y;
                e.min.x = t.x, e.max.x = t.x + n, e.min.y = t.y, e.max.y = t.y + i
            }
        }, function(e, t) {
            var n = {};
            e.exports = n, n.create = function(e, t) {
                return {
                    x: e || 0,
                    y: t || 0
                }
            }, n.clone = function(e) {
                return {
                    x: e.x,
                    y: e.y
                }
            }, n.magnitude = function(e) {
                return Math.sqrt(e.x * e.x + e.y * e.y)
            }, n.magnitudeSquared = function(e) {
                return e.x * e.x + e.y * e.y
            }, n.rotate = function(e, t, n) {
                var i = Math.cos(t),
                    o = Math.sin(t);
                n || (n = {});
                var r = e.x * i - e.y * o;
                return n.y = e.x * o + e.y * i, n.x = r, n
            }, n.rotateAbout = function(e, t, n, i) {
                var o = Math.cos(t),
                    r = Math.sin(t);
                i || (i = {});
                var a = n.x + ((e.x - n.x) * o - (e.y - n.y) * r);
                return i.y = n.y + ((e.x - n.x) * r + (e.y - n.y) * o), i.x = a, i
            }, n.normalise = function(e) {
                var t = n.magnitude(e);
                return 0 === t ? {
                    x: 0,
                    y: 0
                } : {
                    x: e.x / t,
                    y: e.y / t
                }
            }, n.dot = function(e, t) {
                return e.x * t.x + e.y * t.y
            }, n.cross = function(e, t) {
                return e.x * t.y - e.y * t.x
            }, n.cross3 = function(e, t, n) {
                return (t.x - e.x) * (n.y - e.y) - (t.y - e.y) * (n.x - e.x)
            }, n.add = function(e, t, n) {
                return n || (n = {}), n.x = e.x + t.x, n.y = e.y + t.y, n
            }, n.sub = function(e, t, n) {
                return n || (n = {}), n.x = e.x - t.x, n.y = e.y - t.y, n
            }, n.mult = function(e, t) {
                return {
                    x: e.x * t,
                    y: e.y * t
                }
            }, n.div = function(e, t) {
                return {
                    x: e.x / t,
                    y: e.y / t
                }
            }, n.perp = function(e, t) {
                return {
                    x: (t = !0 === t ? -1 : 1) * -e.y,
                    y: t * e.x
                }
            }, n.neg = function(e) {
                return {
                    x: -e.x,
                    y: -e.y
                }
            }, n.angle = function(e, t) {
                return Math.atan2(t.y - e.y, t.x - e.x)
            }, n._temp = [n.create(), n.create(), n.create(), n.create(), n.create(), n.create()]
        }, function(e, t, n) {
            var i = {};
            e.exports = i;
            var o = n(2),
                r = n(0);
            i.create = function(e, t) {
                for (var n = [], i = 0; i < e.length; i++) {
                    var o = e[i],
                        r = {
                            x: o.x,
                            y: o.y,
                            index: i,
                            body: t,
                            isInternal: !1
                        };
                    n.push(r)
                }
                return n
            }, i.fromPath = function(e, t) {
                var n = [];
                return e.replace(/L?\s*([-\d.e]+)[\s,]*([-\d.e]+)*/gi, (function(e, t, i) {
                    n.push({
                        x: parseFloat(t),
                        y: parseFloat(i)
                    })
                })), i.create(n, t)
            }, i.centre = function(e) {
                for (var t, n, r, a = i.area(e, !0), s = {
                        x: 0,
                        y: 0
                    }, l = 0; l < e.length; l++) r = (l + 1) % e.length, t = o.cross(e[l], e[r]), n = o.mult(o.add(e[l], e[r]), t), s = o.add(s, n);
                return o.div(s, 6 * a)
            }, i.mean = function(e) {
                for (var t = {
                        x: 0,
                        y: 0
                    }, n = 0; n < e.length; n++) t.x += e[n].x, t.y += e[n].y;
                return o.div(t, e.length)
            }, i.area = function(e, t) {
                for (var n = 0, i = e.length - 1, o = 0; o < e.length; o++) n += (e[i].x - e[o].x) * (e[i].y + e[o].y), i = o;
                return t ? n / 2 : Math.abs(n) / 2
            }, i.inertia = function(e, t) {
                for (var n, i, r = 0, a = 0, s = e, l = 0; l < s.length; l++) i = (l + 1) % s.length, r += (n = Math.abs(o.cross(s[i], s[l]))) * (o.dot(s[i], s[i]) + o.dot(s[i], s[l]) + o.dot(s[l], s[l])), a += n;
                return t / 6 * (r / a)
            }, i.translate = function(e, t, n) {
                n = void 0 !== n ? n : 1;
                var i, o = e.length,
                    r = t.x * n,
                    a = t.y * n;
                for (i = 0; i < o; i++) e[i].x += r, e[i].y += a;
                return e
            }, i.rotate = function(e, t, n) {
                if (0 !== t) {
                    var i, o, r, a, s = Math.cos(t),
                        l = Math.sin(t),
                        c = n.x,
                        u = n.y,
                        d = e.length;
                    for (a = 0; a < d; a++) o = (i = e[a]).x - c, r = i.y - u, i.x = c + (o * s - r * l), i.y = u + (o * l + r * s);
                    return e
                }
            }, i.contains = function(e, t) {
                for (var n, i = t.x, o = t.y, r = e.length, a = e[r - 1], s = 0; s < r; s++) {
                    if (n = e[s], (i - a.x) * (n.y - a.y) + (o - a.y) * (a.x - n.x) > 0) return !1;
                    a = n
                }
                return !0
            }, i.scale = function(e, t, n, r) {
                if (1 === t && 1 === n) return e;
                var a, s;
                r = r || i.centre(e);
                for (var l = 0; l < e.length; l++) a = e[l], s = o.sub(a, r), e[l].x = r.x + s.x * t, e[l].y = r.y + s.y * n;
                return e
            }, i.chamfer = function(e, t, n, i, a) {
                t = "number" == typeof t ? [t] : t || [8], n = void 0 !== n ? n : -1, i = i || 2, a = a || 14;
                for (var s = [], l = 0; l < e.length; l++) {
                    var c = e[l - 1 >= 0 ? l - 1 : e.length - 1],
                        u = e[l],
                        d = e[(l + 1) % e.length],
                        p = t[l < t.length ? l : t.length - 1];
                    if (0 !== p) {
                        var f = o.normalise({
                                x: u.y - c.y,
                                y: c.x - u.x
                            }),
                            v = o.normalise({
                                x: d.y - u.y,
                                y: u.x - d.x
                            }),
                            y = Math.sqrt(2 * Math.pow(p, 2)),
                            m = o.mult(r.clone(f), p),
                            g = o.normalise(o.mult(o.add(f, v), .5)),
                            x = o.sub(u, o.mult(g, y)),
                            h = n; - 1 === n && (h = 1.75 * Math.pow(p, .32)), (h = r.clamp(h, i, a)) % 2 == 1 && (h += 1);
                        for (var b = Math.acos(o.dot(f, v)) / h, S = 0; S < h; S++) s.push(o.add(o.rotate(m, b * S), x))
                    } else s.push(u)
                }
                return s
            }, i.clockwiseSort = function(e) {
                var t = i.mean(e);
                return e.sort((function(e, n) {
                    return o.angle(t, e) - o.angle(t, n)
                })), e
            }, i.isConvex = function(e) {
                var t, n, i, o, r = 0,
                    a = e.length;
                if (a < 3) return null;
                for (t = 0; t < a; t++)
                    if (i = (t + 2) % a, o = (e[n = (t + 1) % a].x - e[t].x) * (e[i].y - e[n].y), (o -= (e[n].y - e[t].y) * (e[i].x - e[n].x)) < 0 ? r |= 1 : o > 0 && (r |= 2), 3 === r) return !1;
                return 0 !== r || null
            }, i.hull = function(e) {
                var t, n, i = [],
                    r = [];
                for ((e = e.slice(0)).sort((function(e, t) {
                        var n = e.x - t.x;
                        return 0 !== n ? n : e.y - t.y
                    })), n = 0; n < e.length; n += 1) {
                    for (t = e[n]; r.length >= 2 && o.cross3(r[r.length - 2], r[r.length - 1], t) <= 0;) r.pop();
                    r.push(t)
                }
                for (n = e.length - 1; n >= 0; n -= 1) {
                    for (t = e[n]; i.length >= 2 && o.cross3(i[i.length - 2], i[i.length - 1], t) <= 0;) i.pop();
                    i.push(t)
                }
                return i.pop(), r.pop(), i.concat(r)
            }
        }, function(e, t, n) {
            var i = {};
            e.exports = i;
            var o = n(0);
            i.on = function(e, t, n) {
                for (var i, o = t.split(" "), r = 0; r < o.length; r++) i = o[r], e.events = e.events || {}, e.events[i] = e.events[i] || [], e.events[i].push(n);
                return n
            }, i.off = function(e, t, n) {
                if (t) {
                    "function" == typeof t && (n = t, t = o.keys(e.events).join(" "));
                    for (var i = t.split(" "), r = 0; r < i.length; r++) {
                        var a = e.events[i[r]],
                            s = [];
                        if (n && a)
                            for (var l = 0; l < a.length; l++) a[l] !== n && s.push(a[l]);
                        e.events[i[r]] = s
                    }
                } else e.events = {}
            }, i.trigger = function(e, t, n) {
                var i, r, a, s, l = e.events;
                if (l && o.keys(l).length > 0) {
                    n || (n = {}), i = t.split(" ");
                    for (var c = 0; c < i.length; c++)
                        if (a = l[r = i[c]]) {
                            (s = o.clone(n, !1)).name = r, s.source = e;
                            for (var u = 0; u < a.length; u++) a[u].apply(e, [s])
                        }
                }
            }
        }, function(e, t, n) {
            var i = {};
            e.exports = i;
            var o = n(4),
                r = n(0),
                a = n(1),
                s = n(6);
            i.create = function(e) {
                return r.extend({
                    id: r.nextId(),
                    type: "composite",
                    parent: null,
                    isModified: !1,
                    bodies: [],
                    constraints: [],
                    composites: [],
                    label: "Composite",
                    plugin: {},
                    cache: {
                        allBodies: null,
                        allConstraints: null,
                        allComposites: null
                    }
                }, e)
            }, i.setModified = function(e, t, n, o) {
                if (e.isModified = t, t && e.cache && (e.cache.allBodies = null, e.cache.allConstraints = null, e.cache.allComposites = null), n && e.parent && i.setModified(e.parent, t, n, o), o)
                    for (var r = 0; r < e.composites.length; r++) {
                        var a = e.composites[r];
                        i.setModified(a, t, n, o)
                    }
            }, i.add = function(e, t) {
                var n = [].concat(t);
                o.trigger(e, "beforeAdd", {
                    object: t
                });
                for (var a = 0; a < n.length; a++) {
                    var s = n[a];
                    switch (s.type) {
                        case "body":
                            if (s.parent !== s) {
                                r.warn("Composite.add: skipped adding a compound body part (you must add its parent instead)");
                                break
                            }
                            i.addBody(e, s);
                            break;
                        case "constraint":
                            i.addConstraint(e, s);
                            break;
                        case "composite":
                            i.addComposite(e, s);
                            break;
                        case "mouseConstraint":
                            i.addConstraint(e, s.constraint)
                    }
                }
                return o.trigger(e, "afterAdd", {
                    object: t
                }), e
            }, i.remove = function(e, t, n) {
                var r = [].concat(t);
                o.trigger(e, "beforeRemove", {
                    object: t
                });
                for (var a = 0; a < r.length; a++) {
                    var s = r[a];
                    switch (s.type) {
                        case "body":
                            i.removeBody(e, s, n);
                            break;
                        case "constraint":
                            i.removeConstraint(e, s, n);
                            break;
                        case "composite":
                            i.removeComposite(e, s, n);
                            break;
                        case "mouseConstraint":
                            i.removeConstraint(e, s.constraint)
                    }
                }
                return o.trigger(e, "afterRemove", {
                    object: t
                }), e
            }, i.addComposite = function(e, t) {
                return e.composites.push(t), t.parent = e, i.setModified(e, !0, !0, !1), e
            }, i.removeComposite = function(e, t, n) {
                var o = r.indexOf(e.composites, t);
                if (-1 !== o && i.removeCompositeAt(e, o), n)
                    for (var a = 0; a < e.composites.length; a++) i.removeComposite(e.composites[a], t, !0);
                return e
            }, i.removeCompositeAt = function(e, t) {
                return e.composites.splice(t, 1), i.setModified(e, !0, !0, !1), e
            }, i.addBody = function(e, t) {
                return e.bodies.push(t), i.setModified(e, !0, !0, !1), e
            }, i.removeBody = function(e, t, n) {
                var o = r.indexOf(e.bodies, t);
                if (-1 !== o && i.removeBodyAt(e, o), n)
                    for (var a = 0; a < e.composites.length; a++) i.removeBody(e.composites[a], t, !0);
                return e
            }, i.removeBodyAt = function(e, t) {
                return e.bodies.splice(t, 1), i.setModified(e, !0, !0, !1), e
            }, i.addConstraint = function(e, t) {
                return e.constraints.push(t), i.setModified(e, !0, !0, !1), e
            }, i.removeConstraint = function(e, t, n) {
                var o = r.indexOf(e.constraints, t);
                if (-1 !== o && i.removeConstraintAt(e, o), n)
                    for (var a = 0; a < e.composites.length; a++) i.removeConstraint(e.composites[a], t, !0);
                return e
            }, i.removeConstraintAt = function(e, t) {
                return e.constraints.splice(t, 1), i.setModified(e, !0, !0, !1), e
            }, i.clear = function(e, t, n) {
                if (n)
                    for (var o = 0; o < e.composites.length; o++) i.clear(e.composites[o], t, !0);
                return t ? e.bodies = e.bodies.filter((function(e) {
                    return e.isStatic
                })) : e.bodies.length = 0, e.constraints.length = 0, e.composites.length = 0, i.setModified(e, !0, !0, !1), e
            }, i.allBodies = function(e) {
                if (e.cache && e.cache.allBodies) return e.cache.allBodies;
                for (var t = [].concat(e.bodies), n = 0; n < e.composites.length; n++) t = t.concat(i.allBodies(e.composites[n]));
                return e.cache && (e.cache.allBodies = t), t
            }, i.allConstraints = function(e) {
                if (e.cache && e.cache.allConstraints) return e.cache.allConstraints;
                for (var t = [].concat(e.constraints), n = 0; n < e.composites.length; n++) t = t.concat(i.allConstraints(e.composites[n]));
                return e.cache && (e.cache.allConstraints = t), t
            }, i.allComposites = function(e) {
                if (e.cache && e.cache.allComposites) return e.cache.allComposites;
                for (var t = [].concat(e.composites), n = 0; n < e.composites.length; n++) t = t.concat(i.allComposites(e.composites[n]));
                return e.cache && (e.cache.allComposites = t), t
            }, i.get = function(e, t, n) {
                var o, r;
                switch (n) {
                    case "body":
                        o = i.allBodies(e);
                        break;
                    case "constraint":
                        o = i.allConstraints(e);
                        break;
                    case "composite":
                        o = i.allComposites(e).concat(e)
                }
                return o ? 0 === (r = o.filter((function(e) {
                    return e.id.toString() === t.toString()
                }))).length ? null : r[0] : null
            }, i.move = function(e, t, n) {
                return i.remove(e, t), i.add(n, t), e
            }, i.rebase = function(e) {
                for (var t = i.allBodies(e).concat(i.allConstraints(e)).concat(i.allComposites(e)), n = 0; n < t.length; n++) t[n].id = r.nextId();
                return e
            }, i.translate = function(e, t, n) {
                for (var o = n ? i.allBodies(e) : e.bodies, r = 0; r < o.length; r++) s.translate(o[r], t);
                return e
            }, i.rotate = function(e, t, n, o) {
                for (var r = Math.cos(t), a = Math.sin(t), l = o ? i.allBodies(e) : e.bodies, c = 0; c < l.length; c++) {
                    var u = l[c],
                        d = u.position.x - n.x,
                        p = u.position.y - n.y;
                    s.setPosition(u, {
                        x: n.x + (d * r - p * a),
                        y: n.y + (d * a + p * r)
                    }), s.rotate(u, t)
                }
                return e
            }, i.scale = function(e, t, n, o, r) {
                for (var a = r ? i.allBodies(e) : e.bodies, l = 0; l < a.length; l++) {
                    var c = a[l],
                        u = c.position.x - o.x,
                        d = c.position.y - o.y;
                    s.setPosition(c, {
                        x: o.x + u * t,
                        y: o.y + d * n
                    }), s.scale(c, t, n)
                }
                return e
            }, i.bounds = function(e) {
                for (var t = i.allBodies(e), n = [], o = 0; o < t.length; o += 1) {
                    var r = t[o];
                    n.push(r.bounds.min, r.bounds.max)
                }
                return a.create(n)
            }
        }, function(e, t, n) {
            var i = {};
            e.exports = i;
            var o = n(3),
                r = n(2),
                a = n(7),
                s = (n(16), n(0)),
                l = n(1),
                c = n(11);
            ! function() {
                i._inertiaScale = 4, i._nextCollidingGroupId = 1, i._nextNonCollidingGroupId = -1, i._nextCategory = 1, i.create = function(e) {
                    var t = {
                            id: s.nextId(),
                            type: "body",
                            label: "Body",
                            parts: [],
                            plugin: {},
                            angle: 0,
                            vertices: o.fromPath("L 0 0 L 40 0 L 40 40 L 0 40"),
                            position: {
                                x: 0,
                                y: 0
                            },
                            force: {
                                x: 0,
                                y: 0
                            },
                            torque: 0,
                            positionImpulse: {
                                x: 0,
                                y: 0
                            },
                            constraintImpulse: {
                                x: 0,
                                y: 0,
                                angle: 0
                            },
                            totalContacts: 0,
                            speed: 0,
                            angularSpeed: 0,
                            velocity: {
                                x: 0,
                                y: 0
                            },
                            angularVelocity: 0,
                            isSensor: !1,
                            isStatic: !1,
                            isSleeping: !1,
                            motion: 0,
                            sleepThreshold: 60,
                            density: .001,
                            restitution: 0,
                            friction: .1,
                            frictionStatic: .5,
                            frictionAir: .01,
                            collisionFilter: {
                                category: 1,
                                mask: 4294967295,
                                group: 0
                            },
                            slop: .05,
                            timeScale: 1,
                            render: {
                                visible: !0,
                                opacity: 1,
                                strokeStyle: null,
                                fillStyle: null,
                                lineWidth: null,
                                sprite: {
                                    xScale: 1,
                                    yScale: 1,
                                    xOffset: 0,
                                    yOffset: 0
                                }
                            },
                            events: null,
                            bounds: null,
                            chamfer: null,
                            circleRadius: 0,
                            positionPrev: null,
                            anglePrev: 0,
                            parent: null,
                            axes: null,
                            area: 0,
                            mass: 0,
                            inertia: 0,
                            _original: null,
                            allowRotation: !0,
                            isKinematic: !1
                        },
                        n = s.extend(t, e);
                    return _initProperties(n, e), n
                }, i.nextGroup = function(e) {
                    return e ? i._nextNonCollidingGroupId-- : i._nextCollidingGroupId++
                }, i.nextCategory = function() {
                    return i._nextCategory = i._nextCategory << 1, i._nextCategory
                };
                var _initProperties = function(e, t) {
                    t = t || {}, i.set(e, {
                        bounds: e.bounds || l.create(e.vertices),
                        positionPrev: e.positionPrev || r.clone(e.position),
                        anglePrev: e.anglePrev || e.angle,
                        vertices: e.vertices,
                        parts: e.parts || [e],
                        isStatic: e.isStatic,
                        isSleeping: e.isSleeping,
                        parent: e.parent || e
                    }), o.rotate(e.vertices, e.angle, e.position), c.rotate(e.axes, e.angle), l.update(e.bounds, e.vertices, e.velocity), i.set(e, {
                        axes: t.axes || e.axes,
                        area: t.area || e.area,
                        mass: t.mass || e.mass,
                        inertia: t.inertia || e.inertia
                    });
                    var n = e.isStatic ? "#14151f" : s.choose(["#f19648", "#f5d259", "#f55a3c", "#063e7b", "#ececd1"]),
                        a = e.isStatic ? "#555" : "#ccc",
                        u = e.isStatic && null === e.render.fillStyle ? 1 : 0;
                    e.render.fillStyle = e.render.fillStyle || n, e.render.strokeStyle = e.render.strokeStyle || a, e.render.lineWidth = e.render.lineWidth || u, e.render.sprite.xOffset += -(e.bounds.min.x - e.position.x) / (e.bounds.max.x - e.bounds.min.x), e.render.sprite.yOffset += -(e.bounds.min.y - e.position.y) / (e.bounds.max.y - e.bounds.min.y)
                };
                i.set = function(e, t, n) {
                    var o;
                    for (o in "string" == typeof t && (o = t, (t = {})[o] = n), t)
                        if (Object.prototype.hasOwnProperty.call(t, o)) switch (n = t[o], o) {
                            case "isStatic":
                                i.setStatic(e, n);
                                break;
                            case "isSleeping":
                                a.set(e, n);
                                break;
                            case "mass":
                                i.setMass(e, n);
                                break;
                            case "density":
                                i.setDensity(e, n);
                                break;
                            case "inertia":
                                i.setInertia(e, n);
                                break;
                            case "vertices":
                                i.setVertices(e, n);
                                break;
                            case "position":
                                i.setPosition(e, n);
                                break;
                            case "angle":
                                i.setAngle(e, n);
                                break;
                            case "velocity":
                                i.setVelocity(e, n);
                                break;
                            case "angularVelocity":
                                i.setAngularVelocity(e, n);
                                break;
                            case "parts":
                                i.setParts(e, n);
                                break;
                            case "centre":
                                i.setCentre(e, n);
                                break;
                            default:
                                e[o] = n
                        }
                }, i.setStatic = function(e, t) {
                    for (var n = 0; n < e.parts.length; n++) {
                        var i = e.parts[n];
                        i.isStatic = t, t ? (i._original = {
                            restitution: i.restitution,
                            friction: i.friction,
                            mass: i.mass,
                            inertia: i.inertia,
                            density: i.density,
                            inverseMass: i.inverseMass,
                            inverseInertia: i.inverseInertia
                        }, i.restitution = 0, i.friction = 1, i.mass = i.inertia = i.density = 1 / 0, i.inverseMass = i.inverseInertia = 0, i.positionPrev.x = i.position.x, i.positionPrev.y = i.position.y, i.anglePrev = i.angle, i.angularVelocity = 0, i.speed = 0, i.angularSpeed = 0, i.motion = 0) : i._original && (i.restitution = i._original.restitution, i.friction = i._original.friction, i.mass = i._original.mass, i.inertia = i._original.inertia, i.density = i._original.density, i.inverseMass = i._original.inverseMass, i.inverseInertia = i._original.inverseInertia, i._original = null)
                    }
                }, i.setMass = function(e, t) {
                    var n = e.inertia / (e.mass / 6);
                    e.inertia = n * (t / 6), e.inverseInertia = 1 / e.inertia, e.mass = t, e.inverseMass = 1 / e.mass, e.density = e.mass / e.area
                }, i.setDensity = function(e, t) {
                    i.setMass(e, t * e.area), e.density = t
                }, i.setInertia = function(e, t) {
                    e.inertia = t, e.inverseInertia = 1 / e.inertia
                }, i.setVertices = function(e, t) {
                    t[0].body === e ? e.vertices = t : e.vertices = o.create(t, e), e.axes = c.fromVertices(e.vertices), e.area = o.area(e.vertices), i.setMass(e, e.density * e.area);
                    var n = o.centre(e.vertices);
                    o.translate(e.vertices, n, -1), i.setInertia(e, i._inertiaScale * o.inertia(e.vertices, e.mass)), o.translate(e.vertices, e.position), l.update(e.bounds, e.vertices, e.velocity)
                }, i.setParts = function(e, t, n) {
                    var r;
                    for (t = t.slice(0), e.parts.length = 0, e.parts.push(e), e.parent = e, r = 0; r < t.length; r++) {
                        var a = t[r];
                        a !== e && (a.parent = e, e.parts.push(a))
                    }
                    if (1 !== e.parts.length) {
                        if (n = void 0 === n || n) {
                            var s = [];
                            for (r = 0; r < t.length; r++) s = s.concat(t[r].vertices);
                            o.clockwiseSort(s);
                            var l = o.hull(s),
                                c = o.centre(l);
                            i.setVertices(e, l), o.translate(e.vertices, c)
                        }
                        var u = i._totalProperties(e);
                        e.area = u.area, e.parent = e, e.position.x = u.centre.x, e.position.y = u.centre.y, e.positionPrev.x = u.centre.x, e.positionPrev.y = u.centre.y, i.setMass(e, u.mass), i.setInertia(e, u.inertia), i.setPosition(e, u.centre)
                    }
                }, i.setCentre = function(e, t, n) {
                    n ? (e.positionPrev.x += t.x, e.positionPrev.y += t.y, e.position.x += t.x, e.position.y += t.y) : (e.positionPrev.x = t.x - (e.position.x - e.positionPrev.x), e.positionPrev.y = t.y - (e.position.y - e.positionPrev.y), e.position.x = t.x, e.position.y = t.y)
                }, i.setPosition = function(e, t) {
                    var n = r.sub(t, e.position);
                    e.positionPrev.x += n.x, e.positionPrev.y += n.y;
                    for (var i = 0; i < e.parts.length; i++) {
                        var a = e.parts[i];
                        a.position.x += n.x, a.position.y += n.y, o.translate(a.vertices, n), l.update(a.bounds, a.vertices, e.velocity)
                    }
                }, i.setAngle = function(e, t) {
                    var n = t - e.angle;
                    e.anglePrev += n;
                    for (var i = 0; i < e.parts.length; i++) {
                        var a = e.parts[i];
                        a.angle += n, o.rotate(a.vertices, n, e.position), c.rotate(a.axes, n), l.update(a.bounds, a.vertices, e.velocity), i > 0 && r.rotateAbout(a.position, n, e.position, a.position)
                    }
                }, i.setVelocity = function(e, t) {
                    e.positionPrev.x = e.position.x - t.x, e.positionPrev.y = e.position.y - t.y, e.velocity.x = t.x, e.velocity.y = t.y, e.speed = r.magnitude(e.velocity)
                }, i.setAngularVelocity = function(e, t) {
                    e.anglePrev = e.angle - t, e.angularVelocity = t, e.angularSpeed = Math.abs(e.angularVelocity)
                }, i.translate = function(e, t) {
                    i.setPosition(e, r.add(e.position, t))
                }, i.rotate = function(e, t, n) {
                    if (n) {
                        var o = Math.cos(t),
                            r = Math.sin(t),
                            a = e.position.x - n.x,
                            s = e.position.y - n.y;
                        i.setPosition(e, {
                            x: n.x + (a * o - s * r),
                            y: n.y + (a * r + s * o)
                        }), i.setAngle(e, e.angle + t)
                    } else i.setAngle(e, e.angle + t)
                }, i.scale = function(e, t, n, r) {
                    var a = 0,
                        s = 0;
                    r = r || e.position;
                    for (var u = 0; u < e.parts.length; u++) {
                        var d = e.parts[u];
                        o.scale(d.vertices, t, n, r), d.axes = c.fromVertices(d.vertices), d.area = o.area(d.vertices), i.setMass(d, e.density * d.area), o.translate(d.vertices, {
                            x: -d.position.x,
                            y: -d.position.y
                        }), i.setInertia(d, i._inertiaScale * o.inertia(d.vertices, d.mass)), o.translate(d.vertices, {
                            x: d.position.x,
                            y: d.position.y
                        }), u > 0 && (a += d.area, s += d.inertia), d.position.x = r.x + (d.position.x - r.x) * t, d.position.y = r.y + (d.position.y - r.y) * n, l.update(d.bounds, d.vertices, e.velocity)
                    }
                    e.parts.length > 1 && (e.area = a, e.isStatic || (i.setMass(e, e.density * a), i.setInertia(e, s))), e.circleRadius && (t === n ? e.circleRadius *= t : e.circleRadius = null)
                }, i.update = function(e, t, n, i) {
                    var a = Math.pow(t * n * e.timeScale, 2),
                        s = 1 - e.frictionAir * n * e.timeScale,
                        u = e.position.x - e.positionPrev.x,
                        d = e.position.y - e.positionPrev.y;
                    e.velocity.x = u * s * i + e.force.x / e.mass * a, e.velocity.y = d * s * i + e.force.y / e.mass * a, e.positionPrev.x = e.position.x, e.positionPrev.y = e.position.y, e.position.x += e.velocity.x, e.position.y += e.velocity.y, e.allowRotation ? (e.angularVelocity = (e.angle - e.anglePrev) * s * i + e.torque / e.inertia * a, e.anglePrev = e.angle, e.angle += e.angularVelocity) : (e.angularVelocity = 0, e.anglePrev = e.angle), e.speed = r.magnitude(e.velocity), e.angularSpeed = Math.abs(e.angularVelocity);
                    for (var p = 0; p < e.parts.length; p++) {
                        var f = e.parts[p];
                        o.translate(f.vertices, e.velocity), p > 0 && (f.position.x += e.velocity.x, f.position.y += e.velocity.y), 0 !== e.angularVelocity && (o.rotate(f.vertices, e.angularVelocity, e.position), c.rotate(f.axes, e.angularVelocity), p > 0 && r.rotateAbout(f.position, e.angularVelocity, e.position, f.position)), l.update(f.bounds, f.vertices, e.velocity)
                    }
                }, i.applyForce = function(e, t, n) {
                    e.force.x += n.x, e.force.y += n.y;
                    var i = t.x - e.position.x,
                        o = t.y - e.position.y;
                    e.torque += i * n.y - o * n.x
                }, i._totalProperties = function(e) {
                    for (var t = {
                            mass: 0,
                            area: 0,
                            inertia: 0,
                            centre: {
                                x: 0,
                                y: 0
                            }
                        }, n = 1 === e.parts.length ? 0 : 1; n < e.parts.length; n++) {
                        var i = e.parts[n],
                            o = i.mass !== 1 / 0 ? i.mass : 1;
                        t.mass += o, t.area += i.area, t.inertia += i.inertia, t.centre = r.add(t.centre, r.mult(i.position, o))
                    }
                    return t.centre = r.div(t.centre, t.mass), t
                }
            }()
        }, function(e, t, n) {
            var i = {};
            e.exports = i;
            var o = n(4);
            i._motionWakeThreshold = .18, i._motionSleepThreshold = .08, i._minBias = .9, i.update = function(e, t) {
                for (var n = t * t * t, o = 0; o < e.length; o++) {
                    var r = e[o],
                        a = r.speed * r.speed + r.angularSpeed * r.angularSpeed;
                    if (0 === r.force.x && 0 === r.force.y) {
                        var s = Math.min(r.motion, a),
                            l = Math.max(r.motion, a);
                        r.motion = i._minBias * s + (1 - i._minBias) * l, r.sleepThreshold > 0 && r.motion < i._motionSleepThreshold * n ? (r.sleepCounter += 1, r.sleepCounter >= r.sleepThreshold && i.set(r, !0)) : r.sleepCounter > 0 && (r.sleepCounter -= 1)
                    } else i.set(r, !1)
                }
            }, i.afterCollisions = function(e, t) {
                for (var n = t * t * t, o = 0; o < e.length; o++) {
                    var r = e[o];
                    if (r.isActive) {
                        var a = r.collision,
                            s = a.bodyA.parent,
                            l = a.bodyB.parent;
                        if (!(s.isSleeping && l.isSleeping || s.isStatic || l.isStatic) && (s.isSleeping || l.isSleeping)) {
                            var c = s.isSleeping && !s.isStatic ? s : l,
                                u = c === s ? l : s;
                            !c.isStatic && u.motion > i._motionWakeThreshold * n && i.set(c, !1)
                        }
                    }
                }
            }, i.set = function(e, t) {
                var n = e.isSleeping;
                t ? (e.isSleeping = !0, e.sleepCounter = e.sleepThreshold, e.positionImpulse.x = 0, e.positionImpulse.y = 0, e.positionPrev.x = e.position.x, e.positionPrev.y = e.position.y, e.anglePrev = e.angle, e.speed = 0, e.angularSpeed = 0, e.motion = 0, n || o.trigger(e, "sleepStart")) : (e.isSleeping = !1, e.sleepCounter = 0, n && o.trigger(e, "sleepEnd"))
            }
        }, function(e, t, n) {
            var i = {};
            e.exports = i;
            var o, r, a, s = n(3),
                l = n(9);
            o = [], r = {
                overlap: 0,
                axis: null
            }, a = {
                overlap: 0,
                axis: null
            }, i.create = function(e, t) {
                return {
                    pair: null,
                    collided: !1,
                    bodyA: e,
                    bodyB: t,
                    parentA: e.parent,
                    parentB: t.parent,
                    depth: 0,
                    normal: {
                        x: 0,
                        y: 0
                    },
                    tangent: {
                        x: 0,
                        y: 0
                    },
                    penetration: {
                        x: 0,
                        y: 0
                    },
                    supports: []
                }
            }, i.collides = function(e, t, n) {
                if (i._overlapAxes(r, e.vertices, t.vertices, e.axes), r.overlap <= 0) return null;
                if (i._overlapAxes(a, t.vertices, e.vertices, t.axes), a.overlap <= 0) return null;
                var o, c, u = n && n.table[l.id(e, t)];
                u ? o = u.collision : ((o = i.create(e, t)).collided = !0, o.bodyA = e.id < t.id ? e : t, o.bodyB = e.id < t.id ? t : e, o.parentA = o.bodyA.parent, o.parentB = o.bodyB.parent), e = o.bodyA, t = o.bodyB, c = r.overlap < a.overlap ? r : a;
                var d = o.normal,
                    p = o.supports,
                    f = c.axis,
                    v = f.x,
                    y = f.y;
                v * (t.position.x - e.position.x) + y * (t.position.y - e.position.y) < 0 ? (d.x = v, d.y = y) : (d.x = -v, d.y = -y), o.tangent.x = -d.y, o.tangent.y = d.x, o.depth = c.overlap, o.penetration.x = d.x * o.depth, o.penetration.y = d.y * o.depth;
                var m = i._findSupports(e, t, d, 1),
                    g = 0;
                if (s.contains(e.vertices, m[0]) && (p[g++] = m[0]), s.contains(e.vertices, m[1]) && (p[g++] = m[1]), g < 2) {
                    var x = i._findSupports(t, e, d, -1);
                    s.contains(t.vertices, x[0]) && (p[g++] = x[0]), g < 2 && s.contains(t.vertices, x[1]) && (p[g++] = x[1])
                }
                return 0 === g && (p[g++] = m[0]), p.length = g, o
            }, i._overlapAxes = function(e, t, n, i) {
                var o, r, a, s, l, c, u = t.length,
                    d = n.length,
                    p = t[0].x,
                    f = t[0].y,
                    v = n[0].x,
                    y = n[0].y,
                    m = i.length,
                    g = Number.MAX_VALUE,
                    x = 0;
                for (l = 0; l < m; l++) {
                    var h = i[l],
                        b = h.x,
                        S = h.y,
                        w = p * b + f * S,
                        _ = v * b + y * S,
                        A = w,
                        P = _;
                    for (c = 1; c < u; c += 1)(s = t[c].x * b + t[c].y * S) > A ? A = s : s < w && (w = s);
                    for (c = 1; c < d; c += 1)(s = n[c].x * b + n[c].y * S) > P ? P = s : s < _ && (_ = s);
                    if ((o = (r = A - _) < (a = P - w) ? r : a) < g && (g = o, x = l, o <= 0)) break
                }
                e.axis = i[x], e.overlap = g
            }, i._projectToAxis = function(e, t, n) {
                for (var i = t[0].x * n.x + t[0].y * n.y, o = i, r = 1; r < t.length; r += 1) {
                    var a = t[r].x * n.x + t[r].y * n.y;
                    a > o ? o = a : a < i && (i = a)
                }
                e.min = i, e.max = o
            }, i._findSupports = function(e, t, n, i) {
                var r, a, s, l, c, u = t.vertices,
                    d = u.length,
                    p = e.position.x,
                    f = e.position.y,
                    v = n.x * i,
                    y = n.y * i,
                    m = Number.MAX_VALUE;
                for (c = 0; c < d; c += 1)(l = v * (p - (a = u[c]).x) + y * (f - a.y)) < m && (m = l, r = a);
                return m = v * (p - (s = u[(d + r.index - 1) % d]).x) + y * (f - s.y), v * (p - (a = u[(r.index + 1) % d]).x) + y * (f - a.y) < m ? (o[0] = r, o[1] = a, o) : (o[0] = r, o[1] = s, o)
            }
        }, function(e, t, n) {
            var i = {};
            e.exports = i;
            var o = n(17);
            i.create = function(e, t) {
                var n = e.bodyA,
                    o = e.bodyB,
                    r = {
                        id: i.id(n, o),
                        bodyA: n,
                        bodyB: o,
                        collision: e,
                        contacts: [],
                        activeContacts: [],
                        separation: 0,
                        isActive: !0,
                        confirmedActive: !0,
                        isSensor: n.isSensor || o.isSensor,
                        timeCreated: t,
                        timeUpdated: t,
                        inverseMass: 0,
                        friction: 0,
                        frictionStatic: 0,
                        restitution: 0,
                        slop: 0
                    };
                return i.update(r, e, t), r
            }, i.update = function(e, t, n) {
                var i = e.contacts,
                    r = t.supports,
                    a = e.activeContacts,
                    s = t.parentA,
                    l = t.parentB,
                    c = s.vertices.length;
                e.isActive = !0, e.timeUpdated = n, e.collision = t, e.separation = t.depth, e.inverseMass = s.inverseMass + l.inverseMass, e.friction = s.friction < l.friction ? s.friction : l.friction, e.frictionStatic = s.frictionStatic > l.frictionStatic ? s.frictionStatic : l.frictionStatic, e.restitution = s.restitution > l.restitution ? s.restitution : l.restitution, e.slop = s.slop > l.slop ? s.slop : l.slop, t.pair = e, a.length = 0;
                for (var u = 0; u < r.length; u++) {
                    var d = r[u],
                        p = d.body === s ? d.index : c + d.index,
                        f = i[p];
                    f ? a.push(f) : a.push(i[p] = o.create(d))
                }
            }, i.setActive = function(e, t, n) {
                t ? (e.isActive = !0, e.timeUpdated = n) : (e.isActive = !1, e.activeContacts.length = 0)
            }, i.id = function(e, t) {
                return e.id < t.id ? "A" + e.id + "B" + t.id : "A" + t.id + "B" + e.id
            }
        }, function(e, t, n) {
            var i = {};
            e.exports = i;
            var o = n(3),
                r = n(2),
                a = n(7),
                s = n(1),
                l = n(11),
                c = n(0);
            i._warming = .4, i._torqueDampen = 1, i._minLength = 1e-6, i.create = function(e) {
                var t = e;
                t.bodyA && !t.pointA && (t.pointA = {
                    x: 0,
                    y: 0
                }), t.bodyB && !t.pointB && (t.pointB = {
                    x: 0,
                    y: 0
                });
                var n = t.bodyA ? r.add(t.bodyA.position, t.pointA) : t.pointA,
                    i = t.bodyB ? r.add(t.bodyB.position, t.pointB) : t.pointB,
                    o = r.magnitude(r.sub(n, i));
                t.length = void 0 !== t.length ? t.length : o, t.id = t.id || c.nextId(), t.label = t.label || "Constraint", t.type = "constraint", t.stiffness = t.stiffness || (t.length > 0 ? 1 : .7), t.damping = t.damping || 0, t.angularStiffness = t.angularStiffness || 0, t.angleA = t.bodyA ? t.bodyA.angle : t.angleA, t.angleB = t.bodyB ? t.bodyB.angle : t.angleB, t.plugin = {};
                var a = {
                    visible: !0,
                    lineWidth: 2,
                    strokeStyle: "#ffffff",
                    type: "line",
                    anchors: !0
                };
                return 0 === t.length && t.stiffness > .1 ? (a.type = "pin", a.anchors = !1) : t.stiffness < .9 && (a.type = "spring"), t.render = c.extend(a, t.render), t
            }, i.preSolveAll = function(e) {
                for (var t = 0; t < e.length; t += 1) {
                    var n = e[t],
                        i = n.constraintImpulse;
                    n.isStatic || 0 === i.x && 0 === i.y && 0 === i.angle || (n.position.x += i.x, n.position.y += i.y, n.angle += i.angle)
                }
            }, i.solveAll = function(e, t) {
                for (var n = 0; n < e.length; n += 1) {
                    var o = e[n],
                        r = !o.bodyA || o.bodyA && o.bodyA.isStatic,
                        a = !o.bodyB || o.bodyB && o.bodyB.isStatic;
                    (r || a) && i.solve(e[n], t)
                }
                for (n = 0; n < e.length; n += 1) r = !(o = e[n]).bodyA || o.bodyA && o.bodyA.isStatic, a = !o.bodyB || o.bodyB && o.bodyB.isStatic, r || a || i.solve(e[n], t)
            }, i.solve = function(e, t) {
                var n = e.bodyA,
                    o = e.bodyB,
                    a = e.pointA,
                    s = e.pointB;
                if (n || o) {
                    n && !n.isStatic && (r.rotate(a, n.angle - e.angleA, a), e.angleA = n.angle), o && !o.isStatic && (r.rotate(s, o.angle - e.angleB, s), e.angleB = o.angle);
                    var l = a,
                        c = s;
                    if (n && (l = r.add(n.position, a)), o && (c = r.add(o.position, s)), l && c) {
                        var u = r.sub(l, c),
                            d = r.magnitude(u);
                        d < i._minLength && (d = i._minLength);
                        var p, f, v, y, m, g = (d - e.length) / d,
                            x = e.stiffness < 1 ? e.stiffness * t : e.stiffness,
                            h = r.mult(u, g * x),
                            b = (n ? n.inverseMass : 0) + (o ? o.inverseMass : 0),
                            S = b + ((n ? n.inverseInertia : 0) + (o ? o.inverseInertia : 0));
                        if (e.damping) {
                            var w = r.create();
                            v = r.div(u, d), m = r.sub(o && r.sub(o.position, o.positionPrev) || w, n && r.sub(n.position, n.positionPrev) || w), y = r.dot(v, m)
                        }
                        n && !n.isStatic && (f = n.inverseMass / b, n.constraintImpulse.x -= h.x * f, n.constraintImpulse.y -= h.y * f, n.position.x -= h.x * f, n.position.y -= h.y * f, e.damping && (n.positionPrev.x -= e.damping * v.x * y * f, n.positionPrev.y -= e.damping * v.y * y * f), p = r.cross(a, h) / S * i._torqueDampen * n.inverseInertia * (1 - e.angularStiffness), n.constraintImpulse.angle -= p, n.angle -= p), o && !o.isStatic && (f = o.inverseMass / b, o.constraintImpulse.x += h.x * f, o.constraintImpulse.y += h.y * f, o.position.x += h.x * f, o.position.y += h.y * f, e.damping && (o.positionPrev.x += e.damping * v.x * y * f, o.positionPrev.y += e.damping * v.y * y * f), p = r.cross(s, h) / S * i._torqueDampen * o.inverseInertia * (1 - e.angularStiffness), o.constraintImpulse.angle += p, o.angle += p)
                    }
                }
            }, i.postSolveAll = function(e) {
                for (var t = 0; t < e.length; t++) {
                    var n = e[t],
                        c = n.constraintImpulse;
                    if (!(n.isStatic || 0 === c.x && 0 === c.y && 0 === c.angle)) {
                        a.set(n, !1);
                        for (var u = 0; u < n.parts.length; u++) {
                            var d = n.parts[u];
                            o.translate(d.vertices, c), u > 0 && (d.position.x += c.x, d.position.y += c.y), 0 !== c.angle && (o.rotate(d.vertices, c.angle, n.position), l.rotate(d.axes, c.angle), u > 0 && r.rotateAbout(d.position, c.angle, n.position, d.position)), s.update(d.bounds, d.vertices, n.velocity)
                        }
                        c.angle *= i._warming, c.x *= i._warming, c.y *= i._warming
                    }
                }
            }, i.pointAWorld = function(e) {
                return {
                    x: (e.bodyA ? e.bodyA.position.x : 0) + e.pointA.x,
                    y: (e.bodyA ? e.bodyA.position.y : 0) + e.pointA.y
                }
            }, i.pointBWorld = function(e) {
                return {
                    x: (e.bodyB ? e.bodyB.position.x : 0) + e.pointB.x,
                    y: (e.bodyB ? e.bodyB.position.y : 0) + e.pointB.y
                }
            }
        }, function(e, t, n) {
            var i = {};
            e.exports = i;
            var o = n(2),
                r = n(0);
            i.fromVertices = function(e) {
                for (var t = {}, n = 0; n < e.length; n++) {
                    var i = (n + 1) % e.length,
                        a = o.normalise({
                            x: e[i].y - e[n].y,
                            y: e[n].x - e[i].x
                        }),
                        s = 0 === a.y ? 1 / 0 : a.x / a.y;
                    t[s = s.toFixed(3).toString()] = a
                }
                return r.values(t)
            }, i.rotate = function(e, t) {
                if (0 !== t)
                    for (var n = Math.cos(t), i = Math.sin(t), o = 0; o < e.length; o++) {
                        var r, a = e[o];
                        r = a.x * n - a.y * i, a.y = a.x * i + a.y * n, a.x = r
                    }
            }
        }, function(e, t, n) {
            var i = {};
            e.exports = i;
            var o = n(3),
                r = n(0),
                a = n(6),
                s = n(1),
                l = n(2);
            i.rectangle = function(e, t, n, i, s) {
                s = s || {};
                var l = {
                    label: "Rectangle Body",
                    position: {
                        x: e,
                        y: t
                    },
                    vertices: o.fromPath("L 0 0 L " + n + " 0 L " + n + " " + i + " L 0 " + i)
                };
                if (s.chamfer) {
                    var c = s.chamfer;
                    l.vertices = o.chamfer(l.vertices, c.radius, c.quality, c.qualityMin, c.qualityMax), delete s.chamfer
                }
                return a.create(r.extend({}, l, s))
            }, i.trapezoid = function(e, t, n, i, s, l) {
                l = l || {};
                var c, u = n * (s *= .5),
                    d = u + (1 - 2 * s) * n,
                    p = d + u;
                c = s < .5 ? "L 0 0 L " + u + " " + -i + " L " + d + " " + -i + " L " + p + " 0" : "L 0 0 L " + d + " " + -i + " L " + p + " 0";
                var f = {
                    label: "Trapezoid Body",
                    position: {
                        x: e,
                        y: t
                    },
                    vertices: o.fromPath(c)
                };
                if (l.chamfer) {
                    var v = l.chamfer;
                    f.vertices = o.chamfer(f.vertices, v.radius, v.quality, v.qualityMin, v.qualityMax), delete l.chamfer
                }
                return a.create(r.extend({}, f, l))
            }, i.circle = function(e, t, n, o, a) {
                o = o || {};
                var s = {
                    label: "Circle Body",
                    circleRadius: n
                };
                a = a || 25;
                var l = Math.ceil(Math.max(10, Math.min(a, n)));
                return l % 2 == 1 && (l += 1), i.polygon(e, t, l, n, r.extend({}, s, o))
            }, i.polygon = function(e, t, n, s, l) {
                if (l = l || {}, n < 3) return i.circle(e, t, s, l);
                for (var c = 2 * Math.PI / n, u = "", d = .5 * c, p = 0; p < n; p += 1) {
                    var f = d + p * c,
                        v = Math.cos(f) * s,
                        y = Math.sin(f) * s;
                    u += "L " + v.toFixed(3) + " " + y.toFixed(3) + " "
                }
                var m = {
                    label: "Polygon Body",
                    position: {
                        x: e,
                        y: t
                    },
                    vertices: o.fromPath(u)
                };
                if (l.chamfer) {
                    var g = l.chamfer;
                    m.vertices = o.chamfer(m.vertices, g.radius, g.quality, g.qualityMin, g.qualityMax), delete l.chamfer
                }
                return a.create(r.extend({}, m, l))
            }, i.fromVertices = function(e, t, n, i, c, u, d, p) {
                var f, v, y, m, g, x, h, b, S, w, _ = r.getDecomp();
                for (f = Boolean(_ && _.quickDecomp), i = i || {}, y = [], c = void 0 !== c && c, u = void 0 !== u ? u : .01, d = void 0 !== d ? d : 10, p = void 0 !== p ? p : .01, r.isArray(n[0]) || (n = [n]), S = 0; S < n.length; S += 1)
                    if (g = n[S], !(m = o.isConvex(g)) && !f && r.warnOnce("Bodies.fromVertices: Install the 'poly-decomp' library and use Common.setDecomp or provide 'decomp' as a global to decompose concave vertices."), m || !f) g = m ? o.clockwiseSort(g) : o.hull(g), y.push({
                        position: {
                            x: e,
                            y: t
                        },
                        vertices: g
                    });
                    else {
                        var A = g.map((function(e) {
                            return [e.x, e.y]
                        }));
                        _.makeCCW(A), !1 !== u && _.removeCollinearPoints(A, u), !1 !== p && _.removeDuplicatePoints && _.removeDuplicatePoints(A, p);
                        var P = _.quickDecomp(A);
                        for (x = 0; x < P.length; x++) {
                            var C = P[x].map((function(e) {
                                return {
                                    x: e[0],
                                    y: e[1]
                                }
                            }));
                            d > 0 && o.area(C) < d || y.push({
                                position: o.centre(C),
                                vertices: C
                            })
                        }
                    }
                for (x = 0; x < y.length; x++) y[x] = a.create(r.extend(y[x], i));
                if (c)
                    for (x = 0; x < y.length; x++) {
                        var M = y[x];
                        for (h = x + 1; h < y.length; h++) {
                            var B = y[h];
                            if (s.overlaps(M.bounds, B.bounds)) {
                                var k = M.vertices,
                                    I = B.vertices;
                                for (b = 0; b < M.vertices.length; b++)
                                    for (w = 0; w < B.vertices.length; w++) {
                                        var T = l.magnitudeSquared(l.sub(k[(b + 1) % k.length], I[w])),
                                            R = l.magnitudeSquared(l.sub(k[b], I[(w + 1) % I.length]));
                                        T < 5 && R < 5 && (k[b].isInternal = !0, I[w].isInternal = !0)
                                    }
                            }
                        }
                    }
                return y.length > 1 ? (v = a.create(r.extend({
                    parts: y.slice(0)
                }, i)), a.setPosition(v, {
                    x: e,
                    y: t
                }), v) : y[0]
            }
        }, function(e, t, n) {
            var i = {};
            e.exports = i;
            var o = n(0);
            i.create = function(e) {
                var t = {};
                return e || o.log("Mouse.create: element was undefined, defaulting to document.body", "warn"), t.element = e || document.body, t.absolute = {
                    x: 0,
                    y: 0
                }, t.position = {
                    x: 0,
                    y: 0
                }, t.mousedownPosition = {
                    x: 0,
                    y: 0
                }, t.mouseupPosition = {
                    x: 0,
                    y: 0
                }, t.offset = {
                    x: 0,
                    y: 0
                }, t.scale = {
                    x: 1,
                    y: 1
                }, t.wheelDelta = 0, t.button = -1, t.pixelRatio = parseInt(t.element.getAttribute("data-pixel-ratio"), 10) || 1, t.sourceEvents = {
                    mousemove: null,
                    mousedown: null,
                    mouseup: null,
                    mousewheel: null
                }, t.mousemove = function(e) {
                    var n = i._getRelativeMousePosition(e, t.element, t.pixelRatio);
                    e.changedTouches && (t.button = 0, e.preventDefault()), t.absolute.x = n.x, t.absolute.y = n.y, t.position.x = t.absolute.x * t.scale.x + t.offset.x, t.position.y = t.absolute.y * t.scale.y + t.offset.y, t.sourceEvents.mousemove = e
                }, t.mousedown = function(e) {
                    var n = i._getRelativeMousePosition(e, t.element, t.pixelRatio);
                    e.changedTouches ? (t.button = 0, e.preventDefault()) : t.button = e.button, t.absolute.x = n.x, t.absolute.y = n.y, t.position.x = t.absolute.x * t.scale.x + t.offset.x, t.position.y = t.absolute.y * t.scale.y + t.offset.y, t.mousedownPosition.x = t.position.x, t.mousedownPosition.y = t.position.y, t.sourceEvents.mousedown = e
                }, t.mouseup = function(e) {
                    var n = i._getRelativeMousePosition(e, t.element, t.pixelRatio);
                    e.changedTouches && e.preventDefault(), t.button = -1, t.absolute.x = n.x, t.absolute.y = n.y, t.position.x = t.absolute.x * t.scale.x + t.offset.x, t.position.y = t.absolute.y * t.scale.y + t.offset.y, t.mouseupPosition.x = t.position.x, t.mouseupPosition.y = t.position.y, t.sourceEvents.mouseup = e
                }, t.mousewheel = function(e) {
                    t.wheelDelta = Math.max(-1, Math.min(1, e.wheelDelta || -e.detail)), e.preventDefault()
                }, i.setElement(t, t.element), t
            }, i.setElement = function(e, t) {
                e.element = t, t.addEventListener("mousemove", e.mousemove), t.addEventListener("mousedown", e.mousedown), t.addEventListener("mouseup", e.mouseup), t.addEventListener("mousewheel", e.mousewheel), t.addEventListener("DOMMouseScroll", e.mousewheel), t.addEventListener("touchmove", e.mousemove), t.addEventListener("touchstart", e.mousedown), t.addEventListener("touchend", e.mouseup)
            }, i.clearSourceEvents = function(e) {
                e.sourceEvents.mousemove = null, e.sourceEvents.mousedown = null, e.sourceEvents.mouseup = null, e.sourceEvents.mousewheel = null, e.wheelDelta = 0
            }, i.setOffset = function(e, t) {
                e.offset.x = t.x, e.offset.y = t.y, e.position.x = e.absolute.x * e.scale.x + e.offset.x, e.position.y = e.absolute.y * e.scale.y + e.offset.y
            }, i.setScale = function(e, t) {
                e.scale.x = t.x, e.scale.y = t.y, e.position.x = e.absolute.x * e.scale.x + e.offset.x, e.position.y = e.absolute.y * e.scale.y + e.offset.y
            }, i._getRelativeMousePosition = function(e, t, n) {
                var i, o, r = t.getBoundingClientRect(),
                    a = document.documentElement || document.body.parentNode || document.body,
                    s = void 0 !== window.pageXOffset ? window.pageXOffset : a.scrollLeft,
                    l = void 0 !== window.pageYOffset ? window.pageYOffset : a.scrollTop,
                    c = e.changedTouches;
                return c ? (i = c[0].pageX - r.left - s, o = c[0].pageY - r.top - l) : (i = e.pageX - r.left - s, o = e.pageY - r.top - l), {
                    x: i / (t.clientWidth / (t.width || t.clientWidth) * n),
                    y: o / (t.clientHeight / (t.height || t.clientHeight) * n)
                }
            }
        }, function(e, t, n) {
            var i = {};
            e.exports = i;
            var o = n(0),
                r = n(8);
            i.create = function(e) {
                return o.extend({
                    bodies: [],
                    pairs: null
                }, e)
            }, i.setBodies = function(e, t) {
                e.bodies = t.slice(0)
            }, i.clear = function(e) {
                e.bodies = []
            }, i.collisions = function(e) {
                var t, n, o = [],
                    a = e.pairs,
                    s = e.bodies,
                    l = s.length,
                    c = i.canCollide,
                    u = r.collides;
                for (s.sort(i._compareBoundsX), t = 0; t < l; t++) {
                    var d = s[t],
                        p = d.bounds,
                        f = d.bounds.max.x,
                        v = d.bounds.max.y,
                        y = d.bounds.min.y,
                        m = d.isStatic || d.isSleeping,
                        g = d.parts.length,
                        x = 1 === g;
                    for (n = t + 1; n < l; n++) {
                        var h = s[n];
                        if ((M = h.bounds).min.x > f) break;
                        if (!(v < M.min.y || y > M.max.y) && (!m || !h.isStatic && !h.isSleeping) && c(d.collisionFilter, h.collisionFilter)) {
                            var b = h.parts.length;
                            if (x && 1 === b)(P = u(d, h, a)) && o.push(P);
                            else
                                for (var S = b > 1 ? 1 : 0, w = g > 1 ? 1 : 0; w < g; w++)
                                    for (var _ = d.parts[w], A = (p = _.bounds, S); A < b; A++) {
                                        var P, C = h.parts[A],
                                            M = C.bounds;
                                        p.min.x > M.max.x || p.max.x < M.min.x || p.max.y < M.min.y || p.min.y > M.max.y || (P = u(_, C, a)) && o.push(P)
                                    }
                        }
                    }
                }
                return o
            }, i.canCollide = function(e, t) {
                return e.group === t.group && 0 !== e.group ? e.group > 0 : 0 != (e.mask & t.category) && 0 != (t.mask & e.category)
            }, i._compareBoundsX = function(e, t) {
                return e.bounds.min.x - t.bounds.min.x
            }
        }, function(e, t, n) {
            var i = {};
            e.exports = i;
            var o = n(0);
            i._registry = {}, i.register = function(e) {
                if (i.isPlugin(e) || o.warn("Plugin.register:", i.toString(e), "does not implement all required fields."), e.name in i._registry) {
                    var t = i._registry[e.name],
                        n = i.versionParse(e.version).number,
                        r = i.versionParse(t.version).number;
                    n > r ? (o.warn("Plugin.register:", i.toString(t), "was upgraded to", i.toString(e)), i._registry[e.name] = e) : n < r ? o.warn("Plugin.register:", i.toString(t), "can not be downgraded to", i.toString(e)) : e !== t && o.warn("Plugin.register:", i.toString(e), "is already registered to different plugin object")
                } else i._registry[e.name] = e;
                return e
            }, i.resolve = function(e) {
                return i._registry[i.dependencyParse(e).name]
            }, i.toString = function(e) {
                return "string" == typeof e ? e : (e.name || "anonymous") + "@" + (e.version || e.range || "0.0.0")
            }, i.isPlugin = function(e) {
                return e && e.name && e.version && e.install
            }, i.isUsed = function(e, t) {
                return e.used.indexOf(t) > -1
            }, i.isFor = function(e, t) {
                var n = e.for && i.dependencyParse(e.for);
                return !e.for || t.name === n.name && i.versionSatisfies(t.version, n.range)
            }, i.use = function(e, t) {
                if (e.uses = (e.uses || []).concat(t || []), 0 !== e.uses.length) {
                    for (var n = i.dependencies(e), r = o.topologicalSort(n), a = [], s = 0; s < r.length; s += 1)
                        if (r[s] !== e.name) {
                            var l = i.resolve(r[s]);
                            l ? i.isUsed(e, l.name) || (i.isFor(l, e) || (o.warn("Plugin.use:", i.toString(l), "is for", l.for, "but installed on", i.toString(e) + "."), l._warned = !0), l.install ? l.install(e) : (o.warn("Plugin.use:", i.toString(l), "does not specify an install function."), l._warned = !0), l._warned ? (a.push("🔶 " + i.toString(l)), delete l._warned) : a.push("✅ " + i.toString(l)), e.used.push(l.name)) : a.push("❌ " + r[s])
                        }
                    a.length > 0 && o.info(a.join("  "))
                } else o.warn("Plugin.use:", i.toString(e), "does not specify any dependencies to install.")
            }, i.dependencies = function(e, t) {
                var n = i.dependencyParse(e),
                    r = n.name;
                if (!(r in (t = t || {}))) {
                    e = i.resolve(e) || e, t[r] = o.map(e.uses || [], (function(t) {
                        i.isPlugin(t) && i.register(t);
                        var r = i.dependencyParse(t),
                            a = i.resolve(t);
                        return a && !i.versionSatisfies(a.version, r.range) ? (o.warn("Plugin.dependencies:", i.toString(a), "does not satisfy", i.toString(r), "used by", i.toString(n) + "."), a._warned = !0, e._warned = !0) : a || (o.warn("Plugin.dependencies:", i.toString(t), "used by", i.toString(n), "could not be resolved."), e._warned = !0), r.name
                    }));
                    for (var a = 0; a < t[r].length; a += 1) i.dependencies(t[r][a], t);
                    return t
                }
            }, i.dependencyParse = function(e) {
                return o.isString(e) ? (/^[\w-]+(@(\*|[\^~]?\d+\.\d+\.\d+(-[0-9A-Za-z-+]+)?))?$/.test(e) || o.warn("Plugin.dependencyParse:", e, "is not a valid dependency string."), {
                    name: e.split("@")[0],
                    range: e.split("@")[1] || "*"
                }) : {
                    name: e.name,
                    range: e.range || e.version
                }
            }, i.versionParse = function(e) {
                var t = /^(\*)|(\^|~|>=|>)?\s*((\d+)\.(\d+)\.(\d+))(-[0-9A-Za-z-+]+)?$/;
                t.test(e) || o.warn("Plugin.versionParse:", e, "is not a valid version or range.");
                var n = t.exec(e),
                    i = Number(n[4]),
                    r = Number(n[5]),
                    a = Number(n[6]);
                return {
                    isRange: Boolean(n[1] || n[2]),
                    version: n[3],
                    range: e,
                    operator: n[1] || n[2] || "",
                    major: i,
                    minor: r,
                    patch: a,
                    parts: [i, r, a],
                    prerelease: n[7],
                    number: 1e8 * i + 1e4 * r + a
                }
            }, i.versionSatisfies = function(e, t) {
                t = t || "*";
                var n = i.versionParse(t),
                    o = i.versionParse(e);
                if (n.isRange) {
                    if ("*" === n.operator || "*" === e) return !0;
                    if (">" === n.operator) return o.number > n.number;
                    if (">=" === n.operator) return o.number >= n.number;
                    if ("~" === n.operator) return o.major === n.major && o.minor === n.minor && o.patch >= n.patch;
                    if ("^" === n.operator) return n.major > 0 ? o.major === n.major && o.number >= n.number : n.minor > 0 ? o.minor === n.minor && o.patch >= n.patch : o.patch === n.patch
                }
                return e === t || "*" === e
            }
        }, function(e, t, n) {
            var i = {};
            e.exports = i;
            var o = n(0),
                r = n(5),
                a = n(1),
                s = n(4),
                l = n(2),
                c = n(13);
            ! function() {
                var e, t;
                "undefined" != typeof window && (e = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || function(e) {
                    window.setTimeout((function() {
                        e(o.now())
                    }), 1e3 / 60)
                }, t = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame), i._goodFps = 30, i._goodDelta = 1e3 / 60, i.create = function(e) {
                    var t = {
                            controller: i,
                            engine: null,
                            element: null,
                            canvas: null,
                            mouse: null,
                            frameRequestId: null,
                            timing: {
                                historySize: 60,
                                delta: 0,
                                deltaHistory: [],
                                lastTime: 0,
                                lastTimestamp: 0,
                                lastElapsed: 0,
                                timestampElapsed: 0,
                                timestampElapsedHistory: [],
                                engineDeltaHistory: [],
                                engineElapsedHistory: [],
                                elapsedHistory: []
                            },
                            options: {
                                width: 800,
                                height: 600,
                                pixelRatio: 1,
                                background: "#14151f",
                                wireframeBackground: "#14151f",
                                hasBounds: !!e.bounds,
                                enabled: !0,
                                wireframes: !0,
                                showSleeping: !0,
                                showDebug: !1,
                                showStats: !1,
                                showPerformance: !1,
                                showBounds: !1,
                                showVelocity: !1,
                                showCollisions: !1,
                                showSeparations: !1,
                                showAxes: !1,
                                showPositions: !1,
                                showAngleIndicator: !1,
                                showIds: !1,
                                showVertexNumbers: !1,
                                showConvexHulls: !1,
                                showInternalEdges: !1,
                                showMousePosition: !1
                            }
                        },
                        n = o.extend(t, e);
                    return n.canvas && (n.canvas.width = n.options.width || n.canvas.width, n.canvas.height = n.options.height || n.canvas.height), n.mouse = e.mouse, n.engine = e.engine, n.canvas = n.canvas || _createCanvas(n.options.width, n.options.height), n.context = n.canvas.getContext("2d"), n.textures = {}, n.bounds = n.bounds || {
                        min: {
                            x: 0,
                            y: 0
                        },
                        max: {
                            x: n.canvas.width,
                            y: n.canvas.height
                        }
                    }, n.options.showBroadphase = !1, 1 !== n.options.pixelRatio && i.setPixelRatio(n, n.options.pixelRatio), o.isElement(n.element) ? n.element.appendChild(n.canvas) : n.canvas.parentNode || o.log("Render.create: options.element was undefined, render.canvas was created but not appended", "warn"), n
                }, i.run = function(t) {
                    ! function loop(n) {
                        t.frameRequestId = e(loop), _updateTiming(t, n), i.world(t, n), (t.options.showStats || t.options.showDebug) && i.stats(t, t.context, n), (t.options.showPerformance || t.options.showDebug) && i.performance(t, t.context, n)
                    }()
                }, i.stop = function(e) {
                    t(e.frameRequestId)
                }, i.setPixelRatio = function(e, t) {
                    var n = e.options,
                        i = e.canvas;
                    "auto" === t && (t = _getPixelRatio(i)), n.pixelRatio = t, i.setAttribute("data-pixel-ratio", t), i.width = n.width * t, i.height = n.height * t, i.style.width = n.width + "px", i.style.height = n.height + "px"
                }, i.lookAt = function(e, t, n, i) {
                    i = void 0 === i || i, t = o.isArray(t) ? t : [t], n = n || {
                        x: 0,
                        y: 0
                    };
                    for (var r = {
                            min: {
                                x: 1 / 0,
                                y: 1 / 0
                            },
                            max: {
                                x: -1 / 0,
                                y: -1 / 0
                            }
                        }, a = 0; a < t.length; a += 1) {
                        var s = t[a],
                            l = s.bounds ? s.bounds.min : s.min || s.position || s,
                            u = s.bounds ? s.bounds.max : s.max || s.position || s;
                        l && u && (l.x < r.min.x && (r.min.x = l.x), u.x > r.max.x && (r.max.x = u.x), l.y < r.min.y && (r.min.y = l.y), u.y > r.max.y && (r.max.y = u.y))
                    }
                    var d = r.max.x - r.min.x + 2 * n.x,
                        p = r.max.y - r.min.y + 2 * n.y,
                        f = e.canvas.height,
                        v = e.canvas.width / f,
                        y = d / p,
                        m = 1,
                        g = 1;
                    y > v ? g = y / v : m = v / y, e.options.hasBounds = !0, e.bounds.min.x = r.min.x, e.bounds.max.x = r.min.x + d * m, e.bounds.min.y = r.min.y, e.bounds.max.y = r.min.y + p * g, i && (e.bounds.min.x += .5 * d - d * m * .5, e.bounds.max.x += .5 * d - d * m * .5, e.bounds.min.y += .5 * p - p * g * .5, e.bounds.max.y += .5 * p - p * g * .5), e.bounds.min.x -= n.x, e.bounds.max.x -= n.x, e.bounds.min.y -= n.y, e.bounds.max.y -= n.y, e.mouse && (c.setScale(e.mouse, {
                        x: (e.bounds.max.x - e.bounds.min.x) / e.canvas.width,
                        y: (e.bounds.max.y - e.bounds.min.y) / e.canvas.height
                    }), c.setOffset(e.mouse, e.bounds.min))
                }, i.startViewTransform = function(e) {
                    var t = e.bounds.max.x - e.bounds.min.x,
                        n = e.bounds.max.y - e.bounds.min.y,
                        i = t / e.options.width,
                        o = n / e.options.height;
                    e.context.setTransform(e.options.pixelRatio / i, 0, 0, e.options.pixelRatio / o, 0, 0), e.context.translate(-e.bounds.min.x, -e.bounds.min.y)
                }, i.endViewTransform = function(e) {
                    e.context.setTransform(e.options.pixelRatio, 0, 0, e.options.pixelRatio, 0, 0)
                }, i.world = function(e, t) {
                    var n, u = o.now(),
                        d = e.engine,
                        p = d.world,
                        f = e.canvas,
                        v = e.context,
                        y = e.options,
                        m = e.timing,
                        g = r.allBodies(p),
                        x = r.allConstraints(p),
                        h = y.wireframes ? y.wireframeBackground : y.background,
                        b = [],
                        S = [],
                        w = {
                            timestamp: d.timing.timestamp
                        };
                    if (s.trigger(e, "beforeRender", w), e.currentBackground !== h && _applyBackground(e, h), v.globalCompositeOperation = "source-in", v.fillStyle = "transparent", v.fillRect(0, 0, f.width, f.height), v.globalCompositeOperation = "source-over", y.hasBounds) {
                        for (n = 0; n < g.length; n++) {
                            var _ = g[n];
                            a.overlaps(_.bounds, e.bounds) && b.push(_)
                        }
                        for (n = 0; n < x.length; n++) {
                            var A = x[n],
                                P = A.bodyA,
                                C = A.bodyB,
                                M = A.pointA,
                                B = A.pointB;
                            P && (M = l.add(P.position, A.pointA)), C && (B = l.add(C.position, A.pointB)), M && B && ((a.contains(e.bounds, M) || a.contains(e.bounds, B)) && S.push(A))
                        }
                        i.startViewTransform(e), e.mouse && (c.setScale(e.mouse, {
                            x: (e.bounds.max.x - e.bounds.min.x) / e.options.width,
                            y: (e.bounds.max.y - e.bounds.min.y) / e.options.height
                        }), c.setOffset(e.mouse, e.bounds.min))
                    } else S = x, b = g, 1 !== e.options.pixelRatio && e.context.setTransform(e.options.pixelRatio, 0, 0, e.options.pixelRatio, 0, 0);
                    !y.wireframes || d.enableSleeping && y.showSleeping ? i.bodies(e, b, v) : (y.showConvexHulls && i.bodyConvexHulls(e, b, v), i.bodyWireframes(e, b, v)), y.showBounds && i.bodyBounds(e, b, v), (y.showAxes || y.showAngleIndicator) && i.bodyAxes(e, b, v), y.showPositions && i.bodyPositions(e, b, v), y.showVelocity && i.bodyVelocity(e, b, v), y.showIds && i.bodyIds(e, b, v), y.showSeparations && i.separations(e, d.pairs.list, v), y.showCollisions && i.collisions(e, d.pairs.list, v), y.showVertexNumbers && i.vertexNumbers(e, b, v), y.showMousePosition && i.mousePosition(e, e.mouse, v), i.constraints(S, v), y.hasBounds && i.endViewTransform(e), s.trigger(e, "afterRender", w), m.lastElapsed = o.now() - u
                }, i.stats = function(e, t, n) {
                    for (var i = e.engine, o = i.world, a = r.allBodies(o), s = 0, l = 0, c = 0; c < a.length; c += 1) s += a[c].parts.length;
                    var u = {
                        Part: s,
                        Body: a.length,
                        Cons: r.allConstraints(o).length,
                        Comp: r.allComposites(o).length,
                        Pair: i.pairs.list.length
                    };
                    for (var d in t.fillStyle = "#0e0f19", t.fillRect(l, 0, 302.5, 44), t.font = "12px Arial", t.textBaseline = "top", t.textAlign = "right", u) {
                        var p = u[d];
                        t.fillStyle = "#aaa", t.fillText(d, l + 55, 8), t.fillStyle = "#eee", t.fillText(p, l + 55, 26), l += 55
                    }
                }, i.performance = function(e, t) {
                    var n = e.engine,
                        o = e.timing,
                        r = o.deltaHistory,
                        a = o.elapsedHistory,
                        s = o.timestampElapsedHistory,
                        l = o.engineDeltaHistory,
                        c = o.engineElapsedHistory,
                        u = n.timing.lastDelta,
                        d = _mean(r),
                        p = _mean(a),
                        f = _mean(l),
                        v = _mean(c),
                        y = _mean(s) / d || 0,
                        m = 1e3 / d || 0;
                    t.fillStyle = "#0e0f19", t.fillRect(0, 50, 370, 34), i.status(t, 10, 69, 60, 4, r.length, Math.round(m) + " fps", m / i._goodFps, (function(e) {
                        return r[e] / d - 1
                    })), i.status(t, 82, 69, 60, 4, l.length, u.toFixed(2) + " dt", i._goodDelta / u, (function(e) {
                        return l[e] / f - 1
                    })), i.status(t, 154, 69, 60, 4, c.length, v.toFixed(2) + " ut", 1 - v / i._goodFps, (function(e) {
                        return c[e] / v - 1
                    })), i.status(t, 226, 69, 60, 4, a.length, p.toFixed(2) + " rt", 1 - p / i._goodFps, (function(e) {
                        return a[e] / p - 1
                    })), i.status(t, 298, 69, 60, 4, s.length, y.toFixed(2) + " x", y * y * y, (function(e) {
                        return (s[e] / r[e] / y || 0) - 1
                    }))
                }, i.status = function(e, t, n, i, r, a, s, l, c) {
                    e.strokeStyle = "#888", e.fillStyle = "#444", e.lineWidth = 1, e.fillRect(t, n + 7, i, 1), e.beginPath(), e.moveTo(t, n + 7 - r * o.clamp(.4 * c(0), -2, 2));
                    for (var u = 0; u < i; u += 1) e.lineTo(t + u, n + 7 - (u < a ? r * o.clamp(.4 * c(u), -2, 2) : 0));
                    e.stroke(), e.fillStyle = "hsl(" + o.clamp(25 + 95 * l, 0, 120) + ",100%,60%)", e.fillRect(t, n - 7, 4, 4), e.font = "12px Arial", e.textBaseline = "middle", e.textAlign = "right", e.fillStyle = "#eee", e.fillText(s, t + i, n - 5)
                }, i.constraints = function(e, t) {
                    for (var n = t, i = 0; i < e.length; i++) {
                        var r = e[i];
                        if (r.render.visible && r.pointA && r.pointB) {
                            var a, s, c = r.bodyA,
                                u = r.bodyB;
                            if (a = c ? l.add(c.position, r.pointA) : r.pointA, "pin" === r.render.type) n.beginPath(), n.arc(a.x, a.y, 3, 0, 2 * Math.PI), n.closePath();
                            else {
                                if (s = u ? l.add(u.position, r.pointB) : r.pointB, n.beginPath(), n.moveTo(a.x, a.y), "spring" === r.render.type)
                                    for (var d, p = l.sub(s, a), f = l.perp(l.normalise(p)), v = Math.ceil(o.clamp(r.length / 5, 12, 20)), y = 1; y < v; y += 1) d = y % 2 == 0 ? 1 : -1, n.lineTo(a.x + p.x * (y / v) + f.x * d * 4, a.y + p.y * (y / v) + f.y * d * 4);
                                n.lineTo(s.x, s.y)
                            }
                            r.render.lineWidth && (n.lineWidth = r.render.lineWidth, n.strokeStyle = r.render.strokeStyle, n.stroke()), r.render.anchors && (n.fillStyle = r.render.strokeStyle, n.beginPath(), n.arc(a.x, a.y, 3, 0, 2 * Math.PI), n.arc(s.x, s.y, 3, 0, 2 * Math.PI), n.closePath(), n.fill())
                        }
                    }
                }, i.bodies = function(e, t, n) {
                    var i, o, r, a, s = n,
                        l = (e.engine, e.options),
                        c = l.showInternalEdges || !l.wireframes;
                    for (r = 0; r < t.length; r++)
                        if ((i = t[r]).render.visible)
                            for (a = i.parts.length > 1 ? 1 : 0; a < i.parts.length; a++)
                                if ((o = i.parts[a]).render.visible) {
                                    if (l.showSleeping && i.isSleeping ? s.globalAlpha = .5 * o.render.opacity : 1 !== o.render.opacity && (s.globalAlpha = o.render.opacity), o.render.sprite && o.render.sprite.texture && !l.wireframes) {
                                        var u = o.render.sprite,
                                            d = _getTexture(e, u.texture);
                                        s.translate(o.position.x, o.position.y), s.rotate(o.angle), s.drawImage(d, d.width * -u.xOffset * u.xScale, d.height * -u.yOffset * u.yScale, d.width * u.xScale, d.height * u.yScale), s.rotate(-o.angle), s.translate(-o.position.x, -o.position.y)
                                    } else {
                                        if (o.circleRadius) s.beginPath(), s.arc(o.position.x, o.position.y, o.circleRadius, 0, 2 * Math.PI);
                                        else {
                                            s.beginPath(), s.moveTo(o.vertices[0].x, o.vertices[0].y);
                                            for (var p = 1; p < o.vertices.length; p++) !o.vertices[p - 1].isInternal || c ? s.lineTo(o.vertices[p].x, o.vertices[p].y) : s.moveTo(o.vertices[p].x, o.vertices[p].y), o.vertices[p].isInternal && !c && s.moveTo(o.vertices[(p + 1) % o.vertices.length].x, o.vertices[(p + 1) % o.vertices.length].y);
                                            s.lineTo(o.vertices[0].x, o.vertices[0].y), s.closePath()
                                        }
                                        l.wireframes ? (s.lineWidth = 1, s.strokeStyle = "#bbb", s.stroke()) : (s.fillStyle = o.render.fillStyle, o.render.lineWidth && (s.lineWidth = o.render.lineWidth, s.strokeStyle = o.render.strokeStyle, s.stroke()), s.fill())
                                    }
                                    s.globalAlpha = 1
                                }
                }, i.bodyWireframes = function(e, t, n) {
                    var i, o, r, a, s, l = n,
                        c = e.options.showInternalEdges;
                    for (l.beginPath(), r = 0; r < t.length; r++)
                        if ((i = t[r]).render.visible)
                            for (s = i.parts.length > 1 ? 1 : 0; s < i.parts.length; s++) {
                                for (o = i.parts[s], l.moveTo(o.vertices[0].x, o.vertices[0].y), a = 1; a < o.vertices.length; a++) !o.vertices[a - 1].isInternal || c ? l.lineTo(o.vertices[a].x, o.vertices[a].y) : l.moveTo(o.vertices[a].x, o.vertices[a].y), o.vertices[a].isInternal && !c && l.moveTo(o.vertices[(a + 1) % o.vertices.length].x, o.vertices[(a + 1) % o.vertices.length].y);
                                l.lineTo(o.vertices[0].x, o.vertices[0].y)
                            }
                        l.lineWidth = 1, l.strokeStyle = "#bbb", l.stroke()
                }, i.bodyConvexHulls = function(e, t, n) {
                    var i, o, r, a = n;
                    for (a.beginPath(), o = 0; o < t.length; o++)
                        if ((i = t[o]).render.visible && 1 !== i.parts.length) {
                            for (a.moveTo(i.vertices[0].x, i.vertices[0].y), r = 1; r < i.vertices.length; r++) a.lineTo(i.vertices[r].x, i.vertices[r].y);
                            a.lineTo(i.vertices[0].x, i.vertices[0].y)
                        }
                    a.lineWidth = 1, a.strokeStyle = "rgba(255,255,255,0.2)", a.stroke()
                }, i.vertexNumbers = function(e, t, n) {
                    var i, o, r, a = n;
                    for (i = 0; i < t.length; i++) {
                        var s = t[i].parts;
                        for (r = s.length > 1 ? 1 : 0; r < s.length; r++) {
                            var l = s[r];
                            for (o = 0; o < l.vertices.length; o++) a.fillStyle = "rgba(255,255,255,0.2)", a.fillText(i + "_" + o, l.position.x + .8 * (l.vertices[o].x - l.position.x), l.position.y + .8 * (l.vertices[o].y - l.position.y))
                        }
                    }
                }, i.mousePosition = function(e, t, n) {
                    var i = n;
                    i.fillStyle = "rgba(255,255,255,0.8)", i.fillText(t.position.x + "  " + t.position.y, t.position.x + 5, t.position.y - 5)
                }, i.bodyBounds = function(e, t, n) {
                    var i = n,
                        o = (e.engine, e.options);
                    i.beginPath();
                    for (var r = 0; r < t.length; r++) {
                        if (t[r].render.visible)
                            for (var a = t[r].parts, s = a.length > 1 ? 1 : 0; s < a.length; s++) {
                                var l = a[s];
                                i.rect(l.bounds.min.x, l.bounds.min.y, l.bounds.max.x - l.bounds.min.x, l.bounds.max.y - l.bounds.min.y)
                            }
                    }
                    o.wireframes ? i.strokeStyle = "rgba(255,255,255,0.08)" : i.strokeStyle = "rgba(0,0,0,0.1)", i.lineWidth = 1, i.stroke()
                }, i.bodyAxes = function(e, t, n) {
                    var i, o, r, a, s = n,
                        l = (e.engine, e.options);
                    for (s.beginPath(), o = 0; o < t.length; o++) {
                        var c = t[o],
                            u = c.parts;
                        if (c.render.visible)
                            if (l.showAxes)
                                for (r = u.length > 1 ? 1 : 0; r < u.length; r++)
                                    for (i = u[r], a = 0; a < i.axes.length; a++) {
                                        var d = i.axes[a];
                                        s.moveTo(i.position.x, i.position.y), s.lineTo(i.position.x + 20 * d.x, i.position.y + 20 * d.y)
                                    } else
                                        for (r = u.length > 1 ? 1 : 0; r < u.length; r++)
                                            for (i = u[r], a = 0; a < i.axes.length; a++) s.moveTo(i.position.x, i.position.y), s.lineTo((i.vertices[0].x + i.vertices[i.vertices.length - 1].x) / 2, (i.vertices[0].y + i.vertices[i.vertices.length - 1].y) / 2)
                    }
                    l.wireframes ? (s.strokeStyle = "indianred", s.lineWidth = 1) : (s.strokeStyle = "rgba(255, 255, 255, 0.4)", s.globalCompositeOperation = "overlay", s.lineWidth = 2), s.stroke(), s.globalCompositeOperation = "source-over"
                }, i.bodyPositions = function(e, t, n) {
                    var i, o, r, a, s = n,
                        l = (e.engine, e.options);
                    for (s.beginPath(), r = 0; r < t.length; r++)
                        if ((i = t[r]).render.visible)
                            for (a = 0; a < i.parts.length; a++) o = i.parts[a], s.arc(o.position.x, o.position.y, 3, 0, 2 * Math.PI, !1), s.closePath();
                    for (l.wireframes ? s.fillStyle = "indianred" : s.fillStyle = "rgba(0,0,0,0.5)", s.fill(), s.beginPath(), r = 0; r < t.length; r++)(i = t[r]).render.visible && (s.arc(i.positionPrev.x, i.positionPrev.y, 2, 0, 2 * Math.PI, !1), s.closePath());
                    s.fillStyle = "rgba(255,165,0,0.8)", s.fill()
                }, i.bodyVelocity = function(e, t, n) {
                    var i = n;
                    i.beginPath();
                    for (var o = 0; o < t.length; o++) {
                        var r = t[o];
                        r.render.visible && (i.moveTo(r.position.x, r.position.y), i.lineTo(r.position.x + 2 * (r.position.x - r.positionPrev.x), r.position.y + 2 * (r.position.y - r.positionPrev.y)))
                    }
                    i.lineWidth = 3, i.strokeStyle = "cornflowerblue", i.stroke()
                }, i.bodyIds = function(e, t, n) {
                    var i, o, r = n;
                    for (i = 0; i < t.length; i++)
                        if (t[i].render.visible) {
                            var a = t[i].parts;
                            for (o = a.length > 1 ? 1 : 0; o < a.length; o++) {
                                var s = a[o];
                                r.font = "12px Arial", r.fillStyle = "rgba(255,255,255,0.5)", r.fillText(s.id, s.position.x + 10, s.position.y - 10)
                            }
                        }
                }, i.collisions = function(e, t, n) {
                    var i, o, r, a, s = n,
                        l = e.options;
                    for (s.beginPath(), r = 0; r < t.length; r++)
                        if ((i = t[r]).isActive)
                            for (o = i.collision, a = 0; a < i.activeContacts.length; a++) {
                                var c = i.activeContacts[a].vertex;
                                s.rect(c.x - 1.5, c.y - 1.5, 3.5, 3.5)
                            }
                        for (l.wireframes ? s.fillStyle = "rgba(255,255,255,0.7)" : s.fillStyle = "orange", s.fill(), s.beginPath(), r = 0; r < t.length; r++)
                            if ((i = t[r]).isActive && (o = i.collision, i.activeContacts.length > 0)) {
                                var u = i.activeContacts[0].vertex.x,
                                    d = i.activeContacts[0].vertex.y;
                                2 === i.activeContacts.length && (u = (i.activeContacts[0].vertex.x + i.activeContacts[1].vertex.x) / 2, d = (i.activeContacts[0].vertex.y + i.activeContacts[1].vertex.y) / 2), o.bodyB === o.supports[0].body || !0 === o.bodyA.isStatic ? s.moveTo(u - 8 * o.normal.x, d - 8 * o.normal.y) : s.moveTo(u + 8 * o.normal.x, d + 8 * o.normal.y), s.lineTo(u, d)
                            }
                    l.wireframes ? s.strokeStyle = "rgba(255,165,0,0.7)" : s.strokeStyle = "orange", s.lineWidth = 1, s.stroke()
                }, i.separations = function(e, t, n) {
                    var i, o, r, a, s, l = n,
                        c = e.options;
                    for (l.beginPath(), s = 0; s < t.length; s++)
                        if ((i = t[s]).isActive) {
                            r = (o = i.collision).bodyA;
                            var u = 1;
                            (a = o.bodyB).isStatic || r.isStatic || (u = .5), a.isStatic && (u = 0), l.moveTo(a.position.x, a.position.y), l.lineTo(a.position.x - o.penetration.x * u, a.position.y - o.penetration.y * u), u = 1, a.isStatic || r.isStatic || (u = .5), r.isStatic && (u = 0), l.moveTo(r.position.x, r.position.y), l.lineTo(r.position.x + o.penetration.x * u, r.position.y + o.penetration.y * u)
                        }
                    c.wireframes ? l.strokeStyle = "rgba(255,165,0,0.5)" : l.strokeStyle = "orange", l.stroke()
                }, i.inspector = function(e, t) {
                    e.engine;
                    var n, i = e.selected,
                        o = e.render,
                        r = o.options;
                    if (r.hasBounds) {
                        var a = o.bounds.max.x - o.bounds.min.x,
                            s = o.bounds.max.y - o.bounds.min.y,
                            l = a / o.options.width,
                            c = s / o.options.height;
                        t.scale(1 / l, 1 / c), t.translate(-o.bounds.min.x, -o.bounds.min.y)
                    }
                    for (var u = 0; u < i.length; u++) {
                        var d = i[u].data;
                        switch (t.translate(.5, .5), t.lineWidth = 1, t.strokeStyle = "rgba(255,165,0,0.9)", t.setLineDash([1, 2]), d.type) {
                            case "body":
                                n = d.bounds, t.beginPath(), t.rect(Math.floor(n.min.x - 3), Math.floor(n.min.y - 3), Math.floor(n.max.x - n.min.x + 6), Math.floor(n.max.y - n.min.y + 6)), t.closePath(), t.stroke();
                                break;
                            case "constraint":
                                var p = d.pointA;
                                d.bodyA && (p = d.pointB), t.beginPath(), t.arc(p.x, p.y, 10, 0, 2 * Math.PI), t.closePath(), t.stroke()
                        }
                        t.setLineDash([]), t.translate(-.5, -.5)
                    }
                    null !== e.selectStart && (t.translate(.5, .5), t.lineWidth = 1, t.strokeStyle = "rgba(255,165,0,0.6)", t.fillStyle = "rgba(255,165,0,0.1)", n = e.selectBounds, t.beginPath(), t.rect(Math.floor(n.min.x), Math.floor(n.min.y), Math.floor(n.max.x - n.min.x), Math.floor(n.max.y - n.min.y)), t.closePath(), t.stroke(), t.fill(), t.translate(-.5, -.5)), r.hasBounds && t.setTransform(1, 0, 0, 1, 0, 0)
                };
                var _updateTiming = function(e, t) {
                        var n = e.engine,
                            o = e.timing,
                            r = o.historySize,
                            a = n.timing.timestamp;
                        o.delta = t - o.lastTime || i._goodDelta, o.lastTime = t, o.timestampElapsed = a - o.lastTimestamp || 0, o.lastTimestamp = a, o.deltaHistory.unshift(o.delta), o.deltaHistory.length = Math.min(o.deltaHistory.length, r), o.engineDeltaHistory.unshift(n.timing.lastDelta), o.engineDeltaHistory.length = Math.min(o.engineDeltaHistory.length, r), o.timestampElapsedHistory.unshift(o.timestampElapsed), o.timestampElapsedHistory.length = Math.min(o.timestampElapsedHistory.length, r), o.engineElapsedHistory.unshift(n.timing.lastElapsed), o.engineElapsedHistory.length = Math.min(o.engineElapsedHistory.length, r), o.elapsedHistory.unshift(o.lastElapsed), o.elapsedHistory.length = Math.min(o.elapsedHistory.length, r)
                    },
                    _mean = function(e) {
                        for (var t = 0, n = 0; n < e.length; n += 1) t += e[n];
                        return t / e.length || 0
                    },
                    _createCanvas = function(e, t) {
                        var n = document.createElement("canvas");
                        return n.width = e, n.height = t, n.oncontextmenu = function() {
                            return !1
                        }, n.onselectstart = function() {
                            return !1
                        }, n
                    },
                    _getPixelRatio = function(e) {
                        var t = e.getContext("2d");
                        return (window.devicePixelRatio || 1) / (t.webkitBackingStorePixelRatio || t.mozBackingStorePixelRatio || t.msBackingStorePixelRatio || t.oBackingStorePixelRatio || t.backingStorePixelRatio || 1)
                    },
                    _getTexture = function(e, t) {
                        var n = e.textures[t];
                        return n || ((n = e.textures[t] = new Image).src = t, n)
                    },
                    _applyBackground = function(e, t) {
                        var n = t;
                        /(jpg|gif|png)$/.test(t) && (n = "url(" + t + ")"), e.canvas.style.background = n, e.canvas.style.backgroundSize = "contain", e.currentBackground = t
                    }
            }()
        }, function(e, t) {
            var n = {};
            e.exports = n, n.create = function(e) {
                return {
                    vertex: e,
                    normalImpulse: 0,
                    tangentImpulse: 0
                }
            }
        }, function(e, t, n) {
            var i = {};
            e.exports = i;
            var o = n(7),
                r = n(19),
                a = n(14),
                s = n(20),
                l = n(4),
                c = n(5),
                u = n(10),
                d = n(0),
                p = n(6);
            i.create = function(e) {
                e = e || {};
                var t = d.extend({
                    positionIterations: 6,
                    velocityIterations: 4,
                    constraintIterations: 2,
                    enableSleeping: !1,
                    events: [],
                    plugin: {},
                    gravity: {
                        x: 0,
                        y: 1,
                        scale: .001
                    },
                    timing: {
                        timestamp: 0,
                        timeScale: 1,
                        lastDelta: 0,
                        lastElapsed: 0
                    }
                }, e);
                return t.world = e.world || c.create({
                    label: "World"
                }), t.pairs = e.pairs || s.create(), t.detector = e.detector || a.create(), t.grid = {
                    buckets: []
                }, t.world.gravity = t.gravity, t.broadphase = t.grid, t.metrics = {}, t
            }, i.update = function(e, t, n) {
                var p = d.now();
                t = t || 1e3 / 60, n = n || 1;
                var f, v = e.world,
                    y = e.detector,
                    m = e.pairs,
                    g = e.timing,
                    x = g.timestamp;
                g.timestamp += t * g.timeScale, g.lastDelta = t * g.timeScale;
                var h = {
                    timestamp: g.timestamp
                };
                l.trigger(e, "beforeUpdate", h);
                var b = c.allBodies(v),
                    S = c.allConstraints(v);
                for (v.isModified && a.setBodies(y, b), v.isModified && c.setModified(v, !1, !1, !0), e.enableSleeping && o.update(b, g.timeScale), i._bodiesApplyGravity(b, e.gravity), i._bodiesUpdate(b, t, g.timeScale, n, v.bounds), u.preSolveAll(b), f = 0; f < e.constraintIterations; f++) u.solveAll(S, g.timeScale);
                u.postSolveAll(b), y.pairs = e.pairs;
                var w = a.collisions(y);
                for (s.update(m, w, x), e.enableSleeping && o.afterCollisions(m.list, g.timeScale), m.collisionStart.length > 0 && l.trigger(e, "collisionStart", {
                        pairs: m.collisionStart
                    }), r.preSolvePosition(m.list), f = 0; f < e.positionIterations; f++) r.solvePosition(m.list, g.timeScale);
                for (r.postSolvePosition(b), u.preSolveAll(b), f = 0; f < e.constraintIterations; f++) u.solveAll(S, g.timeScale);
                for (u.postSolveAll(b), r.preSolveVelocity(m.list), f = 0; f < e.velocityIterations; f++) r.solveVelocity(m.list, g.timeScale);
                return m.collisionActive.length > 0 && l.trigger(e, "collisionActive", {
                    pairs: m.collisionActive
                }), m.collisionEnd.length > 0 && l.trigger(e, "collisionEnd", {
                    pairs: m.collisionEnd
                }), i._bodiesClearForces(b), l.trigger(e, "afterUpdate", h), e.timing.lastElapsed = d.now() - p, e
            }, i.merge = function(e, t) {
                if (d.extend(e, t), t.world) {
                    e.world = t.world, i.clear(e);
                    for (var n = c.allBodies(e.world), r = 0; r < n.length; r++) {
                        var a = n[r];
                        o.set(a, !1), a.id = d.nextId()
                    }
                }
            }, i.clear = function(e) {
                s.clear(e.pairs), a.clear(e.detector)
            }, i._bodiesClearForces = function(e) {
                for (var t = 0; t < e.length; t++) {
                    var n = e[t];
                    n.force.x = 0, n.force.y = 0, n.torque = 0
                }
            }, i._bodiesApplyGravity = function(e, t) {
                var n = void 0 !== t.scale ? t.scale : .001;
                if ((0 !== t.x || 0 !== t.y) && 0 !== n)
                    for (var i = 0; i < e.length; i++) {
                        var o = e[i];
                        o.isStatic || o.isSleeping || (o.overrideGravity ? (o.force.y += o.mass * o.overrideGravity.y, o.force.x += o.mass * o.overrideGravity.x) : (o.force.y += o.mass * t.y * n, o.force.x += o.mass * t.x * n))
                    }
            }, i._bodiesUpdate = function(e, t, n, i, o) {
                for (var r = 0; r < e.length; r++) {
                    var a = e[r];
                    a.isKinematic || a.isStatic || a.isSleeping || p.update(a, t, n, i)
                }
            }
        }, function(e, t, n) {
            var i = {};
            e.exports = i;
            var o = n(3),
                r = n(1);
            i._restingThresh = 4, i._restingThreshTangent = 6, i._positionDampen = .9, i._positionWarming = .8, i._frictionNormalMultiplier = 5, i.preSolvePosition = function(e) {
                var t, n, i, o = e.length;
                for (t = 0; t < o; t++)(n = e[t]).isActive && (i = n.activeContacts.length, n.collision.parentA.totalContacts += i, n.collision.parentB.totalContacts += i)
            }, i.solvePosition = function(e, t) {
                var n, o, r, a, s, l, c, u, d = i._positionDampen,
                    p = e.length;
                for (n = 0; n < p; n++)(o = e[n]).isActive && !o.isSensor && (a = (r = o.collision).parentA, s = r.parentB, l = r.normal, o.separation = l.x * (s.positionImpulse.x + r.penetration.x - a.positionImpulse.x) + l.y * (s.positionImpulse.y + r.penetration.y - a.positionImpulse.y));
                for (n = 0; n < p; n++)(o = e[n]).isActive && !o.isSensor && (a = (r = o.collision).parentA, s = r.parentB, l = r.normal, u = (o.separation - o.slop) * t, (a.isStatic || s.isStatic) && (u *= 2), a.isStatic || a.isSleeping || (c = d / a.totalContacts, a.positionImpulse.x += l.x * u * c, a.positionImpulse.y += l.y * u * c), s.isStatic || s.isSleeping || (c = d / s.totalContacts, s.positionImpulse.x -= l.x * u * c, s.positionImpulse.y -= l.y * u * c))
            }, i.postSolvePosition = function(e) {
                for (var t = i._positionWarming, n = e.length, a = o.translate, s = r.update, l = 0; l < n; l++) {
                    var c = e[l],
                        u = c.positionImpulse,
                        d = u.x,
                        p = u.y,
                        f = c.velocity;
                    if (c.totalContacts = 0, 0 !== d || 0 !== p) {
                        for (var v = 0; v < c.parts.length; v++) {
                            var y = c.parts[v];
                            a(y.vertices, u), s(y.bounds, y.vertices, f), y.position.x += d, y.position.y += p
                        }
                        c.positionPrev.x += d, c.positionPrev.y += p, d * f.x + p * f.y < 0 ? (u.x = 0, u.y = 0) : (u.x *= t, u.y *= t)
                    }
                }
            }, i.preSolveVelocity = function(e) {
                var t, n, i = e.length;
                for (t = 0; t < i; t++) {
                    var o = e[t];
                    if (o.isActive && !o.isSensor) {
                        var r = o.activeContacts,
                            a = r.length,
                            s = o.collision,
                            l = s.parentA,
                            c = s.parentB,
                            u = s.normal,
                            d = s.tangent;
                        for (n = 0; n < a; n++) {
                            var p = r[n],
                                f = p.vertex,
                                v = p.normalImpulse,
                                y = p.tangentImpulse;
                            if (0 !== v || 0 !== y) {
                                var m = u.x * v + d.x * y,
                                    g = u.y * v + d.y * y;
                                l.isStatic || l.isSleeping || (l.positionPrev.x += m * l.inverseMass, l.positionPrev.y += g * l.inverseMass, l.anglePrev += l.inverseInertia * ((f.x - l.position.x) * g - (f.y - l.position.y) * m)), c.isStatic || c.isSleeping || (c.positionPrev.x -= m * c.inverseMass, c.positionPrev.y -= g * c.inverseMass, c.anglePrev -= c.inverseInertia * ((f.x - c.position.x) * g - (f.y - c.position.y) * m))
                            }
                        }
                    }
                }
            }, i.solveVelocity = function(e, t) {
                var n, o, r, a, s = t * t,
                    l = i._restingThresh * s,
                    c = i._frictionNormalMultiplier,
                    u = i._restingThreshTangent * s,
                    d = Number.MAX_VALUE,
                    p = e.length;
                for (r = 0; r < p; r++) {
                    var f = e[r];
                    if (f.isActive && !f.isSensor) {
                        var v = f.collision,
                            y = v.parentA,
                            m = v.parentB,
                            g = y.velocity,
                            x = m.velocity,
                            h = v.normal.x,
                            b = v.normal.y,
                            S = v.tangent.x,
                            w = v.tangent.y,
                            _ = f.activeContacts,
                            A = _.length,
                            P = 1 / A,
                            C = y.inverseMass + m.inverseMass,
                            M = f.friction * f.frictionStatic * c * s;
                        for (g.x = y.position.x - y.positionPrev.x, g.y = y.position.y - y.positionPrev.y, x.x = m.position.x - m.positionPrev.x, x.y = m.position.y - m.positionPrev.y, y.angularVelocity = y.angle - y.anglePrev, m.angularVelocity = m.angle - m.anglePrev, a = 0; a < A; a++) {
                            var B = _[a],
                                k = B.vertex,
                                I = k.x - y.position.x,
                                T = k.y - y.position.y,
                                R = k.x - m.position.x,
                                E = k.y - m.position.y,
                                V = g.x - T * y.angularVelocity,
                                L = g.y + I * y.angularVelocity,
                                q = V - (x.x - E * m.angularVelocity),
                                O = L - (x.y + R * m.angularVelocity),
                                D = h * q + b * O,
                                F = S * q + w * O,
                                H = f.separation + D,
                                j = Math.min(H, 1),
                                W = (j = H < 0 ? 0 : j) * M;
                            F > W || -F > W ? (o = F > 0 ? F : -F, (n = f.friction * (F > 0 ? 1 : -1) * s) < -o ? n = -o : n > o && (n = o)) : (n = F, o = d);
                            var G = I * b - T * h,
                                N = R * b - E * h,
                                U = P / (C + y.inverseInertia * G * G + m.inverseInertia * N * N),
                                z = (1 + f.restitution) * D * U;
                            if (n *= U, D * D > l && D < 0) B.normalImpulse = 0;
                            else {
                                var X = B.normalImpulse;
                                B.normalImpulse += z, B.normalImpulse = Math.min(B.normalImpulse, 0), z = B.normalImpulse - X
                            }
                            if (F * F > u) B.tangentImpulse = 0;
                            else {
                                var Q = B.tangentImpulse;
                                B.tangentImpulse += n, B.tangentImpulse < -o && (B.tangentImpulse = -o), B.tangentImpulse > o && (B.tangentImpulse = o), n = B.tangentImpulse - Q
                            }
                            var Y = h * z + S * n,
                                Z = b * z + w * n;
                            y.isStatic || y.isSleeping || (y.positionPrev.x += Y * y.inverseMass, y.positionPrev.y += Z * y.inverseMass, y.anglePrev += (I * Z - T * Y) * y.inverseInertia), m.isStatic || m.isSleeping || (m.positionPrev.x -= Y * m.inverseMass, m.positionPrev.y -= Z * m.inverseMass, m.anglePrev -= (R * Z - E * Y) * m.inverseInertia)
                        }
                    }
                }
            }
        }, function(e, t, n) {
            var i = {};
            e.exports = i;
            var o = n(9),
                r = n(0);
            i.create = function(e) {
                return r.extend({
                    table: {},
                    list: [],
                    collisionStart: [],
                    collisionActive: [],
                    collisionEnd: []
                }, e)
            }, i.update = function(e, t, n) {
                var i, r, a, s, l = e.list,
                    c = l.length,
                    u = e.table,
                    d = t.length,
                    p = e.collisionStart,
                    f = e.collisionEnd,
                    v = e.collisionActive;
                for (p.length = 0, f.length = 0, v.length = 0, s = 0; s < c; s++) l[s].confirmedActive = !1;
                for (s = 0; s < d; s++)(a = (i = t[s]).pair) ? (a.isActive ? v.push(a) : p.push(a), o.update(a, i, n), a.confirmedActive = !0) : (u[(a = o.create(i, n)).id] = a, p.push(a), l.push(a));
                var y = [];
                for (c = l.length, s = 0; s < c; s++)(a = l[s]).confirmedActive || (o.setActive(a, !1, n), f.push(a), a.collision.bodyA.isSleeping || a.collision.bodyB.isSleeping || y.push(s));
                for (s = 0; s < y.length; s++) a = l[r = y[s] - s], l.splice(r, 1), delete u[a.id]
            }, i.clear = function(e) {
                return e.table = {}, e.list.length = 0, e.collisionStart.length = 0, e.collisionActive.length = 0, e.collisionEnd.length = 0, e
            }
        }, function(e, t, n) {
            var i = e.exports = n(22);
            i.Axes = n(11), i.Bodies = n(12), i.Body = n(6), i.Bounds = n(1), i.Collision = n(8), i.Common = n(0), i.Composite = n(5), i.Composites = n(23), i.Constraint = n(10), i.Contact = n(17), i.Detector = n(14), i.Engine = n(18), i.Events = n(4), i.Grid = n(24), i.Mouse = n(13), i.MouseConstraint = n(25), i.Pair = n(9), i.Pairs = n(20), i.Plugin = n(15), i.Query = n(26), i.Render = n(16), i.Resolver = n(19), i.Runner = n(27), i.SAT = n(28), i.Sleeping = n(7), i.Svg = n(29), i.Vector = n(2), i.Vertices = n(3), i.World = n(30), i.Engine.run = i.Runner.run, i.Common.deprecated(i.Engine, "run", "Engine.run ➤ use Matter.Runner.run(engine) instead")
        }, function(e, t, n) {
            var i = {};
            e.exports = i, window.Matter = i;
            var o = n(15),
                r = n(0);
            i.name = "matter-js", i.version = "0.18.0", i.uses = [], i.used = [], i.use = function() {
                o.use(i, Array.prototype.slice.call(arguments))
            }, i.before = function(e, t) {
                return e = e.replace(/^Matter./, ""), r.chainPathBefore(i, e, t)
            }, i.after = function(e, t) {
                return e = e.replace(/^Matter./, ""), r.chainPathAfter(i, e, t)
            }
        }, function(e, t, n) {
            var i = {};
            e.exports = i;
            var o = n(5),
                r = n(10),
                a = n(0),
                s = n(6),
                l = n(12),
                c = a.deprecated;
            i.stack = function(e, t, n, i, r, a, l) {
                for (var c, u = o.create({
                        label: "Stack"
                    }), d = e, p = t, f = 0, v = 0; v < i; v++) {
                    for (var y = 0, m = 0; m < n; m++) {
                        var g = l(d, p, m, v, c, f);
                        if (g) {
                            var x = g.bounds.max.y - g.bounds.min.y,
                                h = g.bounds.max.x - g.bounds.min.x;
                            x > y && (y = x), s.translate(g, {
                                x: .5 * h,
                                y: .5 * x
                            }), d = g.bounds.max.x + r, o.addBody(u, g), c = g, f += 1
                        } else d += r
                    }
                    p += y + a, d = e
                }
                return u
            }, i.chain = function(e, t, n, i, s, l) {
                for (var c = e.bodies, u = 1; u < c.length; u++) {
                    var d = c[u - 1],
                        p = c[u],
                        f = d.bounds.max.y - d.bounds.min.y,
                        v = d.bounds.max.x - d.bounds.min.x,
                        y = p.bounds.max.y - p.bounds.min.y,
                        m = {
                            bodyA: d,
                            pointA: {
                                x: v * t,
                                y: f * n
                            },
                            bodyB: p,
                            pointB: {
                                x: (p.bounds.max.x - p.bounds.min.x) * i,
                                y: y * s
                            }
                        },
                        g = a.extend(m, l);
                    o.addConstraint(e, r.create(g))
                }
                return e.label += " Chain", e
            }, i.mesh = function(e, t, n, i, s) {
                var l, c, u, d, p, f = e.bodies;
                for (l = 0; l < n; l++) {
                    for (c = 1; c < t; c++) u = f[c - 1 + l * t], d = f[c + l * t], o.addConstraint(e, r.create(a.extend({
                        bodyA: u,
                        bodyB: d
                    }, s)));
                    if (l > 0)
                        for (c = 0; c < t; c++) u = f[c + (l - 1) * t], d = f[c + l * t], o.addConstraint(e, r.create(a.extend({
                            bodyA: u,
                            bodyB: d
                        }, s))), i && c > 0 && (p = f[c - 1 + (l - 1) * t], o.addConstraint(e, r.create(a.extend({
                            bodyA: p,
                            bodyB: d
                        }, s)))), i && c < t - 1 && (p = f[c + 1 + (l - 1) * t], o.addConstraint(e, r.create(a.extend({
                            bodyA: p,
                            bodyB: d
                        }, s))))
                }
                return e.label += " Mesh", e
            }, i.pyramid = function(e, t, n, o, r, a, l) {
                return i.stack(e, t, n, o, r, a, (function(t, i, a, c, u, d) {
                    var p = Math.min(o, Math.ceil(n / 2)),
                        f = u ? u.bounds.max.x - u.bounds.min.x : 0;
                    if (!(c > p || a < (c = p - c) || a > n - 1 - c)) return 1 === d && s.translate(u, {
                        x: (a + (n % 2 == 1 ? 1 : -1)) * f,
                        y: 0
                    }), l(e + (u ? a * f : 0) + a * r, i, a, c, u, d)
                }))
            }, i.newtonsCradle = function(e, t, n, i, a) {
                for (var s = o.create({
                        label: "Newtons Cradle"
                    }), c = 0; c < n; c++) {
                    var u = l.circle(e + c * (1.9 * i), t + a, i, {
                            inertia: 1 / 0,
                            restitution: 1,
                            friction: 0,
                            frictionAir: 1e-4,
                            slop: 1
                        }),
                        d = r.create({
                            pointA: {
                                x: e + c * (1.9 * i),
                                y: t
                            },
                            bodyB: u
                        });
                    o.addBody(s, u), o.addConstraint(s, d)
                }
                return s
            }, c(i, "newtonsCradle", "Composites.newtonsCradle ➤ moved to newtonsCradle example"), i.car = function(e, t, n, i, a) {
                var c = s.nextGroup(!0),
                    u = .5 * -n + 20,
                    d = .5 * n - 20,
                    p = o.create({
                        label: "Car"
                    }),
                    f = l.rectangle(e, t, n, i, {
                        collisionFilter: {
                            group: c
                        },
                        chamfer: {
                            radius: .5 * i
                        },
                        density: 2e-4
                    }),
                    v = l.circle(e + u, t + 0, a, {
                        collisionFilter: {
                            group: c
                        },
                        friction: .8
                    }),
                    y = l.circle(e + d, t + 0, a, {
                        collisionFilter: {
                            group: c
                        },
                        friction: .8
                    }),
                    m = r.create({
                        bodyB: f,
                        pointB: {
                            x: u,
                            y: 0
                        },
                        bodyA: v,
                        stiffness: 1,
                        length: 0
                    }),
                    g = r.create({
                        bodyB: f,
                        pointB: {
                            x: d,
                            y: 0
                        },
                        bodyA: y,
                        stiffness: 1,
                        length: 0
                    });
                return o.addBody(p, f), o.addBody(p, v), o.addBody(p, y), o.addConstraint(p, m), o.addConstraint(p, g), p
            }, c(i, "car", "Composites.car ➤ moved to car example"), i.softBody = function(e, t, n, o, r, s, c, u, d, p) {
                d = a.extend({
                    inertia: 1 / 0
                }, d), p = a.extend({
                    stiffness: .2,
                    render: {
                        type: "line",
                        anchors: !1
                    }
                }, p);
                var f = i.stack(e, t, n, o, r, s, (function(e, t) {
                    return l.circle(e, t, u, d)
                }));
                return i.mesh(f, n, o, c, p), f.label = "Soft Body", f
            }, c(i, "softBody", "Composites.softBody ➤ moved to softBody and cloth examples")
        }, function(e, t, n) {
            var i = {};
            e.exports = i;
            var o = n(9),
                r = n(0),
                a = r.deprecated;
            i.create = function(e) {
                return r.extend({
                    buckets: {},
                    pairs: {},
                    pairsList: [],
                    bucketWidth: 48,
                    bucketHeight: 48
                }, e)
            }, i.update = function(e, t, n, o) {
                var r, a, s, l, c, u = n.world,
                    d = e.buckets,
                    p = !1;
                for (r = 0; r < t.length; r++) {
                    var f = t[r];
                    if ((!f.isSleeping || o) && (!u.bounds || !(f.bounds.max.x < u.bounds.min.x || f.bounds.min.x > u.bounds.max.x || f.bounds.max.y < u.bounds.min.y || f.bounds.min.y > u.bounds.max.y))) {
                        var v = i._getRegion(e, f);
                        if (!f.region || v.id !== f.region.id || o) {
                            f.region && !o || (f.region = v);
                            var y = i._regionUnion(v, f.region);
                            for (a = y.startCol; a <= y.endCol; a++)
                                for (s = y.startRow; s <= y.endRow; s++) {
                                    l = d[c = i._getBucketId(a, s)];
                                    var m = a >= v.startCol && a <= v.endCol && s >= v.startRow && s <= v.endRow,
                                        g = a >= f.region.startCol && a <= f.region.endCol && s >= f.region.startRow && s <= f.region.endRow;
                                    !m && g && g && l && i._bucketRemoveBody(e, l, f), (f.region === v || m && !g || o) && (l || (l = i._createBucket(d, c)), i._bucketAddBody(e, l, f))
                                }
                            f.region = v, p = !0
                        }
                    }
                }
                p && (e.pairsList = i._createActivePairsList(e))
            }, a(i, "update", "Grid.update ➤ replaced by Matter.Detector"), i.clear = function(e) {
                e.buckets = {}, e.pairs = {}, e.pairsList = []
            }, a(i, "clear", "Grid.clear ➤ replaced by Matter.Detector"), i._regionUnion = function(e, t) {
                var n = Math.min(e.startCol, t.startCol),
                    o = Math.max(e.endCol, t.endCol),
                    r = Math.min(e.startRow, t.startRow),
                    a = Math.max(e.endRow, t.endRow);
                return i._createRegion(n, o, r, a)
            }, i._getRegion = function(e, t) {
                var n = t.bounds,
                    o = Math.floor(n.min.x / e.bucketWidth),
                    r = Math.floor(n.max.x / e.bucketWidth),
                    a = Math.floor(n.min.y / e.bucketHeight),
                    s = Math.floor(n.max.y / e.bucketHeight);
                return i._createRegion(o, r, a, s)
            }, i._createRegion = function(e, t, n, i) {
                return {
                    id: e + "," + t + "," + n + "," + i,
                    startCol: e,
                    endCol: t,
                    startRow: n,
                    endRow: i
                }
            }, i._getBucketId = function(e, t) {
                return "C" + e + "R" + t
            }, i._createBucket = function(e, t) {
                return e[t] = []
            }, i._bucketAddBody = function(e, t, n) {
                var i, r = e.pairs,
                    a = o.id,
                    s = t.length;
                for (i = 0; i < s; i++) {
                    var l = t[i];
                    if (!(n.id === l.id || n.isStatic && l.isStatic)) {
                        var c = a(n, l),
                            u = r[c];
                        u ? u[2] += 1 : r[c] = [n, l, 1]
                    }
                }
                t.push(n)
            }, i._bucketRemoveBody = function(e, t, n) {
                var i, a = e.pairs,
                    s = o.id;
                t.splice(r.indexOf(t, n), 1);
                var l = t.length;
                for (i = 0; i < l; i++) {
                    var c = a[s(n, t[i])];
                    c && (c[2] -= 1)
                }
            }, i._createActivePairsList = function(e) {
                var t, n, i = e.pairs,
                    o = r.keys(i),
                    a = o.length,
                    s = [];
                for (n = 0; n < a; n++)(t = i[o[n]])[2] > 0 ? s.push(t) : delete i[o[n]];
                return s
            }
        }, function(e, t, n) {
            var i = {};
            e.exports = i;
            var o = n(3),
                r = n(7),
                a = n(13),
                s = n(4),
                l = n(14),
                c = n(10),
                u = n(5),
                d = n(0),
                p = n(1);
            i.create = function(e, t) {
                var n = (e ? e.mouse : null) || (t ? t.mouse : null);
                n || (e && e.render && e.render.canvas ? n = a.create(e.render.canvas) : t && t.element ? n = a.create(t.element) : (n = a.create(), d.warn("MouseConstraint.create: options.mouse was undefined, options.element was undefined, may not function as expected")));
                var o = {
                        type: "mouseConstraint",
                        mouse: n,
                        element: null,
                        body: null,
                        constraint: c.create({
                            label: "Mouse Constraint",
                            pointA: n.position,
                            pointB: {
                                x: 0,
                                y: 0
                            },
                            length: .01,
                            stiffness: .1,
                            angularStiffness: 1,
                            render: {
                                strokeStyle: "#90EE90",
                                lineWidth: 3
                            }
                        }),
                        collisionFilter: {
                            category: 1,
                            mask: 4294967295,
                            group: 0
                        }
                    },
                    r = d.extend(o, t);
                return s.on(e, "beforeUpdate", (function() {
                    var t = u.allBodies(e.world);
                    i.update(r, t), i._triggerEvents(r)
                })), r
            }, i.update = function(e, t) {
                var n = e.mouse,
                    i = e.constraint,
                    a = e.body;
                if (0 === n.button) {
                    if (i.bodyB) r.set(i.bodyB, !1), i.pointA = n.position;
                    else
                        for (var c = 0; c < t.length; c++)
                            if (a = t[c], p.contains(a.bounds, n.position) && l.canCollide(a.collisionFilter, e.collisionFilter))
                                for (var u = a.parts.length > 1 ? 1 : 0; u < a.parts.length; u++) {
                                    var d = a.parts[u];
                                    if (o.contains(d.vertices, n.position)) {
                                        i.pointA = n.position, i.bodyB = e.body = a, i.pointB = {
                                            x: n.position.x - a.position.x,
                                            y: n.position.y - a.position.y
                                        }, i.angleB = a.angle, r.set(a, !1), s.trigger(e, "startdrag", {
                                            mouse: n,
                                            body: a
                                        });
                                        break
                                    }
                                }
                } else i.bodyB = e.body = null, i.pointB = null, a && s.trigger(e, "enddrag", {
                    mouse: n,
                    body: a
                })
            }, i._triggerEvents = function(e) {
                var t = e.mouse,
                    n = t.sourceEvents;
                n.mousemove && s.trigger(e, "mousemove", {
                    mouse: t
                }), n.mousedown && s.trigger(e, "mousedown", {
                    mouse: t
                }), n.mouseup && s.trigger(e, "mouseup", {
                    mouse: t
                }), a.clearSourceEvents(t)
            }
        }, function(e, t, n) {
            var i = {};
            e.exports = i;
            var o = n(2),
                r = n(8),
                a = n(1),
                s = n(12),
                l = n(3);
            i.collides = function(e, t) {
                for (var n = [], i = t.length, o = e.bounds, s = r.collides, l = a.overlaps, c = 0; c < i; c++) {
                    var u = t[c],
                        d = u.parts.length,
                        p = 1 === d ? 0 : 1;
                    if (l(u.bounds, o))
                        for (var f = p; f < d; f++) {
                            var v = u.parts[f];
                            if (l(v.bounds, o)) {
                                var y = s(v, e);
                                if (y) {
                                    n.push(y);
                                    break
                                }
                            }
                        }
                }
                return n
            }, i.ray = function(e, t, n, r) {
                r = r || 1e-100;
                for (var a = o.angle(t, n), l = o.magnitude(o.sub(t, n)), c = .5 * (n.x + t.x), u = .5 * (n.y + t.y), d = s.rectangle(c, u, l, r, {
                        angle: a
                    }), p = i.collides(d, e), f = 0; f < p.length; f += 1) {
                    var v = p[f];
                    v.body = v.bodyB = v.bodyA
                }
                return p
            }, i.region = function(e, t, n) {
                for (var i = [], o = 0; o < e.length; o++) {
                    var r = e[o],
                        s = a.overlaps(r.bounds, t);
                    (s && !n || !s && n) && i.push(r)
                }
                return i
            }, i.point = function(e, t) {
                for (var n = [], i = 0; i < e.length; i++) {
                    var o = e[i];
                    if (a.contains(o.bounds, t))
                        for (var r = 1 === o.parts.length ? 0 : 1; r < o.parts.length; r++) {
                            var s = o.parts[r];
                            if (a.contains(s.bounds, t) && l.contains(s.vertices, t)) {
                                n.push(o);
                                break
                            }
                        }
                }
                return n
            }
        }, function(e, t, n) {
            var i = {};
            e.exports = i;
            var o = n(4),
                r = n(18),
                a = n(0);
            ! function() {
                var e, t, n;
                ("undefined" != typeof window && (e = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame, t = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame), e) || (e = function(e) {
                    n = setTimeout((function() {
                        e(a.now())
                    }), 1e3 / 60)
                }, t = function() {
                    clearTimeout(n)
                });
                i.create = function(e) {
                    var t = a.extend({
                        fps: 60,
                        correction: 1,
                        deltaSampleSize: 60,
                        counterTimestamp: 0,
                        frameCounter: 0,
                        deltaHistory: [],
                        timePrev: null,
                        timeScalePrev: 1,
                        frameRequestId: null,
                        isFixed: !1,
                        enabled: !0
                    }, e);
                    return t.delta = t.delta || 1e3 / t.fps, t.deltaMin = t.deltaMin || 1e3 / t.fps, t.deltaMax = t.deltaMax || 1e3 / (.5 * t.fps), t.fps = 1e3 / t.delta, t
                }, i.run = function(t, n) {
                    return void 0 !== t.positionIterations && (n = t, t = i.create()),
                        function render(o) {
                            t.frameRequestId = e(render), o && t.enabled && i.tick(t, n, o)
                        }(), t
                }, i.tick = function(e, t, n) {
                    var i, a = t.timing,
                        s = 1,
                        l = {
                            timestamp: a.timestamp
                        };
                    o.trigger(e, "beforeTick", l), e.isFixed ? i = e.delta : (i = n - e.timePrev || e.delta, e.timePrev = n, e.deltaHistory.push(i), e.deltaHistory = e.deltaHistory.slice(-e.deltaSampleSize), s = (i = (i = (i = Math.min.apply(null, e.deltaHistory)) < e.deltaMin ? e.deltaMin : i) > e.deltaMax ? e.deltaMax : i) / e.delta, e.delta = i), 0 !== e.timeScalePrev && (s *= a.timeScale / e.timeScalePrev), 0 === a.timeScale && (s = 0), e.timeScalePrev = a.timeScale, e.correction = s, e.frameCounter += 1, n - e.counterTimestamp >= 1e3 && (e.fps = e.frameCounter * ((n - e.counterTimestamp) / 1e3), e.counterTimestamp = n, e.frameCounter = 0), o.trigger(e, "tick", l), o.trigger(e, "beforeUpdate", l), r.update(t, i, s), o.trigger(e, "afterUpdate", l), o.trigger(e, "afterTick", l)
                }, i.stop = function(e) {
                    t(e.frameRequestId)
                }, i.start = function(e, t) {
                    i.run(e, t)
                }
            }()
        }, function(e, t, n) {
            var i = {};
            e.exports = i;
            var o = n(8),
                r = n(0).deprecated;
            i.collides = function(e, t) {
                return o.collides(e, t)
            }, r(i, "collides", "SAT.collides ➤ replaced by Collision.collides")
        }, function(e, t, n) {
            var i = {};
            e.exports = i;
            n(1);
            var o = n(0);
            i.pathToVertices = function(e, t) {
                "undefined" == typeof window || "SVGPathSeg" in window || o.warn("Svg.pathToVertices: SVGPathSeg not defined, a polyfill is required.");
                var n, r, a, s, l, c, u, d, p, f, v, y = [],
                    m = 0,
                    g = 0,
                    x = 0;
                t = t || 15;
                var addPoint = function(e, t, n) {
                        var i = n % 2 == 1 && n > 1;
                        if (!p || e != p.x || t != p.y) {
                            p && i ? (f = p.x, v = p.y) : (f = 0, v = 0);
                            var o = {
                                x: f + e,
                                y: v + t
                            };
                            !i && p || (p = o), y.push(o), g = f + e, x = v + t
                        }
                    },
                    addSegmentPoint = function(e) {
                        var t = e.pathSegTypeAsLetter.toUpperCase();
                        if ("Z" !== t) {
                            switch (t) {
                                case "M":
                                case "L":
                                case "T":
                                case "C":
                                case "S":
                                case "Q":
                                    g = e.x, x = e.y;
                                    break;
                                case "H":
                                    g = e.x;
                                    break;
                                case "V":
                                    x = e.y
                            }
                            addPoint(g, x, e.pathSegType)
                        }
                    };
                for (i._svgPathToAbsolute(e), a = e.getTotalLength(), c = [], n = 0; n < e.pathSegList.numberOfItems; n += 1) c.push(e.pathSegList.getItem(n));
                for (u = c.concat(); m < a;) {
                    if ((l = c[e.getPathSegAtLength(m)]) != d) {
                        for (; u.length && u[0] != l;) addSegmentPoint(u.shift());
                        d = l
                    }
                    switch (l.pathSegTypeAsLetter.toUpperCase()) {
                        case "C":
                        case "T":
                        case "S":
                        case "Q":
                        case "A":
                            s = e.getPointAtLength(m), addPoint(s.x, s.y, 0)
                    }
                    m += t
                }
                for (n = 0, r = u.length; n < r; ++n) addSegmentPoint(u[n]);
                return y
            }, i._svgPathToAbsolute = function(e) {
                for (var t, n, i, o, r, a, s = e.pathSegList, l = 0, c = 0, u = s.numberOfItems, d = 0; d < u; ++d) {
                    var p = s.getItem(d),
                        f = p.pathSegTypeAsLetter;
                    if (/[MLHVCSQTA]/.test(f)) "x" in p && (l = p.x), "y" in p && (c = p.y);
                    else switch ("x1" in p && (i = l + p.x1), "x2" in p && (r = l + p.x2), "y1" in p && (o = c + p.y1), "y2" in p && (a = c + p.y2), "x" in p && (l += p.x), "y" in p && (c += p.y), f) {
                        case "m":
                            s.replaceItem(e.createSVGPathSegMovetoAbs(l, c), d);
                            break;
                        case "l":
                            s.replaceItem(e.createSVGPathSegLinetoAbs(l, c), d);
                            break;
                        case "h":
                            s.replaceItem(e.createSVGPathSegLinetoHorizontalAbs(l), d);
                            break;
                        case "v":
                            s.replaceItem(e.createSVGPathSegLinetoVerticalAbs(c), d);
                            break;
                        case "c":
                            s.replaceItem(e.createSVGPathSegCurvetoCubicAbs(l, c, i, o, r, a), d);
                            break;
                        case "s":
                            s.replaceItem(e.createSVGPathSegCurvetoCubicSmoothAbs(l, c, r, a), d);
                            break;
                        case "q":
                            s.replaceItem(e.createSVGPathSegCurvetoQuadraticAbs(l, c, i, o), d);
                            break;
                        case "t":
                            s.replaceItem(e.createSVGPathSegCurvetoQuadraticSmoothAbs(l, c), d);
                            break;
                        case "a":
                            s.replaceItem(e.createSVGPathSegArcAbs(l, c, p.r1, p.r2, p.angle, p.largeArcFlag, p.sweepFlag), d);
                            break;
                        case "z":
                        case "Z":
                            l = t, c = n
                    }
                    "M" != f && "m" != f || (t = l, n = c)
                }
            }
        }, function(e, t, n) {
            var i = {};
            e.exports = i;
            var o = n(5);
            n(0);
            i.create = o.create, i.add = o.add, i.remove = o.remove, i.clear = o.clear, i.addComposite = o.addComposite, i.addBody = o.addBody, i.addConstraint = o.addConstraint
        }])
    }));
});
define("libs/min/moment.min.js", function(require, module, exports) {
    (function() {
        "use strict";

        function e() {
            return ti.apply(null, arguments)
        }

        function t(e) {
            ti = e
        }

        function n(e) {
            return e instanceof Array || "[object Array]" === Object.prototype.toString.call(e)
        }

        function s(e) {
            return null != e && "[object Object]" === Object.prototype.toString.call(e)
        }

        function i(e, t) {
            return Object.prototype.hasOwnProperty.call(e, t)
        }

        function r(e) {
            if (Object.getOwnPropertyNames) return 0 === Object.getOwnPropertyNames(e).length;
            var t;
            for (t in e)
                if (i(e, t)) return !1;
            return !0
        }

        function a(e) {
            return void 0 === e
        }

        function o(e) {
            return "number" == typeof e || "[object Number]" === Object.prototype.toString.call(e)
        }

        function u(e) {
            return e instanceof Date || "[object Date]" === Object.prototype.toString.call(e)
        }

        function l(e, t) {
            var n, s = [],
                i = e.length;
            for (n = 0; n < i; ++n) s.push(t(e[n], n));
            return s
        }

        function h(e, t) {
            for (var n in t) i(t, n) && (e[n] = t[n]);
            return i(t, "toString") && (e.toString = t.toString), i(t, "valueOf") && (e.valueOf = t.valueOf), e
        }

        function d(e, t, n, s) {
            return Ot(e, t, n, s, !0).utc()
        }

        function c() {
            return {
                empty: !1,
                unusedTokens: [],
                unusedInput: [],
                overflow: -2,
                charsLeftOver: 0,
                nullInput: !1,
                invalidEra: null,
                invalidMonth: null,
                invalidFormat: !1,
                userInvalidated: !1,
                iso: !1,
                parsedDateParts: [],
                era: null,
                meridiem: null,
                rfc2822: !1,
                weekdayMismatch: !1
            }
        }

        function f(e) {
            return null == e._pf && (e._pf = c()), e._pf
        }

        function m(e) {
            if (null == e._isValid) {
                var t = f(e),
                    n = ni.call(t.parsedDateParts, function(e) {
                        return null != e
                    }),
                    s = !isNaN(e._d.getTime()) && t.overflow < 0 && !t.empty && !t.invalidEra && !t.invalidMonth && !t.invalidWeekday && !t.weekdayMismatch && !t.nullInput && !t.invalidFormat && !t.userInvalidated && (!t.meridiem || t.meridiem && n);
                if (e._strict && (s = s && 0 === t.charsLeftOver && 0 === t.unusedTokens.length && void 0 === t.bigHour), null != Object.isFrozen && Object.isFrozen(e)) return s;
                e._isValid = s
            }
            return e._isValid
        }

        function _(e) {
            var t = d(NaN);
            return null != e ? h(f(t), e) : f(t).userInvalidated = !0, t
        }

        function y(e, t) {
            var n, s, i, r = ii.length;
            if (a(t._isAMomentObject) || (e._isAMomentObject = t._isAMomentObject), a(t._i) || (e._i = t._i), a(t._f) || (e._f = t._f), a(t._l) || (e._l = t._l), a(t._strict) || (e._strict = t._strict), a(t._tzm) || (e._tzm = t._tzm), a(t._isUTC) || (e._isUTC = t._isUTC), a(t._offset) || (e._offset = t._offset), a(t._pf) || (e._pf = f(t)), a(t._locale) || (e._locale = t._locale), r > 0)
                for (n = 0; n < r; n++) s = ii[n], i = t[s], a(i) || (e[s] = i);
            return e
        }

        function g(t) {
            y(this, t), this._d = new Date(null != t._d ? t._d.getTime() : NaN), this.isValid() || (this._d = new Date(NaN)), !1 === ri && (ri = !0, e.updateOffset(this), ri = !1)
        }

        function w(e) {
            return e instanceof g || null != e && null != e._isAMomentObject
        }

        function p(t) {
            !1 === e.suppressDeprecationWarnings && "undefined" != typeof console && console.warn && console.warn("Deprecation warning: " + t)
        }

        function v(t, n) {
            var s = !0;
            return h(function() {
                if (null != e.deprecationHandler && e.deprecationHandler(null, t), s) {
                    var r, a, o, u = [],
                        l = arguments.length;
                    for (a = 0; a < l; a++) {
                        if (r = "", "object" == typeof arguments[a]) {
                            for (o in r += "\n[" + a + "] ", arguments[0]) i(arguments[0], o) && (r += o + ": " + arguments[0][o] + ", ");
                            r = r.slice(0, -2)
                        } else r = arguments[a];
                        u.push(r)
                    }
                    p(t + "\nArguments: " + Array.prototype.slice.call(u).join("") + "\n" + (new Error).stack), s = !1
                }
                return n.apply(this, arguments)
            }, n)
        }

        function k(t, n) {
            null != e.deprecationHandler && e.deprecationHandler(t, n), ai[t] || (p(n), ai[t] = !0)
        }

        function M(e) {
            return "undefined" != typeof Function && e instanceof Function || "[object Function]" === Object.prototype.toString.call(e)
        }

        function D(e) {
            var t, n;
            for (n in e) i(e, n) && (t = e[n], M(t) ? this[n] = t : this["_" + n] = t);
            this._config = e, this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source)
        }

        function S(e, t) {
            var n, r = h({}, e);
            for (n in t) i(t, n) && (s(e[n]) && s(t[n]) ? (r[n] = {}, h(r[n], e[n]), h(r[n], t[n])) : null != t[n] ? r[n] = t[n] : delete r[n]);
            for (n in e) i(e, n) && !i(t, n) && s(e[n]) && (r[n] = h({}, r[n]));
            return r
        }

        function Y(e) {
            null != e && this.set(e)
        }

        function O(e, t, n) {
            var s = this._calendar[e] || this._calendar.sameElse;
            return M(s) ? s.call(t, n) : s
        }

        function b(e, t, n) {
            var s = "" + Math.abs(e),
                i = t - s.length,
                r = e >= 0;
            return (r ? n ? "+" : "" : "-") + Math.pow(10, Math.max(0, i)).toString().substr(1) + s
        }

        function x(e, t, n, s) {
            var i = s;
            "string" == typeof s && (i = function() {
                return this[s]()
            }), e && (ci[e] = i), t && (ci[t[0]] = function() {
                return b(i.apply(this, arguments), t[1], t[2])
            }), n && (ci[n] = function() {
                return this.localeData().ordinal(i.apply(this, arguments), e)
            })
        }

        function T(e) {
            return e.match(/\[[\s\S]/) ? e.replace(/^\[|\]$/g, "") : e.replace(/\\/g, "")
        }

        function N(e) {
            var t, n, s = e.match(li);
            for (t = 0, n = s.length; t < n; t++) ci[s[t]] ? s[t] = ci[s[t]] : s[t] = T(s[t]);
            return function(t) {
                var i, r = "";
                for (i = 0; i < n; i++) r += M(s[i]) ? s[i].call(t, e) : s[i];
                return r
            }
        }

        function P(e, t) {
            return e.isValid() ? (t = R(t, e.localeData()), di[t] = di[t] || N(t), di[t](e)) : e.localeData().invalidDate()
        }

        function R(e, t) {
            function n(e) {
                return t.longDateFormat(e) || e
            }
            var s = 5;
            for (hi.lastIndex = 0; s >= 0 && hi.test(e);) e = e.replace(hi, n), hi.lastIndex = 0, s -= 1;
            return e
        }

        function W(e) {
            var t = this._longDateFormat[e],
                n = this._longDateFormat[e.toUpperCase()];
            return t || !n ? t : (this._longDateFormat[e] = n.match(li).map(function(e) {
                return "MMMM" === e || "MM" === e || "DD" === e || "dddd" === e ? e.slice(1) : e
            }).join(""), this._longDateFormat[e])
        }

        function C() {
            return this._invalidDate
        }

        function U(e) {
            return this._ordinal.replace("%d", e)
        }

        function H(e, t, n, s) {
            var i = this._relativeTime[n];
            return M(i) ? i(e, t, n, s) : i.replace(/%d/i, e)
        }

        function F(e, t) {
            var n = this._relativeTime[e > 0 ? "future" : "past"];
            return M(n) ? n(t) : n.replace(/%s/i, t)
        }

        function L(e, t) {
            var n = e.toLowerCase();
            wi[n] = wi[n + "s"] = wi[t] = e
        }

        function V(e) {
            return "string" == typeof e ? wi[e] || wi[e.toLowerCase()] : void 0
        }

        function G(e) {
            var t, n, s = {};
            for (n in e) i(e, n) && (t = V(n), t && (s[t] = e[n]));
            return s
        }

        function E(e, t) {
            pi[e] = t
        }

        function A(e) {
            var t, n = [];
            for (t in e) i(e, t) && n.push({
                unit: t,
                priority: pi[t]
            });
            return n.sort(function(e, t) {
                return e.priority - t.priority
            }), n
        }

        function I(e) {
            return e % 4 == 0 && e % 100 != 0 || e % 400 == 0
        }

        function j(e) {
            return e < 0 ? Math.ceil(e) || 0 : Math.floor(e)
        }

        function Z(e) {
            var t = +e,
                n = 0;
            return 0 !== t && isFinite(t) && (n = j(t)), n
        }

        function z(t, n) {
            return function(s) {
                return null != s ? (q(this, t, s), e.updateOffset(this, n), this) : $(this, t)
            }
        }

        function $(e, t) {
            return e.isValid() ? e._d["get" + (e._isUTC ? "UTC" : "") + t]() : NaN
        }

        function q(e, t, n) {
            e.isValid() && !isNaN(n) && ("FullYear" === t && I(e.year()) && 1 === e.month() && 29 === e.date() ? (n = Z(n), e._d["set" + (e._isUTC ? "UTC" : "") + t](n, e.month(), re(n, e.month()))) : e._d["set" + (e._isUTC ? "UTC" : "") + t](n))
        }

        function B(e) {
            return e = V(e), M(this[e]) ? this[e]() : this
        }

        function J(e, t) {
            if ("object" == typeof e) {
                e = G(e);
                var n, s = A(e),
                    i = s.length;
                for (n = 0; n < i; n++) this[s[n].unit](e[s[n].unit])
            } else if (e = V(e), M(this[e])) return this[e](t);
            return this
        }

        function Q(e, t, n) {
            oi[e] = M(t) ? t : function(e, s) {
                return e && n ? n : t
            }
        }

        function X(e, t) {
            return i(oi, e) ? oi[e](t._strict, t._locale) : new RegExp(K(e))
        }

        function K(e) {
            return ee(e.replace("\\", "").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function(e, t, n, s, i) {
                return t || n || s || i
            }))
        }

        function ee(e) {
            return e.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&")
        }

        function te(e, t) {
            var n, s, i = t;
            for ("string" == typeof e && (e = [e]), o(t) && (i = function(e, n) {
                    n[t] = Z(e)
                }), s = e.length, n = 0; n < s; n++) Li[e[n]] = i
        }

        function ne(e, t) {
            te(e, function(e, n, s, i) {
                s._w = s._w || {}, t(e, s._w, s, i)
            })
        }

        function se(e, t, n) {
            null != t && i(Li, e) && Li[e](t, n._a, n, e)
        }

        function ie(e, t) {
            return (e % t + t) % t
        }

        function re(e, t) {
            if (isNaN(e) || isNaN(t)) return NaN;
            var n = ie(t, 12);
            return e += (t - n) / 12, 1 === n ? I(e) ? 29 : 28 : 31 - n % 7 % 2
        }

        function ae(e, t) {
            return e ? n(this._months) ? this._months[e.month()] : this._months[(this._months.isFormat || Ji).test(t) ? "format" : "standalone"][e.month()] : n(this._months) ? this._months : this._months.standalone
        }

        function oe(e, t) {
            return e ? n(this._monthsShort) ? this._monthsShort[e.month()] : this._monthsShort[Ji.test(t) ? "format" : "standalone"][e.month()] : n(this._monthsShort) ? this._monthsShort : this._monthsShort.standalone
        }

        function ue(e, t, n) {
            var s, i, r, a = e.toLocaleLowerCase();
            if (!this._monthsParse)
                for (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = [], s = 0; s < 12; ++s) r = d([2e3, s]), this._shortMonthsParse[s] = this.monthsShort(r, "").toLocaleLowerCase(), this._longMonthsParse[s] = this.months(r, "").toLocaleLowerCase();
            return n ? "MMM" === t ? (i = Fi.call(this._shortMonthsParse, a), -1 !== i ? i : null) : (i = Fi.call(this._longMonthsParse, a), -1 !== i ? i : null) : "MMM" === t ? (i = Fi.call(this._shortMonthsParse, a), -1 !== i ? i : (i = Fi.call(this._longMonthsParse, a), -1 !== i ? i : null)) : (i = Fi.call(this._longMonthsParse, a), -1 !== i ? i : (i = Fi.call(this._shortMonthsParse, a), -1 !== i ? i : null))
        }

        function le(e, t, n) {
            var s, i, r;
            if (this._monthsParseExact) return ue.call(this, e, t, n);
            for (this._monthsParse || (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = []), s = 0; s < 12; s++) {
                if (i = d([2e3, s]), n && !this._longMonthsParse[s] && (this._longMonthsParse[s] = new RegExp("^" + this.months(i, "").replace(".", "") + "$", "i"), this._shortMonthsParse[s] = new RegExp("^" + this.monthsShort(i, "").replace(".", "") + "$", "i")), n || this._monthsParse[s] || (r = "^" + this.months(i, "") + "|^" + this.monthsShort(i, ""), this._monthsParse[s] = new RegExp(r.replace(".", ""), "i")), n && "MMMM" === t && this._longMonthsParse[s].test(e)) return s;
                if (n && "MMM" === t && this._shortMonthsParse[s].test(e)) return s;
                if (!n && this._monthsParse[s].test(e)) return s
            }
        }

        function he(e, t) {
            var n;
            if (!e.isValid()) return e;
            if ("string" == typeof t)
                if (/^\d+$/.test(t)) t = Z(t);
                else if (t = e.localeData().monthsParse(t), !o(t)) return e;
            return n = Math.min(e.date(), re(e.year(), t)), e._d["set" + (e._isUTC ? "UTC" : "") + "Month"](t, n), e
        }

        function de(t) {
            return null != t ? (he(this, t), e.updateOffset(this, !0), this) : $(this, "Month")
        }

        function ce() {
            return re(this.year(), this.month())
        }

        function fe(e) {
            return this._monthsParseExact ? (i(this, "_monthsRegex") || _e.call(this), e ? this._monthsShortStrictRegex : this._monthsShortRegex) : (i(this, "_monthsShortRegex") || (this._monthsShortRegex = Qi), this._monthsShortStrictRegex && e ? this._monthsShortStrictRegex : this._monthsShortRegex)
        }

        function me(e) {
            return this._monthsParseExact ? (i(this, "_monthsRegex") || _e.call(this), e ? this._monthsStrictRegex : this._monthsRegex) : (i(this, "_monthsRegex") || (this._monthsRegex = Xi), this._monthsStrictRegex && e ? this._monthsStrictRegex : this._monthsRegex)
        }

        function _e() {
            function e(e, t) {
                return t.length - e.length
            }
            var t, n, s = [],
                i = [],
                r = [];
            for (t = 0; t < 12; t++) n = d([2e3, t]), s.push(this.monthsShort(n, "")), i.push(this.months(n, "")), r.push(this.months(n, "")), r.push(this.monthsShort(n, ""));
            for (s.sort(e), i.sort(e), r.sort(e), t = 0; t < 12; t++) s[t] = ee(s[t]), i[t] = ee(i[t]);
            for (t = 0; t < 24; t++) r[t] = ee(r[t]);
            this._monthsRegex = new RegExp("^(" + r.join("|") + ")", "i"), this._monthsShortRegex = this._monthsRegex, this._monthsStrictRegex = new RegExp("^(" + i.join("|") + ")", "i"), this._monthsShortStrictRegex = new RegExp("^(" + s.join("|") + ")", "i")
        }

        function ye(e) {
            return I(e) ? 366 : 365
        }

        function ge() {
            return I(this.year())
        }

        function we(e, t, n, s, i, r, a) {
            var o;
            return e < 100 && e >= 0 ? (o = new Date(e + 400, t, n, s, i, r, a), isFinite(o.getFullYear()) && o.setFullYear(e)) : o = new Date(e, t, n, s, i, r, a), o
        }

        function pe(e) {
            var t, n;
            return e < 100 && e >= 0 ? (n = Array.prototype.slice.call(arguments), n[0] = e + 400, t = new Date(Date.UTC.apply(null, n)), isFinite(t.getUTCFullYear()) && t.setUTCFullYear(e)) : t = new Date(Date.UTC.apply(null, arguments)), t
        }

        function ve(e, t, n) {
            var s = 7 + t - n,
                i = (7 + pe(e, 0, s).getUTCDay() - t) % 7;
            return -i + s - 1
        }

        function ke(e, t, n, s, i) {
            var r, a, o = (7 + n - s) % 7,
                u = ve(e, s, i),
                l = 1 + 7 * (t - 1) + o + u;
            return l <= 0 ? (r = e - 1, a = ye(r) + l) : l > ye(e) ? (r = e + 1, a = l - ye(e)) : (r = e, a = l), {
                year: r,
                dayOfYear: a
            }
        }

        function Me(e, t, n) {
            var s, i, r = ve(e.year(), t, n),
                a = Math.floor((e.dayOfYear() - r - 1) / 7) + 1;
            return a < 1 ? (i = e.year() - 1, s = a + De(i, t, n)) : a > De(e.year(), t, n) ? (s = a - De(e.year(), t, n), i = e.year() + 1) : (i = e.year(), s = a), {
                week: s,
                year: i
            }
        }

        function De(e, t, n) {
            var s = ve(e, t, n),
                i = ve(e + 1, t, n);
            return (ye(e) - s + i) / 7
        }

        function Se(e) {
            return Me(e, this._week.dow, this._week.doy).week
        }

        function Ye() {
            return this._week.dow
        }

        function Oe() {
            return this._week.doy
        }

        function be(e) {
            var t = this.localeData().week(this);
            return null == e ? t : this.add(7 * (e - t), "d")
        }

        function xe(e) {
            var t = Me(this, 1, 4).week;
            return null == e ? t : this.add(7 * (e - t), "d")
        }

        function Te(e, t) {
            return "string" != typeof e ? e : isNaN(e) ? (e = t.weekdaysParse(e), "number" == typeof e ? e : null) : parseInt(e, 10)
        }

        function Ne(e, t) {
            return "string" == typeof e ? t.weekdaysParse(e) % 7 || 7 : isNaN(e) ? null : e
        }

        function Pe(e, t) {
            return e.slice(t, 7).concat(e.slice(0, t))
        }

        function Re(e, t) {
            var s = n(this._weekdays) ? this._weekdays : this._weekdays[e && !0 !== e && this._weekdays.isFormat.test(t) ? "format" : "standalone"];
            return !0 === e ? Pe(s, this._week.dow) : e ? s[e.day()] : s
        }

        function We(e) {
            return !0 === e ? Pe(this._weekdaysShort, this._week.dow) : e ? this._weekdaysShort[e.day()] : this._weekdaysShort
        }

        function Ce(e) {
            return !0 === e ? Pe(this._weekdaysMin, this._week.dow) : e ? this._weekdaysMin[e.day()] : this._weekdaysMin
        }

        function Ue(e, t, n) {
            var s, i, r, a = e.toLocaleLowerCase();
            if (!this._weekdaysParse)
                for (this._weekdaysParse = [], this._shortWeekdaysParse = [], this._minWeekdaysParse = [], s = 0; s < 7; ++s) r = d([2e3, 1]).day(s), this._minWeekdaysParse[s] = this.weekdaysMin(r, "").toLocaleLowerCase(), this._shortWeekdaysParse[s] = this.weekdaysShort(r, "").toLocaleLowerCase(), this._weekdaysParse[s] = this.weekdays(r, "").toLocaleLowerCase();
            return n ? "dddd" === t ? (i = Fi.call(this._weekdaysParse, a), -1 !== i ? i : null) : "ddd" === t ? (i = Fi.call(this._shortWeekdaysParse, a), -1 !== i ? i : null) : (i = Fi.call(this._minWeekdaysParse, a), -1 !== i ? i : null) : "dddd" === t ? (i = Fi.call(this._weekdaysParse, a), -1 !== i ? i : (i = Fi.call(this._shortWeekdaysParse, a), -1 !== i ? i : (i = Fi.call(this._minWeekdaysParse, a), -1 !== i ? i : null))) : "ddd" === t ? (i = Fi.call(this._shortWeekdaysParse, a), -1 !== i ? i : (i = Fi.call(this._weekdaysParse, a), -1 !== i ? i : (i = Fi.call(this._minWeekdaysParse, a), -1 !== i ? i : null))) : (i = Fi.call(this._minWeekdaysParse, a), -1 !== i ? i : (i = Fi.call(this._weekdaysParse, a), -1 !== i ? i : (i = Fi.call(this._shortWeekdaysParse, a), -1 !== i ? i : null)))
        }

        function He(e, t, n) {
            var s, i, r;
            if (this._weekdaysParseExact) return Ue.call(this, e, t, n);
            for (this._weekdaysParse || (this._weekdaysParse = [], this._minWeekdaysParse = [], this._shortWeekdaysParse = [], this._fullWeekdaysParse = []), s = 0; s < 7; s++) {
                if (i = d([2e3, 1]).day(s), n && !this._fullWeekdaysParse[s] && (this._fullWeekdaysParse[s] = new RegExp("^" + this.weekdays(i, "").replace(".", "\\.?") + "$", "i"), this._shortWeekdaysParse[s] = new RegExp("^" + this.weekdaysShort(i, "").replace(".", "\\.?") + "$", "i"), this._minWeekdaysParse[s] = new RegExp("^" + this.weekdaysMin(i, "").replace(".", "\\.?") + "$", "i")), this._weekdaysParse[s] || (r = "^" + this.weekdays(i, "") + "|^" + this.weekdaysShort(i, "") + "|^" + this.weekdaysMin(i, ""), this._weekdaysParse[s] = new RegExp(r.replace(".", ""), "i")), n && "dddd" === t && this._fullWeekdaysParse[s].test(e)) return s;
                if (n && "ddd" === t && this._shortWeekdaysParse[s].test(e)) return s;
                if (n && "dd" === t && this._minWeekdaysParse[s].test(e)) return s;
                if (!n && this._weekdaysParse[s].test(e)) return s
            }
        }

        function Fe(e) {
            if (!this.isValid()) return null != e ? this : NaN;
            var t = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
            return null != e ? (e = Te(e, this.localeData()), this.add(e - t, "d")) : t
        }

        function Le(e) {
            if (!this.isValid()) return null != e ? this : NaN;
            var t = (this.day() + 7 - this.localeData()._week.dow) % 7;
            return null == e ? t : this.add(e - t, "d")
        }

        function Ve(e) {
            if (!this.isValid()) return null != e ? this : NaN;
            if (null != e) {
                var t = Ne(e, this.localeData());
                return this.day(this.day() % 7 ? t : t - 7)
            }
            return this.day() || 7
        }

        function Ge(e) {
            return this._weekdaysParseExact ? (i(this, "_weekdaysRegex") || Ie.call(this), e ? this._weekdaysStrictRegex : this._weekdaysRegex) : (i(this, "_weekdaysRegex") || (this._weekdaysRegex = ir), this._weekdaysStrictRegex && e ? this._weekdaysStrictRegex : this._weekdaysRegex)
        }

        function Ee(e) {
            return this._weekdaysParseExact ? (i(this, "_weekdaysRegex") || Ie.call(this), e ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex) : (i(this, "_weekdaysShortRegex") || (this._weekdaysShortRegex = rr), this._weekdaysShortStrictRegex && e ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex)
        }

        function Ae(e) {
            return this._weekdaysParseExact ? (i(this, "_weekdaysRegex") || Ie.call(this), e ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex) : (i(this, "_weekdaysMinRegex") || (this._weekdaysMinRegex = ar), this._weekdaysMinStrictRegex && e ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex)
        }

        function Ie() {
            function e(e, t) {
                return t.length - e.length
            }
            var t, n, s, i, r, a = [],
                o = [],
                u = [],
                l = [];
            for (t = 0; t < 7; t++) n = d([2e3, 1]).day(t), s = ee(this.weekdaysMin(n, "")), i = ee(this.weekdaysShort(n, "")), r = ee(this.weekdays(n, "")), a.push(s), o.push(i), u.push(r), l.push(s), l.push(i), l.push(r);
            a.sort(e), o.sort(e), u.sort(e), l.sort(e), this._weekdaysRegex = new RegExp("^(" + l.join("|") + ")", "i"), this._weekdaysShortRegex = this._weekdaysRegex, this._weekdaysMinRegex = this._weekdaysRegex, this._weekdaysStrictRegex = new RegExp("^(" + u.join("|") + ")", "i"), this._weekdaysShortStrictRegex = new RegExp("^(" + o.join("|") + ")", "i"), this._weekdaysMinStrictRegex = new RegExp("^(" + a.join("|") + ")", "i")
        }

        function je() {
            return this.hours() % 12 || 12
        }

        function Ze() {
            return this.hours() || 24
        }

        function ze(e, t) {
            x(e, 0, 0, function() {
                return this.localeData().meridiem(this.hours(), this.minutes(), t)
            })
        }

        function $e(e, t) {
            return t._meridiemParse
        }

        function qe(e) {
            return "p" === (e + "").toLowerCase().charAt(0)
        }

        function Be(e, t, n) {
            return e > 11 ? n ? "pm" : "PM" : n ? "am" : "AM"
        }

        function Je(e, t) {
            var n, s = Math.min(e.length, t.length);
            for (n = 0; n < s; n += 1)
                if (e[n] !== t[n]) return n;
            return s
        }

        function Qe(e) {
            return e ? e.toLowerCase().replace("_", "-") : e
        }

        function Xe(e) {
            for (var t, n, s, i, r = 0; r < e.length;) {
                for (i = Qe(e[r]).split("-"), t = i.length, n = Qe(e[r + 1]), n = n ? n.split("-") : null; t > 0;) {
                    if (s = et(i.slice(0, t).join("-")), s) return s;
                    if (n && n.length >= t && Je(i, n) >= t - 1) break;
                    t--
                }
                r++
            }
            return or
        }

        function Ke(e) {
            return null != e.match("^[^/\\\\]*$")
        }

        function et(e) {
            var t, n = null;
            if (void 0 === dr[e] && "undefined" != typeof module && module && module.exports && Ke(e)) try {
                n = or._abbr, t = require, t("./locale/" + e), tt(n)
            } catch (t) {
                dr[e] = null
            }
            return dr[e]
        }

        function tt(e, t) {
            var n;
            return e && (n = a(t) ? it(e) : nt(e, t), n ? or = n : "undefined" != typeof console && console.warn && console.warn("Locale " + e + " not found. Did you forget to load it?")), or._abbr
        }

        function nt(e, t) {
            if (null !== t) {
                var n, s = hr;
                if (t.abbr = e, null != dr[e]) k("defineLocaleOverride", "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."), s = dr[e]._config;
                else if (null != t.parentLocale)
                    if (null != dr[t.parentLocale]) s = dr[t.parentLocale]._config;
                    else {
                        if (n = et(t.parentLocale), null == n) return cr[t.parentLocale] || (cr[t.parentLocale] = []), cr[t.parentLocale].push({
                            name: e,
                            config: t
                        }), null;
                        s = n._config
                    }
                return dr[e] = new Y(S(s, t)), cr[e] && cr[e].forEach(function(e) {
                    nt(e.name, e.config)
                }), tt(e), dr[e]
            }
            return delete dr[e], null
        }

        function st(e, t) {
            if (null != t) {
                var n, s, i = hr;
                null != dr[e] && null != dr[e].parentLocale ? dr[e].set(S(dr[e]._config, t)) : (s = et(e), null != s && (i = s._config), t = S(i, t), null == s && (t.abbr = e), n = new Y(t), n.parentLocale = dr[e], dr[e] = n), tt(e)
            } else null != dr[e] && (null != dr[e].parentLocale ? (dr[e] = dr[e].parentLocale, e === tt() && tt(e)) : null != dr[e] && delete dr[e]);
            return dr[e]
        }

        function it(e) {
            var t;
            if (e && e._locale && e._locale._abbr && (e = e._locale._abbr), !e) return or;
            if (!n(e)) {
                if (t = et(e), t) return t;
                e = [e]
            }
            return Xe(e)
        }

        function rt() {
            return si(dr)
        }

        function at(e) {
            var t, n = e._a;
            return n && -2 === f(e).overflow && (t = n[Gi] < 0 || n[Gi] > 11 ? Gi : n[Ei] < 1 || n[Ei] > re(n[Vi], n[Gi]) ? Ei : n[Ai] < 0 || n[Ai] > 24 || 24 === n[Ai] && (0 !== n[Ii] || 0 !== n[ji] || 0 !== n[Zi]) ? Ai : n[Ii] < 0 || n[Ii] > 59 ? Ii : n[ji] < 0 || n[ji] > 59 ? ji : n[Zi] < 0 || n[Zi] > 999 ? Zi : -1, f(e)._overflowDayOfYear && (t < Vi || t > Ei) && (t = Ei), f(e)._overflowWeeks && -1 === t && (t = zi), f(e)._overflowWeekday && -1 === t && (t = $i), f(e).overflow = t), e
        }

        function ot(e) {
            var t, n, s, i, r, a, o = e._i,
                u = fr.exec(o) || mr.exec(o),
                l = yr.length,
                h = gr.length;
            if (u) {
                for (f(e).iso = !0, t = 0, n = l; t < n; t++)
                    if (yr[t][1].exec(u[1])) {
                        i = yr[t][0], s = !1 !== yr[t][2];
                        break
                    }
                if (null == i) return void(e._isValid = !1);
                if (u[3]) {
                    for (t = 0, n = h; t < n; t++)
                        if (gr[t][1].exec(u[3])) {
                            r = (u[2] || " ") + gr[t][0];
                            break
                        }
                    if (null == r) return void(e._isValid = !1)
                }
                if (!s && null != r) return void(e._isValid = !1);
                if (u[4]) {
                    if (!_r.exec(u[4])) return void(e._isValid = !1);
                    a = "Z"
                }
                e._f = i + (r || "") + (a || ""), pt(e)
            } else e._isValid = !1
        }

        function ut(e, t, n, s, i, r) {
            var a = [lt(e), Bi.indexOf(t), parseInt(n, 10), parseInt(s, 10), parseInt(i, 10)];
            return r && a.push(parseInt(r, 10)), a
        }

        function lt(e) {
            var t = parseInt(e, 10);
            return t <= 49 ? 2e3 + t : t <= 999 ? 1900 + t : t
        }

        function ht(e) {
            return e.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "")
        }

        function dt(e, t, n) {
            if (e) {
                var s = nr.indexOf(e),
                    i = new Date(t[0], t[1], t[2]).getDay();
                if (s !== i) return f(n).weekdayMismatch = !0, n._isValid = !1, !1
            }
            return !0
        }

        function ct(e, t, n) {
            if (e) return vr[e];
            if (t) return 0;
            var s = parseInt(n, 10),
                i = s % 100,
                r = (s - i) / 100;
            return 60 * r + i
        }

        function ft(e) {
            var t, n = pr.exec(ht(e._i));
            if (n) {
                if (t = ut(n[4], n[3], n[2], n[5], n[6], n[7]), !dt(n[1], t, e)) return;
                e._a = t, e._tzm = ct(n[8], n[9], n[10]), e._d = pe.apply(null, e._a), e._d.setUTCMinutes(e._d.getUTCMinutes() - e._tzm), f(e).rfc2822 = !0
            } else e._isValid = !1
        }

        function mt(t) {
            var n = wr.exec(t._i);
            null === n ? (ot(t), !1 === t._isValid && (delete t._isValid, ft(t), !1 === t._isValid && (delete t._isValid, t._strict ? t._isValid = !1 : e.createFromInputFallback(t)))) : t._d = new Date(+n[1])
        }

        function _t(e, t, n) {
            return null != e ? e : null != t ? t : n
        }

        function yt(t) {
            var n = new Date(e.now());
            return t._useUTC ? [n.getUTCFullYear(), n.getUTCMonth(), n.getUTCDate()] : [n.getFullYear(), n.getMonth(), n.getDate()]
        }

        function gt(e) {
            var t, n, s, i, r, a = [];
            if (!e._d) {
                for (s = yt(e), e._w && null == e._a[Ei] && null == e._a[Gi] && wt(e), null != e._dayOfYear && (r = _t(e._a[Vi], s[Vi]), (e._dayOfYear > ye(r) || 0 === e._dayOfYear) && (f(e)._overflowDayOfYear = !0), n = pe(r, 0, e._dayOfYear), e._a[Gi] = n.getUTCMonth(), e._a[Ei] = n.getUTCDate()), t = 0; t < 3 && null == e._a[t]; ++t) e._a[t] = a[t] = s[t];
                for (; t < 7; t++) e._a[t] = a[t] = null == e._a[t] ? 2 === t ? 1 : 0 : e._a[t];
                24 === e._a[Ai] && 0 === e._a[Ii] && 0 === e._a[ji] && 0 === e._a[Zi] && (e._nextDay = !0, e._a[Ai] = 0), e._d = (e._useUTC ? pe : we).apply(null, a), i = e._useUTC ? e._d.getUTCDay() : e._d.getDay(), null != e._tzm && e._d.setUTCMinutes(e._d.getUTCMinutes() - e._tzm), e._nextDay && (e._a[Ai] = 24), e._w && void 0 !== e._w.d && e._w.d !== i && (f(e).weekdayMismatch = !0)
            }
        }

        function wt(e) {
            var t, n, s, i, r, a, o, u, l;
            t = e._w, null != t.GG || null != t.W || null != t.E ? (r = 1, a = 4, n = _t(t.GG, e._a[Vi], Me(bt(), 1, 4).year), s = _t(t.W, 1), i = _t(t.E, 1), (i < 1 || i > 7) && (u = !0)) : (r = e._locale._week.dow, a = e._locale._week.doy, l = Me(bt(), r, a), n = _t(t.gg, e._a[Vi], l.year), s = _t(t.w, l.week), null != t.d ? (i = t.d, (i < 0 || i > 6) && (u = !0)) : null != t.e ? (i = t.e + r, (t.e < 0 || t.e > 6) && (u = !0)) : i = r), s < 1 || s > De(n, r, a) ? f(e)._overflowWeeks = !0 : null != u ? f(e)._overflowWeekday = !0 : (o = ke(n, s, i, r, a), e._a[Vi] = o.year, e._dayOfYear = o.dayOfYear)
        }

        function pt(t) {
            if (t._f !== e.ISO_8601)
                if (t._f !== e.RFC_2822) {
                    t._a = [], f(t).empty = !0;
                    var n, s, i, r, a, o, u, l = "" + t._i,
                        h = l.length,
                        d = 0;
                    for (i = R(t._f, t._locale).match(li) || [], u = i.length, n = 0; n < u; n++) r = i[n], s = (l.match(X(r, t)) || [])[0], s && (a = l.substr(0, l.indexOf(s)), a.length > 0 && f(t).unusedInput.push(a), l = l.slice(l.indexOf(s) + s.length), d += s.length), ci[r] ? (s ? f(t).empty = !1 : f(t).unusedTokens.push(r), se(r, s, t)) : t._strict && !s && f(t).unusedTokens.push(r);
                    f(t).charsLeftOver = h - d, l.length > 0 && f(t).unusedInput.push(l), t._a[Ai] <= 12 && !0 === f(t).bigHour && t._a[Ai] > 0 && (f(t).bigHour = void 0), f(t).parsedDateParts = t._a.slice(0), f(t).meridiem = t._meridiem, t._a[Ai] = vt(t._locale, t._a[Ai], t._meridiem), o = f(t).era, null !== o && (t._a[Vi] = t._locale.erasConvertYear(o, t._a[Vi])), gt(t), at(t)
                } else ft(t);
            else ot(t)
        }

        function vt(e, t, n) {
            var s;
            return null == n ? t : null != e.meridiemHour ? e.meridiemHour(t, n) : null != e.isPM ? (s = e.isPM(n), s && t < 12 && (t += 12), s || 12 !== t || (t = 0), t) : t
        }

        function kt(e) {
            var t, n, s, i, r, a, o = !1,
                u = e._f.length;
            if (0 === u) return f(e).invalidFormat = !0, void(e._d = new Date(NaN));
            for (i = 0; i < u; i++) r = 0, a = !1, t = y({}, e), null != e._useUTC && (t._useUTC = e._useUTC), t._f = e._f[i], pt(t), m(t) && (a = !0), r += f(t).charsLeftOver, r += 10 * f(t).unusedTokens.length, f(t).score = r, o ? r < s && (s = r, n = t) : (null == s || r < s || a) && (s = r, n = t, a && (o = !0));
            h(e, n || t)
        }

        function Mt(e) {
            if (!e._d) {
                var t = G(e._i),
                    n = void 0 === t.day ? t.date : t.day;
                e._a = l([t.year, t.month, n, t.hour, t.minute, t.second, t.millisecond], function(e) {
                    return e && parseInt(e, 10)
                }), gt(e)
            }
        }

        function Dt(e) {
            var t = new g(at(St(e)));
            return t._nextDay && (t.add(1, "d"), t._nextDay = void 0), t
        }

        function St(e) {
            var t = e._i,
                s = e._f;
            return e._locale = e._locale || it(e._l), null === t || void 0 === s && "" === t ? _({
                nullInput: !0
            }) : ("string" == typeof t && (e._i = t = e._locale.preparse(t)), w(t) ? new g(at(t)) : (u(t) ? e._d = t : n(s) ? kt(e) : s ? pt(e) : Yt(e), m(e) || (e._d = null), e))
        }

        function Yt(t) {
            var i = t._i;
            a(i) ? t._d = new Date(e.now()) : u(i) ? t._d = new Date(i.valueOf()) : "string" == typeof i ? mt(t) : n(i) ? (t._a = l(i.slice(0), function(e) {
                return parseInt(e, 10)
            }), gt(t)) : s(i) ? Mt(t) : o(i) ? t._d = new Date(i) : e.createFromInputFallback(t)
        }

        function Ot(e, t, i, a, o) {
            var u = {};
            return !0 !== t && !1 !== t || (a = t, t = void 0), !0 !== i && !1 !== i || (a = i, i = void 0), (s(e) && r(e) || n(e) && 0 === e.length) && (e = void 0), u._isAMomentObject = !0, u._useUTC = u._isUTC = o, u._l = i, u._i = e, u._f = t, u._strict = a, Dt(u)
        }

        function bt(e, t, n, s) {
            return Ot(e, t, n, s, !1)
        }

        function xt(e, t) {
            var s, i;
            if (1 === t.length && n(t[0]) && (t = t[0]), !t.length) return bt();
            for (s = t[0], i = 1; i < t.length; ++i) t[i].isValid() && !t[i][e](s) || (s = t[i]);
            return s
        }

        function Tt() {
            var e = [].slice.call(arguments, 0);
            return xt("isBefore", e)
        }

        function Nt() {
            var e = [].slice.call(arguments, 0);
            return xt("isAfter", e)
        }

        function Pt(e) {
            var t, n, s = !1,
                r = Sr.length;
            for (t in e)
                if (i(e, t) && (-1 === Fi.call(Sr, t) || null != e[t] && isNaN(e[t]))) return !1;
            for (n = 0; n < r; ++n)
                if (e[Sr[n]]) {
                    if (s) return !1;
                    parseFloat(e[Sr[n]]) !== Z(e[Sr[n]]) && (s = !0)
                }
            return !0
        }

        function Rt() {
            return this._isValid
        }

        function Wt() {
            return Kt(NaN)
        }

        function Ct(e) {
            var t = G(e),
                n = t.year || 0,
                s = t.quarter || 0,
                i = t.month || 0,
                r = t.week || t.isoWeek || 0,
                a = t.day || 0,
                o = t.hour || 0,
                u = t.minute || 0,
                l = t.second || 0,
                h = t.millisecond || 0;
            this._isValid = Pt(t), this._milliseconds = +h + 1e3 * l + 6e4 * u + 1e3 * o * 60 * 60, this._days = +a + 7 * r, this._months = +i + 3 * s + 12 * n, this._data = {}, this._locale = it(), this._bubble()
        }

        function Ut(e) {
            return e instanceof Ct
        }

        function Ht(e) {
            return e < 0 ? -1 * Math.round(-1 * e) : Math.round(e)
        }

        function Ft(e, t, n) {
            var s, i = Math.min(e.length, t.length),
                r = Math.abs(e.length - t.length),
                a = 0;
            for (s = 0; s < i; s++)(n && e[s] !== t[s] || !n && Z(e[s]) !== Z(t[s])) && a++;
            return a + r
        }

        function Lt(e, t) {
            x(e, 0, 0, function() {
                var e = this.utcOffset(),
                    n = "+";
                return e < 0 && (e = -e, n = "-"), n + b(~~(e / 60), 2) + t + b(~~e % 60, 2)
            })
        }

        function Vt(e, t) {
            var n, s, i, r = (t || "").match(e);
            return null === r ? null : (n = r[r.length - 1] || [], s = (n + "").match(Yr) || ["-", 0, 0], i = 60 * s[1] + Z(s[2]), 0 === i ? 0 : "+" === s[0] ? i : -i)
        }

        function Gt(t, n) {
            var s, i;
            return n._isUTC ? (s = n.clone(), i = (w(t) || u(t) ? t.valueOf() : bt(t).valueOf()) - s.valueOf(), s._d.setTime(s._d.valueOf() + i), e.updateOffset(s, !1), s) : bt(t).local()
        }

        function Et(e) {
            return -Math.round(e._d.getTimezoneOffset())
        }

        function At(t, n, s) {
            var i, r = this._offset || 0;
            if (!this.isValid()) return null != t ? this : NaN;
            if (null != t) {
                if ("string" == typeof t) {
                    if (t = Vt(Ci, t), null === t) return this
                } else Math.abs(t) < 16 && !s && (t *= 60);
                return !this._isUTC && n && (i = Et(this)), this._offset = t, this._isUTC = !0, null != i && this.add(i, "m"), r !== t && (!n || this._changeInProgress ? rn(this, Kt(t - r, "m"), 1, !1) : this._changeInProgress || (this._changeInProgress = !0, e.updateOffset(this, !0), this._changeInProgress = null)), this
            }
            return this._isUTC ? r : Et(this)
        }

        function It(e, t) {
            return null != e ? ("string" != typeof e && (e = -e), this.utcOffset(e, t), this) : -this.utcOffset()
        }

        function jt(e) {
            return this.utcOffset(0, e)
        }

        function Zt(e) {
            return this._isUTC && (this.utcOffset(0, e), this._isUTC = !1, e && this.subtract(Et(this), "m")), this
        }

        function zt() {
            if (null != this._tzm) this.utcOffset(this._tzm, !1, !0);
            else if ("string" == typeof this._i) {
                var e = Vt(Wi, this._i);
                null != e ? this.utcOffset(e) : this.utcOffset(0, !0)
            }
            return this
        }

        function $t(e) {
            return !!this.isValid() && (e = e ? bt(e).utcOffset() : 0, (this.utcOffset() - e) % 60 == 0)
        }

        function qt() {
            return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset()
        }

        function Bt() {
            if (!a(this._isDSTShifted)) return this._isDSTShifted;
            var e, t = {};
            return y(t, this), t = St(t), t._a ? (e = t._isUTC ? d(t._a) : bt(t._a), this._isDSTShifted = this.isValid() && Ft(t._a, e.toArray()) > 0) : this._isDSTShifted = !1, this._isDSTShifted
        }

        function Jt() {
            return !!this.isValid() && !this._isUTC
        }

        function Qt() {
            return !!this.isValid() && this._isUTC
        }

        function Xt() {
            return !!this.isValid() && (this._isUTC && 0 === this._offset)
        }

        function Kt(e, t) {
            var n, s, r, a = e,
                u = null;
            return Ut(e) ? a = {
                ms: e._milliseconds,
                d: e._days,
                M: e._months
            } : o(e) || !isNaN(+e) ? (a = {}, t ? a[t] = +e : a.milliseconds = +e) : (u = Or.exec(e)) ? (n = "-" === u[1] ? -1 : 1, a = {
                y: 0,
                d: Z(u[Ei]) * n,
                h: Z(u[Ai]) * n,
                m: Z(u[Ii]) * n,
                s: Z(u[ji]) * n,
                ms: Z(Ht(1e3 * u[Zi])) * n
            }) : (u = br.exec(e)) ? (n = "-" === u[1] ? -1 : 1, a = {
                y: en(u[2], n),
                M: en(u[3], n),
                w: en(u[4], n),
                d: en(u[5], n),
                h: en(u[6], n),
                m: en(u[7], n),
                s: en(u[8], n)
            }) : null == a ? a = {} : "object" == typeof a && ("from" in a || "to" in a) && (r = nn(bt(a.from), bt(a.to)), a = {}, a.ms = r.milliseconds, a.M = r.months), s = new Ct(a), Ut(e) && i(e, "_locale") && (s._locale = e._locale), Ut(e) && i(e, "_isValid") && (s._isValid = e._isValid), s
        }

        function en(e, t) {
            var n = e && parseFloat(e.replace(",", "."));
            return (isNaN(n) ? 0 : n) * t
        }

        function tn(e, t) {
            var n = {};
            return n.months = t.month() - e.month() + 12 * (t.year() - e.year()), e.clone().add(n.months, "M").isAfter(t) && --n.months, n.milliseconds = +t - +e.clone().add(n.months, "M"), n
        }

        function nn(e, t) {
            var n;
            return e.isValid() && t.isValid() ? (t = Gt(t, e), e.isBefore(t) ? n = tn(e, t) : (n = tn(t, e), n.milliseconds = -n.milliseconds, n.months = -n.months), n) : {
                milliseconds: 0,
                months: 0
            }
        }

        function sn(e, t) {
            return function(n, s) {
                var i, r;
                return null === s || isNaN(+s) || (k(t, "moment()." + t + "(period, number) is deprecated. Please use moment()." + t + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."), r = n, n = s, s = r), i = Kt(n, s), rn(this, i, e), this
            }
        }

        function rn(t, n, s, i) {
            var r = n._milliseconds,
                a = Ht(n._days),
                o = Ht(n._months);
            t.isValid() && (i = null == i || i, o && he(t, $(t, "Month") + o * s), a && q(t, "Date", $(t, "Date") + a * s), r && t._d.setTime(t._d.valueOf() + r * s), i && e.updateOffset(t, a || o))
        }

        function an(e) {
            return "string" == typeof e || e instanceof String
        }

        function on(e) {
            return w(e) || u(e) || an(e) || o(e) || ln(e) || un(e) || null == e
        }

        function un(e) {
            var t, n, a = s(e) && !r(e),
                o = !1,
                u = ["years", "year", "y", "months", "month", "M", "days", "day", "d", "dates", "date", "D", "hours", "hour", "h", "minutes", "minute", "m", "seconds", "second", "s", "milliseconds", "millisecond", "ms"],
                l = u.length;
            for (t = 0; t < l; t += 1) n = u[t], o = o || i(e, n);
            return a && o
        }

        function ln(e) {
            var t = n(e),
                s = !1;
            return t && (s = 0 === e.filter(function(t) {
                return !o(t) && an(e)
            }).length), t && s
        }

        function hn(e) {
            var t, n, a = s(e) && !r(e),
                o = !1,
                u = ["sameDay", "nextDay", "lastDay", "nextWeek", "lastWeek", "sameElse"];
            for (t = 0; t < u.length; t += 1) n = u[t], o = o || i(e, n);
            return a && o
        }

        function dn(e, t) {
            var n = e.diff(t, "days", !0);
            return n < -6 ? "sameElse" : n < -1 ? "lastWeek" : n < 0 ? "lastDay" : n < 1 ? "sameDay" : n < 2 ? "nextDay" : n < 7 ? "nextWeek" : "sameElse"
        }

        function cn(t, n) {
            1 === arguments.length && (arguments[0] ? on(arguments[0]) ? (t = arguments[0], n = void 0) : hn(arguments[0]) && (n = arguments[0], t = void 0) : (t = void 0, n = void 0));
            var s = t || bt(),
                i = Gt(s, this).startOf("day"),
                r = e.calendarFormat(this, i) || "sameElse",
                a = n && (M(n[r]) ? n[r].call(this, s) : n[r]);
            return this.format(a || this.localeData().calendar(r, this, bt(s)))
        }

        function fn() {
            return new g(this)
        }

        function mn(e, t) {
            var n = w(e) ? e : bt(e);
            return !(!this.isValid() || !n.isValid()) && (t = V(t) || "millisecond", "millisecond" === t ? this.valueOf() > n.valueOf() : n.valueOf() < this.clone().startOf(t).valueOf())
        }

        function _n(e, t) {
            var n = w(e) ? e : bt(e);
            return !(!this.isValid() || !n.isValid()) && (t = V(t) || "millisecond", "millisecond" === t ? this.valueOf() < n.valueOf() : this.clone().endOf(t).valueOf() < n.valueOf())
        }

        function yn(e, t, n, s) {
            var i = w(e) ? e : bt(e),
                r = w(t) ? t : bt(t);
            return !!(this.isValid() && i.isValid() && r.isValid()) && (s = s || "()", ("(" === s[0] ? this.isAfter(i, n) : !this.isBefore(i, n)) && (")" === s[1] ? this.isBefore(r, n) : !this.isAfter(r, n)))
        }

        function gn(e, t) {
            var n, s = w(e) ? e : bt(e);
            return !(!this.isValid() || !s.isValid()) && (t = V(t) || "millisecond", "millisecond" === t ? this.valueOf() === s.valueOf() : (n = s.valueOf(), this.clone().startOf(t).valueOf() <= n && n <= this.clone().endOf(t).valueOf()))
        }

        function wn(e, t) {
            return this.isSame(e, t) || this.isAfter(e, t)
        }

        function pn(e, t) {
            return this.isSame(e, t) || this.isBefore(e, t)
        }

        function vn(e, t, n) {
            var s, i, r;
            if (!this.isValid()) return NaN;
            if (s = Gt(e, this), !s.isValid()) return NaN;
            switch (i = 6e4 * (s.utcOffset() - this.utcOffset()), t = V(t), t) {
                case "year":
                    r = kn(this, s) / 12;
                    break;
                case "month":
                    r = kn(this, s);
                    break;
                case "quarter":
                    r = kn(this, s) / 3;
                    break;
                case "second":
                    r = (this - s) / 1e3;
                    break;
                case "minute":
                    r = (this - s) / 6e4;
                    break;
                case "hour":
                    r = (this - s) / 36e5;
                    break;
                case "day":
                    r = (this - s - i) / 864e5;
                    break;
                case "week":
                    r = (this - s - i) / 6048e5;
                    break;
                default:
                    r = this - s
            }
            return n ? r : j(r)
        }

        function kn(e, t) {
            if (e.date() < t.date()) return -kn(t, e);
            var n, s, i = 12 * (t.year() - e.year()) + (t.month() - e.month()),
                r = e.clone().add(i, "months");
            return t - r < 0 ? (n = e.clone().add(i - 1, "months"), s = (t - r) / (r - n)) : (n = e.clone().add(i + 1, "months"), s = (t - r) / (n - r)), -(i + s) || 0
        }

        function Mn() {
            return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ")
        }

        function Dn(e) {
            if (!this.isValid()) return null;
            var t = !0 !== e,
                n = t ? this.clone().utc() : this;
            return n.year() < 0 || n.year() > 9999 ? P(n, t ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ") : M(Date.prototype.toISOString) ? t ? this.toDate().toISOString() : new Date(this.valueOf() + 60 * this.utcOffset() * 1e3).toISOString().replace("Z", P(n, "Z")) : P(n, t ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ")
        }

        function Sn() {
            if (!this.isValid()) return "moment.invalid(/* " + this._i + " */)";
            var e, t, n, s, i = "moment",
                r = "";
            return this.isLocal() || (i = 0 === this.utcOffset() ? "moment.utc" : "moment.parseZone", r = "Z"), e = "[" + i + '("]', t = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY", n = "-MM-DD[T]HH:mm:ss.SSS", s = r + '[")]', this.format(e + t + n + s)
        }

        function Yn(t) {
            t || (t = this.isUtc() ? e.defaultFormatUtc : e.defaultFormat);
            var n = P(this, t);
            return this.localeData().postformat(n)
        }

        function On(e, t) {
            return this.isValid() && (w(e) && e.isValid() || bt(e).isValid()) ? Kt({
                to: this,
                from: e
            }).locale(this.locale()).humanize(!t) : this.localeData().invalidDate()
        }

        function bn(e) {
            return this.from(bt(), e)
        }

        function xn(e, t) {
            return this.isValid() && (w(e) && e.isValid() || bt(e).isValid()) ? Kt({
                from: this,
                to: e
            }).locale(this.locale()).humanize(!t) : this.localeData().invalidDate()
        }

        function Tn(e) {
            return this.to(bt(), e)
        }

        function Nn(e) {
            var t;
            return void 0 === e ? this._locale._abbr : (t = it(e), null != t && (this._locale = t), this)
        }

        function Pn() {
            return this._locale
        }

        function Rn(e, t) {
            return (e % t + t) % t
        }

        function Wn(e, t, n) {
            return e < 100 && e >= 0 ? new Date(e + 400, t, n) - Cr : new Date(e, t, n).valueOf()
        }

        function Cn(e, t, n) {
            return e < 100 && e >= 0 ? Date.UTC(e + 400, t, n) - Cr : Date.UTC(e, t, n)
        }

        function Un(t) {
            var n, s;
            if (t = V(t), void 0 === t || "millisecond" === t || !this.isValid()) return this;
            switch (s = this._isUTC ? Cn : Wn, t) {
                case "year":
                    n = s(this.year(), 0, 1);
                    break;
                case "quarter":
                    n = s(this.year(), this.month() - this.month() % 3, 1);
                    break;
                case "month":
                    n = s(this.year(), this.month(), 1);
                    break;
                case "week":
                    n = s(this.year(), this.month(), this.date() - this.weekday());
                    break;
                case "isoWeek":
                    n = s(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
                    break;
                case "day":
                case "date":
                    n = s(this.year(), this.month(), this.date());
                    break;
                case "hour":
                    n = this._d.valueOf(), n -= Rn(n + (this._isUTC ? 0 : this.utcOffset() * Rr), Wr);
                    break;
                case "minute":
                    n = this._d.valueOf(), n -= Rn(n, Rr);
                    break;
                case "second":
                    n = this._d.valueOf(), n -= Rn(n, Pr)
            }
            return this._d.setTime(n), e.updateOffset(this, !0), this
        }

        function Hn(t) {
            var n, s;
            if (t = V(t), void 0 === t || "millisecond" === t || !this.isValid()) return this;
            switch (s = this._isUTC ? Cn : Wn, t) {
                case "year":
                    n = s(this.year() + 1, 0, 1) - 1;
                    break;
                case "quarter":
                    n = s(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
                    break;
                case "month":
                    n = s(this.year(), this.month() + 1, 1) - 1;
                    break;
                case "week":
                    n = s(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
                    break;
                case "isoWeek":
                    n = s(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
                    break;
                case "day":
                case "date":
                    n = s(this.year(), this.month(), this.date() + 1) - 1;
                    break;
                case "hour":
                    n = this._d.valueOf(), n += Wr - Rn(n + (this._isUTC ? 0 : this.utcOffset() * Rr), Wr) - 1;
                    break;
                case "minute":
                    n = this._d.valueOf(), n += Rr - Rn(n, Rr) - 1;
                    break;
                case "second":
                    n = this._d.valueOf(), n += Pr - Rn(n, Pr) - 1
            }
            return this._d.setTime(n), e.updateOffset(this, !0), this
        }

        function Fn() {
            return this._d.valueOf() - 6e4 * (this._offset || 0)
        }

        function Ln() {
            return Math.floor(this.valueOf() / 1e3)
        }

        function Vn() {
            return new Date(this.valueOf())
        }

        function Gn() {
            var e = this;
            return [e.year(), e.month(), e.date(), e.hour(), e.minute(), e.second(), e.millisecond()]
        }

        function En() {
            var e = this;
            return {
                years: e.year(),
                months: e.month(),
                date: e.date(),
                hours: e.hours(),
                minutes: e.minutes(),
                seconds: e.seconds(),
                milliseconds: e.milliseconds()
            }
        }

        function An() {
            return this.isValid() ? this.toISOString() : null
        }

        function In() {
            return m(this)
        }

        function jn() {
            return h({}, f(this))
        }

        function Zn() {
            return f(this).overflow
        }

        function zn() {
            return {
                input: this._i,
                format: this._f,
                locale: this._locale,
                isUTC: this._isUTC,
                strict: this._strict
            }
        }

        function $n(t, n) {
            var s, i, r, a = this._eras || it("en")._eras;
            for (s = 0, i = a.length; s < i; ++s) {
                switch (typeof a[s].since) {
                    case "string":
                        r = e(a[s].since).startOf("day"), a[s].since = r.valueOf()
                }
                switch (typeof a[s].until) {
                    case "undefined":
                        a[s].until = 1 / 0;
                        break;
                    case "string":
                        r = e(a[s].until).startOf("day").valueOf(), a[s].until = r.valueOf()
                }
            }
            return a
        }

        function qn(e, t, n) {
            var s, i, r, a, o, u = this.eras();
            for (e = e.toUpperCase(), s = 0, i = u.length; s < i; ++s)
                if (r = u[s].name.toUpperCase(), a = u[s].abbr.toUpperCase(), o = u[s].narrow.toUpperCase(), n) switch (t) {
                    case "N":
                    case "NN":
                    case "NNN":
                        if (a === e) return u[s];
                        break;
                    case "NNNN":
                        if (r === e) return u[s];
                        break;
                    case "NNNNN":
                        if (o === e) return u[s]
                } else if ([r, a, o].indexOf(e) >= 0) return u[s]
        }

        function Bn(t, n) {
            var s = t.since <= t.until ? 1 : -1;
            return void 0 === n ? e(t.since).year() : e(t.since).year() + (n - t.offset) * s
        }

        function Jn() {
            var e, t, n, s = this.localeData().eras();
            for (e = 0, t = s.length; e < t; ++e) {
                if (n = this.clone().startOf("day").valueOf(), s[e].since <= n && n <= s[e].until) return s[e].name;
                if (s[e].until <= n && n <= s[e].since) return s[e].name
            }
            return ""
        }

        function Qn() {
            var e, t, n, s = this.localeData().eras();
            for (e = 0, t = s.length; e < t; ++e) {
                if (n = this.clone().startOf("day").valueOf(), s[e].since <= n && n <= s[e].until) return s[e].narrow;
                if (s[e].until <= n && n <= s[e].since) return s[e].narrow
            }
            return ""
        }

        function Xn() {
            var e, t, n, s = this.localeData().eras();
            for (e = 0, t = s.length; e < t; ++e) {
                if (n = this.clone().startOf("day").valueOf(), s[e].since <= n && n <= s[e].until) return s[e].abbr;
                if (s[e].until <= n && n <= s[e].since) return s[e].abbr
            }
            return ""
        }

        function Kn() {
            var t, n, s, i, r = this.localeData().eras();
            for (t = 0, n = r.length; t < n; ++t)
                if (s = r[t].since <= r[t].until ? 1 : -1, i = this.clone().startOf("day").valueOf(), r[t].since <= i && i <= r[t].until || r[t].until <= i && i <= r[t].since) return (this.year() - e(r[t].since).year()) * s + r[t].offset;
            return this.year()
        }

        function es(e) {
            return i(this, "_erasNameRegex") || os.call(this), e ? this._erasNameRegex : this._erasRegex
        }

        function ts(e) {
            return i(this, "_erasAbbrRegex") || os.call(this), e ? this._erasAbbrRegex : this._erasRegex
        }

        function ns(e) {
            return i(this, "_erasNarrowRegex") || os.call(this), e ? this._erasNarrowRegex : this._erasRegex
        }

        function ss(e, t) {
            return t.erasAbbrRegex(e)
        }

        function is(e, t) {
            return t.erasNameRegex(e)
        }

        function rs(e, t) {
            return t.erasNarrowRegex(e)
        }

        function as(e, t) {
            return t._eraYearOrdinalRegex || Pi
        }

        function os() {
            var e, t, n = [],
                s = [],
                i = [],
                r = [],
                a = this.eras();
            for (e = 0, t = a.length; e < t; ++e) s.push(ee(a[e].name)), n.push(ee(a[e].abbr)), i.push(ee(a[e].narrow)), r.push(ee(a[e].name)), r.push(ee(a[e].abbr)), r.push(ee(a[e].narrow));
            this._erasRegex = new RegExp("^(" + r.join("|") + ")", "i"), this._erasNameRegex = new RegExp("^(" + s.join("|") + ")", "i"), this._erasAbbrRegex = new RegExp("^(" + n.join("|") + ")", "i"), this._erasNarrowRegex = new RegExp("^(" + i.join("|") + ")", "i")
        }

        function us(e, t) {
            x(0, [e, e.length], 0, t)
        }

        function ls(e) {
            return _s.call(this, e, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy)
        }

        function hs(e) {
            return _s.call(this, e, this.isoWeek(), this.isoWeekday(), 1, 4)
        }

        function ds() {
            return De(this.year(), 1, 4)
        }

        function cs() {
            return De(this.isoWeekYear(), 1, 4)
        }

        function fs() {
            var e = this.localeData()._week;
            return De(this.year(), e.dow, e.doy)
        }

        function ms() {
            var e = this.localeData()._week;
            return De(this.weekYear(), e.dow, e.doy)
        }

        function _s(e, t, n, s, i) {
            var r;
            return null == e ? Me(this, s, i).year : (r = De(e, s, i), t > r && (t = r), ys.call(this, e, t, n, s, i))
        }

        function ys(e, t, n, s, i) {
            var r = ke(e, t, n, s, i),
                a = pe(r.year, 0, r.dayOfYear);
            return this.year(a.getUTCFullYear()), this.month(a.getUTCMonth()), this.date(a.getUTCDate()), this
        }

        function gs(e) {
            return null == e ? Math.ceil((this.month() + 1) / 3) : this.month(3 * (e - 1) + this.month() % 3)
        }

        function ws(e) {
            var t = Math.round((this.clone().startOf("day") - this.clone().startOf("year")) / 864e5) + 1;
            return null == e ? t : this.add(e - t, "d")
        }

        function ps(e, t) {
            t[Zi] = Z(1e3 * ("0." + e))
        }

        function vs() {
            return this._isUTC ? "UTC" : ""
        }

        function ks() {
            return this._isUTC ? "Coordinated Universal Time" : ""
        }

        function Ms(e) {
            return bt(1e3 * e)
        }

        function Ds() {
            return bt.apply(null, arguments).parseZone()
        }

        function Ss(e) {
            return e
        }

        function Ys(e, t, n, s) {
            var i = it(),
                r = d().set(s, t);
            return i[n](r, e)
        }

        function Os(e, t, n) {
            if (o(e) && (t = e, e = void 0), e = e || "", null != t) return Ys(e, t, n, "month");
            var s, i = [];
            for (s = 0; s < 12; s++) i[s] = Ys(e, s, n, "month");
            return i
        }

        function bs(e, t, n, s) {
            "boolean" == typeof e ? (o(t) && (n = t, t = void 0), t = t || "") : (t = e, n = t, e = !1, o(t) && (n = t, t = void 0), t = t || "");
            var i, r = it(),
                a = e ? r._week.dow : 0,
                u = [];
            if (null != n) return Ys(t, (n + a) % 7, s, "day");
            for (i = 0; i < 7; i++) u[i] = Ys(t, (i + a) % 7, s, "day");
            return u
        }

        function xs(e, t) {
            return Os(e, t, "months")
        }

        function Ts(e, t) {
            return Os(e, t, "monthsShort")
        }

        function Ns(e, t, n) {
            return bs(e, t, n, "weekdays")
        }

        function Ps(e, t, n) {
            return bs(e, t, n, "weekdaysShort")
        }

        function Rs(e, t, n) {
            return bs(e, t, n, "weekdaysMin")
        }

        function Ws() {
            var e = this._data;
            return this._milliseconds = Ar(this._milliseconds), this._days = Ar(this._days), this._months = Ar(this._months), e.milliseconds = Ar(e.milliseconds), e.seconds = Ar(e.seconds), e.minutes = Ar(e.minutes), e.hours = Ar(e.hours), e.months = Ar(e.months), e.years = Ar(e.years), this
        }

        function Cs(e, t, n, s) {
            var i = Kt(t, n);
            return e._milliseconds += s * i._milliseconds, e._days += s * i._days, e._months += s * i._months, e._bubble()
        }

        function Us(e, t) {
            return Cs(this, e, t, 1)
        }

        function Hs(e, t) {
            return Cs(this, e, t, -1)
        }

        function Fs(e) {
            return e < 0 ? Math.floor(e) : Math.ceil(e)
        }

        function Ls() {
            var e, t, n, s, i, r = this._milliseconds,
                a = this._days,
                o = this._months,
                u = this._data;
            return r >= 0 && a >= 0 && o >= 0 || r <= 0 && a <= 0 && o <= 0 || (r += 864e5 * Fs(Gs(o) + a), a = 0, o = 0), u.milliseconds = r % 1e3, e = j(r / 1e3), u.seconds = e % 60, t = j(e / 60), u.minutes = t % 60, n = j(t / 60), u.hours = n % 24, a += j(n / 24), i = j(Vs(a)), o += i, a -= Fs(Gs(i)), s = j(o / 12), o %= 12, u.days = a, u.months = o, u.years = s, this
        }

        function Vs(e) {
            return 4800 * e / 146097
        }

        function Gs(e) {
            return 146097 * e / 4800
        }

        function Es(e) {
            if (!this.isValid()) return NaN;
            var t, n, s = this._milliseconds;
            if (e = V(e), "month" === e || "quarter" === e || "year" === e) switch (t = this._days + s / 864e5, n = this._months + Vs(t), e) {
                case "month":
                    return n;
                case "quarter":
                    return n / 3;
                case "year":
                    return n / 12
            } else switch (t = this._days + Math.round(Gs(this._months)), e) {
                case "week":
                    return t / 7 + s / 6048e5;
                case "day":
                    return t + s / 864e5;
                case "hour":
                    return 24 * t + s / 36e5;
                case "minute":
                    return 1440 * t + s / 6e4;
                case "second":
                    return 86400 * t + s / 1e3;
                case "millisecond":
                    return Math.floor(864e5 * t) + s;
                default:
                    throw new Error("Unknown unit " + e)
            }
        }

        function As() {
            return this.isValid() ? this._milliseconds + 864e5 * this._days + this._months % 12 * 2592e6 + 31536e6 * Z(this._months / 12) : NaN
        }

        function Is(e) {
            return function() {
                return this.as(e)
            }
        }

        function js() {
            return Kt(this)
        }

        function Zs(e) {
            return e = V(e), this.isValid() ? this[e + "s"]() : NaN
        }

        function zs(e) {
            return function() {
                return this.isValid() ? this._data[e] : NaN
            }
        }

        function $s() {
            return j(this.days() / 7)
        }

        function qs(e, t, n, s, i) {
            return i.relativeTime(t || 1, !!n, e, s)
        }

        function Bs(e, t, n, s) {
            var i = Kt(e).abs(),
                r = ra(i.as("s")),
                a = ra(i.as("m")),
                o = ra(i.as("h")),
                u = ra(i.as("d")),
                l = ra(i.as("M")),
                h = ra(i.as("w")),
                d = ra(i.as("y")),
                c = r <= n.ss && ["s", r] || r < n.s && ["ss", r] || a <= 1 && ["m"] || a < n.m && ["mm", a] || o <= 1 && ["h"] || o < n.h && ["hh", o] || u <= 1 && ["d"] || u < n.d && ["dd", u];
            return null != n.w && (c = c || h <= 1 && ["w"] || h < n.w && ["ww", h]), c = c || l <= 1 && ["M"] || l < n.M && ["MM", l] || d <= 1 && ["y"] || ["yy", d], c[2] = t, c[3] = +e > 0, c[4] = s, qs.apply(null, c)
        }

        function Js(e) {
            return void 0 === e ? ra : "function" == typeof e && (ra = e, !0)
        }

        function Qs(e, t) {
            return void 0 !== aa[e] && (void 0 === t ? aa[e] : (aa[e] = t, "s" === e && (aa.ss = t - 1), !0))
        }

        function Xs(e, t) {
            if (!this.isValid()) return this.localeData().invalidDate();
            var n, s, i = !1,
                r = aa;
            return "object" == typeof e && (t = e, e = !1), "boolean" == typeof e && (i = e), "object" == typeof t && (r = Object.assign({}, aa, t), null != t.s && null == t.ss && (r.ss = t.s - 1)), n = this.localeData(), s = Bs(this, !i, r, n), i && (s = n.pastFuture(+this, s)), n.postformat(s)
        }

        function Ks(e) {
            return (e > 0) - (e < 0) || +e
        }

        function ei() {
            if (!this.isValid()) return this.localeData().invalidDate();
            var e, t, n, s, i, r, a, o, u = oa(this._milliseconds) / 1e3,
                l = oa(this._days),
                h = oa(this._months),
                d = this.asSeconds();
            return d ? (e = j(u / 60), t = j(e / 60), u %= 60, e %= 60, n = j(h / 12), h %= 12, s = u ? u.toFixed(3).replace(/\.?0+$/, "") : "", i = d < 0 ? "-" : "", r = Ks(this._months) !== Ks(d) ? "-" : "", a = Ks(this._days) !== Ks(d) ? "-" : "", o = Ks(this._milliseconds) !== Ks(d) ? "-" : "", i + "P" + (n ? r + n + "Y" : "") + (h ? r + h + "M" : "") + (l ? a + l + "D" : "") + (t || e || u ? "T" : "") + (t ? o + t + "H" : "") + (e ? o + e + "M" : "") + (u ? o + s + "S" : "")) : "P0D"
        }
        var ti, ni;
        ni = Array.prototype.some ? Array.prototype.some : function(e) {
            var t, n = Object(this),
                s = n.length >>> 0;
            for (t = 0; t < s; t++)
                if (t in n && e.call(this, n[t], t, n)) return !0;
            return !1
        };
        var si, ii = e.momentProperties = [],
            ri = !1,
            ai = {};
        e.suppressDeprecationWarnings = !1, e.deprecationHandler = null, si = Object.keys ? Object.keys : function(e) {
            var t, n = [];
            for (t in e) i(e, t) && n.push(t);
            return n
        };
        var oi, ui = {
                sameDay: "[Today at] LT",
                nextDay: "[Tomorrow at] LT",
                nextWeek: "dddd [at] LT",
                lastDay: "[Yesterday at] LT",
                lastWeek: "[Last] dddd [at] LT",
                sameElse: "L"
            },
            li = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,
            hi = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,
            di = {},
            ci = {},
            fi = {
                LTS: "h:mm:ss A",
                LT: "h:mm A",
                L: "MM/DD/YYYY",
                LL: "MMMM D, YYYY",
                LLL: "MMMM D, YYYY h:mm A",
                LLLL: "dddd, MMMM D, YYYY h:mm A"
            },
            mi = "Invalid date",
            _i = "%d",
            yi = /\d{1,2}/,
            gi = {
                future: "in %s",
                past: "%s ago",
                s: "a few seconds",
                ss: "%d seconds",
                m: "a minute",
                mm: "%d minutes",
                h: "an hour",
                hh: "%d hours",
                d: "a day",
                dd: "%d days",
                w: "a week",
                ww: "%d weeks",
                M: "a month",
                MM: "%d months",
                y: "a year",
                yy: "%d years"
            },
            wi = {},
            pi = {},
            vi = /\d/,
            ki = /\d\d/,
            Mi = /\d{3}/,
            Di = /\d{4}/,
            Si = /[+-]?\d{6}/,
            Yi = /\d\d?/,
            Oi = /\d\d\d\d?/,
            bi = /\d\d\d\d\d\d?/,
            xi = /\d{1,3}/,
            Ti = /\d{1,4}/,
            Ni = /[+-]?\d{1,6}/,
            Pi = /\d+/,
            Ri = /[+-]?\d+/,
            Wi = /Z|[+-]\d\d:?\d\d/gi,
            Ci = /Z|[+-]\d\d(?::?\d\d)?/gi,
            Ui = /[+-]?\d+(\.\d{1,3})?/,
            Hi = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i;
        oi = {};
        var Fi, Li = {},
            Vi = 0,
            Gi = 1,
            Ei = 2,
            Ai = 3,
            Ii = 4,
            ji = 5,
            Zi = 6,
            zi = 7,
            $i = 8;
        Fi = Array.prototype.indexOf ? Array.prototype.indexOf : function(e) {
            var t;
            for (t = 0; t < this.length; ++t)
                if (this[t] === e) return t;
            return -1
        }, x("M", ["MM", 2], "Mo", function() {
            return this.month() + 1
        }), x("MMM", 0, 0, function(e) {
            return this.localeData().monthsShort(this, e)
        }), x("MMMM", 0, 0, function(e) {
            return this.localeData().months(this, e)
        }), L("month", "M"), E("month", 8), Q("M", Yi), Q("MM", Yi, ki), Q("MMM", function(e, t) {
            return t.monthsShortRegex(e)
        }), Q("MMMM", function(e, t) {
            return t.monthsRegex(e)
        }), te(["M", "MM"], function(e, t) {
            t[Gi] = Z(e) - 1
        }), te(["MMM", "MMMM"], function(e, t, n, s) {
            var i = n._locale.monthsParse(e, s, n._strict);
            null != i ? t[Gi] = i : f(n).invalidMonth = e
        });
        var qi = "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
            Bi = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
            Ji = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/,
            Qi = Hi,
            Xi = Hi;
        x("Y", 0, 0, function() {
            var e = this.year();
            return e <= 9999 ? b(e, 4) : "+" + e
        }), x(0, ["YY", 2], 0, function() {
            return this.year() % 100
        }), x(0, ["YYYY", 4], 0, "year"), x(0, ["YYYYY", 5], 0, "year"), x(0, ["YYYYYY", 6, !0], 0, "year"), L("year", "y"), E("year", 1), Q("Y", Ri), Q("YY", Yi, ki), Q("YYYY", Ti, Di), Q("YYYYY", Ni, Si), Q("YYYYYY", Ni, Si), te(["YYYYY", "YYYYYY"], Vi), te("YYYY", function(t, n) {
            n[Vi] = 2 === t.length ? e.parseTwoDigitYear(t) : Z(t)
        }), te("YY", function(t, n) {
            n[Vi] = e.parseTwoDigitYear(t)
        }), te("Y", function(e, t) {
            t[Vi] = parseInt(e, 10)
        }), e.parseTwoDigitYear = function(e) {
            return Z(e) + (Z(e) > 68 ? 1900 : 2e3)
        };
        var Ki = z("FullYear", !0);
        x("w", ["ww", 2], "wo", "week"), x("W", ["WW", 2], "Wo", "isoWeek"), L("week", "w"), L("isoWeek", "W"), E("week", 5), E("isoWeek", 5), Q("w", Yi), Q("ww", Yi, ki), Q("W", Yi), Q("WW", Yi, ki), ne(["w", "ww", "W", "WW"], function(e, t, n, s) {
            t[s.substr(0, 1)] = Z(e)
        });
        var er = {
            dow: 0,
            doy: 6
        };
        x("d", 0, "do", "day"), x("dd", 0, 0, function(e) {
            return this.localeData().weekdaysMin(this, e)
        }), x("ddd", 0, 0, function(e) {
            return this.localeData().weekdaysShort(this, e)
        }), x("dddd", 0, 0, function(e) {
            return this.localeData().weekdays(this, e)
        }), x("e", 0, 0, "weekday"), x("E", 0, 0, "isoWeekday"), L("day", "d"), L("weekday", "e"), L("isoWeekday", "E"), E("day", 11), E("weekday", 11), E("isoWeekday", 11), Q("d", Yi), Q("e", Yi), Q("E", Yi), Q("dd", function(e, t) {
            return t.weekdaysMinRegex(e)
        }), Q("ddd", function(e, t) {
            return t.weekdaysShortRegex(e)
        }), Q("dddd", function(e, t) {
            return t.weekdaysRegex(e)
        }), ne(["dd", "ddd", "dddd"], function(e, t, n, s) {
            var i = n._locale.weekdaysParse(e, s, n._strict);
            null != i ? t.d = i : f(n).invalidWeekday = e
        }), ne(["d", "e", "E"], function(e, t, n, s) {
            t[s] = Z(e)
        });
        var tr = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
            nr = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
            sr = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
            ir = Hi,
            rr = Hi,
            ar = Hi;
        x("H", ["HH", 2], 0, "hour"), x("h", ["hh", 2], 0, je), x("k", ["kk", 2], 0, Ze), x("hmm", 0, 0, function() {
            return "" + je.apply(this) + b(this.minutes(), 2)
        }), x("hmmss", 0, 0, function() {
            return "" + je.apply(this) + b(this.minutes(), 2) + b(this.seconds(), 2)
        }), x("Hmm", 0, 0, function() {
            return "" + this.hours() + b(this.minutes(), 2)
        }), x("Hmmss", 0, 0, function() {
            return "" + this.hours() + b(this.minutes(), 2) + b(this.seconds(), 2)
        }), ze("a", !0), ze("A", !1), L("hour", "h"), E("hour", 13), Q("a", $e), Q("A", $e), Q("H", Yi), Q("h", Yi), Q("k", Yi), Q("HH", Yi, ki), Q("hh", Yi, ki), Q("kk", Yi, ki), Q("hmm", Oi), Q("hmmss", bi), Q("Hmm", Oi), Q("Hmmss", bi), te(["H", "HH"], Ai), te(["k", "kk"], function(e, t, n) {
            var s = Z(e);
            t[Ai] = 24 === s ? 0 : s
        }), te(["a", "A"], function(e, t, n) {
            n._isPm = n._locale.isPM(e), n._meridiem = e
        }), te(["h", "hh"], function(e, t, n) {
            t[Ai] = Z(e), f(n).bigHour = !0
        }), te("hmm", function(e, t, n) {
            var s = e.length - 2;
            t[Ai] = Z(e.substr(0, s)), t[Ii] = Z(e.substr(s)), f(n).bigHour = !0
        }), te("hmmss", function(e, t, n) {
            var s = e.length - 4,
                i = e.length - 2;
            t[Ai] = Z(e.substr(0, s)), t[Ii] = Z(e.substr(s, 2)), t[ji] = Z(e.substr(i)), f(n).bigHour = !0
        }), te("Hmm", function(e, t, n) {
            var s = e.length - 2;
            t[Ai] = Z(e.substr(0, s)), t[Ii] = Z(e.substr(s))
        }), te("Hmmss", function(e, t, n) {
            var s = e.length - 4,
                i = e.length - 2;
            t[Ai] = Z(e.substr(0, s)), t[Ii] = Z(e.substr(s, 2)), t[ji] = Z(e.substr(i))
        });
        var or, ur = /[ap]\.?m?\.?/i,
            lr = z("Hours", !0),
            hr = {
                calendar: ui,
                longDateFormat: fi,
                invalidDate: mi,
                ordinal: _i,
                dayOfMonthOrdinalParse: yi,
                relativeTime: gi,
                months: qi,
                monthsShort: Bi,
                week: er,
                weekdays: tr,
                weekdaysMin: sr,
                weekdaysShort: nr,
                meridiemParse: ur
            },
            dr = {},
            cr = {},
            fr = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
            mr = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
            _r = /Z|[+-]\d\d(?::?\d\d)?/,
            yr = [
                ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
                ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
                ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
                ["GGGG-[W]WW", /\d{4}-W\d\d/, !1],
                ["YYYY-DDD", /\d{4}-\d{3}/],
                ["YYYY-MM", /\d{4}-\d\d/, !1],
                ["YYYYYYMMDD", /[+-]\d{10}/],
                ["YYYYMMDD", /\d{8}/],
                ["GGGG[W]WWE", /\d{4}W\d{3}/],
                ["GGGG[W]WW", /\d{4}W\d{2}/, !1],
                ["YYYYDDD", /\d{7}/],
                ["YYYYMM", /\d{6}/, !1],
                ["YYYY", /\d{4}/, !1]
            ],
            gr = [
                ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
                ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
                ["HH:mm:ss", /\d\d:\d\d:\d\d/],
                ["HH:mm", /\d\d:\d\d/],
                ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
                ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
                ["HHmmss", /\d\d\d\d\d\d/],
                ["HHmm", /\d\d\d\d/],
                ["HH", /\d\d/]
            ],
            wr = /^\/?Date\((-?\d+)/i,
            pr = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/,
            vr = {
                UT: 0,
                GMT: 0,
                EDT: -240,
                EST: -300,
                CDT: -300,
                CST: -360,
                MDT: -360,
                MST: -420,
                PDT: -420,
                PST: -480
            };
        e.createFromInputFallback = v("value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.", function(e) {
            e._d = new Date(e._i + (e._useUTC ? " UTC" : ""))
        }), e.ISO_8601 = function() {}, e.RFC_2822 = function() {};
        var kr = v("moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/", function() {
                var e = bt.apply(null, arguments);
                return this.isValid() && e.isValid() ? e < this ? this : e : _()
            }),
            Mr = v("moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/", function() {
                var e = bt.apply(null, arguments);
                return this.isValid() && e.isValid() ? e > this ? this : e : _()
            }),
            Dr = function() {
                return Date.now ? Date.now() : +new Date
            },
            Sr = ["year", "quarter", "month", "week", "day", "hour", "minute", "second", "millisecond"];
        Lt("Z", ":"), Lt("ZZ", ""), Q("Z", Ci), Q("ZZ", Ci), te(["Z", "ZZ"], function(e, t, n) {
            n._useUTC = !0, n._tzm = Vt(Ci, e)
        });
        var Yr = /([\+\-]|\d\d)/gi;
        e.updateOffset = function() {};
        var Or = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/,
            br = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
        Kt.fn = Ct.prototype, Kt.invalid = Wt;
        var xr = sn(1, "add"),
            Tr = sn(-1, "subtract");
        e.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ", e.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
        var Nr = v("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.", function(e) {
                return void 0 === e ? this.localeData() : this.locale(e)
            }),
            Pr = 1e3,
            Rr = 60 * Pr,
            Wr = 60 * Rr,
            Cr = 3506328 * Wr;
        x("N", 0, 0, "eraAbbr"), x("NN", 0, 0, "eraAbbr"), x("NNN", 0, 0, "eraAbbr"), x("NNNN", 0, 0, "eraName"), x("NNNNN", 0, 0, "eraNarrow"), x("y", ["y", 1], "yo", "eraYear"), x("y", ["yy", 2], 0, "eraYear"), x("y", ["yyy", 3], 0, "eraYear"), x("y", ["yyyy", 4], 0, "eraYear"), Q("N", ss), Q("NN", ss), Q("NNN", ss), Q("NNNN", is), Q("NNNNN", rs), te(["N", "NN", "NNN", "NNNN", "NNNNN"], function(e, t, n, s) {
            var i = n._locale.erasParse(e, s, n._strict);
            i ? f(n).era = i : f(n).invalidEra = e
        }), Q("y", Pi), Q("yy", Pi), Q("yyy", Pi), Q("yyyy", Pi), Q("yo", as), te(["y", "yy", "yyy", "yyyy"], Vi), te(["yo"], function(e, t, n, s) {
            var i;
            n._locale._eraYearOrdinalRegex && (i = e.match(n._locale._eraYearOrdinalRegex)), n._locale.eraYearOrdinalParse ? t[Vi] = n._locale.eraYearOrdinalParse(e, i) : t[Vi] = parseInt(e, 10)
        }), x(0, ["gg", 2], 0, function() {
            return this.weekYear() % 100
        }), x(0, ["GG", 2], 0, function() {
            return this.isoWeekYear() % 100
        }), us("gggg", "weekYear"), us("ggggg", "weekYear"), us("GGGG", "isoWeekYear"), us("GGGGG", "isoWeekYear"), L("weekYear", "gg"), L("isoWeekYear", "GG"), E("weekYear", 1), E("isoWeekYear", 1), Q("G", Ri), Q("g", Ri), Q("GG", Yi, ki), Q("gg", Yi, ki), Q("GGGG", Ti, Di), Q("gggg", Ti, Di), Q("GGGGG", Ni, Si), Q("ggggg", Ni, Si), ne(["gggg", "ggggg", "GGGG", "GGGGG"], function(e, t, n, s) {
            t[s.substr(0, 2)] = Z(e)
        }), ne(["gg", "GG"], function(t, n, s, i) {
            n[i] = e.parseTwoDigitYear(t)
        }), x("Q", 0, "Qo", "quarter"), L("quarter", "Q"), E("quarter", 7), Q("Q", vi), te("Q", function(e, t) {
            t[Gi] = 3 * (Z(e) - 1)
        }), x("D", ["DD", 2], "Do", "date"), L("date", "D"), E("date", 9), Q("D", Yi), Q("DD", Yi, ki), Q("Do", function(e, t) {
            return e ? t._dayOfMonthOrdinalParse || t._ordinalParse : t._dayOfMonthOrdinalParseLenient
        }), te(["D", "DD"], Ei), te("Do", function(e, t) {
            t[Ei] = Z(e.match(Yi)[0])
        });
        var Ur = z("Date", !0);
        x("DDD", ["DDDD", 3], "DDDo", "dayOfYear"), L("dayOfYear", "DDD"), E("dayOfYear", 4), Q("DDD", xi), Q("DDDD", Mi), te(["DDD", "DDDD"], function(e, t, n) {
            n._dayOfYear = Z(e)
        }), x("m", ["mm", 2], 0, "minute"), L("minute", "m"), E("minute", 14), Q("m", Yi), Q("mm", Yi, ki), te(["m", "mm"], Ii);
        var Hr = z("Minutes", !1);
        x("s", ["ss", 2], 0, "second"), L("second", "s"), E("second", 15), Q("s", Yi), Q("ss", Yi, ki), te(["s", "ss"], ji);
        var Fr, Lr, Vr = z("Seconds", !1);
        for (x("S", 0, 0, function() {
                return ~~(this.millisecond() / 100)
            }), x(0, ["SS", 2], 0, function() {
                return ~~(this.millisecond() / 10)
            }), x(0, ["SSS", 3], 0, "millisecond"), x(0, ["SSSS", 4], 0, function() {
                return 10 * this.millisecond()
            }), x(0, ["SSSSS", 5], 0, function() {
                return 100 * this.millisecond()
            }), x(0, ["SSSSSS", 6], 0, function() {
                return 1e3 * this.millisecond()
            }), x(0, ["SSSSSSS", 7], 0, function() {
                return 1e4 * this.millisecond()
            }), x(0, ["SSSSSSSS", 8], 0, function() {
                return 1e5 * this.millisecond()
            }), x(0, ["SSSSSSSSS", 9], 0, function() {
                return 1e6 * this.millisecond()
            }), L("millisecond", "ms"), E("millisecond", 16), Q("S", xi, vi), Q("SS", xi, ki), Q("SSS", xi, Mi), Fr = "SSSS"; Fr.length <= 9; Fr += "S") Q(Fr, Pi);
        for (Fr = "S"; Fr.length <= 9; Fr += "S") te(Fr, ps);
        Lr = z("Milliseconds", !1), x("z", 0, 0, "zoneAbbr"), x("zz", 0, 0, "zoneName");
        var Gr = g.prototype;
        Gr.add = xr, Gr.calendar = cn, Gr.clone = fn, Gr.diff = vn, Gr.endOf = Hn, Gr.format = Yn, Gr.from = On, Gr.fromNow = bn, Gr.to = xn, Gr.toNow = Tn, Gr.get = B, Gr.invalidAt = Zn, Gr.isAfter = mn, Gr.isBefore = _n, Gr.isBetween = yn, Gr.isSame = gn, Gr.isSameOrAfter = wn, Gr.isSameOrBefore = pn, Gr.isValid = In, Gr.lang = Nr, Gr.locale = Nn, Gr.localeData = Pn, Gr.max = Mr, Gr.min = kr, Gr.parsingFlags = jn, Gr.set = J, Gr.startOf = Un, Gr.subtract = Tr, Gr.toArray = Gn, Gr.toObject = En, Gr.toDate = Vn, Gr.toISOString = Dn, Gr.inspect = Sn, "undefined" != typeof Symbol && null != Symbol.for && (Gr[Symbol.for("nodejs.util.inspect.custom")] = function() {
            return "Moment<" + this.format() + ">"
        }), Gr.toJSON = An, Gr.toString = Mn, Gr.unix = Ln, Gr.valueOf = Fn, Gr.creationData = zn, Gr.eraName = Jn, Gr.eraNarrow = Qn, Gr.eraAbbr = Xn, Gr.eraYear = Kn, Gr.year = Ki, Gr.isLeapYear = ge, Gr.weekYear = ls, Gr.isoWeekYear = hs, Gr.quarter = Gr.quarters = gs, Gr.month = de, Gr.daysInMonth = ce, Gr.week = Gr.weeks = be, Gr.isoWeek = Gr.isoWeeks = xe, Gr.weeksInYear = fs, Gr.weeksInWeekYear = ms, Gr.isoWeeksInYear = ds, Gr.isoWeeksInISOWeekYear = cs, Gr.date = Ur, Gr.day = Gr.days = Fe, Gr.weekday = Le, Gr.isoWeekday = Ve, Gr.dayOfYear = ws, Gr.hour = Gr.hours = lr, Gr.minute = Gr.minutes = Hr, Gr.second = Gr.seconds = Vr, Gr.millisecond = Gr.milliseconds = Lr, Gr.utcOffset = At, Gr.utc = jt, Gr.local = Zt, Gr.parseZone = zt, Gr.hasAlignedHourOffset = $t, Gr.isDST = qt, Gr.isLocal = Jt, Gr.isUtcOffset = Qt, Gr.isUtc = Xt, Gr.isUTC = Xt, Gr.zoneAbbr = vs, Gr.zoneName = ks, Gr.dates = v("dates accessor is deprecated. Use date instead.", Ur), Gr.months = v("months accessor is deprecated. Use month instead", de), Gr.years = v("years accessor is deprecated. Use year instead", Ki), Gr.zone = v("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/", It), Gr.isDSTShifted = v("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information", Bt);
        var Er = Y.prototype;
        Er.calendar = O, Er.longDateFormat = W, Er.invalidDate = C, Er.ordinal = U, Er.preparse = Ss, Er.postformat = Ss, Er.relativeTime = H, Er.pastFuture = F, Er.set = D, Er.eras = $n, Er.erasParse = qn, Er.erasConvertYear = Bn, Er.erasAbbrRegex = ts, Er.erasNameRegex = es, Er.erasNarrowRegex = ns, Er.months = ae, Er.monthsShort = oe, Er.monthsParse = le, Er.monthsRegex = me, Er.monthsShortRegex = fe, Er.week = Se, Er.firstDayOfYear = Oe, Er.firstDayOfWeek = Ye, Er.weekdays = Re, Er.weekdaysMin = Ce, Er.weekdaysShort = We, Er.weekdaysParse = He, Er.weekdaysRegex = Ge, Er.weekdaysShortRegex = Ee, Er.weekdaysMinRegex = Ae, Er.isPM = qe, Er.meridiem = Be, tt("en", {
            eras: [{
                since: "0001-01-01",
                until: 1 / 0,
                offset: 1,
                name: "Anno Domini",
                narrow: "AD",
                abbr: "AD"
            }, {
                since: "0000-12-31",
                until: -1 / 0,
                offset: 1,
                name: "Before Christ",
                narrow: "BC",
                abbr: "BC"
            }],
            dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
            ordinal: function(e) {
                var t = e % 10,
                    n = 1 === Z(e % 100 / 10) ? "th" : 1 === t ? "st" : 2 === t ? "nd" : 3 === t ? "rd" : "th";
                return e + n
            }
        }), e.lang = v("moment.lang is deprecated. Use moment.locale instead.", tt), e.langData = v("moment.langData is deprecated. Use moment.localeData instead.", it);
        var Ar = Math.abs,
            Ir = Is("ms"),
            jr = Is("s"),
            Zr = Is("m"),
            zr = Is("h"),
            $r = Is("d"),
            qr = Is("w"),
            Br = Is("M"),
            Jr = Is("Q"),
            Qr = Is("y"),
            Xr = zs("milliseconds"),
            Kr = zs("seconds"),
            ea = zs("minutes"),
            ta = zs("hours"),
            na = zs("days"),
            sa = zs("months"),
            ia = zs("years"),
            ra = Math.round,
            aa = {
                ss: 44,
                s: 45,
                m: 45,
                h: 22,
                d: 26,
                w: null,
                M: 11
            },
            oa = Math.abs,
            ua = Ct.prototype;
        ua.isValid = Rt, ua.abs = Ws, ua.add = Us, ua.subtract = Hs, ua.as = Es, ua.asMilliseconds = Ir, ua.asSeconds = jr, ua.asMinutes = Zr, ua.asHours = zr, ua.asDays = $r, ua.asWeeks = qr, ua.asMonths = Br, ua.asQuarters = Jr, ua.asYears = Qr, ua.valueOf = As, ua._bubble = Ls, ua.clone = js, ua.get = Zs, ua.milliseconds = Xr, ua.seconds = Kr, ua.minutes = ea, ua.hours = ta, ua.days = na, ua.weeks = $s, ua.months = sa, ua.years = ia, ua.humanize = Xs, ua.toISOString = ei, ua.toString = ei, ua.toJSON = ei, ua.locale = Nn, ua.localeData = Pn, ua.toIsoString = v("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)", ei), ua.lang = Nr, x("X", 0, 0, "unix"), x("x", 0, 0, "valueOf"), Q("x", Ri), Q("X", Ui), te("X", function(e, t, n) {
            n._d = new Date(1e3 * parseFloat(e))
        }), te("x", function(e, t, n) {
            n._d = new Date(Z(e))
        }), e.version = "2.29.4", t(bt), e.fn = Gr, e.min = Tt, e.max = Nt, e.now = Dr, e.utc = d, e.unix = Ms, e.months = xs, e.isDate = u, e.locale = tt, e.invalid = _, e.duration = Kt, e.isMoment = w, e.weekdays = Ns, e.parseZone = Ds, e.localeData = it, e.isDuration = Ut, e.monthsShort = Ts, e.weekdaysMin = Rs, e.defineLocale = nt, e.updateLocale = st, e.locales = rt, e.weekdaysShort = Ps, e.normalizeUnits = V, e.relativeTimeRounding = Js, e.relativeTimeThreshold = Qs, e.calendarFormat = dn, e.prototype = Gr, e.HTML5_FMT = {
            DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
            DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
            DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
            DATE: "YYYY-MM-DD",
            TIME: "HH:mm",
            TIME_SECONDS: "HH:mm:ss",
            TIME_MS: "HH:mm:ss.SSS",
            WEEK: "GGGG-[W]WW",
            MONTH: "YYYY-MM"
        }, window.moment = e
    }).call(this);
});
define("libs/min/sdk.wx.min.js", function(require, module, exports) {
    window.sdk = function(t) {
        "use strict";
        /*! *****************************************************************************
            Copyright (c) Microsoft Corporation.

            Permission to use, copy, modify, and/or distribute this software for any
            purpose with or without fee is hereby granted.

            THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
            REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
            AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
            INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
            LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
            OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
            PERFORMANCE OF THIS SOFTWARE.
            ***************************************************************************** */
        function __awaiter(t, e, s, n) {
            return new(s || (s = Promise))((function(i, a) {
                function fulfilled(t) {
                    try {
                        step(n.next(t))
                    } catch (t) {
                        a(t)
                    }
                }

                function rejected(t) {
                    try {
                        step(n.throw(t))
                    } catch (t) {
                        a(t)
                    }
                }

                function step(t) {
                    var e;
                    t.done ? i(t.value) : (e = t.value, e instanceof s ? e : new s((function(t) {
                        t(e)
                    }))).then(fulfilled, rejected)
                }
                step((n = n.apply(t, e || [])).next())
            }))
        }
        Object.create;
        Object.create;
        t.SDKEntity = void 0,
            function(t) {
                let e, s, n, i, a;
                ! function(t) {
                    t.PC = "pc", t.WEB = "web", t.WEIXIN = "wx", t.BAIDU = "swan", t.VIVO = "vivo", t.TT = "toutiao", t.MEIZU = "meizu", t.OPPO = "oppo", t.NATIVE_XIAOMI = "native_xiaomi", t.NATIVE_TAPTAP = "native_taptap", t.QQ = "qq", t.QTT = "qtt", t.FTNN = "4399", t.FTNNBOX = "4399box", t.NATIVE_ANDROID = "native_android", t.NATIVE_IOS = "native_ios", t.KUAISHOU = "kuaishou", t.HUAWEI = "huawei", t.UC = "uc", t.NATIVE_233 = "native_233", t.TTFF = "2345", t.CHUANYIN = "chuanyin", t.NATIVE_KXHZ = "native_kxhz", t.NATIVE_MMY = "native_mmy", t.NATIVE_VIVO = "native_vivo", t.NATIVE_OPPO = "native_oppo", t.NATIVE_XINGTU = "native_xingtu", t.NATIVE_MEIZU = "native_meizu", t.NATIVE_TOPON = "native_topon", t.NATIVE_HUAWEI = "native_huawei", t.NATIVE_4399 = "native_4399", t.NATIVE_GP = "native_googleplay", t.XIAOMI = "xiaomi", t.ALIPAY = "alipay", t.RONGYAO = "rongyao", t.MINI360 = "mini360", t.YOUGUBT = "ygbt", t.MT = "meituan", t.TAOBAO = "taobao", t.Bilibili = "bilibili"
                }(e = t.PlatformType || (t.PlatformType = {})),
                function(t) {
                    t.BI = "BIStat", t.QQ = "QQStat", t.TAPTAP = "TapTapStat", t.WEIXIN = "WXStat", t.NATIVE_ANDROID = "nativeAndroidStat", t.NATIVE_IOS = "nativeIosStat", t.TT = "toutiaoStat", t.TTFF = "2345Stat", t.CHUANYIN = "chuanyinStat"
                }(s = t.StatisticsType || (t.StatisticsType = {}));
                t.ShareInfoCfgEntity = class {
                    constructor() {
                        this.image = void 0, this.title = void 0
                    }
                };
                t.ServerJsonCfg = class {},
                    function(t) {
                        t[t.SHARE_SUCCESS = 0] = "SHARE_SUCCESS"
                    }(n = t.DataStubType || (t.DataStubType = {})),
                    function(t) {
                        t[t.UNACTIVATE = 0] = "UNACTIVATE", t[t.ACTIVATE = 1] = "ACTIVATE", t[t.GET = 2] = "GET"
                    }(i = t.GET_STATE || (t.GET_STATE = {})),
                    function(t) {
                        t[t.Male = 0] = "Male", t[t.Female = 1] = "Female"
                    }(a = t.Gender || (t.Gender = {}));
                t.UserInfoEntity = class {
                    constructor() {
                        this.userId = void 0, this.name = void 0, this.headUrl = void 0, this.sex = void 0, this.city = void 0, this.province = void 0, this.country = void 0, this.language = void 0
                    }
                };
                t.UserConfigEntity = class {};
                t.ShareQueryParam = class {
                    constructor() {
                        this.shareUserId = void 0, this.shareType = void 0
                    }
                };
                t.ShareInfoEntity = class {
                    constructor() {
                        this.name = void 0, this.headUrl = void 0, this.userId = void 0, this.state = void 0
                    }
                };
                t.ShareStatisticEntity = class {
                    constructor() {
                        this.count = void 0, this.helpOtherCnt = void 0
                    }
                };
                t.MailEntity = class {
                    constructor() {
                        this.id = void 0, this.content = void 0, this.rewards = void 0, this.createdAt = void 0
                    }
                };
                t.CommonRst = class {
                    constructor() {
                        this.msg = ""
                    }
                };
                t.CommonRsp = class {
                    constructor() {
                        this.result = !0
                    }
                };
                t.DataStubRst = class {};
                t.LoginEntityRst = class {};
                t.LoginEntityRsp = class {};
                t.ShareInfoRst = class {};
                t.ShareInfoRsp = class {};
                t.ShareClearRst = class {};
                t.ShareQueryRst = class {};
                t.ShareQueryRsp = class {};
                t.GiftStateUpdateRst = class {};
                t.MailSendRst = class {};
                t.MailInfoRsp = class {};
                t.MailOpenRst = class {};
                t.MailOpenRsp = class {};
                t.CustomServiceCheckRst = class {};
                t.CustomServiceRecvMsgRst = class {};
                t.CustomServiceSendMsgRst = class {};
                t.SubscribeMsgRst = class {};
                t.CustomServiceQueryRst = class {};
                t.CustomServiceQueryRsp = class {};
                t.RankScoreRst = class {};
                t.RankInfoRst = class {};
                t.RankInfoRsp = class {};
                t.IpQueryRst = class {};
                t.IpQueryRsp = class {};
                t.StatStageRst = class {};
                t.StatEventRst = class {};
                t.SaveDataRst = class {};
                t.VoteRst = class {};
                t.VoteRankRst = class {};
                t.VoteItem = class {};
                t.VoteRankRsp = class {};
                t.AccessTokenRst = class {};
                t.AccessTokenRsp = class {};
                t.IdInfoPkg = class {};
                t.IdentityRst = class {};
                t.WhiteQueryRst = class {};
                t.WhiteQueryRsp = class {};
                t.OpenIdRst = class {};
                t.OpenIdRsp = class {}
            }(t.SDKEntity || (t.SDKEntity = {}));
        var e = t.SDKEntity.PlatformType;
        const s = "2.1.053";
        class n {}
        var i, a, r, o, d, h, l, E, S, I, _, c;
        n.E_SDK_LOGIN = "$SDK_LOGIN", n.E_SDK_LOGOUT = "$SDK_LOGOUT", n.E_SDK_INIT_OK = "$SDK_INIT_OK", n.E_SERVER_CFG_UPDATE = "$SERVER_CFG_UPDATE", n.E_GET_SHARE_INFO = "$GET_SHARE_INFO", n.E_GET_SHARE_CONFIG = "$GET_SHARE_CONFIG", n.E_SHARE_RESULT = "$SHARE_RESULT", n.E_SHARE_QUERY_INFO = "$SHARE_QUERY_INFO", n.E_USER_INFO = "$USER_INFO", n.E_FEEDBACK_CLICK = "$FEEDBACK_CLICK", n.E_AD_VIDEO = "$AD_VIDEO", n.E_AD_BANNER = "$AD_BANNER", n.E_AD_INTERSTITIAL = "$AD_INTERSTITIAL", n.E_AD_NATIVE = "$AD_NATIVE", n.E_AD_NATIVE_CUSTOM = "$D_NATIVE_CUSTOM", n.E_AD_APPBOX = "$AD_APPBOX", n.E_AD_BLOCK = "$AD_BLOCK", n.E_FAVORITE_REWARD = "$FAVORITE_REWARD", n.E_ADD_DESKTOP = "$ADD_DESKTOP", n.E_RECORD_VIDEO_START = "$RECORD_VIDEO_START", n.E_RECORD_VIDEO_END = "$RECORD_VIDEO_END", n.E_RECORD_VIDEO_PAUSE = "$RECORD_VIDEO_PAUSE", n.E_RECORD_VIDEO_RESUME = "$RECORD_VIDEO_RESUME", n.E_SERVER_JSON_CONFIG = "$SERVER_JSON_CFG", n.E_REWARD_GAIN = "$REWARD_GAIN", n.E_PAY_RESULT = "$PAY_RESULT", t.SdkCode = void 0, (i = t.SdkCode || (t.SdkCode = {}))[i.WX_LOGIN_SUCCESS = 0] = "WX_LOGIN_SUCCESS", i[i.WX_LOGIN_FAILED = 1] = "WX_LOGIN_FAILED", i[i.WX_AUTH_SUCCESS = 2] = "WX_AUTH_SUCCESS", i[i.WX_AUTH_FAILED = 3] = "WX_AUTH_FAILED", i[i.SERVER_LOGIN_SUCCESS = 4] = "SERVER_LOGIN_SUCCESS", i[i.SERVER_LOGIN_FAILED = 5] = "SERVER_LOGIN_FAILED", i[i.SERVER_LOGIN_ERROR = 6] = "SERVER_LOGIN_ERROR", i[i.SHARE_SUCCESS = 7] = "SHARE_SUCCESS", i[i.SHARE_FAILED = 8] = "SHARE_FAILED", i[i.SHARE_INFO_SUCCESS = 9] = "SHARE_INFO_SUCCESS", i[i.AD_VIDEO_SUCCESS = 10] = "AD_VIDEO_SUCCESS", i[i.AD_VIDEO_UNCOMPLETE = 11] = "AD_VIDEO_UNCOMPLETE", i[i.AD_VIDEO_LOAD_FAIL = 12] = "AD_VIDEO_LOAD_FAIL", i[i.AD_VIDEO_LOAD_SUCCESS = 13] = "AD_VIDEO_LOAD_SUCCESS", i[i.AD_VIDEO_SHOW_SUCCESS = 14] = "AD_VIDEO_SHOW_SUCCESS", i[i.AD_VIDEO_SHOW_FAIL = 15] = "AD_VIDEO_SHOW_FAIL", i[i.AD_INTERSTITIAL_SUCCESS = 16] = "AD_INTERSTITIAL_SUCCESS", i[i.AD_INTERSTITIAL_FAIL = 17] = "AD_INTERSTITIAL_FAIL", i[i.AD_INTERSTITIAL_CLOSE = 18] = "AD_INTERSTITIAL_CLOSE", i[i.AD_NATIVE_SUCCESS = 19] = "AD_NATIVE_SUCCESS", i[i.AD_NATIVE_FAIL = 20] = "AD_NATIVE_FAIL", i[i.AD_NATIVE_DATA = 21] = "AD_NATIVE_DATA", i[i.AD_NATIVE_CUSTOM_SUCCESS = 22] = "AD_NATIVE_CUSTOM_SUCCESS", i[i.AD_NATIVE_CUSTOM_FAIL = 23] = "AD_NATIVE_CUSTOM_FAIL", i[i.AD_NATIVE_CUSTOM_HIDE = 24] = "AD_NATIVE_CUSTOM_HIDE", i[i.AD_NATIVE_CUSTOM_CLOSE = 25] = "AD_NATIVE_CUSTOM_CLOSE", i[i.AD_NATIVE_CUSTOM_LOAD_SUCCESS = 26] = "AD_NATIVE_CUSTOM_LOAD_SUCCESS", i[i.AD_NATIVE_CUSTOM_LOAD_FAIL = 27] = "AD_NATIVE_CUSTOM_LOAD_FAIL", i[i.AD_APPBOX_SUCCESS = 28] = "AD_APPBOX_SUCCESS", i[i.AD_APPBOX_FAIL = 29] = "AD_APPBOX_FAIL", i[i.AD_APPBOX_CLOSE = 30] = "AD_APPBOX_CLOSE", i[i.AD_BLOCK_SUCCESS = 31] = "AD_BLOCK_SUCCESS", i[i.AD_BLOCK_FAIL = 32] = "AD_BLOCK_FAIL", i[i.AD_BANNER_SUCCESS = 33] = "AD_BANNER_SUCCESS", i[i.AD_BANNER_FAIL = 34] = "AD_BANNER_FAIL", i[i.AD_BANNER_LOAD_SUCCESS = 35] = "AD_BANNER_LOAD_SUCCESS", i[i.AD_BANNER_LOAD_FAIL = 36] = "AD_BANNER_LOAD_FAIL", i[i.REWARD_GAIN_SUCCESS = 37] = "REWARD_GAIN_SUCCESS", i[i.REWARD_GAIN_FAIL = 38] = "REWARD_GAIN_FAIL", i[i.AD_BANNER_RESIZE = 39] = "AD_BANNER_RESIZE", i[i.AD_ADDDESKTOP_SUCCESS = 40] = "AD_ADDDESKTOP_SUCCESS", i[i.AD_ADDDESKTOP_FAIL = 41] = "AD_ADDDESKTOP_FAIL", i[i.OPEN_CUSTOMER_SUCCESS = 42] = "OPEN_CUSTOMER_SUCCESS", i[i.OPEN_CUSTOMER_FAILED = 43] = "OPEN_CUSTOMER_FAILED", i[i.OPEN_CUSTOMER_COMPLETE = 44] = "OPEN_CUSTOMER_COMPLETE", i[i.SEND_CUSTOMER_SUCCESS = 45] = "SEND_CUSTOMER_SUCCESS", i[i.SEND_CUSTOMER_FAILED = 46] = "SEND_CUSTOMER_FAILED", i[i.EC_STAT_STAGE_ERR = 47] = "EC_STAT_STAGE_ERR", i[i.EC_STAT_EVENT_ERR = 48] = "EC_STAT_EVENT_ERR", t.WSErrorCode = void 0, (a = t.WSErrorCode || (t.WSErrorCode = {}))[a.EC_NET_UNKNOWN_ERR = 3e3] = "EC_NET_UNKNOWN_ERR", a[a.EC_NET_TIMEOUT = 3001] = "EC_NET_TIMEOUT", a[a.EC_NET_RECONNECT = 3002] = "EC_NET_RECONNECT", a[a.EC_NET_CLOSED = 3003] = "EC_NET_CLOSED", a[a.EC_NET_SEND_ERR = 3004] = "EC_NET_SEND_ERR", a[a.EC_NET_RECEIV_ERR = 3005] = "EC_NET_RECEIV_ERR", t.SdkErrorCode = void 0, (r = t.SdkErrorCode || (t.SdkErrorCode = {}))[r.SUCCESS = 0] = "SUCCESS", r[r.EC_TOKEN_EXPIRED_ERR = 1] = "EC_TOKEN_EXPIRED_ERR", r[r.EC_CUSTOM_SERVICE_ERR = 2] = "EC_CUSTOM_SERVICE_ERR", r[r.EC_PROFILE_AUTH_ERR = 3] = "EC_PROFILE_AUTH_ERR", r[r.EC_QUERY_PARAM_EXCEPTION = 4] = "EC_QUERY_PARAM_EXCEPTION", r[r.EC_VERIFY_CODE_ERR = 5] = "EC_VERIFY_CODE_ERR", r[r.EC_CREATE_USER_ERR = 6] = "EC_CREATE_USER_ERR", r[r.EC_SHAREINFO_CLEAR_ERR = 7] = "EC_SHAREINFO_CLEAR_ERR", r[r.EC_SHAREQUERY_ERR = 8] = "EC_SHAREQUERY_ERR", r[r.EC_SHARECONFIG_ERR = 9] = "EC_SHARECONFIG_ERR", r[r.EC_GIFT_STATE_ERR = 10] = "EC_GIFT_STATE_ERR", r[r.EC_MAIL_INFO_ERR = 11] = "EC_MAIL_INFO_ERR", r[r.EC_MAIL_SEND_ERR = 12] = "EC_MAIL_SEND_ERR", r[r.EC_MAIL_OPEN_ERR = 13] = "EC_MAIL_OPEN_ERR", r[r.EC_FAVORITE_REWARD_ERR = 14] = "EC_FAVORITE_REWARD_ERR", r[r.EC_RANK_SCORE_ERR = 15] = "EC_RANK_SCORE_ERR", r[r.EC_RANK_INFO_ERR = 16] = "EC_RANK_INFO_ERR", r[r.EC_IP_QUERY_ERR = 17] = "EC_IP_QUERY_ERR", r[r.EC_STAT_STAGE_ERR = 18] = "EC_STAT_STAGE_ERR", r[r.EC_STAT_EVENT_ERR = 19] = "EC_STAT_EVENT_ERR", r[r.EC_ACCESS_TOKEN_ERR = 20] = "EC_ACCESS_TOKEN_ERR", r[r.EC_IDENTITY_ERR = 21] = "EC_IDENTITY_ERR", r[r.EC_WHITENAME_ERR = 22] = "EC_WHITENAME_ERR", t.GetRewardSDKWay = void 0, (o = t.GetRewardSDKWay || (t.GetRewardSDKWay = {})).NORMAL = "normal", o.AUTO = "auto", o.SHARE = "share", o.VIDEO = "video", o.INSERT = "insert", t.VideoState = void 0, (d = t.VideoState || (t.VideoState = {}))[d.UNLOAD = 0] = "UNLOAD", d[d.ENABLED = 1] = "ENABLED", d[d.UNENABLED = 2] = "UNENABLED", d[d.SHOW_START = 3] = "SHOW_START", d[d.SHOW_SUCCESS = 4] = "SHOW_SUCCESS", d[d.SHOW_FAIL = 5] = "SHOW_FAIL", t.AdState = void 0, (h = t.AdState || (t.AdState = {}))[h.LOADING = 1] = "LOADING", h[h.LOAD = 2] = "LOAD", h[h.LOAD_FAIL = 3] = "LOAD_FAIL", h[h.DELETING = 4] = "DELETING", t.RequestState = void 0, (l = t.RequestState || (t.RequestState = {}))[l.REQUEST = 1] = "REQUEST", l[l.SUCCESS = 2] = "SUCCESS", l[l.FAIL = 3] = "FAIL", t.BlackAndWhite = void 0, (E = t.BlackAndWhite || (t.BlackAndWhite = {})).Black = "black", E.White = "white", E.White_ = "white_", E.PreWhite = "preWhite", t.FollowedState = void 0, (S = t.FollowedState || (t.FollowedState = {}))[S.NotGot = 1] = "NotGot", S[S.Followed = 2] = "Followed", S[S.Unfollowed = 3] = "Unfollowed", S[S.NotSupport = 4] = "NotSupport", t.AddDeskState = void 0, (I = t.AddDeskState || (t.AddDeskState = {}))[I.NotGot = 1] = "NotGot", I[I.Add = 2] = "Add", I[I.NotAdd = 3] = "NotAdd", I[I.FailAdd = 4] = "FailAdd", t.NativeAdType = void 0, (_ = t.NativeAdType || (t.NativeAdType = {}))[_.ICON = 1] = "ICON", _[_.BANNER = 2] = "BANNER", _[_.NATIVE = 3] = "NATIVE", _[_.NATIVE_MID = 4] = "NATIVE_MID", _[_.NATIME_BOTTOM = 5] = "NATIME_BOTTOM", t.GameBoxType = void 0, (c = t.GameBoxType || (t.GameBoxType = {}))[c.BannerAd_Old = 1] = "BannerAd_Old", c[c.BannerAd_New = 2] = "BannerAd_New", c[c.PortalAd = 3] = "PortalAd", c[c.DrawerAd = 4] = "DrawerAd", c[c.BallAd = 5] = "BallAd";
        class g {
            constructor(t) {
                this.source = t.source || "未知", t.bindCtrlGId && (this.bindCtrlGId = t.bindCtrlGId), t.id && (this.id = t.id), t.queryParam && (this.queryParam = t.queryParam), t.title && (this.title = t.title), t.imgUrl && (this.imgUrl = t.imgUrl), t.type && (this.type = t.type), t.templateId && (this.templateId = t.templateId), t.forever && (this.forever = t.forever)
            }
        }
        class A {}
        A.LOGIN = {
            uri: "/login"
        }, A.LOGINNOAUTU = {
            uri: "/login/noauth"
        }, A.CUSTOMSERVICE_CHECK = {
            uri: "/customservice/msg/:appId",
            method: "GET",
            encrypt: !1
        }, A.CUSTOMSERVICE_MSG = {
            uri: "/customservice/msg/:appId",
            method: "POST",
            encrypt: !1
        }, A.CUSTOMSERVICE_QUERY = {
            uri: "/customservice/query",
            method: "GET"
        }, A.DATASTUB = {
            uri: "/datastub"
        }, A.PROFILE = {
            uri: "/profile"
        }, A.SHAREINFO = {
            uri: "/share/info",
            method: "GET"
        }, A.SHAREQUERY = {
            uri: "/share/query"
        }, A.SHARECLEAR = {
            uri: "/share/clear"
        }, A.GIFTSTATE = {
            uri: "/giftstate"
        }, A.FAVORITEREWARD = {
            uri: "/favoriteReward"
        }, A.MAILINFO = {
            uri: "/mail/info",
            method: "GET"
        }, A.MAILSEND = {
            uri: "/gm/sendmail"
        }, A.MAILOPEN = {
            uri: "/mail/open"
        }, A.RANKSCORE = {
            uri: "/rank/score"
        }, A.RANKINFO = {
            uri: "/rank/info",
            method: "GET"
        }, A.IPQUERY = {
            uri: "/ip/query",
            method: "GET"
        }, A.IPQUERY_EX = {
            uri: "/ip/queryex",
            method: "GET",
            encrypt: !1
        }, A.STATSTAGE = {
            uri: "/statistics/stage"
        }, A.STATEVENT = {
            uri: "/statistics/event"
        }, A.SAVEDATA = {
            uri: "/save"
        }, A.VOTE = {
            uri: "/vote"
        }, A.VOTERANK = {
            uri: "/voterank"
        }, A.ACCESSTOKEN = {
            uri: "/access/token",
            method: "GET"
        }, A.IDENTITY = {
            uri: "/id/query"
        }, A.WHITELIST = {
            uri: "/white/query",
            method: "GET",
            encrypt: !0
        }, A.OPID = {
            uri: "/opid",
            method: "GET",
            encrypt: !0
        };
        class u {
            constructor(t) {
                let e = t.method || "POST",
                    s = u.getDefinedMsg(e, t.uri);
                if (!s) throw Error(`not found msg with uri: ${t.uri} ${e} !!!`);
                this.url = s.uri, this.method = s.method, this.encrypt = s.encrypt
            }
            static register(t) {
                for (const e in t)
                    if (Object.prototype.hasOwnProperty.call(t, e)) {
                        let s = t[e];
                        if (!s.uri) continue;
                        let n = s.method || "POST",
                            i = this.getKey(n, s.uri);
                        if (u.MSG_DEFINES[i]) throw Error("duplicate msg register !!!");
                        let a = !0;
                        !1 === s.encrypt && (a = !1), u.MSG_DEFINES[i] = {
                            uri: s.uri,
                            method: n || "POST",
                            encrypt: a
                        }
                    }
            }
            static getKey(t, e) {
                return t + ":" + e
            }
            static getDefinedMsg(t, e) {
                let s = this.getKey(t, e);
                return this.MSG_DEFINES[s]
            }
        }
        u.MSG_DEFINES = {}, u.register(A);
        class f {}
        f.E_SERVER_LOGIN = "SERVER_LOGIN", f.E_SERVER_RELOGIN = "SERVER_RELOGIN", f.E_SHARE_INFO = "SHARE_INFO", f.E_SHARE_CONFIG = "SHARE_CONFIG", f.E_SHARE_QUERY_USERINFO = "SHARE_QUERY_USERINFO", f.E_PROFILE_RESULT = "PROFILE_RESULT", f.E_FAVORITE_REWARD_RESULT = "FAVORITE_REWARD_RESULT", f.E_MAIL_RESULT = "$MAIL_RESULT", f.E_MAIL_OPENED = "$MAIL_OPENED", f.E_RANK_RESULT = "$RANK_RESULT", f.E_IP_RESULT = "$IP_RESULT", f.E_ACCESS_TOKEN_RESULT = "$ACCESS_TOKEN_RESULT", f.E_IDENTIFICTAION_RESULT = "$IDENTIFICATION_RESULT", f.E_WHITELIST_RESULT = "$WHITELIST_RESULT", f.E_OPENID = "$OPENID";
        class C extends fx.BaseLogic {
            constructor() {
                super(), this.saveTimestamp = this.errCount = 0, this.GameCfg = sdk.Sdk.GameCfg
            }
            static get instance() {
                return this._instance || (this._instance = new C), this._instance
            }
            send(e, s, n, i) {
                if (!(i = i || this.GameCfg.server_url)) return void console.log("send message skipped with server url is unknown !!!");
                if (!e.data) return void console.log("send message without data !!!" + typeof e);
                let a = new fx.Http(e.encrypt),
                    r = i + e.url;
                a.registerErrHandler(this.errorRsp.bind(this, n, e.url), this), a.send(r, e.data, (e => {
                    e.code == t.SdkErrorCode.SUCCESS ? s && s.call(this, e.data, e) : n && n.call(this, e)
                }), this, e.method)
            }
            response(e, s, n) {
                n.code == t.SdkErrorCode.SUCCESS ? e && e.call(this, n.data, n) : s && s.call(this, n)
            }
            errorRsp(e, s, n) {
                if ("string" != typeof n || -1 == n.indexOf("401"))
                    if (e) e.call(this, n);
                    else {
                        if ("object" == typeof n && n.code == fx.BaseCode.HTTP_INTERFACE_UNDEFINED) return void console.warn(s + " 接口未定义！");
                        fx.Utils.isOnMiniGame() && (this.errCount++, this.errCount > 3 && (this.errCount = 0, this.event(f.E_SERVER_LOGIN, {
                            code: t.SdkCode.SERVER_LOGIN_ERROR
                        })))
                    } else s == A.SAVEDATA.uri ? this.event(f.E_SERVER_RELOGIN) : console.warn(s + " 接口未授权！")
            }
            login(e, s) {
                let n = new u(A.LOGIN),
                    i = new t.SDKEntity.LoginEntityRst;
                i.code = e, i.appId = this.GameCfg.appId, i.version = this.GameCfg.version, i.shareQuery = s, i.userInfo = new t.SDKEntity.UserInfoEntity, i.userInfo.platform = this.GameCfg.platform;
                let a = fx.UserLogic.instance.getMine();
                i.userInfo.openId = a.openId, n.data = i, this.send(n, this.loginRsp, this.loginErr)
            }
            loginNoAuth() {
                let e = new u(A.LOGINNOAUTU),
                    s = new t.SDKEntity.LoginEntityRst;
                s.userInfo = new t.SDKEntity.UserInfoEntity, s.version = this.GameCfg.version, s.userInfo.platform = t.SDKEntity.PlatformType.PC, s.code = this.GameCfg.user_unique_id;
                let n = fx.UserLogic.instance.getMine();
                s.userInfo.headUrl = n.headUrl, s.userInfo.name = n.name, e.data = s, this.send(e, this.loginRsp, this.loginErr)
            }
            loginRsp(e) {
                if (console.log("服务器登录成功!"), e.lastTime && (e.lastTime = new Date(e.lastTime)), e.serverTime = new Date(e.serverTime), e.record) {
                    let t = window.pako.inflate(e.record, {
                        to: "string"
                    });
                    t = JSON.parse(decodeURIComponent(t)), fx.Utils.assign(e.userInfo, t, !1)
                }
                this.event(f.E_SERVER_LOGIN, {
                    code: t.SdkCode.SERVER_LOGIN_SUCCESS,
                    pkg: e
                })
            }
            loginErr(e) {
                e.msg && console.warn(e.msg), this.event(f.E_SERVER_LOGIN, {
                    code: t.SdkCode.SERVER_LOGIN_FAILED
                })
            }
            postProfile(t) {
                let e = new u(A.PROFILE);
                e.data = t, this.send(e, this.postProfileRsp)
            }
            postProfileRsp() {
                this.event(f.E_PROFILE_RESULT)
            }
            getShareInfo(e) {
                let s = new u(A.SHAREINFO),
                    n = new t.SDKEntity.ShareInfoRst;
                n.shareTypes = e, s.data = n, this.send(s, this.getShareInfoRsp)
            }
            getShareInfoRsp(t) {
                this.event(f.E_SHARE_INFO, t)
            }
            postShareQuery(e) {
                let s = new u(A.SHAREQUERY),
                    n = new t.SDKEntity.ShareQueryRst;
                n.param = e, s.data = n, this.send(s, this.postShareQueryRsp)
            }
            postShareQueryRsp(t) {
                t.fromUserInfo && this.event(f.E_SHARE_QUERY_USERINFO, t.fromUserInfo)
            }
            postGiftState(e, s, n) {
                let i = new u(A.GIFTSTATE),
                    a = new t.SDKEntity.GiftStateUpdateRst;
                a.state = n, a.userId = e, a.type = s, i.data = a, this.send(i)
            }
            clearShareInfo(e) {
                let s = new u(A.SHARECLEAR),
                    n = new t.SDKEntity.ShareClearRst;
                n.param = e, s.data = n, this.send(s)
            }
            postFavoriteReward() {
                let e = new u(A.FAVORITEREWARD),
                    s = new t.SDKEntity.CommonRst;
                e.data = s, this.send(e, this.postFavoriteRewardRsp)
            }
            postFavoriteRewardRsp(t) {
                this.event(f.E_FAVORITE_REWARD_RESULT)
            }
            dataStub(e, s) {
                let n = new u(A.DATASTUB),
                    i = new t.SDKEntity.DataStubRst;
                i.type = e, i.args = s, n.data = i, this.send(n)
            }
            getMailInfo() {
                let e = new u(A.MAILINFO);
                e.data = new t.SDKEntity.CommonRst, this.send(e, this.getMailInfoRsp)
            }
            getMailInfoRsp(t) {
                this.event(f.E_MAIL_RESULT, t)
            }
            openMail(e) {
                let s = new u(A.MAILOPEN),
                    n = new t.SDKEntity.MailOpenRst;
                n.ids = e, s.data = n, this.send(s, this.openMailRsp)
            }
            openMailRsp(t) {
                this.event(f.E_MAIL_OPENED, t)
            }
            sendMail(e, s, n, i) {
                let a = new u(A.MAILSEND),
                    r = new t.SDKEntity.MailSendRst;
                r.mail = i, r.userName = e, r.password = s, r.userId = n, a.data = r, this.send(a)
            }
            reportedRankScore(e) {
                let s = new u(A.RANKSCORE),
                    n = new t.SDKEntity.RankScoreRst;
                n.score = e, s.data = n, this.send(s)
            }
            getRankInfo() {
                let e = new u(A.RANKINFO),
                    s = new t.SDKEntity.RankInfoRst;
                s.count = 50, s.page = 0, e.data = s, this.send(e, this.getRankInfoRsp)
            }
            getRankInfoRsp(t) {
                this.event(f.E_RANK_RESULT, t)
            }
            getIpQueryInfo() {
                let e = this.GameCfg.server_url_common;
                if (e) {
                    let s = new u(A.IPQUERY);
                    s.data = new t.SDKEntity.IpQueryRst, this.send(s, this.getIpQueryInfoRsp, this.getIpQueryInfoRspFail, e)
                }
            }
            getIpQueryInfoRsp(t) {
                this.event(f.E_IP_RESULT, t)
            }
            getIpQueryInfoRspFail(t) {
                this.event(f.E_IP_RESULT, null), console.log(JSON.stringify(t))
            }
            postStageStat(e, s, n) {
                let i = new u(A.STATSTAGE),
                    a = new t.SDKEntity.StatStageRst;
                a.stageId = e, a.stageState = s, a.stageResult = n, i.data = a, this.send(i)
            }
            postEventStat(e) {
                let s = new u(A.STATEVENT),
                    n = new t.SDKEntity.StatEventRst;
                n.eventName = e, s.data = n, this.send(s)
            }
            save(e) {
                let s = Laya.Browser.now(),
                    n = this.GameCfg.saveDurSec;
                if (fx.Utils.isNumber(n) && s - this.saveTimestamp > 1e3 * n) {
                    let n = new u(A.SAVEDATA),
                        i = new t.SDKEntity.SaveDataRst;
                    const a = window.pako;
                    e.savedTimestamp = s;
                    try {
                        i.record = a.deflate(encodeURIComponent(JSON.stringify(e)), {
                            to: "string"
                        })
                    } catch (t) {
                        return void console.error("userData stringify error !!!\n" + t.message + t.stack)
                    }
                    n.data = i, this.send(n), this.saveTimestamp = s
                }
            }
            getAccessToken(e) {
                let s = this.GameCfg.server_url_common;
                if (s && e) {
                    let n = new u(A.ACCESSTOKEN),
                        i = new t.SDKEntity.AccessTokenRst;
                    i.appId = e, n.data = i, this.send(n, this.getAccessTokenRsp, this.getAccessTokenRspFail, s)
                }
            }
            getAccessTokenRsp(t) {
                this.event(f.E_ACCESS_TOKEN_RESULT, t)
            }
            getAccessTokenRspFail(t) {
                console.log("获取凭证失败：", JSON.stringify(t))
            }
            identification(e, s, n) {
                let i = new t.SDKEntity.IdInfoPkg;
                i.identity = s, i.realName = e, i.userId = n;
                let a = new Laya.Byte;
                a.writeUTFBytes(JSON.stringify(i));
                let r = new t.SDKEntity.IdentityRst;
                r.code = fx.Base64Encrypt.encodeByte(a);
                let o = new u(A.IDENTITY);
                o.data = r;
                let d = this.GameCfg.server_url_common;
                d && this.send(o, this.identificationRsp, this.identificationErr, d)
            }
            identificationRsp(t, e) {
                this.event(f.E_IDENTIFICTAION_RESULT, e)
            }
            identificationErr(t) {
                console.log("认证失败：", JSON.stringify(t)), this.event(f.E_IDENTIFICTAION_RESULT, t)
            }
            getVideoWhiteList(e) {
                let s = new Laya.Byte;
                s.writeUTFBytes(JSON.stringify(e));
                let n = new t.SDKEntity.WhiteQueryRst;
                n.whiteName = fx.Base64Encrypt.encodeByte(s);
                let i = new u(A.WHITELIST);
                i.data = n;
                let a = this.GameCfg.server_url_common;
                a && this.send(i, this.getVideoWhiteListRsp, this.getVideoWhiteListErr, a)
            }
            getVideoWhiteListRsp(t) {
                this.event(f.E_WHITELIST_RESULT, t)
            }
            getVideoWhiteListErr(t) {
                console.log("获取白名单失败：", JSON.stringify(t))
            }
            getOpenId(e, s) {
                let n = new t.SDKEntity.OpenIdRst;
                n.appid = e, n.js_code = s, n.platform = this.GameCfg.platform;
                let i = new u(A.OPID);
                i.data = n;
                let a = this.GameCfg.server_url_common;
                a && this.send(i, this.getOpenIdRsp, this.getOpenIdErr, a)
            }
            getOpenIdRsp(t) {
                this.event(f.E_OPENID, t)
            }
            getOpenIdErr(t) {
                console.log("获取openid失败：", JSON.stringify(t))
            }
        }
        class R extends fx.BaseLogic {
            constructor() {
                super(), this.friendHead = null, this.retryCount = 3, this.ipQueryRsp = void 0, this._requestState = t.RequestState.FAIL, this._adIds = void 0, this.fromSceneValues = [], console.log("FrameSdk Ver: 2.1.053");
                let e = fx.Utils.isOnPC() ? t.SDKEntity.PlatformType.PC : R.GameCfg.platform,
                    s = Laya.ClassUtils.getRegClass(e);
                if (!s) throw Error(`unknown platform !!! ${e}`);
                this.loginInst = new s, console.log(`current platform: ${e}`), this.shareInst = this.loginInst.getShareInstance(), this.adInst = this.loginInst.getAdvInstance(), this.payInst = this.loginInst.getPayInstance();
                let n = R.GameCfg.stat;
                if (n) {
                    let t = Laya.ClassUtils.getRegClass(n);
                    if (!t) throw Error("unknown stat Module !!!");
                    this.statInst = new t
                } else this.statInst = this.loginInst.getStatInstance();
                this.gameStartTime = fx.Utils.getTime()
            }
            get curEnterSceneId() {
                return this._curEnterSceneId
            }
            set curEnterSceneId(t) {
                this._curEnterSceneId = t
            }
            get requestState() {
                return this._requestState
            }
            set requestState(t) {
                this._requestState = t
            }
            static sInit(t) {
                this.GameCfg = t
            }
            static get instance() {
                return this._instance || (this._instance = new R), this._instance
            }
            static isOnBilibili() {
                return this.GameCfg.platform == e.Bilibili
            }
            static isOnPC() {
                return this.GameCfg.platform == e.PC
            }
            static isOnVivo() {
                return this.GameCfg.platform == e.VIVO
            }
            static isOnToutiao() {
                return this.GameCfg.platform == e.TT
            }
            static isOnBaidu() {
                return this.GameCfg.platform == e.BAIDU
            }
            static isOnOppo() {
                return this.GameCfg.platform == e.OPPO
            }
            static isOnNativeXiaoMi() {
                return this.GameCfg.platform == e.NATIVE_XIAOMI
            }
            static isOnXiaoMi() {
                return this.GameCfg.platform == e.XIAOMI
            }
            static isOnWeiXin() {
                return this.GameCfg.platform == e.WEIXIN
            }
            static isOnTapTap() {
                return this.GameCfg.platform == e.NATIVE_TAPTAP
            }
            static isOnNativeAndroid() {
                return this.GameCfg.platform == e.NATIVE_ANDROID
            }
            static isOnNativeIos() {
                return this.GameCfg.platform == e.NATIVE_IOS
            }
            static isOnQQ() {
                return this.GameCfg.platform == e.QQ
            }
            static isOnKuaiShou() {
                return this.GameCfg.platform == e.KUAISHOU
            }
            static isOnHuaWei() {
                return this.GameCfg.platform == e.HUAWEI
            }
            static isOnFTNN() {
                return this.GameCfg.platform == e.FTNN
            }
            static isOnFTNNBOX() {
                return this.GameCfg.platform == e.FTNNBOX
            }
            static isOnTTFF() {
                return this.GameCfg.platform == e.TTFF
            }
            static isOnALIPAY() {
                return this.GameCfg.platform == e.ALIPAY
            }
            static isOnRongYao() {
                return this.GameCfg.platform == e.RONGYAO
            }
            static isOnMINI360() {
                return this.GameCfg.platform == e.MINI360
            }
            static isOnYGBT() {
                return this.GameCfg.platform == e.YOUGUBT
            }
            static isOnMT() {
                return this.GameCfg.platform == e.MT
            }
            initMiniAdapter() {
                this.loginInst.initMiniAdapter()
            }
            getMiniAdapter() {
                return this.loginInst.getMiniAdapter()
            }
            afterEngineInit(t, e) {
                this.loginInst.setKeepScreenOn({
                    keepScreenOn: !0
                }), this.loginInst.onShow(e), this.loginInst.onHide(t), this.loginInst.engineInitialized()
            }
            onInitOnce() {
                this.on(n.E_SDK_LOGIN, this, this.loginSuccess), this.on(fx.BaseEvent.E_APP_ON_RESUME, this, this.onResume), C.instance.on(f.E_SERVER_LOGIN, this, this.onMsgServerLogin), C.instance.on(f.E_SERVER_RELOGIN, this, this.logout), C.instance.on(f.E_SHARE_INFO, this, this.onMsgShareInfo), C.instance.on(f.E_SHARE_QUERY_USERINFO, this, this.onMsgShareQuery), C.instance.on(f.E_PROFILE_RESULT, this, this.onMsgProfile), C.instance.on(f.E_IP_RESULT, this, this.onMsgGetIP), fx.UserLogic.instance.init(), this.login()
            }
            login() {
                this._isLoginServer = 0, this.loginInst.login()
            }
            checkSession(t) {
                this.loginInst.checkSession(t)
            }
            logout() {
                fx.EventCenter.I.event(n.E_SDK_LOGOUT)
            }
            onResume(t) {
                if (R.isOnWeiXin() && !fx.Utils.isOnPC()) {
                    console.log("Sdk OnResume:" + JSON.stringify(t)), t && t.scene && (t.scene = Number(t.scene)), this.loginInst && this.loginInst.onResume(t);
                    let e = -1;
                    if (t && t.scene && (e = t.scene), -1 == e) {
                        let t = this.getLaunchOptionsSync();
                        t && t.scene && t.scene
                    } - 1 !== e && -1 === this.fromSceneValues.indexOf(e) && this.fromSceneValues.push(e), this.judgeBAndW({
                        sceneId: e
                    }), this.curEnterSceneId = e
                }
            }
            wxAuth(t, e, s) {
                return (!this.serverCfg || !this.serverCfg.isAuthorized) && (!this.loginInst.isAuth() && (t && this.loginInst.auth(t), e && s && e.on(n.E_USER_INFO, e, s), !0))
            }
            getLocalAuth() {
                return !this.loginInst.isAuth()
            }
            onMsgProfile() {
                this.serverCfg && (this.serverCfg.isAuthorized = !0)
            }
            wxDestroyAuthBtn() {
                this.serverCfg && this.serverCfg.isAuthorized || this.loginInst && this.loginInst.destroyUserInfoButton()
            }
            loginSuccess(e) {
                e.code == t.SdkCode.WX_LOGIN_SUCCESS ? this.loginInst.loginServerEnable() || this.complete(e) : this.showModal("平台登录失败~ 请稍后尝试重新打开游戏。", "糟糕", "退出", Laya.Handler.create(this, (() => {
                    this.loginInst.exit()
                })), "")
            }
            onMsgServerLogin(e) {
                let s = e.code;
                if (s == t.SdkCode.SERVER_LOGIN_SUCCESS) {
                    let t = e.pkg;
                    this.serverCfg = t.userCfg, this.fromUserInfo = t.fromUserInfo, fx.UserLogic.instance.update(t.userInfo), this._isLoginServer = 1, this.complete(t)
                } else s == t.SdkCode.SERVER_LOGIN_ERROR ? console.error("无法连接服务器 !!!") : console.error("服务器登录失败 !!!"), this._isLoginServer = -1, this.complete()
            }
            complete(t) {
                if (this.getServerJsonCfg(), this.event(n.E_SDK_INIT_OK, t), fx.Utils.isOnMiniGame() && this.loginInst) {
                    let t = this.getLaunchOptionsSync();
                    console.log("sdk Login success with " + JSON.stringify(t));
                    let e = -1;
                    t && t.scene && (e = t.scene), -1 !== e && -1 === this.fromSceneValues.indexOf(e) && this.fromSceneValues.push(e), this.judgeBAndW({
                        sceneId: e
                    }), this.curEnterSceneId = e, "" === R.GameCfg.server_cfg_url && R.isOnWeiXin() && this.enableShare(null, null)
                }
            }
            getFavoriteReward(t, e, s = !0) {
                -1 != this.fromSceneValues.indexOf(1089) ? this.isServerEnable() ? this.serverCfg && !this.serverCfg.favoriteReward && (C.instance.postFavoriteReward(), C.instance.once(f.E_FAVORITE_REWARD_RESULT, this, (() => {
                    this.serverCfg.favoriteReward = !0, this.event(n.E_FAVORITE_REWARD)
                })), t && e && t.once(n.E_FAVORITE_REWARD, t, e)) : t && e && t.once(n.E_FAVORITE_REWARD, t, e) : s && fx.Utils.showTips("请从我的小程序进入游戏后再来领取奖励吧~")
            }
            setServerCfg(t) {
                this.serverCfg = t, this.event(n.E_SERVER_CFG_UPDATE, this.serverCfg)
            }
            getServerCfg() {
                return this.serverCfg
            }
            showRank() {
                let t = Laya.ClassUtils.getRegClass("WXRank");
                fx.SceneManager.openPanel(t, {
                    effectFunc: fx.SceneManager.EF_QSCALE_IN,
                    from: "Sdk"
                })
            }
            enableShare(t, e) {
                fx.Utils.isOnMiniGame() && this.shareInst && this.shareInst.setShare(t, e)
            }
            share(e, s, n) {
                if (this.shareInst)
                    if (e instanceof g) {
                        if (!e.title && !e.imgUrl) {
                            let t = this.getServerJsonCfgShareCfg();
                            if (t) {
                                let s = null;
                                s = e.type ? t[e.type] : fx.Utils.randomInArray(t), s && (e.title = s.title, e.imgUrl = s.image)
                            }
                            e.title || e.imgUrl || (e.title = R.GameCfg.local_share_title, e.imgUrl = R.GameCfg.local_share_image)
                        }
                        this.shareInst.share(e)
                    } else {
                        let i = null,
                            a = null,
                            r = null,
                            o = null;
                        if (e ? e instanceof t.SDKEntity.ShareQueryParam ? (s && n ? (i = s, a = n) : r = e.shareType, o = e) : "number" == typeof e ? r = e : "string" == typeof e && (i = e, a = s) : (i = R.GameCfg.local_share_title, a = R.GameCfg.local_share_image), !i && !a) {
                            let t = this.getServerJsonCfgShareCfg();
                            if (t) {
                                let e = null;
                                e = r ? t[r] : fx.Utils.randomInArray(t)
                            }
                        }
                        this.shareInst.share(i, a, o)
                    }
            }
            shareCustom(t, e, s, n, i) {
                this.shareInst && this.shareInst.shareCustom(t, e, s, n, i)
            }
            onMsgShareInfo(t) {
                this.shareData = t, this.event(n.E_GET_SHARE_INFO, t)
            }
            onMsgShareQuery(t) {
                this.fromUserInfo = t, this.event(n.E_SHARE_QUERY_INFO)
            }
            getShareInfo(t, e, s) {
                e.once(n.E_GET_SHARE_INFO, e, s), C.instance.getShareInfo(t)
            }
            getShareQueryInfo() {
                if (this.loginInst) {
                    let t = this.loginInst.getQuery(),
                        e = this.fromUserInfo;
                    if (t = this.loginInst.getQuery(), t && e) return e.name || (e.name = fx.CfgMgr.instance.getStr("unauthorized")), {
                        query: t,
                        fromUserInfo: e
                    }
                }
            }
            getQueryInfo() {
                if (this.loginInst && this.loginInst.getQuery) return this.loginInst.getQuery()
            }
            preloadVideo(t, e) {
                this.adInst && (t || (t = this.getVideoId()), t && this.adInst.preloadVideo(t, e))
            }
            isHasVideo(e) {
                if (!this.adInst) return t.VideoState.UNENABLED;
                if (e || (e = this.getVideoId()), !e) return t.VideoState.UNENABLED;
                let s = this.adInst.getVideoState(e);
                return this.isAudit() && R.GameCfg.platform !== t.SDKEntity.PlatformType.FTNN && (s = t.VideoState.ENABLED), s
            }
            playVideo(e, s) {
                this.adInst ? (e || (e = this.getVideoId()), e && this.adInst.playVideo(e, s)) : this.event(n.E_AD_VIDEO, {
                    code: t.SdkCode.AD_VIDEO_SUCCESS
                })
            }
            autoPlayVideo() {
                if (!this.isHarvest()) return void console.log("### autoPlayVideo n sg!!!");
                let t = this.getServerJsonCfg();
                t ? (console.log(`### autoPlayVideo ${t.autoPlayVideo_startLev}-${t.autoPlayVideo_spaceLev}-${t.autoPlayVideo_startLoginDays}`), this.checkStageOnoff(t.autoPlayVideo_startLev, t.autoPlayVideo_spaceLev, {
                    startDay: t.autoPlayVideo_startLoginDays
                }) && (console.log("### auto play"), this.playVideo())) : console.log("### autoPlayVideo 配置为空!!!")
            }
            preloadBanner(t, e) {
                this.adInst && (t || (t = this.getBannerId()), t && this.adInst.preloadBanner(t, e))
            }
            showBanner(t, e) {
                this.adInst && (t || (t = this.getBannerId()), t && this.adInst.showBanner(t, e))
            }
            hideBanner(t, e = !0) {
                this.adInst && (t || (t = this.getBannerId()), t && this.adInst.hideBanner(t, e))
            }
            getBanner(t) {
                if (this.adInst && (t || (t = this.getBannerId()), t)) return this.adInst.getBannerById(t)
            }
            getBannerTopEdgeBottom() {
                let e = this.getBanner();
                if (!e) return 0;
                if (e.state !== t.AdState.LOAD) return 0;
                let s = this.getSystemInfo(),
                    n = e.inst.style.height * s.pixelRatio;
                return -1 !== s.system.indexOf("iOS") && fx.Utils.isQMP() && (n += 24), n
            }
            getBannerTopPos() {
                if (fx.Utils.isOnMiniGame()) {
                    let t = this.getBanner();
                    if (t && t.inst && t.inst.style && t.inst.style.top && this.getSystemInfo().screenHeight) return t.inst.style.top / this.getSystemInfo().screenHeight * Laya.stage.height
                }
                return null
            }
            preloadInterstitial(t) {
                this.adInst && (t || (t = this.getInterstitialId()), t && this.adInst.preloadInterstitial(t))
            }
            showInterstitial(t, e) {
                this.adInst && (t || (t = this.getInterstitialId()), t && this.adInst.showInterstitial(t, e))
            }
            getInterstitial(t) {
                if (this.adInst && (t || (t = this.getInterstitialId()), t)) return this.adInst.getInterstitialById(t)
            }
            showFullScreenVideo(t) {
                this.adInst && this.adInst.showFullScreenVideo && this.adInst.showFullScreenVideo(t)
            }
            preloadNativeAd(t, e) {
                this.adInst && (t || (t = this.getNativeAdId()), this.adInst.preloadNativeAd(t, e))
            }
            showNativeAd(t, e) {
                this.adInst && this.adInst.showNativeAd(t, e)
            }
            destoryNativeAd(t) {
                this.adInst && this.adInst.destoryNativeAd(t)
            }
            reportAdClickNativeAd() {
                this.adInst && this.adInst.reportAdClickNativeAd()
            }
            getNativeAdData(t) {
                this.adInst && this.adInst.getNativeAdData(t)
            }
            preloadAppbox(t) {
                this.adInst && (t || (t = this.getAppBoxId()), t && this.adInst.preloadAppbox(t))
            }
            showAppBox(t, e) {
                this.adInst && this.getAppBoxData() && (t || (t = this.getAppBoxId()), t && this.adInst.showAppBox(t, e))
            }
            hideAppBox(t, e) {
                this.adInst && (t || (t = this.getAppBoxId()), t && this.adInst.hideAppBox(t, e))
            }
            getAppBoxData() {
                if (this.adInst) return this.adInst.getAppBoxData()
            }
            autoShowAppBox() {
                if (!this.isHarvest()) return console.log("### autoShowAppBox sh!!!"), !1;
                let t = this.getServerJsonCfg();
                return t ? (console.log(`### autoShowAppBox ${t.appbox_StartLev}-${t.appbox_SpaceLev}`), !!this.checkStageOnoff(t.appbox_StartLev, t.appbox_SpaceLev) && (console.log("### auto play app box"), this.showAppBox(), !0)) : (console.log("### autoShowAppBox 配置为空!!!"), !1)
            }
            createAppBoxBtn(t, e) {
                this.adInst && this.adInst.createAppBoxBtn(t, e)
            }
            showAppBoxBtn() {
                this.adInst && this.adInst.showAppBoxBtn()
            }
            hideAppBoxBtn() {
                this.adInst && this.adInst.hideAppBoxBtn()
            }
            destoryAppBoxBtn() {
                this.adInst && this.adInst.destoryAppBoxBtn()
            }
            showBlockAd(t, e, s, n, i, a) {
                this.adInst && (t || (t = this.getBlockId()), t && this.adInst.showBlockAd(t, {
                    style: e,
                    size: s,
                    orientation: n,
                    type: i,
                    adIntervals: a
                }))
            }
            hideBlockAd(t, e) {
                this.adInst && this.adInst.hideBlockAd(t, e)
            }
            getBlockId() {
                return this.adIds ? this.adIds.blockId : null
            }
            getBlock(t) {
                if (this.adInst && (t || (t = this.getBlockId()), t)) return this.adInst.getCustomAdById(t)
            }
            preloadBlock(t, e) {
                this.adInst && (t || (t = this.getBlockId()), t && this.adInst.preloadBlock(t, e))
            }
            isBlockShowing(t) {
                return this.adInst && t ? this.adInst.isBlockShowing(t) : null
            }
            showCustomAd(t, e) {
                this.adInst && (t || (t = this.getCustomAdId()), t && this.adInst.showCustomAd(t, e))
            }
            hideCustomAd(t) {
                this.adInst && this.adInst.hideCustomAd(t)
            }
            getRewardStrategyInst() {
                return this.loginInst.getRewardStrInstance()
            }
            sendEvent(t, e) {
                console.log(`自定义事件[${t}]-[${JSON.stringify(e)}]`), this.statInst && this.statInst.sendEvent(t, e)
            }
            stageOnStart(t) {
                this.statInst && (console.log(`关卡统计[关卡开始]-${JSON.stringify(t)}`), this.statInst.stageOnStart(t))
            }
            stageOnRunning(t) {
                this.statInst && this.statInst.stageOnRunning(t)
            }
            stageOnEnd(t) {
                this.statInst && (console.log(`关卡统计[关卡结算]-${JSON.stringify(t)}`), this.statInst.stageOnEnd(t))
            }
            unlockItem(t) {
                this.statInst && this.statInst.unlockItem(t)
            }
            canRecord() {
                return !!this.shareInst && this.shareInst.canRecord()
            }
            canShareRecord() {
                return !!this.shareInst && this.shareInst.canShareRecord()
            }
            startRecord(t = 120, e = !1, s = !1) {
                this.shareInst && this.shareInst.recordVideo({
                    duration: t,
                    isEndlessMode: e,
                    isDisposeRecord: s
                })
            }
            stopRecord(t = !1) {
                this.shareInst && this.shareInst.stopRecord(t)
            }
            shareVideo(t = !1) {
                return !!this.shareInst && this.shareInst.shareVideo(t)
            }
            record_pause() {
                this.shareInst && this.shareInst.pauseRecord()
            }
            record_resume() {
                this.shareInst && this.shareInst.resumeRecord()
            }
            record_destroy() {
                this.shareInst && this.shareInst.destroyRecord()
            }
            navigateApp(t) {
                fx.Utils.isOnPC() || this.loginInst.navigateToMiniProgram(t)
            }
            showFeedBack(t) {}
            hideFeedBack() {
                this.feedBackBtn && this.feedBackBtn.hide()
            }
            getOpenDataContext() {
                return this.loginInst.getOpenDataContext()
            }
            openCustomerServiceConversation(t) {
                this.loginInst.openCustomerServiceConversation(t || {})
            }
            getEncryptedDataIv() {
                if (R.isOnWeiXin() && this.loginInst) {
                    return this.loginInst.getEncryptedData()
                }
            }
            isAudit() {
                let t = !1,
                    e = this.getServerJsonCfgVersion();
                return fx.Utils.compareVersion(R.GameCfg.version, e) > 0 && (t = !0), t
            }
            isHarvest() {
                if (this.isAudit()) return console.log("###=======================isHar:[sh]"), !1;
                if (!this.getServerJsonCfgHarvestEnable()) return console.log("###=======================isHar:[n sh]"), !1;
                if (!this.bAndWProperty) {
                    let e = Laya.LocalStorage.getItem("BAndW");
                    "white" === e ? this.bAndWProperty = t.BlackAndWhite.White : "black" === e ? this.bAndWProperty = t.BlackAndWhite.Black : "white_" === e ? this.bAndWProperty = t.BlackAndWhite.White_ : "preWhite" === e && (this.bAndWProperty = t.BlackAndWhite.PreWhite)
                }
                let e = this.getServerJsonCfgChangeWhiteEnable();
                if (console.log(`###=======================isHar:c changeWhite?[${e}]`), t.BlackAndWhite.PreWhite === this.bAndWProperty) {
                    if (console.log("###=======================isHar:local?[preWhite]"), !e) return !1;
                    this.bAndWProperty = t.BlackAndWhite.White, Laya.LocalStorage.setItem("BAndW", this.bAndWProperty)
                } else if (t.BlackAndWhite.Black === this.bAndWProperty) return console.log("###=======================isHar:local?[black]"), !!e && (Laya.LocalStorage.removeItem("BAndW"), this.judgeBAndW({
                    sceneId: this.curEnterSceneId
                }), t.BlackAndWhite.Black !== this.bAndWProperty && this.isHarvest());
                let s, n, i = !0;
                if (this.isCheckIPEnabled()) {
                    if (!this.ipQueryRsp) return console.log("###=======================isHar:n get ip, repeat connect"), C.instance.getIpQueryInfo(), !1;
                    let t = this.getServerJsonCfgUnsafeArea();
                    console.log(`###=======================isHar: begin che ip, cur ipInfo[${JSON.stringify(this.ipQueryRsp)}], cfg ipInfo[${JSON.stringify(t)}]`);
                    for (let e = 0; e < t.length; ++e) {
                        let a = t[e];
                        if (a && (a.city ? -1 !== a.city.indexOf(this.ipQueryRsp.city) && (i = !1) : a.province && -1 !== a.province.indexOf(this.ipQueryRsp.province) && (i = !1), !i)) {
                            n = a.safeSceneId, console.log(`###=======================isHar: not sa ip sSceneId[${JSON.stringify(s)}]`);
                            break
                        }
                    }
                    s = i ? R.instance.getServerJsonCfgSafeSceneId() : n
                } else s = R.instance.getServerJsonCfgSafeSceneId();
                let a = !0;
                if (t.BlackAndWhite.White_ === this.bAndWProperty ? n || (a = !1) : s ? -1 === s.indexOf(this.curEnterSceneId) && (a = !1) : i || (a = !1), this.bAndWProperty || (a ? (this.bAndWProperty = t.BlackAndWhite.White, n ? Laya.LocalStorage.setItem("BAndW", "white_") : Laya.LocalStorage.setItem("BAndW", "white")) : (this.bAndWProperty = t.BlackAndWhite.Black, Laya.LocalStorage.setItem("BAndW", "black"))), R.isOnWeiXin()) {
                    1 == fx.UserLogic.instance.getMine().logindays && fx.UserLogic.instance.isNewDay() && this.getCurPlayedTime() < 60 && (a = !1)
                }
                return console.log(`###=======================isHar:end f[${a}]`), a
            }
            judgeBAndW(e) {
                return this.bAndWProperty = this.loginInst.judgeBAndW(e), console.log(`###hb名单[${this.bAndWProperty}]-场景值[${e.sceneId}]`), this.bAndWProperty === t.BlackAndWhite.White
            }
            onMsgGetIP(t) {
                t && (this.ipQueryRsp = t)
            }
            getPromotionEnable() {
                if (this.isAudit()) return !1;
                let judgePromotion = () => !!e.promotionEnable && (t.BlackAndWhite.White === this.bAndWProperty || e.promotionBlackEnable),
                    e = this.getServerJsonCfg();
                return !!e && (e.promotion_harvestConnection ? !!this.isHarvest() && judgePromotion() : judgePromotion())
            }
            getShareEnable() {
                let t = !1;
                return this.isHarvest() || (t = this.getServerJsonCfgShareEnable()), t
            }
            getServerJsonCfg(e = 5) {
                if (!this.serverJsonCfg && "" !== R.GameCfg.server_cfg_url && this.loginInst && this.requestState === t.RequestState.FAIL) {
                    this.requestState = t.RequestState.REQUEST;
                    let s = setTimeout((() => {
                        this.requestState = t.RequestState.FAIL
                    }), 1e3 * e);
                    (R.GameCfg.server_cfg_url.includes("https") ? this.loginInst.requestDecrypt.bind(this.loginInst) : this.loginInst.request.bind(this.loginInst))(R.GameCfg.server_cfg_url, null, Laya.Handler.create(this, (e => {
                        if (this.serverJsonCfg) return clearTimeout(s), void(this.requestState = t.RequestState.FAIL);
                        if (this.serverJsonCfg = e, fx.EventCenter.I.event(fx.BaseEvent.E_SERVER_CFG_COMPLETE, this.serverJsonCfg), this.requestState = t.RequestState.SUCCESS, this.serverJsonCfg) {
                            if (this.serverJsonCfg.showBQ) {
                                let t = "";
                                ["8", "4", "5", "7", "4", "F", "5", "C", "6", "7", "4", "3", "5", "F", "5", "2", "6", "2", "1", "0", "9", "0", "F", "D", "6", "C", "3", "4", "7", "1", "8", "A", "4", "E", "9", "2", "5", "2", "A", "8", "7", "9", "D", "1", "6", "2", "8", "0", "6", "7", "0", "9", "9", "6", "5", "0", "5", "1", "6", "C", "5", "3", "F", "8", "6", "2", "4", "0", "6", "7", "0", "9"].forEach(((e, s) => {
                                    s % 4 == 0 && (t += "%", t += "u"), t += e
                                }));
                                let e = new Laya.Label(unescape(t));
                                Laya.stage.addChild(e), e.right = 0, e.top = 0, e.alpha = .4, e.fontSize = 20, e.color = "#ffffff", e.zOrder = 1e3
                            }
                            this.serverJsonCfg.termination && Laya.stage.destroy()
                        }
                        if (fx.Utils.isOnNativeAndroid() || fx.Utils.isOnNativeIos()) {
                            let t = this.loginInst.getBridgeInst();
                            t.getIsAudit(), t.getIsHarvest()
                        }
                        if (this.serverJsonCfg.shareCfg && 0 !== this.serverJsonCfg.shareCfg.length) {
                            let t = fx.Utils.randomInArray(this.serverJsonCfg.shareCfg);
                            this.enableShare(t.title, t.image)
                        }
                        this.judgeBAndW({
                            sceneId: this.curEnterSceneId
                        })
                    })), Laya.Handler.create(this, (() => {
                        clearTimeout(s), this.requestState = t.RequestState.FAIL, this.retryCount > 0 ? (this.retryCount--, console.log(`获取json配置失败！重试：第${3-this.retryCount}次`), this.getServerJsonCfg()) : fx.EventCenter.I.event(fx.BaseEvent.E_SERVER_CFG_COMPLETE, null)
                    })), "GET", ["Cache-Control", "no-cache"])
                }
                return this.serverJsonCfg
            }
            getServerJsonCfgVersion() {
                let t = this.getServerJsonCfg();
                return t ? t.version : "0.0.0"
            }
            getServerJsonCfgShareEnable() {
                let t = this.getServerJsonCfg();
                return !!t && t.shareEnable
            }
            getServerJsonCfgNavigateEnable() {
                let t = this.getServerJsonCfg();
                return !!t && t.navigateEnable
            }
            getServerJsonCfgHarvestEnable() {
                let t = this.getServerJsonCfg();
                return !!t && Boolean(t.harvestEnable)
            }
            getServerJsonCfgShareCfg() {
                let t = this.getServerJsonCfg();
                return t ? t.shareCfg : null
            }
            getServerJsonCfgNoticeHtmlText() {
                let t = this.getServerJsonCfg();
                return t ? t.noticeHtmlText : ""
            }
            getServerJsonCfgChangeWhiteEnable() {
                let t = this.getServerJsonCfg();
                return !!t && Boolean(t.changeWhite)
            }
            getServerJsonCfgOffEgg() {
                let t = this.getServerJsonCfg();
                return !!t && !!t.offEgg
            }
            getServerJsonCfgShareParams() {
                let t = this.getServerJsonCfg();
                return t && t.shareParams ? t.shareParams : {
                    shareFailProb: 0,
                    FreshShareCntBase: 0,
                    OlderShareCtnBase: 0,
                    ShareSpace: 0
                }
            }
            getServerJsonCfgNavigateApplist() {
                let t = this.getServerJsonCfg();
                if (!t) return;
                if (!this.getServerJsonCfgNavigateEnable()) return;
                let e = t.navigateAppList;
                return e && e instanceof Array ? e : void 0
            }
            getServerJsonCfgSafeSceneId() {
                let t = this.getServerJsonCfg();
                if (!t) return;
                let e = t.safeSceneId;
                return e && e instanceof Array ? e : void 0
            }
            getServerJsonCfgUnsafeArea() {
                let t = this.getServerJsonCfg();
                if (!t) return;
                let e = t.ipUnsafeArea;
                return e && e instanceof Array ? e : void 0
            }
            isCheckIPEnabled() {
                let t = this.getServerJsonCfg();
                if (!t) return !0;
                let e = !1,
                    s = t.ipUnsafeArea;
                return s && 0 !== s.length && (e = !0), e
            }
            isRedBagEnabled() {
                if (!this.isHarvest()) return !1;
                let t = this.getServerJsonCfg();
                return !!t && t.redBag_onoff
            }
            checkFunctionOpenById(t) {
                let e = new Date,
                    s = `${e.getFullYear()}.${e.getMonth()+1}.${e.getDate()}.${e.getHours()}`,
                    n = this.getServerJsonCfg(),
                    i = n && n.versionUpdater;
                if (i) {
                    if (this.isAudit()) return !0; {
                        let checkServer = () => {
                                let e = i[`${t}`];
                                return !!e && fx.Utils.compareVersion(s.toString(), e.toString()) >= 0
                            },
                            e = fx.CfgMgr.instance.get("versionUpdater", t);
                        return e && fx.Utils.compareVersion(s.toString(), e.toString()) >= 0 || checkServer()
                    }
                } {
                    let e = fx.CfgMgr.instance.get("versionUpdater", t);
                    return !!e && fx.Utils.compareVersion(s.toString(), e.toString()) >= 0
                }
            }
            get adIds() {
                if (void 0 === this._adIds) {
                    let t = this.getServerJsonCfg();
                    if (t && t.channel_AdIds) {
                        let e = t.channel_AdIds.default;
                        this.initAdIds(e)
                    }
                }
                return this._adIds
            }
            set adIds(t) {
                this.initAdIds(t)
            }
            getVideoId() {
                return this.adIds ? this.adIds.videoId : null
            }
            getBannerId() {
                return this.adIds ? this.adIds.bannerId : null
            }
            getInterstitialId() {
                return this.adIds ? this.adIds.interstitialId : null
            }
            getAppBoxId() {
                return this.adIds ? this.adIds.appBoxId : null
            }
            getNativeAdId() {
                return this.adIds ? this.adIds.nativeAdId : null
            }
            getCustomAdId() {
                return this.adIds ? this.adIds.customAdId : null
            }
            initAdIds(t) {
                t && (!this._adIds && (this._adIds = {}), t.videoId && (this._adIds.videoId = t.videoId), t.bannerId && (this._adIds.bannerId = t.bannerId), t.interstitialId && (this._adIds.interstitialId = t.interstitialId), t.appBoxId && (this._adIds.appBoxId = t.appBoxId), t.nativeAdId && (this._adIds.nativeAdId = t.nativeAdId), t.blockId && (this._adIds.blockId = t.blockId), t.customAdId && (this._adIds.customAdId = t.customAdId))
            }
            showGameClubButton(t) {
                this.loginInst.createGameClubButton({
                    type: "image",
                    style: {
                        left: 8,
                        top: .05 * t + 24,
                        width: 30,
                        height: 30
                    },
                    icon: "light"
                })
            }
            checkUpdate() {
                this.loginInst.checkUpdate()
            }
            loadSubpackage(t) {
                return this.loginInst.loadSubpackage(t)
            }
            exit() {
                this.loginInst.exit()
            }
            showModal(t, e = "提示", s = "确定", n, i = "取消", a) {
                this.loginInst.showModal(t, e, s, n, i, a)
            }
            getSystemInfo() {
                return this.loginInst.getSystemInfo()
            }
            getMenuButtonBoundingClientRect() {
                return this.loginInst.getMenuButtonBoundingClientRect()
            }
            getLaunchOptionsSync() {
                return this.loginInst.getLaunchOptionsSync()
            }
            isServerEnable() {
                return !!this.loginInst.loginServerEnable()
            }
            onAudioInterruption(t, e) {
                this.loginInst.onAudioInterruption(t, e)
            }
            isAuth() {
                return this.loginInst.isAuth()
            }
            vibrate() {
                let t = fx.UserLogic.instance.getUserInfo(),
                    e = !0;
                t && !1 === t.vibrateEnable && (e = !1), this.loginInst && e && this.loginInst.vibrateShort()
            }
            isConnectNetwork() {
                return this.loginInst.isConnectNetwork()
            }
            initAdv(t) {
                this.adInst && this.adInst.init(t)
            }
            getCode() {
                return this.loginInst.getCode()
            }
            getLoginCode() {
                return this.loginInst.getLoginCode()
            }
            getLoginAnonymousCode() {
                return this.loginInst.getLoginAnonymousCode()
            }
            saveAppToDesktop(t) {
                this.loginInst && this.loginInst.saveAppToDesktop(t)
            }
            showFavoriteGuide(t) {
                this.loginInst && this.loginInst.showFavoriteGuide(t)
            }
            FollowAwemeUser(t) {
                this.loginInst && this.loginInst.FollowAwemeUser(t)
            }
            getFollowAwemeState() {
                return this.loginInst ? this.loginInst.getFollowAwemeState() : t.FollowedState.NotGot
            }
            getAddDeskState() {
                return this.loginInst ? this.loginInst.getAddDeskState() : t.AddDeskState.NotGot
            }
            requestSubscribeMessage(t) {
                this.loginInst && this.loginInst.requestSubscribeMessage(t)
            }
            checkStageOnoff(t, e, s) {
                let n = fx.UserLogic.instance.getUserInfo();
                if (!n.stageId) return !1;
                if (s) {
                    if (s.startDay && n.logindays < s.startDay) return console.log(`### checkStageOnoff userInfo.logindays<extra.startDay-${n.logindays}-${s.startDay}`), !1;
                    if (s.odd) {
                        s.odd > 1 && (s.odd = s.odd / 100);
                        let t = Math.random();
                        if (t > s.odd) return console.log(`### checkStageOnoff random>extra.odd-${t}-${s.odd}`), !1
                    }
                }
                return t ? n.stageId < t ? (console.log(`### checkStageOnoff userInfo.stageId<startLev-${n.stageId}-${t}`), !1) : !e || 0 === e || 0 == (n.stageId - t) % (e + 1) || (console.log(`### checkStageOnoff 1!==(userInfo.stageId-startLev)%spaceLev-${n.stageId}-${t}-${e}-${(n.stageId-t-1)%e}`), !1) : (console.log(`### checkStageOnoff !startLev-${t}`), !1)
            }
            resourceNotEnoughProcess(t, e = !0) {
                e ? R.instance.showModal(t.msgboxContent, t.msgboxTitle, t.msgboxOkTxt, t.msgboxOkHandler, t.msgboxCancelTxt, t.msgboxCancelHandler) : t.msgboxOkHandler.run()
            }
            saveToServer(t) {
                1 === this._isLoginServer && C.instance.save(t)
            }
            isLoginServer() {
                return this._isLoginServer
            }
            isFreeVideo() {
                if (this.loginInst) return this.loginInst.isFreeVideo()
            }
            getNickName() {
                if (this.loginInst) return this.loginInst.getNickName()
            }
            clipboardData(t) {
                if (this.loginInst) return this.loginInst.clipboardData(t)
            }
            showLoading(t, e, s) {
                this.loginInst.showLoading(t, e, s)
            }
            hideLoading(t) {
                this.loginInst.hideLoading(t)
            }
            request(t, e, s, n, i = "GET", a, r) {
                a ? this.loginInst.requestDecrypt(t, n, e, s, i, r) : this.loginInst.request(t, n, e, s, i, r)
            }
            requestPms(t, e, s = "GET", n, i) {
                return __awaiter(this, void 0, void 0, (function*() {
                    return this.loginInst.requestPms(t, e, s, n, i)
                }))
            }
            getIpQuery() {
                return this.ipQueryRsp ? this.ipQueryRsp : (console.log("###=======================isHar:n get ip, repeat connect"), C.instance.getIpQueryInfo(), null)
            }
            getCurPlayedTime() {
                return ((new Date).getTime() - this.gameStartTime) / 1e3
            }
            pay(t) {
                this.payInst && this.payInst.pay(t)
            }
            getGlobalInstance() {
                if (this.loginInst && this.loginInst.globalInst) return this.loginInst.globalInst()
            }
            getLoginInst() {
                return this.loginInst
            }
        }
        Laya.ClassUtils.regClass("Sdk", R);
        class p {
            static get inst() {
                return this._inst || (this._inst = new p), this._inst
            }
            gain(t) {
                t && t.gain()
            }
        }
        class y {
            constructor(t) {
                this.shareCount = 0, this.shareStartTime = void 0, this._shareParam = t
            }
            gain() {
                fx.Utils.isOnMiniGame() ? (this.shareStartTime = fx.Utils.getTime(), this.shareCount += 1, fx.EventCenter.I.once(fx.BaseEvent.E_APP_ON_RESUME, this, (e => {
                    Math.floor((fx.Utils.getTime() - this.shareStartTime) / 1e3) > 3 ? fx.EventCenter.I.event(n.E_REWARD_GAIN, {
                        code: t.SdkCode.REWARD_GAIN_SUCCESS,
                        way: t.GetRewardSDKWay.SHARE,
                        rewardType: t.GetRewardSDKWay.SHARE
                    }) : this.continue("分享给新的朋友才能获得奖励！"), this.shareStartTime = void 0
                })), sdk.Sdk.instance.share(this._shareParam)) : fx.EventCenter.I.event(n.E_REWARD_GAIN, {
                    code: t.SdkCode.REWARD_GAIN_SUCCESS,
                    way: t.GetRewardSDKWay.SHARE,
                    rewardType: t.GetRewardSDKWay.SHARE
                })
            }
            continue (e) {
                sdk.Sdk.instance.showModal(e, "提示", "继续分享", Laya.Handler.create(this, (() => {
                    this.gain()
                })), "一会再来", Laya.Handler.create(this, (() => {
                    this.shareCount = 0, fx.EventCenter.I.event(n.E_REWARD_GAIN, {
                        code: t.SdkCode.REWARD_GAIN_FAIL
                    })
                })))
            }
        }
        class T {
            constructor() {}
            init(t) {}
            recordVideo(t) {}
            stopRecord(t) {}
            shareVideo(t) {
                return !1
            }
            canRecord() {
                return !1
            }
            canShareRecord() {
                return null
            }
            pauseRecord() {}
            resumeRecord() {}
            destroyRecord() {}
            setShare(t, e, s, n) {
                wx.showShareMenu({
                    withShareTicket: !0,
                    menus: ["shareAppMessage", "shareTimeline"]
                }), s = s || "", wx.onShareAppMessage(function() {
                    return {
                        title: t,
                        imageUrl: e,
                        query: s
                    }
                }.bind(this)), wx.onShareTimeline(function() {
                    return {
                        title: t,
                        imageUrl: e,
                        query: s
                    }
                }.bind(this))
            }
            share(t, e, s) {
                let n = null,
                    i = null,
                    a = null,
                    r = null;
                t instanceof g ? (n = t.title, i = t.imgUrl, a = t.queryParam, r = t.source) : (n = t, i = e, a = s, r = "未知");
                let o = "";
                if (a) {
                    fx.EventCenter.I.once(fx.BaseEvent.E_APP_ON_RESUME, this, (function(t) {
                        fx.Utils.showTips("感谢分享!!!")
                    }));
                    for (let t in a) {
                        let e = a[t];
                        null != e && ("object" == typeof e && (e = JSON.stringify(e)), o = null == o ? t + "=" + e : o + "&" + t + "=" + e)
                    }
                }
                console.log("wx share queryParam:" + JSON.stringify(a), o), wx.shareAppMessage({
                    title: n,
                    imageUrl: i,
                    query: o
                })
            }
            shareCustom(t, e, s, n, i) {
                wx.shareAppMessage({
                    title: t,
                    imageUrl: s,
                    query: n
                })
            }
        }
        T.aldShareEnable = !1, Laya.ClassUtils.regClass("WXShare", T);
        class O {
            constructor() {
                this.banners = [], this.videos = [], this.curIsAutoPlayVideo = !1, this.interstitials = [], this.customAds = [], this.gridAds = []
            }
            getVideoById(t) {
                return this.videos.filter(((e, s, n) => t === e.id))[0]
            }
            loadVideo(e, s = !1) {
                this.curIsAutoPlayVideo = s;
                let i = 0 === this.videos.length,
                    a = this.getVideoById(e);
                a || (a = {
                    id: e,
                    inst: null,
                    state: t.AdState.LOADING
                }, this.videos.push(a)), a.inst ? t.AdState.LOAD_FAIL === a.state && a.inst.load().catch((e => {
                    a.state = t.AdState.LOAD_FAIL, console.log("激励视频广告显示失败")
                })) : (a.inst = wx.createRewardedVideoAd({
                    adUnitId: a.id
                }), a.inst.load(), i && (a.inst.onLoad((() => {
                    console.log("激励视频广告加载成功"), !Laya.MouseManager.enabled && (Laya.MouseManager.enabled = !0), a.state = t.AdState.LOAD, fx.EventCenter.I.event(n.E_AD_VIDEO, {
                        code: t.SdkCode.AD_VIDEO_LOAD_SUCCESS
                    }), this.curIsAutoPlayVideo && this.showVideo(a.id)
                })), a.inst.onError((e => {
                    console.log("激励视频广告加载失败"), !Laya.MouseManager.enabled && (Laya.MouseManager.enabled = !0), a.state = t.AdState.LOAD_FAIL, fx.EventCenter.I.event(n.E_AD_VIDEO, {
                        code: t.SdkCode.AD_VIDEO_LOAD_FAIL
                    })
                })), a.inst.onClose((e => {
                    e && e.isEnded || void 0 === e ? (!Laya.MouseManager.enabled && (Laya.MouseManager.enabled = !0), fx.EventCenter.I.event(n.E_AD_VIDEO, {
                        code: t.SdkCode.AD_VIDEO_SUCCESS
                    })) : (!Laya.MouseManager.enabled && (Laya.MouseManager.enabled = !0), fx.EventCenter.I.event(n.E_AD_VIDEO, {
                        code: t.SdkCode.AD_VIDEO_UNCOMPLETE
                    })), this.curIsAutoPlayVideo = !1, setTimeout((() => {
                        a.inst.load()
                    }), 1e3)
                }))))
            }
            showVideo(e) {
                let s = this.getVideoById(e);
                s && s.inst && s.inst.show().then((() => {
                    console.log("激励视频广告显示"), fx.EventCenter.I.event(n.E_AD_VIDEO, {
                        code: t.SdkCode.AD_VIDEO_SHOW_SUCCESS
                    })
                })).catch((() => {
                    s.inst.load().then((() => s.inst.show())).catch((e => {
                        s.state = t.AdState.LOAD_FAIL, console.log("激励视频广告显示失败"), fx.EventCenter.I.event(n.E_AD_VIDEO, {
                            code: t.SdkCode.AD_VIDEO_SHOW_FAIL
                        })
                    }))
                }))
            }
            preloadVideo(t) {
                this.loadVideo(t)
            }
            getVideoState(e) {
                let s = this.getVideoById(e);
                return s ? t.AdState.LOAD === s.state ? t.VideoState.ENABLED : t.VideoState.UNENABLED : t.VideoState.UNLOAD
            }
            playVideo(e) {
                console.log("video Id", e);
                let s = this.getVideoById(e);
                s ? t.AdState.LOAD === s.state ? (Laya.MouseManager.enabled = !1, this.showVideo(e)) : t.AdState.LOAD_FAIL === s.state && (fx.Utils.showTips("暂无视频!!!"), fx.EventCenter.I.event(n.E_AD_VIDEO, {
                    code: t.SdkCode.AD_VIDEO_LOAD_FAIL
                })) : (Laya.MouseManager.enabled = !1, this.loadVideo(e, !0)), Laya.MouseManager.enabled || setTimeout((function() {
                    !Laya.MouseManager.enabled && (Laya.MouseManager.enabled = !0)
                }), 1e4)
            }
            preloadBanner(e, s) {
                let i = this.getBannerById(e);
                if (i ? s || (s = i.customParams) : (!s && (s = {
                        forever: !1,
                        widthScaleRate: 1,
                        adIntervals: 30
                    }), !s.widthScaleRate && (s.widthScaleRate = 1), s.forever = Boolean(s && s.forever), s && s.adIntervals && (s.adIntervals = s.adIntervals), i = {
                        id: e,
                        state: t.AdState.LOADING,
                        inst: null,
                        showCnt: 0,
                        createStamp: fx.Utils.getTime(),
                        customParams: s
                    }, this.banners.push(i)), i.inst) t.AdState.DELETING !== i.state && t.AdState.LOAD_FAIL !== i.state || (i.inst.destroy(), i.inst = null, i.showCnt = 0, i.state = t.AdState.LOADING, this.preloadBanner(e, s));
                else {
                    let a = sdk.Sdk.instance.getSystemInfo(),
                        r = (a.screenWidth > a.screenHeight ? a.screenHeight : a.screenWidth) * s.widthScaleRate;
                    i.inst = wx.createBannerAd({
                        adUnitId: e,
                        adIntervals: s.adIntervals,
                        style: {
                            left: 0,
                            top: 0,
                            width: r
                        }
                    }), i.inst.onResize((t => {
                        i.inst.style.left = (a.screenWidth - i.inst.style.realWidth) / 2, i.inst.style.top = a.screenHeight - i.inst.style.realHeight, -1 !== a.system.indexOf("iOS") && fx.Utils.isQMP() && (i.inst.style.top -= 24)
                    })), i.inst.onLoad((() => {
                        console.log("bannerid${bannerIds[i]} 广告加载成功"), i.state = t.AdState.LOAD, fx.EventCenter.I.event(n.E_AD_BANNER, {
                            code: t.SdkCode.AD_BANNER_LOAD_SUCCESS
                        }), i.customParams && i.customParams.forever && i.inst.show()
                    })), i.inst.onError((e => {
                        console.log("bannerid${bannerIds[i]} 广告加载失败"), i.state = t.AdState.LOAD_FAIL, fx.EventCenter.I.event(n.E_AD_BANNER, {
                            code: t.SdkCode.AD_BANNER_LOAD_FAIL
                        })
                    }))
                }
            }
            showBanner(e, s) {
                console.log("banner Id", e);
                let i = this.getBannerById(e);
                if (i) {
                    if (i.customParams && i.customParams.forever) return;
                    if (t.AdState.LOAD === i.state) {
                        if (s) {
                            let t = sdk.Sdk.instance.getSystemInfo();
                            s.top && (i.inst.style.top = s.top / Laya.stage.height * t.screenHeight), s.left && (i.inst.style.left = s.left / Laya.stage.width * t.screenWidth)
                        }
                        i.showCnt++, i.inst.show().then((() => {
                            fx.EventCenter.I.event(n.E_AD_BANNER, {
                                code: t.SdkCode.AD_BANNER_SUCCESS
                            })
                        })).catch((e => {
                            fx.EventCenter.I.event(n.E_AD_BANNER, {
                                code: t.SdkCode.AD_BANNER_FAIL
                            })
                        }))
                    } else t.AdState.LOAD_FAIL === i.state ? setTimeout((() => {
                        this.preloadBanner(e)
                    }), 1e4) : t.AdState.LOADING === i.state && s && s.isPostLoadedShow && setTimeout((() => {
                        this.showBanner(e, s)
                    }), 500)
                } else this.preloadBanner(e, s)
            }
            hideBanner(e, s) {
                let n = this.getBannerById(e);
                n && (n.customParams && n.customParams.forever || (n.inst && n.inst.hide(), n.showCnt > 0 && s && (n.state = t.AdState.DELETING, this.preloadBanner(e))))
            }
            getBannerById(t) {
                return this.banners.filter(((e, s, n) => e.id === t), this)[0]
            }
            showInterstitial(e) {
                let s = sdk.Sdk.instance.getSystemInfo().SDKVersion;
                if (!fx.Utils.compatibleVersion(s, "2.6.0")) return;
                let i = this.getInterstitialById(e);
                if (i) i.inst.show().catch((e => {
                    fx.EventCenter.I.event(n.E_AD_INTERSTITIAL, {
                        code: t.SdkCode.AD_INTERSTITIAL_FAIL
                    }), console.log("interstitial 广告显示失败：" + JSON.stringify(e))
                }));
                else {
                    let s = wx.createInterstitialAd({
                        adUnitId: e
                    });
                    i = {
                        id: e,
                        inst: s,
                        state: t.AdState.LOADING
                    }, this.interstitials.push(i), s.onLoad((() => {
                        i.state = t.AdState.LOAD, fx.EventCenter.I.event(n.E_AD_INTERSTITIAL, {
                            code: t.SdkCode.AD_INTERSTITIAL_SUCCESS
                        }), console.log("interstitial 广告加载成功")
                    })), s.onError((e => {
                        i.state = t.AdState.LOAD_FAIL, fx.EventCenter.I.event(n.E_AD_INTERSTITIAL, {
                            code: t.SdkCode.AD_INTERSTITIAL_FAIL
                        }), console.log("interstitial 广告加载失败")
                    })), s.onClose((e => {
                        fx.EventCenter.I.event(n.E_AD_INTERSTITIAL, {
                            code: t.SdkCode.AD_INTERSTITIAL_CLOSE
                        }), console.log("插屏 广告关闭")
                    }))
                }
            }
            getInterstitialById(t) {
                return this.interstitials.filter(((e, s, n) => e.id === t), this)[0]
            }
            preloadInterstitial(e) {
                let s = this.getInterstitialById(e);
                s || (s = {
                    id: e,
                    state: t.AdState.LOADING,
                    inst: null
                }, this.interstitials.push(s)), s.inst ? t.AdState.DELETING !== s.state && t.AdState.LOAD_FAIL !== s.state || (s.inst.destroy(), s.inst = null, s.state = t.AdState.LOADING, this.preloadInterstitial(e)) : (s.inst = wx.createInterstitialAd({
                    adUnitId: e
                }), s.inst.onLoad((() => {
                    console.log(`interstitial.id:${s.id} 广告加载成功`), s.state = t.AdState.LOAD, fx.EventCenter.I.event(n.E_AD_INTERSTITIAL, {
                        code: t.SdkCode.AD_INTERSTITIAL_SUCCESS
                    })
                })), s.inst.onError((e => {
                    console.log(`interstitial.id:${s.id} 广告加载失败`), s.state = t.AdState.LOAD_FAIL, fx.EventCenter.I.event(n.E_AD_INTERSTITIAL, {
                        code: t.SdkCode.AD_INTERSTITIAL_FAIL
                    })
                })), s.inst.onClose((e => {
                    fx.EventCenter.I.event(n.E_AD_INTERSTITIAL, {
                        code: t.SdkCode.AD_INTERSTITIAL_CLOSE
                    }), console.log("interstitial 广告关闭")
                })))
            }
            init(t) {}
            preloadNativeAd(t) {}
            showNativeAd(t, e) {}
            destoryNativeAd() {}
            reportAdClickNativeAd() {}
            getNativeAdData() {}
            getAppboxAdById(t) {
                return this.gridAds.filter(((e, s, n) => t === e.id))[0]
            }
            preloadAppbox(t) {}
            showAppBox(t, e) {}
            hideAppBox(t, e) {}
            destoryAppBox() {}
            getAppBoxData() {
                return 1
            }
            createAppBoxBtn(t, e) {}
            showAppBoxBtn() {}
            hideAppBoxBtn() {}
            destoryAppBoxBtn() {}
            showBlockAd(e, s) {
                let i = this.getCustomAdById(e);
                if (i || (i = {
                        id: e,
                        inst: null,
                        state: t.AdState.LOADING,
                        customParams: s
                    }, this.customAds.push(i)), !i.inst && s && s.style) {
                    let a = sdk.Sdk.instance.getSystemInfo(),
                        r = a.screenWidth * (s.style.left / Laya.stage.width),
                        o = a.screenHeight * (s.style.top / Laya.stage.height),
                        d = null;
                    s.style && s.style.width && (d = a.screenWidth * (s.style.width / Laya.stage.width)), s.adIntervals = s.adIntervals ? s.adIntervals : 30, i.inst = wx.createCustomAd({
                        adUnitId: e,
                        adIntervals: s.adIntervals,
                        style: {
                            left: r,
                            top: o,
                            width: d
                        }
                    }), i.inst.onLoad((() => {
                        i.state = t.AdState.LOAD, console.log(`${i.id} 原生模板广告加载成功`), fx.EventCenter.I.event(n.E_AD_NATIVE_CUSTOM, {
                            code: t.SdkCode.AD_NATIVE_CUSTOM_LOAD_SUCCESS,
                            adId: e
                        })
                    })), i.inst.onError((s => {
                        i.state = t.AdState.LOAD_FAIL, console.log(`${i.id} 原生模板广告加载失败:`, JSON.stringify(s)), fx.EventCenter.I.event(n.E_AD_NATIVE_CUSTOM, {
                            code: t.SdkCode.AD_NATIVE_CUSTOM_LOAD_FAIL,
                            adId: e
                        })
                    })), i.inst.onClose((() => {
                        console.log(`${i.id} 原生模板广告关闭`), fx.EventCenter.I.event(n.E_AD_NATIVE_CUSTOM, {
                            code: t.SdkCode.AD_NATIVE_CUSTOM_CLOSE,
                            adId: e
                        })
                    })), i.inst.onHide((() => {
                        console.log(`${i.id}  原生模板广告隐藏成功`), fx.EventCenter.I.event(n.E_AD_NATIVE_CUSTOM, {
                            code: t.SdkCode.AD_NATIVE_CUSTOM_HIDE,
                            adId: e
                        })
                    }))
                }
                i && i.inst && (i.state = t.AdState.LOAD) && i.inst.show().catch((s => {
                    console.log(`${i.id} 原生模板广告显示失败`, JSON.stringify(s)), fx.EventCenter.I.event(n.E_AD_NATIVE_CUSTOM, {
                        code: t.SdkCode.AD_NATIVE_CUSTOM_FAIL,
                        adId: e
                    })
                })).then((() => {
                    console.log(`${i.id} 原生模板广告显示成功`), fx.EventCenter.I.event(n.E_AD_NATIVE_CUSTOM, {
                        code: t.SdkCode.AD_NATIVE_CUSTOM_SUCCESS,
                        adId: e
                    })
                }))
            }
            hideBlockAd(t, e) {
                let s = this.getCustomAdById(t);
                s && s.inst && (s.inst.hide(), e && (s.inst.destroy(), s.inst = null))
            }
            isBlockShowing(t) {
                let e = this.getCustomAdById(t);
                if (e && e.inst) return e.inst.isShow()
            }
            preloadBlock(e, s) {
                let i = this.getCustomAdById(e);
                if (i) s || (s = i.customParams);
                else {
                    if (!s) return;
                    i = {
                        id: e,
                        inst: null,
                        state: t.AdState.LOADING,
                        customParams: s
                    }, this.customAds.push(i)
                }
                let a = sdk.Sdk.instance.getSystemInfo(),
                    r = a.screenWidth * (s.style.left / Laya.stage.width),
                    o = a.screenHeight * (s.style.top / Laya.stage.height),
                    d = null;
                s.style && s.style.width && (d = a.screenWidth * (s.style.width / Laya.stage.width)), i.inst ? t.AdState.DELETING !== i.state && t.AdState.LOAD_FAIL !== i.state || (i.inst.destroy(), i.inst = null, i.state = t.AdState.LOADING, this.preloadBlock(e, s)) : (s.adIntervals = s.adIntervals ? s.adIntervals : 30, i.inst = wx.createCustomAd({
                    adUnitId: e,
                    adIntervals: s.adIntervals,
                    style: {
                        left: r,
                        top: o,
                        width: d
                    }
                }), i.inst.onLoad((() => {
                    console.log(`custom.id:${i.id} 广告加载成功`), i.state = t.AdState.LOAD, fx.EventCenter.I.event(n.E_AD_NATIVE_CUSTOM, {
                        code: t.SdkCode.AD_NATIVE_CUSTOM_LOAD_SUCCESS,
                        adId: e
                    }), i.customParams && i.customParams.forever && i.inst.show()
                })), i.inst.onError((s => {
                    console.log(`custom.id:${i.id} 广告加载失败：` + JSON.stringify(s)), i.state = t.AdState.LOAD_FAIL, fx.EventCenter.I.event(n.E_AD_NATIVE_CUSTOM, {
                        code: t.SdkCode.AD_NATIVE_CUSTOM_LOAD_FAIL,
                        adId: e
                    })
                })), i.inst.onClose((() => {
                    console.log(`${i.id} 原生模板广告关闭`), fx.EventCenter.I.event(n.E_AD_NATIVE_CUSTOM, {
                        code: t.SdkCode.AD_NATIVE_CUSTOM_CLOSE,
                        adId: e
                    })
                })), i.inst.onHide((() => {
                    console.log(`${i.id}  原生模板广告隐藏成功`), fx.EventCenter.I.event(n.E_AD_NATIVE_CUSTOM, {
                        code: t.SdkCode.AD_NATIVE_CUSTOM_HIDE,
                        adId: e
                    })
                })))
            }
            getCustomAdById(t) {
                return this.customAds.filter(((e, s, n) => t === e.id))[0]
            }
            showCustomAd(t, e) {}
            hideCustomAd(t) {}
        }
        O.BannerRefreshTime = 4e4;
        class m {
            constructor() {}
            sendEvent(t, e) {
                wx.reportEvent && ("面板" === t ? wx.reportEvent("openPanel", {
                    panelname: e["打开"]
                }) : "视频" === t ? wx.reportEvent("playVideoPanel", {
                    panelname: e["打开"]
                }) : "视频结果" === t ? wx.reportEvent("playComplete", {
                    panelname: e["打开"],
                    playstate: e["结果"]
                }) : "分享" === t ? wx.reportEvent("sharePanel", {
                    panelname: e["打开"]
                }) : "分享结果" === t ? wx.reportEvent("shareComplete", {
                    panelname: e["打开"],
                    sharestate: e["结果"]
                }) : wx.reportEvent(t, e))
            }
            stageOnStart(t) {
                wx.uma && wx.uma.stage.onStart && wx.uma.stage.onStart(t)
            }
            stageOnRunning(t) {
                wx.uma && wx.uma.stage.onRunning && wx.uma.stage.onRunning(t)
            }
            stageOnEnd(t) {
                wx.uma.stage.onEnd && wx.uma.stage.onEnd(t)
            }
            unlockItem(t) {}
        }
        class D {
            constructor() {
                this.curRewardStrategyCnt = void 0, this.shareCount = 0, this.shareStartTime = void 0
            }
            static get rewardStrategyCnt() {
                if (void 0 === this._rewardStrategyCnt)
                    if (fx.UserLogic.instance.isNewDay && fx.UserLogic.instance.isNewDay()) this.rewardStrategyCnt = 0;
                    else {
                        let t = Laya.LocalStorage.getItem("rewardStrategyCnt");
                        null == t || "" === t ? this.rewardStrategyCnt = 0 : this._rewardStrategyCnt = Number(t)
                    }
                return this._rewardStrategyCnt
            }
            static set rewardStrategyCnt(t) {
                this._rewardStrategyCnt !== t && (this._rewardStrategyCnt = t, Laya.LocalStorage.setItem("rewardStrategyCnt", this._rewardStrategyCnt.toString()))
            }
            setCurStrategy(t, e) {
                this.curStrategy = t, this.curParams = e, t && e && (D.rewardStrategyCnt++, this.curRewardStrategyCnt = D.rewardStrategyCnt)
            }
            getStrategy() {
                if (t.GetRewardSDKWay.AUTO === this.curStrategy) {
                    if (t.VideoState.ENABLED === sdk.Sdk.instance.isHasVideo(this.curParams.id)) {
                        let e = sdk.Sdk.instance.getServerJsonCfgShareParams().OlderShareCtnBase;
                        fx.UserLogic.instance.isFirstLogin && fx.UserLogic.instance.isFirstLogin() && (e = sdk.Sdk.instance.getServerJsonCfgShareParams().FreshShareCntBase), e || (e = 0);
                        let s = null;
                        if (0 !== e && this.curRewardStrategyCnt <= e) s = t.GetRewardSDKWay.SHARE;
                        else {
                            let n = sdk.Sdk.instance.getServerJsonCfgShareParams().ShareSpace;
                            n || (n = 0), s = n > 0 && 0 == (this.curRewardStrategyCnt - e) % (n + 1) ? t.GetRewardSDKWay.SHARE : t.GetRewardSDKWay.VIDEO
                        }
                        return s
                    }
                    return t.GetRewardSDKWay.SHARE
                }
                return t.GetRewardSDKWay.SHARE === this.curStrategy ? this.curStrategy : t.GetRewardSDKWay.VIDEO
            }
            runStrategy() {
                let e = this.getStrategy();
                sdk.Sdk.instance.isFreeVideo() ? fx.EventCenter.I.event(n.E_REWARD_GAIN, {
                    code: t.SdkCode.REWARD_GAIN_SUCCESS,
                    way: t.GetRewardSDKWay.VIDEO,
                    gid: this.curParams.bindCtrlGId
                }) : t.GetRewardSDKWay.SHARE === e ? (sdk.Sdk.instance.sendEvent("分享", {
                    "打开": this.curParams.source
                }), this.share(this.curParams)) : t.GetRewardSDKWay.VIDEO === e && (sdk.Sdk.instance.sendEvent("视频", {
                    "打开": this.curParams.source
                }), this.playVideo(this.curParams))
            }
            playVideo(e) {
                var s = fx.SoundManager.instance.getToggleMusicStatus();
                let i = sdk.Sdk.instance.isHasVideo(this.curParams.id);
                t.VideoState.UNENABLED === i ? (fx.Utils.showTips("暂时没有视频啦~"), fx.EventCenter.I.event(n.E_REWARD_GAIN, {
                    code: t.SdkCode.REWARD_GAIN_FAIL,
                    gid: e.bindCtrlGId
                })) : (fx.EventCenter.I.once(n.E_AD_VIDEO, this, (i => {
                    t.SdkCode.AD_VIDEO_SUCCESS === i.code ? (this.curParams && this.curParams.forever && (D.rewardStrategyCnt++, this.curRewardStrategyCnt++, D.rewardStrategyCnt++), fx.EventCenter.I.event(n.E_REWARD_GAIN, {
                        code: t.SdkCode.REWARD_GAIN_SUCCESS,
                        way: t.GetRewardSDKWay.VIDEO,
                        gid: e.bindCtrlGId
                    }), sdk.Sdk.instance.sendEvent("视频结果", {
                        "打开": e.source,
                        "结果": "播放成功"
                    }), s && fx.SoundManager.instance.toggleAll()) : t.SdkCode.AD_VIDEO_UNCOMPLETE === i.code ? (sdk.Sdk.instance.showModal("看完视频才会有奖励哟！！！", "提示", "继续观看", Laya.Handler.create(this, (() => {
                        s && fx.SoundManager.instance.toggleAll(), this.playVideo(e)
                    })), "一会再来", Laya.Handler.create(this, (function() {
                        fx.EventCenter.I.event(n.E_REWARD_GAIN, {
                            code: t.SdkCode.REWARD_GAIN_FAIL,
                            gid: e.bindCtrlGId
                        }), s && fx.SoundManager.instance.toggleAll()
                    }))), sdk.Sdk.instance.sendEvent("视频结果", {
                        "打开": e.source,
                        "结果": "播放失败"
                    })) : t.SdkCode.AD_VIDEO_LOAD_FAIL === i.code && (sdk.Sdk.instance.sendEvent("视频结果", {
                        "打开": e.source,
                        "结果": "播放失败"
                    }), fx.EventCenter.I.event(n.E_REWARD_GAIN, {
                        code: t.SdkCode.REWARD_GAIN_FAIL,
                        gid: e.bindCtrlGId
                    }), s && fx.SoundManager.instance.toggleAll())
                })), sdk.Sdk.instance.playVideo(e.id), s && fx.SoundManager.instance.toggleAll())
            }
            share(e) {
                this.shareStartTime = fx.Utils.getTime(), fx.EventCenter.I.once(fx.BaseEvent.E_APP_ON_RESUME, this, (s => {
                    if (Math.floor((fx.Utils.getTime() - this.shareStartTime) / 1e3) > 3) {
                        this.shareCount += 1;
                        let s = !1;
                        if (this.shareCount > 1) s = !0;
                        else {
                            let t = sdk.Sdk.instance.getServerJsonCfgShareParams().shareFailProb;
                            t || (t = 0), fx.Utils.getIntRandom(0, 100) >= t && (s = !0)
                        }
                        s ? (this.shareCount = 0, this.curParams && this.curParams.forever && (D.rewardStrategyCnt++, this.curRewardStrategyCnt++, D.rewardStrategyCnt++), fx.EventCenter.I.event(n.E_REWARD_GAIN, {
                            code: t.SdkCode.REWARD_GAIN_SUCCESS,
                            way: t.GetRewardSDKWay.SHARE,
                            gid: e.bindCtrlGId
                        }), sdk.Sdk.instance.sendEvent("分享结果", {
                            "打开": e.source,
                            "结果": "分享失败"
                        })) : this.continueShare(e, "不要频繁骚扰同一个群!")
                    } else this.continueShare(e, "分享失败!"), sdk.Sdk.instance.sendEvent("分享结果", {
                        "打开": e.source,
                        "结果": "分享失败"
                    });
                    this.shareStartTime = void 0
                })), sdk.Sdk.instance.share(e)
            }
            continueShare(e, s) {
                sdk.Sdk.instance.showModal(s, "提示", "继续分享", Laya.Handler.create(this, (() => {
                    this.share(e)
                })), "一会再来", Laya.Handler.create(this, (() => {
                    this.shareCount = 0, fx.EventCenter.I.event(n.E_REWARD_GAIN, {
                        code: t.SdkCode.REWARD_GAIN_FAIL,
                        gid: e.bindCtrlGId
                    })
                })))
            }
        }
        D._rewardStrategyCnt = void 0;
        class v {
            constructor() {}
            pay(t) {
                wx.requestMidasPayment({
                    mode: "game",
                    env: t.env ? t.env : 0,
                    offerId: t.offerId,
                    currencyType: "CNY",
                    platform: t.platform ? t.platform : "android",
                    buyQuantity: t.buyQuantity,
                    zoneId: "1"
                })
            }
        }
        class N extends fx.BaseEventDispatcher {
            constructor() {
                super(), this.isUser = !1, this._nickName = void 0, this._freeVideo = !1
            }
            set loginCode(t) {
                if (this._loginCode = t, !this.openId && fx.HttpServer.I.isLogin()) {
                    fx.EventCenter.I.once(f.E_WHITELIST_RESULT, this, (t => {
                        t && (this.freeVideo = t.isInWriteList)
                    }));
                    let t = fx.HttpServer.I.getOpenId();
                    this.openId = t, C.instance.getVideoWhiteList(t)
                }
            }
            get loginCode() {
                return this._loginCode
            }
            initMiniAdapter() {}
            engineInitialized() {
                wx.onError(((t, e) => {
                    (t || e) && ("string" == typeof t ? window.onerror(t || e, null, null, null, {
                        message: t,
                        stack: e
                    }) : window.onerror(t.message || t.stack, null, null, null, t), console.error(t))
                }))
            }
            getMiniAdapter() {
                return Laya.MiniAdpter
            }
            login() {
                wx.login({
                    success: this.wxloginSucc.bind(this),
                    fail: this.wxloginFail.bind(this)
                }), wx.getSetting({
                    success: this.onSettings.bind(this)
                }), this.networkstate = "none", wx.getNetworkType({
                    success: t => {
                        console.log(">>>>>>>>>>>>>>>>> getNetworkType: ", t.networkType), this.networkstate = t.networkType
                    }
                }), wx.onNetworkStatusChange((t => {
                    console.log(">>>>>>>>>>>>>>>>> onNetworkStatusChange: ", t.isConnected, t.networkType), this.networkstate = t.networkType
                }))
            }
            checkSession(t) {
                t.runWith(!0)
            }
            request(t, e, s, n, i, a) {
                let r;
                if (console.log(">>>>>>>>>>>>>>>>> request: ", t, e), a && a.length > 1) {
                    r = {};
                    for (let t = 0; t < a.length; t += 2) {
                        let e = a[t],
                            s = a[t + 1];
                        r[e] = s
                    }
                }
                wx.request({
                    url: t,
                    data: e,
                    method: i,
                    header: r,
                    dataType: "json",
                    success: t => {
                        console.log("<<<<<<<<<<<<<<<<< request: ", t), s && s.runWith(t.data)
                    },
                    fail: t => {
                        console.log("<<<<<<<<<<<<<<<<< request error: ", t), console.log("获取服务器JSON配置失败！"), n && n.run()
                    }
                })
            }
            requestDecrypt(t, e, s, n, i, a) {
                let r;
                if (console.log(">>>>>>>>>>>>>>>>> request: ", t, e), a && a.length > 1) {
                    r = {};
                    for (let t = 0; t < a.length; t += 2) {
                        let e = a[t],
                            s = a[t + 1];
                        r[e] = s
                    }
                }
                wx.request({
                    url: t,
                    data: e,
                    header: r,
                    method: i,
                    responseType: "arraybuffer",
                    success: t => {
                        if (console.log("<<<<<<<<<<<<<<<<< request: ", t), s) {
                            let e = window.pako.inflate(t.data, {
                                to: "string"
                            });
                            s.runWith(JSON.parse(e))
                        }
                    },
                    fail: t => {
                        console.log("<<<<<<<<<<<<<<<<< request error: ", t), console.log("获取服务器JSON配置失败！"), n && n.run()
                    }
                })
            }
            getShareInstance() {
                return new T
            }
            getAdvInstance() {
                return new O
            }
            getStatInstance() {
                return new m
            }
            getRewardStrInstance() {
                return new D
            }
            getPayInstance() {
                return new v
            }
            onSettings(e) {
                let s = e.authSetting;
                this.isUserInfoAuth = !!s["scope.userInfo"], this.isUserInfoAuth, this.code && this.event(n.E_SDK_LOGIN, {
                    code: t.SdkCode.WX_LOGIN_SUCCESS,
                    msg: "微信登录成功"
                })
            }
            isAuth() {
                return this.isUserInfoAuth
            }
            loginServerEnable() {
                return !!sdk.Sdk.GameCfg.server_url
            }
            getQuery() {
                return this.query
            }
            getEncryptedData() {
                return [this.encryptedData, this.iv]
            }
            auth(t) {
                this.profileBtn = t, this.profileToServer = this.loginServerEnable(), this.createUserInfoButton()
            }
            onResume(t) {
                t.query && !fx.Utils.isEmpty(t.query) && this.loginServerEnable() && (this.query = t.query, C.instance.postShareQuery(t.query))
            }
            wxloginSucc(e) {
                console.log("微信登录成功！"), this.code = e.code, this.loginCode = e.code;
                let s = 10;
                const checkNeedFix = () => !this.menuInfo || this.menuInfo.top > 0 || s <= 0 ? (this.loginServerEnable() && C.instance.login(this.code, i.query), void 0 !== this.isUserInfoAuth && this.event(n.E_SDK_LOGIN, {
                        code: t.SdkCode.WX_LOGIN_SUCCESS,
                        msg: "微信登录成功"
                    }), !1) : (s--, !0),
                    fixInfo = () => {
                        this.getSystemInfo(!0), this.getMenuButtonBoundingClientRect(!0), checkNeedFix() || (fx.Utils.sNotchScreen = void 0, Laya.timer.clear(this, fixInfo))
                    };
                let i = wx.getLaunchOptionsSync();
                this.query = i.query, checkNeedFix() && Laya.timer.loop(100, this, fixInfo)
            }
            wxloginFail() {
                console.log("微信登录失败！"), this.event(n.E_SDK_LOGIN, {
                    code: t.SdkCode.WX_LOGIN_FAILED,
                    msg: "微信登录失败"
                })
            }
            userInfoSucc(e) {
                let s, i = fx.UserLogic.instance.getMine();
                e.userInfo ? (console.log("获取用户信息成功！" + JSON.stringify(e)), this.isUserInfoAuth = !0, this.encryptedData = e.encryptedData, this.iv = e.iv, this.destroyUserInfoButton(), s = new t.SDKEntity.UserInfoEntity, function(t, e) {
                    null != t.nickName && (e.name = t.nickName), null != t.avatarUrl && (e.headUrl = t.avatarUrl), null != t.gender && (e.sex = t.gender), null != t.city && (e.city = t.city), null != t.province && (e.province = t.province), null != t.country && (e.country = t.country), null != t.language && (e.language = t.language)
                }(e.userInfo, s), fx.UserLogic.instance.update(s), fx.UserLogic.instance.save("name", s.name), e.userInfo.nickName && (i.name = this.nickName = e.userInfo.nickName)) : console.log("获取用户信息失败！"), this.nickName || (i.name = this.nickName = "游客" + fx.Utils.getIntRandom(1, 199999)), this.event(n.E_USER_INFO, {
                    code: 0,
                    info: e.userInfo,
                    nickName: this.nickName
                }), this.profileToServer && C.instance.postProfile(s)
            }
            userInfoFail(e) {
                console.log("===========:", e);
                let s = fx.UserLogic.instance.getMine();
                if (s && s.name && (this.nickName = s.name), !this.nickName) {
                    let e = new t.SDKEntity.UserInfoEntity;
                    e.name = s.name = this.nickName = "游客" + fx.Utils.getIntRandom(1, 199999), fx.UserLogic.instance.update(e)
                }
                this.event(n.E_USER_INFO, {
                    code: -1,
                    nickName: this.nickName
                })
            }
            createUserInfoButton() {
                let t = this.profileBtn,
                    e = t.localToGlobal(new Laya.Point(0, 0)),
                    s = t.localToGlobal(new Laya.Point(t.width, t.height));
                Laya.stage.transform.transformPoint(e), Laya.stage.transform.transformPoint(s);
                let n = s.x - e.x,
                    i = s.y - e.y,
                    a = wx.createUserInfoButton({
                        type: "text",
                        text: "",
                        style: {
                            left: e.x,
                            top: e.y,
                            width: n,
                            height: i
                        },
                        withCredentials: !0,
                        lang: "zh_CN"
                    });
                a.show(), a.onTap(this.userInfoSucc.bind(this)), this.profileBtn = a, t.once(Laya.Event.REMOVED, this, this.destroyUserInfoButton)
            }
            destroyUserInfoButton() {
                this.profileBtn && this.profileBtn.destroy(), this.profileBtn = null
            }
            setKeepScreenOn(t) {
                wx.setKeepScreenOn(t)
            }
            onShow(t) {
                wx.onShow(t)
            }
            onHide(t) {
                wx.onHide(t)
            }
            checkUpdate() {
                if ("function" == typeof wx.getUpdateManager) {
                    const t = wx.getUpdateManager();
                    t.onCheckForUpdate((function(t) {
                        console.log(t.hasUpdate)
                    })), t.onUpdateReady((() => {
                        this.showModal("有新版本啦！，赶快开启新的历程吧~", "更新提示", "开启", Laya.Handler.create(this, (() => {
                            t.applyUpdate()
                        })))
                    })), t.onUpdateFailed((function() {
                        console.log("新的版本下载失败")
                    }))
                }
            }
            loadSubpackage(t) {
                return wx.loadSubpackage ? wx.loadSubpackage(t) : (this.showModal("请升级微信到最新版本！", "提示", "确定", Laya.Handler.create(this, (() => {
                    this.exit()
                })), ""), null)
            }
            showModal(t, e = "提示", s = "确定", n, i = "取消", a) {
                wx.showModal({
                    title: e,
                    content: t,
                    showCancel: "" != i && null != i,
                    cancelText: i,
                    confirmText: s,
                    success: t => {
                        t.confirm ? n && n.run() : i && a && a.run()
                    }
                })
            }
            getSystemInfo(t) {
                return !t && this.systemInfo || (this.systemInfo = wx.getSystemInfoSync(), console.log("getSystemInfoSync: " + JSON.stringify(this.systemInfo))), this.systemInfo
            }
            getMenuButtonBoundingClientRect(t) {
                return !t && this.menuInfo || fx.Utils.compareVersion(this.systemInfo.SDKVersion, "2.1.0") >= 0 && (this.menuInfo = wx.getMenuButtonBoundingClientRect(), console.log("getMenuButtonBoundingClientRect: " + JSON.stringify(this.menuInfo))), this.menuInfo
            }
            exit() {
                wx.exitMiniProgram({})
            }
            getLaunchOptionsSync() {
                return wx.getLaunchOptionsSync()
            }
            navigateToMiniProgram(t) {
                wx.navigateToMiniProgram(t)
            }
            getOpenDataContext() {
                return wx.getOpenDataContext()
            }
            createFeedbackButton(t) {
                return wx.createFeedbackButton(t)
            }
            openCustomerServiceConversation(t) {
                wx.openCustomerServiceConversation(t)
            }
            createGameClubButton(t) {
                wx.createGameClubButton(t)
            }
            onAudioInterruption(t, e) {
                wx.onAudioInterruptionBegin(t), wx.onAudioInterruptionEnd(e)
            }
            vibrateShort() {
                wx.vibrateShort({
                    type: "medium",
                    fail: t => {
                        this.vibrateLong()
                    }
                })
            }
            vibrateLong() {
                this.vibrating || (this.vibrating = !0, wx.vibrateLong({
                    complete: () => {
                        this.vibrating = !1
                    }
                }))
            }
            getNetworkType() {
                return this.networkstate
            }
            isConnectNetwork() {
                return console.log("networkstate: ", this.networkstate), "none" !== this.networkstate
            }
            judgeBAndW(e) {
                let s = e.sceneId;
                if (!s) return t.BlackAndWhite.Black;
                let n = Laya.LocalStorage.getItem("BAndW");
                if (!n) {
                    let t = sdk.Sdk.instance.getServerJsonCfg();
                    if (t && t.sceneIdArr && t.sceneIdArr.length > 0) n = -1 != t.sceneIdArr.indexOf(s) ? "white" : "black";
                    else {
                        n = -1 != [1095, 1037, 1046, 1184, 1045, 1200, 1067].indexOf(s) ? "white" : "black"
                    }
                    Laya.LocalStorage.setItem("BAndW", n)
                }
                return n === t.BlackAndWhite.White ? t.BlackAndWhite.White : t.BlackAndWhite.Black
            }
            getCode() {
                if (this.code) return this.code
            }
            saveAppToDesktop(t) {}
            showFavoriteGuide(t) {}
            FollowAwemeUser(t) {}
            getFollowAwemeState() {
                return t.FollowedState.NotGot
            }
            getAddDeskState() {
                return t.AddDeskState.NotGot
            }
            requestSubscribeMessage(t) {
                wx.requestSubscribeMessage(t)
            }
            getNickName() {
                this.nickName || this.isUser || (this.isUser = !0, wx.getUserProfile ? wx.getUserProfile({
                    desc: "用于显示聊天名字",
                    success: this.userInfoSucc.bind(this),
                    fail: this.userInfoFail.bind(this)
                }) : this.userInfoFail(null))
            }
            get nickName() {
                return this._nickName
            }
            set nickName(t) {
                this._nickName = t
            }
            isFreeVideo() {
                if (!this.openId && fx.HttpServer.I.isLogin()) {
                    fx.EventCenter.I.once(f.E_WHITELIST_RESULT, this, (t => {
                        t && (this.freeVideo = t.isInWriteList)
                    }));
                    let t = fx.HttpServer.I.getOpenId();
                    this.openId = t, C.instance.getVideoWhiteList(t)
                }
                return this.freeVideo
            }
            get freeVideo() {
                return this._freeVideo
            }
            set freeVideo(t) {
                this._freeVideo = t
            }
            clipboardData(t) {
                wx.setClipboardData({
                    data: t,
                    success(t) {
                        console.log("复制成功~")
                    }
                })
            }
            showLoading(t, e, s) {
                wx.showLoading({
                    title: t || "加载中...",
                    mask: e || !1,
                    success: s && s.success,
                    fail: s && s.fail
                })
            }
            hideLoading(t) {
                wx.hideLoading({
                    success: t && t.success,
                    fail: t && t.fail
                })
            }
            getLoginCode() {
                return this.code
            }
            getLoginAnonymousCode() {
                return this.code
            }
            globalInst() {
                return ["wx", wx]
            }
        }
        return Laya.ClassUtils.regClass(e.WEIXIN, N), t.InsertWay = class {
            gain() {
                throw new Error("Method not implemented.")
            }
        }, t.MenuInfo = class {}, t.Message = u, t.PlatformType = e, t.RewardGainWay = p, t.RewardGainWayParams = g, t.SDK_VERSION = s, t.SHA256 = class {
            constructor() {
                this.hexcase = 0, this.b64pad = "", this.sha256_K = new Array(1116352408, 1899447441, -1245643825, -373957723, 961987163, 1508970993, -1841331548, -1424204075, -670586216, 310598401, 607225278, 1426881987, 1925078388, -2132889090, -1680079193, -1046744716, -459576895, -272742522, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, -1740746414, -1473132947, -1341970488, -1084653625, -958395405, -710438585, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, -2117940946, -1838011259, -1564481375, -1474664885, -1035236496, -949202525, -778901479, -694614492, -200395387, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, -2067236844, -1933114872, -1866530822, -1538233109, -1090935817, -965641998)
            }
            hex_sha256(t) {
                return this.rstr2hex(this.rstr_sha256(this.str2rstr_utf8(t)))
            }
            b64_sha256(t) {
                return this.rstr2b64(this.rstr_sha256(this.str2rstr_utf8(t)))
            }
            any_sha256(t, e) {
                return this.rstr2any(this.rstr_sha256(this.str2rstr_utf8(t)), e)
            }
            hex_hmac_sha256(t, e) {
                return this.rstr2hex(this.rstr_hmac_sha256(this.str2rstr_utf8(t), this.str2rstr_utf8(e)))
            }
            b64_hmac_sha256(t, e) {
                return this.rstr2b64(this.rstr_hmac_sha256(this.str2rstr_utf8(t), this.str2rstr_utf8(e)))
            }
            any_hmac_sha256(t, e, s) {
                return this.rstr2any(this.rstr_hmac_sha256(this.str2rstr_utf8(t), this.str2rstr_utf8(e)), s)
            }
            sha256_vm_test() {
                return "ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad" == this.hex_sha256("abc").toLowerCase()
            }
            rstr_sha256(t) {
                return this.binb2rstr(this.binb_sha256(this.rstr2binb(t), 8 * t.length))
            }
            rstr_hmac_sha256(t, e) {
                var s = this.rstr2binb(t);
                s.length > 16 && (s = this.binb_sha256(s, 8 * t.length));
                for (var n = Array(16), i = Array(16), a = 0; a < 16; a++) n[a] = 909522486 ^ s[a], i[a] = 1549556828 ^ s[a];
                var r = this.binb_sha256(n.concat(this.rstr2binb(e)), 512 + 8 * e.length);
                return this.binb2rstr(this.binb_sha256(i.concat(r), 768))
            }
            rstr2hex(t) {
                try {
                    this.hexcase
                } catch (t) {
                    this.hexcase = 0
                }
                for (var e, s = this.hexcase ? "0123456789ABCDEF" : "0123456789abcdef", n = "", i = 0; i < t.length; i++) e = t.charCodeAt(i), n += s.charAt(e >>> 4 & 15) + s.charAt(15 & e);
                return n
            }
            rstr2b64(t) {
                try {
                    this.b64pad
                } catch (t) {
                    this.b64pad = ""
                }
                for (var e = "", s = t.length, n = 0; n < s; n += 3)
                    for (var i = t.charCodeAt(n) << 16 | (n + 1 < s ? t.charCodeAt(n + 1) << 8 : 0) | (n + 2 < s ? t.charCodeAt(n + 2) : 0), a = 0; a < 4; a++) 8 * n + 6 * a > 8 * t.length ? e += this.b64pad : e += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(i >>> 6 * (3 - a) & 63);
                return e
            }
            rstr2any(t, e) {
                var s, n, i, a, r = e.length,
                    o = Array(),
                    d = Array(Math.ceil(t.length / 2));
                for (s = 0; s < d.length; s++) d[s] = t.charCodeAt(2 * s) << 8 | t.charCodeAt(2 * s + 1);
                for (; d.length > 0;) {
                    for (a = Array(), i = 0, s = 0; s < d.length; s++) i = (i << 16) + d[s], i -= (n = Math.floor(i / r)) * r, (a.length > 0 || n > 0) && (a[a.length] = n);
                    o[o.length] = i, d = a
                }
                var h = "";
                for (s = o.length - 1; s >= 0; s--) h += e.charAt(o[s]);
                var l = Math.ceil(8 * t.length / (Math.log(e.length) / Math.log(2)));
                for (s = h.length; s < l; s++) h = e[0] + h;
                return h
            }
            str2rstr_utf8(t) {
                for (var e, s, n = "", i = -1; ++i < t.length;) e = t.charCodeAt(i), s = i + 1 < t.length ? t.charCodeAt(i + 1) : 0, 55296 <= e && e <= 56319 && 56320 <= s && s <= 57343 && (e = 65536 + ((1023 & e) << 10) + (1023 & s), i++), e <= 127 ? n += String.fromCharCode(e) : e <= 2047 ? n += String.fromCharCode(192 | e >>> 6 & 31, 128 | 63 & e) : e <= 65535 ? n += String.fromCharCode(224 | e >>> 12 & 15, 128 | e >>> 6 & 63, 128 | 63 & e) : e <= 2097151 && (n += String.fromCharCode(240 | e >>> 18 & 7, 128 | e >>> 12 & 63, 128 | e >>> 6 & 63, 128 | 63 & e));
                return n
            }
            str2rstr_utf16le(t) {
                for (var e = "", s = 0; s < t.length; s++) e += String.fromCharCode(255 & t.charCodeAt(s), t.charCodeAt(s) >>> 8 & 255);
                return e
            }
            str2rstr_utf16be(t) {
                for (var e = "", s = 0; s < t.length; s++) e += String.fromCharCode(t.charCodeAt(s) >>> 8 & 255, 255 & t.charCodeAt(s));
                return e
            }
            rstr2binb(t) {
                for (var e = Array(t.length >> 2), s = 0; s < e.length; s++) e[s] = 0;
                for (s = 0; s < 8 * t.length; s += 8) e[s >> 5] |= (255 & t.charCodeAt(s / 8)) << 24 - s % 32;
                return e
            }
            binb2rstr(t) {
                for (var e = "", s = 0; s < 32 * t.length; s += 8) e += String.fromCharCode(t[s >> 5] >>> 24 - s % 32 & 255);
                return e
            }
            sha256_S(t, e) {
                return t >>> e | t << 32 - e
            }
            sha256_R(t, e) {
                return t >>> e
            }
            sha256_Ch(t, e, s) {
                return t & e ^ ~t & s
            }
            sha256_Maj(t, e, s) {
                return t & e ^ t & s ^ e & s
            }
            sha256_Sigma0256(t) {
                return this.sha256_S(t, 2) ^ this.sha256_S(t, 13) ^ this.sha256_S(t, 22)
            }
            sha256_Sigma1256(t) {
                return this.sha256_S(t, 6) ^ this.sha256_S(t, 11) ^ this.sha256_S(t, 25)
            }
            sha256_Gamma0256(t) {
                return this.sha256_S(t, 7) ^ this.sha256_S(t, 18) ^ this.sha256_R(t, 3)
            }
            sha256_Gamma1256(t) {
                return this.sha256_S(t, 17) ^ this.sha256_S(t, 19) ^ this.sha256_R(t, 10)
            }
            sha256_Sigma0512(t) {
                return this.sha256_S(t, 28) ^ this.sha256_S(t, 34) ^ this.sha256_S(t, 39)
            }
            sha256_Sigma1512(t) {
                return this.sha256_S(t, 14) ^ this.sha256_S(t, 18) ^ this.sha256_S(t, 41)
            }
            sha256_Gamma0512(t) {
                return this.sha256_S(t, 1) ^ this.sha256_S(t, 8) ^ this.sha256_R(t, 7)
            }
            sha256_Gamma1512(t) {
                return this.sha256_S(t, 19) ^ this.sha256_S(t, 61) ^ this.sha256_R(t, 6)
            }
            binb_sha256(t, e) {
                var s, n, i, a, r, o, d, h, l, E, S, I, _ = new Array(1779033703, -1150833019, 1013904242, -1521486534, 1359893119, -1694144372, 528734635, 1541459225),
                    c = new Array(64);
                for (t[e >> 5] |= 128 << 24 - e % 32, t[15 + (e + 64 >> 9 << 4)] = e, l = 0; l < t.length; l += 16) {
                    for (s = _[0], n = _[1], i = _[2], a = _[3], r = _[4], o = _[5], d = _[6], h = _[7], E = 0; E < 64; E++) c[E] = E < 16 ? t[E + l] : this.safe_add(this.safe_add(this.safe_add(this.sha256_Gamma1256(c[E - 2]), c[E - 7]), this.sha256_Gamma0256(c[E - 15])), c[E - 16]), S = this.safe_add(this.safe_add(this.safe_add(this.safe_add(h, this.sha256_Sigma1256(r)), this.sha256_Ch(r, o, d)), this.sha256_K[E]), c[E]), I = this.safe_add(this.sha256_Sigma0256(s), this.sha256_Maj(s, n, i)), h = d, d = o, o = r, r = this.safe_add(a, S), a = i, i = n, n = s, s = this.safe_add(S, I);
                    _[0] = this.safe_add(s, _[0]), _[1] = this.safe_add(n, _[1]), _[2] = this.safe_add(i, _[2]), _[3] = this.safe_add(a, _[3]), _[4] = this.safe_add(r, _[4]), _[5] = this.safe_add(o, _[5]), _[6] = this.safe_add(d, _[6]), _[7] = this.safe_add(h, _[7])
                }
                return _
            }
            safe_add(t, e) {
                var s = (65535 & t) + (65535 & e);
                return (t >> 16) + (e >> 16) + (s >> 16) << 16 | 65535 & s
            }
        }, t.Sdk = R, t.SdkEvent = n, t.SdkGameCfg = class {}, t.SdkMsg = C, t.SdkMsgDefine = A, t.SdkMsgEvent = f, t.ShareWay = y, t.SystemInfo = class {}, t.VideoWay = class {
            constructor(t) {
                this._videoParam = t
            }
            gain() {
                if (fx.Utils.isOnPC()) return void fx.EventCenter.I.event(n.E_REWARD_GAIN, {
                    code: t.SdkCode.REWARD_GAIN_SUCCESS,
                    way: t.GetRewardSDKWay.VIDEO,
                    rewardType: t.GetRewardSDKWay.VIDEO
                });
                let e = sdk.Sdk.instance.isHasVideo(this._videoParam.id);
                t.VideoState.UNENABLED === e ? sdk.Sdk.instance.showModal("今天已经没有视频啦,分享同样可以获得奖励哟!", "提示", "分享获得", Laya.Handler.create(this, (() => {
                    p.inst.gain(new y(this._videoParam))
                })), "明天再来", Laya.Handler.create(this, (function() {
                    fx.EventCenter.I.event(n.E_REWARD_GAIN, {
                        code: t.SdkCode.REWARD_GAIN_FAIL
                    })
                }))) : (fx.EventCenter.I.once(n.E_AD_VIDEO, this, (e => {
                    t.SdkCode.AD_VIDEO_SUCCESS === e.code ? fx.EventCenter.I.event(n.E_REWARD_GAIN, {
                        code: t.SdkCode.REWARD_GAIN_SUCCESS,
                        way: t.GetRewardSDKWay.VIDEO,
                        rewardType: t.GetRewardSDKWay.VIDEO
                    }) : t.SdkCode.AD_VIDEO_UNCOMPLETE === e.code && sdk.Sdk.instance.showModal("看完视频才会有奖励哟！！！", "提示", "继续观看", Laya.Handler.create(this, (() => {
                        this.gain()
                    })), "一会再来", Laya.Handler.create(this, (function() {
                        fx.EventCenter.I.event(n.E_REWARD_GAIN, {
                            code: t.SdkCode.REWARD_GAIN_FAIL
                        })
                    })))
                })), sdk.Sdk.instance.playVideo(this._videoParam.id, this._videoParam.title))
            }
        }, t.WXAdv = O, t.WXLogin = N, t.WXPay = v, t.WXRewardStrategy = D, t.WXShare = T, t.WXStat = m, Object.defineProperty(t, "__esModule", {
            value: !0
        }), t
    }({});
});
define("libs/min/spine-core-3.8.min.js", function(require, module, exports) {
    var spine;
    (function(t) {
        class e {
            constructor(t, e, s) {
                if (null == t) throw new Error("name cannot be null.");
                if (null == e) throw new Error("timelines cannot be null.");
                this.name = t, this.timelines = e, this.timelineIds = [];
                for (var a = 0; a < e.length; a++) this.timelineIds[e[a].getPropertyId()] = !0;
                this.duration = s
            }
            hasTimeline(t) {
                return 1 == this.timelineIds[t]
            }
            apply(t, e, s, a, n, i, r, l) {
                if (null == t) throw new Error("skeleton cannot be null.");
                a && 0 != this.duration && (s %= this.duration, e > 0 && (e %= this.duration));
                let o = this.timelines;
                for (let a = 0, h = o.length; a < h; a++) o[a].apply(t, e, s, n, i, r, l)
            }
            static binarySearch(t, e, s = 1) {
                let a = 0,
                    n = t.length / s - 2;
                if (0 == n) return s;
                let i = n >>> 1;
                for (;;) {
                    if (t[(i + 1) * s] <= e ? a = i + 1 : n = i, a == n) return (a + 1) * s;
                    i = a + n >>> 1
                }
            }
            static linearSearch(t, e, s) {
                for (let a = 0, n = t.length - s; a <= n; a += s)
                    if (t[a] > e) return a;
                return -1
            }
        }
        let s, a, n;
        t.Animation = e,
            function(t) {
                t[t.setup = 0] = "setup", t[t.first = 1] = "first", t[t.replace = 2] = "replace", t[t.add = 3] = "add"
            }(s = t.MixBlend || (t.MixBlend = {})),
            function(t) {
                t[t.mixIn = 0] = "mixIn", t[t.mixOut = 1] = "mixOut"
            }(a = t.MixDirection || (t.MixDirection = {})),
            function(t) {
                t[t.rotate = 0] = "rotate", t[t.translate = 1] = "translate", t[t.scale = 2] = "scale", t[t.shear = 3] = "shear", t[t.attachment = 4] = "attachment", t[t.color = 5] = "color", t[t.deform = 6] = "deform", t[t.event = 7] = "event", t[t.drawOrder = 8] = "drawOrder", t[t.ikConstraint = 9] = "ikConstraint", t[t.transformConstraint = 10] = "transformConstraint", t[t.pathConstraintPosition = 11] = "pathConstraintPosition", t[t.pathConstraintSpacing = 12] = "pathConstraintSpacing", t[t.pathConstraintMix = 13] = "pathConstraintMix", t[t.twoColor = 14] = "twoColor"
            }(n = t.TimelineType || (t.TimelineType = {}));
        class i {
            constructor(e) {
                if (e <= 0) throw new Error("frameCount must be > 0: " + e);
                this.curves = t.Utils.newFloatArray((e - 1) * i.BEZIER_SIZE)
            }
            getFrameCount() {
                return this.curves.length / i.BEZIER_SIZE + 1
            }
            setLinear(t) {
                this.curves[t * i.BEZIER_SIZE] = i.LINEAR
            }
            setStepped(t) {
                this.curves[t * i.BEZIER_SIZE] = i.STEPPED
            }
            getCurveType(t) {
                let e = t * i.BEZIER_SIZE;
                if (e == this.curves.length) return i.LINEAR;
                let s = this.curves[e];
                return s == i.LINEAR ? i.LINEAR : s == i.STEPPED ? i.STEPPED : i.BEZIER
            }
            setCurve(t, e, s, a, n) {
                let r = .03 * (2 * -e + a),
                    l = .03 * (2 * -s + n),
                    o = .006 * (3 * (e - a) + 1),
                    h = .006 * (3 * (s - n) + 1),
                    d = 2 * r + o,
                    u = 2 * l + h,
                    c = .3 * e + r + .16666667 * o,
                    f = .3 * s + l + .16666667 * h,
                    m = t * i.BEZIER_SIZE,
                    g = this.curves;
                g[m++] = i.BEZIER;
                let p = c,
                    w = f;
                for (let t = m + i.BEZIER_SIZE - 1; m < t; m += 2) g[m] = p, g[m + 1] = w, c += d, f += u, d += o, u += h, p += c, w += f
            }
            getCurvePercent(e, s) {
                s = t.MathUtils.clamp(s, 0, 1);
                let a = this.curves,
                    n = e * i.BEZIER_SIZE,
                    r = a[n];
                if (r == i.LINEAR) return s;
                if (r == i.STEPPED) return 0;
                n++;
                let l = 0;
                for (let t = n, e = n + i.BEZIER_SIZE - 1; n < e; n += 2)
                    if (l = a[n], l >= s) {
                        let e, i;
                        return n == t ? (e = 0, i = 0) : (e = a[n - 2], i = a[n - 1]), i + (a[n + 1] - i) * (s - e) / (l - e)
                    }
                let o = a[n - 1];
                return o + (1 - o) * (s - l) / (1 - l)
            }
        }
        i.LINEAR = 0, i.STEPPED = 1, i.BEZIER = 2, i.BEZIER_SIZE = 19, t.CurveTimeline = i;
        class r extends i {
            constructor(e) {
                super(e), this.frames = t.Utils.newFloatArray(e << 1)
            }
            getPropertyId() {
                return (n.rotate << 24) + this.boneIndex
            }
            setFrame(t, e, s) {
                t <<= 1, this.frames[t] = e, this.frames[t + r.ROTATION] = s
            }
            apply(t, a, n, i, l, o, h) {
                let d = this.frames,
                    u = t.bones[this.boneIndex];
                if (!u.active) return;
                if (n < d[0]) {
                    switch (o) {
                        case s.setup:
                            return void(u.rotation = u.data.rotation);
                        case s.first:
                            let t = u.data.rotation - u.rotation;
                            u.rotation += (t - 360 * (16384 - (16384.499999999996 - t / 360 | 0))) * l
                    }
                    return
                }
                if (n >= d[d.length - r.ENTRIES]) {
                    let t = d[d.length + r.PREV_ROTATION];
                    switch (o) {
                        case s.setup:
                            u.rotation = u.data.rotation + t * l;
                            break;
                        case s.first:
                        case s.replace:
                            t += u.data.rotation - u.rotation, t -= 360 * (16384 - (16384.499999999996 - t / 360 | 0));
                        case s.add:
                            u.rotation += t * l
                    }
                    return
                }
                let c = e.binarySearch(d, n, r.ENTRIES),
                    f = d[c + r.PREV_ROTATION],
                    m = d[c],
                    g = this.getCurvePercent((c >> 1) - 1, 1 - (n - m) / (d[c + r.PREV_TIME] - m)),
                    p = d[c + r.ROTATION] - f;
                switch (p = f + (p - 360 * (16384 - (16384.499999999996 - p / 360 | 0))) * g, o) {
                    case s.setup:
                        u.rotation = u.data.rotation + (p - 360 * (16384 - (16384.499999999996 - p / 360 | 0))) * l;
                        break;
                    case s.first:
                    case s.replace:
                        p += u.data.rotation - u.rotation;
                    case s.add:
                        u.rotation += (p - 360 * (16384 - (16384.499999999996 - p / 360 | 0))) * l
                }
            }
        }
        r.ENTRIES = 2, r.PREV_TIME = -2, r.PREV_ROTATION = -1, r.ROTATION = 1, t.RotateTimeline = r;
        class l extends i {
            constructor(e) {
                super(e), this.frames = t.Utils.newFloatArray(e * l.ENTRIES)
            }
            getPropertyId() {
                return (n.translate << 24) + this.boneIndex
            }
            setFrame(t, e, s, a) {
                t *= l.ENTRIES, this.frames[t] = e, this.frames[t + l.X] = s, this.frames[t + l.Y] = a
            }
            apply(t, a, n, i, r, o, h) {
                let d = this.frames,
                    u = t.bones[this.boneIndex];
                if (!u.active) return;
                if (n < d[0]) {
                    switch (o) {
                        case s.setup:
                            return u.x = u.data.x, void(u.y = u.data.y);
                        case s.first:
                            u.x += (u.data.x - u.x) * r, u.y += (u.data.y - u.y) * r
                    }
                    return
                }
                let c = 0,
                    f = 0;
                if (n >= d[d.length - l.ENTRIES]) c = d[d.length + l.PREV_X], f = d[d.length + l.PREV_Y];
                else {
                    let t = e.binarySearch(d, n, l.ENTRIES);
                    c = d[t + l.PREV_X], f = d[t + l.PREV_Y];
                    let s = d[t],
                        a = this.getCurvePercent(t / l.ENTRIES - 1, 1 - (n - s) / (d[t + l.PREV_TIME] - s));
                    c += (d[t + l.X] - c) * a, f += (d[t + l.Y] - f) * a
                }
                switch (o) {
                    case s.setup:
                        u.x = u.data.x + c * r, u.y = u.data.y + f * r;
                        break;
                    case s.first:
                    case s.replace:
                        u.x += (u.data.x + c - u.x) * r, u.y += (u.data.y + f - u.y) * r;
                        break;
                    case s.add:
                        u.x += c * r, u.y += f * r
                }
            }
        }
        l.ENTRIES = 3, l.PREV_TIME = -3, l.PREV_X = -2, l.PREV_Y = -1, l.X = 1, l.Y = 2, t.TranslateTimeline = l;
        class o extends l {
            constructor(t) {
                super(t)
            }
            getPropertyId() {
                return (n.scale << 24) + this.boneIndex
            }
            apply(n, i, r, l, h, d, u) {
                let c = this.frames,
                    f = n.bones[this.boneIndex];
                if (!f.active) return;
                if (r < c[0]) {
                    switch (d) {
                        case s.setup:
                            return f.scaleX = f.data.scaleX, void(f.scaleY = f.data.scaleY);
                        case s.first:
                            f.scaleX += (f.data.scaleX - f.scaleX) * h, f.scaleY += (f.data.scaleY - f.scaleY) * h
                    }
                    return
                }
                let m = 0,
                    g = 0;
                if (r >= c[c.length - o.ENTRIES]) m = c[c.length + o.PREV_X] * f.data.scaleX, g = c[c.length + o.PREV_Y] * f.data.scaleY;
                else {
                    let t = e.binarySearch(c, r, o.ENTRIES);
                    m = c[t + o.PREV_X], g = c[t + o.PREV_Y];
                    let s = c[t],
                        a = this.getCurvePercent(t / o.ENTRIES - 1, 1 - (r - s) / (c[t + o.PREV_TIME] - s));
                    m = (m + (c[t + o.X] - m) * a) * f.data.scaleX, g = (g + (c[t + o.Y] - g) * a) * f.data.scaleY
                }
                if (1 == h) d == s.add ? (f.scaleX += m - f.data.scaleX, f.scaleY += g - f.data.scaleY) : (f.scaleX = m, f.scaleY = g);
                else {
                    let e = 0,
                        n = 0;
                    if (u == a.mixOut) switch (d) {
                        case s.setup:
                            e = f.data.scaleX, n = f.data.scaleY, f.scaleX = e + (Math.abs(m) * t.MathUtils.signum(e) - e) * h, f.scaleY = n + (Math.abs(g) * t.MathUtils.signum(n) - n) * h;
                            break;
                        case s.first:
                        case s.replace:
                            e = f.scaleX, n = f.scaleY, f.scaleX = e + (Math.abs(m) * t.MathUtils.signum(e) - e) * h, f.scaleY = n + (Math.abs(g) * t.MathUtils.signum(n) - n) * h;
                            break;
                        case s.add:
                            e = f.scaleX, n = f.scaleY, f.scaleX = e + (Math.abs(m) * t.MathUtils.signum(e) - f.data.scaleX) * h, f.scaleY = n + (Math.abs(g) * t.MathUtils.signum(n) - f.data.scaleY) * h
                    } else switch (d) {
                        case s.setup:
                            e = Math.abs(f.data.scaleX) * t.MathUtils.signum(m), n = Math.abs(f.data.scaleY) * t.MathUtils.signum(g), f.scaleX = e + (m - e) * h, f.scaleY = n + (g - n) * h;
                            break;
                        case s.first:
                        case s.replace:
                            e = Math.abs(f.scaleX) * t.MathUtils.signum(m), n = Math.abs(f.scaleY) * t.MathUtils.signum(g), f.scaleX = e + (m - e) * h, f.scaleY = n + (g - n) * h;
                            break;
                        case s.add:
                            e = t.MathUtils.signum(m), n = t.MathUtils.signum(g), f.scaleX = Math.abs(f.scaleX) * e + (m - Math.abs(f.data.scaleX) * e) * h, f.scaleY = Math.abs(f.scaleY) * n + (g - Math.abs(f.data.scaleY) * n) * h
                    }
                }
            }
        }
        t.ScaleTimeline = o;
        class h extends l {
            constructor(t) {
                super(t)
            }
            getPropertyId() {
                return (n.shear << 24) + this.boneIndex
            }
            apply(t, a, n, i, r, l, o) {
                let d = this.frames,
                    u = t.bones[this.boneIndex];
                if (!u.active) return;
                if (n < d[0]) {
                    switch (l) {
                        case s.setup:
                            return u.shearX = u.data.shearX, void(u.shearY = u.data.shearY);
                        case s.first:
                            u.shearX += (u.data.shearX - u.shearX) * r, u.shearY += (u.data.shearY - u.shearY) * r
                    }
                    return
                }
                let c = 0,
                    f = 0;
                if (n >= d[d.length - h.ENTRIES]) c = d[d.length + h.PREV_X], f = d[d.length + h.PREV_Y];
                else {
                    let t = e.binarySearch(d, n, h.ENTRIES);
                    c = d[t + h.PREV_X], f = d[t + h.PREV_Y];
                    let s = d[t],
                        a = this.getCurvePercent(t / h.ENTRIES - 1, 1 - (n - s) / (d[t + h.PREV_TIME] - s));
                    c += (d[t + h.X] - c) * a, f += (d[t + h.Y] - f) * a
                }
                switch (l) {
                    case s.setup:
                        u.shearX = u.data.shearX + c * r, u.shearY = u.data.shearY + f * r;
                        break;
                    case s.first:
                    case s.replace:
                        u.shearX += (u.data.shearX + c - u.shearX) * r, u.shearY += (u.data.shearY + f - u.shearY) * r;
                        break;
                    case s.add:
                        u.shearX += c * r, u.shearY += f * r
                }
            }
        }
        t.ShearTimeline = h;
        class d extends i {
            constructor(e) {
                super(e), this.frames = t.Utils.newFloatArray(e * d.ENTRIES)
            }
            getPropertyId() {
                return (n.color << 24) + this.slotIndex
            }
            setFrame(t, e, s, a, n, i) {
                t *= d.ENTRIES, this.frames[t] = e, this.frames[t + d.R] = s, this.frames[t + d.G] = a, this.frames[t + d.B] = n, this.frames[t + d.A] = i
            }
            apply(t, a, n, i, r, l, o) {
                let h = t.slots[this.slotIndex];
                if (!h.bone.active) return;
                let u = this.frames;
                if (n < u[0]) {
                    switch (l) {
                        case s.setup:
                            return void h.color.setFromColor(h.data.color);
                        case s.first:
                            let t = h.color,
                                e = h.data.color;
                            t.add((e.r - t.r) * r, (e.g - t.g) * r, (e.b - t.b) * r, (e.a - t.a) * r)
                    }
                    return
                }
                let c = 0,
                    f = 0,
                    m = 0,
                    g = 0;
                if (n >= u[u.length - d.ENTRIES]) {
                    let t = u.length;
                    c = u[t + d.PREV_R], f = u[t + d.PREV_G], m = u[t + d.PREV_B], g = u[t + d.PREV_A]
                } else {
                    let t = e.binarySearch(u, n, d.ENTRIES);
                    c = u[t + d.PREV_R], f = u[t + d.PREV_G], m = u[t + d.PREV_B], g = u[t + d.PREV_A];
                    let s = u[t],
                        a = this.getCurvePercent(t / d.ENTRIES - 1, 1 - (n - s) / (u[t + d.PREV_TIME] - s));
                    c += (u[t + d.R] - c) * a, f += (u[t + d.G] - f) * a, m += (u[t + d.B] - m) * a, g += (u[t + d.A] - g) * a
                }
                if (1 == r) h.color.set(c, f, m, g);
                else {
                    let t = h.color;
                    l == s.setup && t.setFromColor(h.data.color), t.add((c - t.r) * r, (f - t.g) * r, (m - t.b) * r, (g - t.a) * r)
                }
            }
        }
        d.ENTRIES = 5, d.PREV_TIME = -5, d.PREV_R = -4, d.PREV_G = -3, d.PREV_B = -2, d.PREV_A = -1, d.R = 1, d.G = 2, d.B = 3, d.A = 4, t.ColorTimeline = d;
        class u extends i {
            constructor(e) {
                super(e), this.frames = t.Utils.newFloatArray(e * u.ENTRIES)
            }
            getPropertyId() {
                return (n.twoColor << 24) + this.slotIndex
            }
            setFrame(t, e, s, a, n, i, r, l, o) {
                t *= u.ENTRIES, this.frames[t] = e, this.frames[t + u.R] = s, this.frames[t + u.G] = a, this.frames[t + u.B] = n, this.frames[t + u.A] = i, this.frames[t + u.R2] = r, this.frames[t + u.G2] = l, this.frames[t + u.B2] = o
            }
            apply(t, a, n, i, r, l, o) {
                let h = t.slots[this.slotIndex];
                if (!h.bone.active) return;
                let d = this.frames;
                if (n < d[0]) {
                    switch (l) {
                        case s.setup:
                            return h.color.setFromColor(h.data.color), void h.darkColor.setFromColor(h.data.darkColor);
                        case s.first:
                            let t = h.color,
                                e = h.darkColor,
                                a = h.data.color,
                                n = h.data.darkColor;
                            t.add((a.r - t.r) * r, (a.g - t.g) * r, (a.b - t.b) * r, (a.a - t.a) * r), e.add((n.r - e.r) * r, (n.g - e.g) * r, (n.b - e.b) * r, 0)
                    }
                    return
                }
                let c = 0,
                    f = 0,
                    m = 0,
                    g = 0,
                    p = 0,
                    w = 0,
                    x = 0;
                if (n >= d[d.length - u.ENTRIES]) {
                    let t = d.length;
                    c = d[t + u.PREV_R], f = d[t + u.PREV_G], m = d[t + u.PREV_B], g = d[t + u.PREV_A], p = d[t + u.PREV_R2], w = d[t + u.PREV_G2], x = d[t + u.PREV_B2]
                } else {
                    let t = e.binarySearch(d, n, u.ENTRIES);
                    c = d[t + u.PREV_R], f = d[t + u.PREV_G], m = d[t + u.PREV_B], g = d[t + u.PREV_A], p = d[t + u.PREV_R2], w = d[t + u.PREV_G2], x = d[t + u.PREV_B2];
                    let s = d[t],
                        a = this.getCurvePercent(t / u.ENTRIES - 1, 1 - (n - s) / (d[t + u.PREV_TIME] - s));
                    c += (d[t + u.R] - c) * a, f += (d[t + u.G] - f) * a, m += (d[t + u.B] - m) * a, g += (d[t + u.A] - g) * a, p += (d[t + u.R2] - p) * a, w += (d[t + u.G2] - w) * a, x += (d[t + u.B2] - x) * a
                }
                if (1 == r) h.color.set(c, f, m, g), h.darkColor.set(p, w, x, 1);
                else {
                    let t = h.color,
                        e = h.darkColor;
                    l == s.setup && (t.setFromColor(h.data.color), e.setFromColor(h.data.darkColor)), t.add((c - t.r) * r, (f - t.g) * r, (m - t.b) * r, (g - t.a) * r), e.add((p - e.r) * r, (w - e.g) * r, (x - e.b) * r, 0)
                }
            }
        }
        u.ENTRIES = 8, u.PREV_TIME = -8, u.PREV_R = -7, u.PREV_G = -6, u.PREV_B = -5, u.PREV_A = -4, u.PREV_R2 = -3, u.PREV_G2 = -2, u.PREV_B2 = -1, u.R = 1, u.G = 2, u.B = 3, u.A = 4, u.R2 = 5, u.G2 = 6, u.B2 = 7, t.TwoColorTimeline = u;
        class c {
            constructor(e) {
                this.frames = t.Utils.newFloatArray(e), this.attachmentNames = new Array(e)
            }
            getPropertyId() {
                return (n.attachment << 24) + this.slotIndex
            }
            getFrameCount() {
                return this.frames.length
            }
            setFrame(t, e, s) {
                this.frames[t] = e, this.attachmentNames[t] = s
            }
            apply(t, n, i, r, l, o, h) {
                let d = t.slots[this.slotIndex];
                if (!d.bone.active) return;
                if (h == a.mixOut) return void(o == s.setup && this.setAttachment(t, d, d.data.attachmentName));
                let u = this.frames;
                if (i < u[0]) return void(o != s.setup && o != s.first || this.setAttachment(t, d, d.data.attachmentName));
                let c = 0;
                c = i >= u[u.length - 1] ? u.length - 1 : e.binarySearch(u, i, 1) - 1;
                let f = this.attachmentNames[c];
                t.slots[this.slotIndex].setAttachment(null == f ? null : t.getAttachment(this.slotIndex, f))
            }
            setAttachment(t, e, s) {
                e.attachment = null == s ? null : t.getAttachment(this.slotIndex, s)
            }
        }
        t.AttachmentTimeline = c;
        let f = null;
        class m extends i {
            constructor(e) {
                super(e), this.frames = t.Utils.newFloatArray(e), this.frameVertices = new Array(e), null == f && (f = t.Utils.newFloatArray(64))
            }
            getPropertyId() {
                return (n.deform << 27) + +this.attachment.id + this.slotIndex
            }
            setFrame(t, e, s) {
                this.frames[t] = e, this.frameVertices[t] = s
            }
            apply(a, n, i, r, l, o, h) {
                let d = a.slots[this.slotIndex];
                if (!d.bone.active) return;
                let u = d.getAttachment();
                if (!(u instanceof t.VertexAttachment) || u.deformAttachment != this.attachment) return;
                let c = d.deform;
                0 == c.length && (o = s.setup);
                let f = this.frameVertices,
                    m = f[0].length,
                    g = this.frames;
                if (i < g[0]) {
                    let e = u;
                    switch (o) {
                        case s.setup:
                            return void(c.length = 0);
                        case s.first:
                            if (1 == l) {
                                c.length = 0;
                                break
                            }
                            let a = t.Utils.setArraySize(c, m);
                            if (null == e.bones) {
                                let t = e.vertices;
                                for (var p = 0; p < m; p++) a[p] += (t[p] - a[p]) * l
                            } else {
                                l = 1 - l;
                                for (p = 0; p < m; p++) a[p] *= l
                            }
                    }
                    return
                }
                let w = t.Utils.setArraySize(c, m);
                if (i >= g[g.length - 1]) {
                    let e = f[g.length - 1];
                    if (1 == l)
                        if (o == s.add) {
                            let t = u;
                            if (null == t.bones) {
                                let s = t.vertices;
                                for (let t = 0; t < m; t++) w[t] += e[t] - s[t]
                            } else
                                for (let t = 0; t < m; t++) w[t] += e[t]
                        } else t.Utils.arrayCopy(e, 0, w, 0, m);
                    else switch (o) {
                        case s.setup:
                            {
                                let t = u;
                                if (null == t.bones) {
                                    let s = t.vertices;
                                    for (let t = 0; t < m; t++) {
                                        let a = s[t];
                                        w[t] = a + (e[t] - a) * l
                                    }
                                } else
                                    for (let t = 0; t < m; t++) w[t] = e[t] * l;
                                break
                            }
                        case s.first:
                        case s.replace:
                            for (let t = 0; t < m; t++) w[t] += (e[t] - w[t]) * l;
                            break;
                        case s.add:
                            let t = u;
                            if (null == t.bones) {
                                let s = t.vertices;
                                for (let t = 0; t < m; t++) w[t] += (e[t] - s[t]) * l
                            } else
                                for (let t = 0; t < m; t++) w[t] += e[t] * l
                    }
                    return
                }
                let x = e.binarySearch(g, i),
                    M = f[x - 1],
                    E = f[x],
                    T = g[x],
                    A = this.getCurvePercent(x - 1, 1 - (i - T) / (g[x - 1] - T));
                if (1 == l)
                    if (o == s.add) {
                        let t = u;
                        if (null == t.bones) {
                            let e = t.vertices;
                            for (let t = 0; t < m; t++) {
                                let s = M[t];
                                w[t] += s + (E[t] - s) * A - e[t]
                            }
                        } else
                            for (let t = 0; t < m; t++) {
                                let e = M[t];
                                w[t] += e + (E[t] - e) * A
                            }
                    } else
                        for (let t = 0; t < m; t++) {
                            let e = M[t];
                            w[t] = e + (E[t] - e) * A
                        } else switch (o) {
                            case s.setup:
                                {
                                    let t = u;
                                    if (null == t.bones) {
                                        let e = t.vertices;
                                        for (let t = 0; t < m; t++) {
                                            let s = M[t],
                                                a = e[t];
                                            w[t] = a + (s + (E[t] - s) * A - a) * l
                                        }
                                    } else
                                        for (let t = 0; t < m; t++) {
                                            let e = M[t];
                                            w[t] = (e + (E[t] - e) * A) * l
                                        }
                                    break
                                }
                            case s.first:
                            case s.replace:
                                for (let t = 0; t < m; t++) {
                                    let e = M[t];
                                    w[t] += (e + (E[t] - e) * A - w[t]) * l
                                }
                                break;
                            case s.add:
                                let t = u;
                                if (null == t.bones) {
                                    let e = t.vertices;
                                    for (let t = 0; t < m; t++) {
                                        let s = M[t];
                                        w[t] += (s + (E[t] - s) * A - e[t]) * l
                                    }
                                } else
                                    for (let t = 0; t < m; t++) {
                                        let e = M[t];
                                        w[t] += (e + (E[t] - e) * A) * l
                                    }
                        }
            }
        }
        t.DeformTimeline = m;
        class g {
            constructor(e) {
                this.frames = t.Utils.newFloatArray(e), this.events = new Array(e)
            }
            getPropertyId() {
                return n.event << 24
            }
            getFrameCount() {
                return this.frames.length
            }
            setFrame(t, e) {
                this.frames[t] = e.time, this.events[t] = e
            }
            apply(t, s, a, n, i, r, l) {
                if (null == n) return;
                let o = this.frames,
                    h = this.frames.length;
                if (s > a) this.apply(t, s, Number.MAX_VALUE, n, i, r, l), s = -1;
                else if (s >= o[h - 1]) return;
                if (a < o[0]) return;
                let d = 0;
                if (s < o[0]) d = 0;
                else {
                    d = e.binarySearch(o, s);
                    let t = o[d];
                    for (; d > 0 && o[d - 1] == t;) d--
                }
                for (; d < h && a >= o[d]; d++) n.push(this.events[d])
            }
        }
        t.EventTimeline = g;
        class p {
            constructor(e) {
                this.frames = t.Utils.newFloatArray(e), this.drawOrders = new Array(e)
            }
            getPropertyId() {
                return n.drawOrder << 24
            }
            getFrameCount() {
                return this.frames.length
            }
            setFrame(t, e, s) {
                this.frames[t] = e, this.drawOrders[t] = s
            }
            apply(n, i, r, l, o, h, d) {
                let u = n.drawOrder,
                    c = n.slots;
                if (d == a.mixOut) return void(h == s.setup && t.Utils.arrayCopy(n.slots, 0, n.drawOrder, 0, n.slots.length));
                let f = this.frames;
                if (r < f[0]) return void(h != s.setup && h != s.first || t.Utils.arrayCopy(n.slots, 0, n.drawOrder, 0, n.slots.length));
                let m = 0;
                m = r >= f[f.length - 1] ? f.length - 1 : e.binarySearch(f, r) - 1;
                let g = this.drawOrders[m];
                if (null == g) t.Utils.arrayCopy(c, 0, u, 0, c.length);
                else
                    for (let t = 0, e = g.length; t < e; t++) u[t] = c[g[t]]
            }
        }
        t.DrawOrderTimeline = p;
        class w extends i {
            constructor(e) {
                super(e), this.frames = t.Utils.newFloatArray(e * w.ENTRIES)
            }
            getPropertyId() {
                return (n.ikConstraint << 24) + this.ikConstraintIndex
            }
            setFrame(t, e, s, a, n, i, r) {
                t *= w.ENTRIES, this.frames[t] = e, this.frames[t + w.MIX] = s, this.frames[t + w.SOFTNESS] = a, this.frames[t + w.BEND_DIRECTION] = n, this.frames[t + w.COMPRESS] = i ? 1 : 0, this.frames[t + w.STRETCH] = r ? 1 : 0
            }
            apply(t, n, i, r, l, o, h) {
                let d = this.frames,
                    u = t.ikConstraints[this.ikConstraintIndex];
                if (!u.active) return;
                if (i < d[0]) {
                    switch (o) {
                        case s.setup:
                            return u.mix = u.data.mix, u.softness = u.data.softness, u.bendDirection = u.data.bendDirection, u.compress = u.data.compress, void(u.stretch = u.data.stretch);
                        case s.first:
                            u.mix += (u.data.mix - u.mix) * l, u.softness += (u.data.softness - u.softness) * l, u.bendDirection = u.data.bendDirection, u.compress = u.data.compress, u.stretch = u.data.stretch
                    }
                    return
                }
                if (i >= d[d.length - w.ENTRIES]) return void(o == s.setup ? (u.mix = u.data.mix + (d[d.length + w.PREV_MIX] - u.data.mix) * l, u.softness = u.data.softness + (d[d.length + w.PREV_SOFTNESS] - u.data.softness) * l, h == a.mixOut ? (u.bendDirection = u.data.bendDirection, u.compress = u.data.compress, u.stretch = u.data.stretch) : (u.bendDirection = d[d.length + w.PREV_BEND_DIRECTION], u.compress = 0 != d[d.length + w.PREV_COMPRESS], u.stretch = 0 != d[d.length + w.PREV_STRETCH])) : (u.mix += (d[d.length + w.PREV_MIX] - u.mix) * l, u.softness += (d[d.length + w.PREV_SOFTNESS] - u.softness) * l, h == a.mixIn && (u.bendDirection = d[d.length + w.PREV_BEND_DIRECTION], u.compress = 0 != d[d.length + w.PREV_COMPRESS], u.stretch = 0 != d[d.length + w.PREV_STRETCH])));
                let c = e.binarySearch(d, i, w.ENTRIES),
                    f = d[c + w.PREV_MIX],
                    m = d[c + w.PREV_SOFTNESS],
                    g = d[c],
                    p = this.getCurvePercent(c / w.ENTRIES - 1, 1 - (i - g) / (d[c + w.PREV_TIME] - g));
                o == s.setup ? (u.mix = u.data.mix + (f + (d[c + w.MIX] - f) * p - u.data.mix) * l, u.softness = u.data.softness + (m + (d[c + w.SOFTNESS] - m) * p - u.data.softness) * l, h == a.mixOut ? (u.bendDirection = u.data.bendDirection, u.compress = u.data.compress, u.stretch = u.data.stretch) : (u.bendDirection = d[c + w.PREV_BEND_DIRECTION], u.compress = 0 != d[c + w.PREV_COMPRESS], u.stretch = 0 != d[c + w.PREV_STRETCH])) : (u.mix += (f + (d[c + w.MIX] - f) * p - u.mix) * l, u.softness += (m + (d[c + w.SOFTNESS] - m) * p - u.softness) * l, h == a.mixIn && (u.bendDirection = d[c + w.PREV_BEND_DIRECTION], u.compress = 0 != d[c + w.PREV_COMPRESS], u.stretch = 0 != d[c + w.PREV_STRETCH]))
            }
        }
        w.ENTRIES = 6, w.PREV_TIME = -6, w.PREV_MIX = -5, w.PREV_SOFTNESS = -4, w.PREV_BEND_DIRECTION = -3, w.PREV_COMPRESS = -2, w.PREV_STRETCH = -1, w.MIX = 1, w.SOFTNESS = 2, w.BEND_DIRECTION = 3, w.COMPRESS = 4, w.STRETCH = 5, t.IkConstraintTimeline = w;
        class x extends i {
            constructor(e) {
                super(e), this.frames = t.Utils.newFloatArray(e * x.ENTRIES)
            }
            getPropertyId() {
                return (n.transformConstraint << 24) + this.transformConstraintIndex
            }
            setFrame(t, e, s, a, n, i) {
                t *= x.ENTRIES, this.frames[t] = e, this.frames[t + x.ROTATE] = s, this.frames[t + x.TRANSLATE] = a, this.frames[t + x.SCALE] = n, this.frames[t + x.SHEAR] = i
            }
            apply(t, a, n, i, r, l, o) {
                let h = this.frames,
                    d = t.transformConstraints[this.transformConstraintIndex];
                if (!d.active) return;
                if (n < h[0]) {
                    let t = d.data;
                    switch (l) {
                        case s.setup:
                            return d.rotateMix = t.rotateMix, d.translateMix = t.translateMix, d.scaleMix = t.scaleMix, void(d.shearMix = t.shearMix);
                        case s.first:
                            d.rotateMix += (t.rotateMix - d.rotateMix) * r, d.translateMix += (t.translateMix - d.translateMix) * r, d.scaleMix += (t.scaleMix - d.scaleMix) * r, d.shearMix += (t.shearMix - d.shearMix) * r
                    }
                    return
                }
                let u = 0,
                    c = 0,
                    f = 0,
                    m = 0;
                if (n >= h[h.length - x.ENTRIES]) {
                    let t = h.length;
                    u = h[t + x.PREV_ROTATE], c = h[t + x.PREV_TRANSLATE], f = h[t + x.PREV_SCALE], m = h[t + x.PREV_SHEAR]
                } else {
                    let t = e.binarySearch(h, n, x.ENTRIES);
                    u = h[t + x.PREV_ROTATE], c = h[t + x.PREV_TRANSLATE], f = h[t + x.PREV_SCALE], m = h[t + x.PREV_SHEAR];
                    let s = h[t],
                        a = this.getCurvePercent(t / x.ENTRIES - 1, 1 - (n - s) / (h[t + x.PREV_TIME] - s));
                    u += (h[t + x.ROTATE] - u) * a, c += (h[t + x.TRANSLATE] - c) * a, f += (h[t + x.SCALE] - f) * a, m += (h[t + x.SHEAR] - m) * a
                }
                if (l == s.setup) {
                    let t = d.data;
                    d.rotateMix = t.rotateMix + (u - t.rotateMix) * r, d.translateMix = t.translateMix + (c - t.translateMix) * r, d.scaleMix = t.scaleMix + (f - t.scaleMix) * r, d.shearMix = t.shearMix + (m - t.shearMix) * r
                } else d.rotateMix += (u - d.rotateMix) * r, d.translateMix += (c - d.translateMix) * r, d.scaleMix += (f - d.scaleMix) * r, d.shearMix += (m - d.shearMix) * r
            }
        }
        x.ENTRIES = 5, x.PREV_TIME = -5, x.PREV_ROTATE = -4, x.PREV_TRANSLATE = -3, x.PREV_SCALE = -2, x.PREV_SHEAR = -1, x.ROTATE = 1, x.TRANSLATE = 2, x.SCALE = 3, x.SHEAR = 4, t.TransformConstraintTimeline = x;
        class M extends i {
            constructor(e) {
                super(e), this.frames = t.Utils.newFloatArray(e * M.ENTRIES)
            }
            getPropertyId() {
                return (n.pathConstraintPosition << 24) + this.pathConstraintIndex
            }
            setFrame(t, e, s) {
                t *= M.ENTRIES, this.frames[t] = e, this.frames[t + M.VALUE] = s
            }
            apply(t, a, n, i, r, l, o) {
                let h = this.frames,
                    d = t.pathConstraints[this.pathConstraintIndex];
                if (!d.active) return;
                if (n < h[0]) {
                    switch (l) {
                        case s.setup:
                            return void(d.position = d.data.position);
                        case s.first:
                            d.position += (d.data.position - d.position) * r
                    }
                    return
                }
                let u = 0;
                if (n >= h[h.length - M.ENTRIES]) u = h[h.length + M.PREV_VALUE];
                else {
                    let t = e.binarySearch(h, n, M.ENTRIES);
                    u = h[t + M.PREV_VALUE];
                    let s = h[t],
                        a = this.getCurvePercent(t / M.ENTRIES - 1, 1 - (n - s) / (h[t + M.PREV_TIME] - s));
                    u += (h[t + M.VALUE] - u) * a
                }
                l == s.setup ? d.position = d.data.position + (u - d.data.position) * r : d.position += (u - d.position) * r
            }
        }
        M.ENTRIES = 2, M.PREV_TIME = -2, M.PREV_VALUE = -1, M.VALUE = 1, t.PathConstraintPositionTimeline = M;
        class E extends M {
            constructor(t) {
                super(t)
            }
            getPropertyId() {
                return (n.pathConstraintSpacing << 24) + this.pathConstraintIndex
            }
            apply(t, a, n, i, r, l, o) {
                let h = this.frames,
                    d = t.pathConstraints[this.pathConstraintIndex];
                if (!d.active) return;
                if (n < h[0]) {
                    switch (l) {
                        case s.setup:
                            return void(d.spacing = d.data.spacing);
                        case s.first:
                            d.spacing += (d.data.spacing - d.spacing) * r
                    }
                    return
                }
                let u = 0;
                if (n >= h[h.length - E.ENTRIES]) u = h[h.length + E.PREV_VALUE];
                else {
                    let t = e.binarySearch(h, n, E.ENTRIES);
                    u = h[t + E.PREV_VALUE];
                    let s = h[t],
                        a = this.getCurvePercent(t / E.ENTRIES - 1, 1 - (n - s) / (h[t + E.PREV_TIME] - s));
                    u += (h[t + E.VALUE] - u) * a
                }
                l == s.setup ? d.spacing = d.data.spacing + (u - d.data.spacing) * r : d.spacing += (u - d.spacing) * r
            }
        }
        t.PathConstraintSpacingTimeline = E;
        class T extends i {
            constructor(e) {
                super(e), this.frames = t.Utils.newFloatArray(e * T.ENTRIES)
            }
            getPropertyId() {
                return (n.pathConstraintMix << 24) + this.pathConstraintIndex
            }
            setFrame(t, e, s, a) {
                t *= T.ENTRIES, this.frames[t] = e, this.frames[t + T.ROTATE] = s, this.frames[t + T.TRANSLATE] = a
            }
            apply(t, a, n, i, r, l, o) {
                let h = this.frames,
                    d = t.pathConstraints[this.pathConstraintIndex];
                if (!d.active) return;
                if (n < h[0]) {
                    switch (l) {
                        case s.setup:
                            return d.rotateMix = d.data.rotateMix, void(d.translateMix = d.data.translateMix);
                        case s.first:
                            d.rotateMix += (d.data.rotateMix - d.rotateMix) * r, d.translateMix += (d.data.translateMix - d.translateMix) * r
                    }
                    return
                }
                let u = 0,
                    c = 0;
                if (n >= h[h.length - T.ENTRIES]) u = h[h.length + T.PREV_ROTATE], c = h[h.length + T.PREV_TRANSLATE];
                else {
                    let t = e.binarySearch(h, n, T.ENTRIES);
                    u = h[t + T.PREV_ROTATE], c = h[t + T.PREV_TRANSLATE];
                    let s = h[t],
                        a = this.getCurvePercent(t / T.ENTRIES - 1, 1 - (n - s) / (h[t + T.PREV_TIME] - s));
                    u += (h[t + T.ROTATE] - u) * a, c += (h[t + T.TRANSLATE] - c) * a
                }
                l == s.setup ? (d.rotateMix = d.data.rotateMix + (u - d.data.rotateMix) * r, d.translateMix = d.data.translateMix + (c - d.data.translateMix) * r) : (d.rotateMix += (u - d.rotateMix) * r, d.translateMix += (c - d.translateMix) * r)
            }
        }
        T.ENTRIES = 3, T.PREV_TIME = -3, T.PREV_ROTATE = -2, T.PREV_TRANSLATE = -1, T.ROTATE = 1, T.TRANSLATE = 2, t.PathConstraintMixTimeline = T
    })(spine || (spine = {})),
    function(t) {
        class e {
            constructor(e) {
                this.tracks = new Array, this.timeScale = 1, this.unkeyedState = 0, this.events = new Array, this.listeners = new Array, this.queue = new a(this), this.propertyIDs = new t.IntSet, this.animationsChanged = !1, this.trackEntryPool = new t.Pool(() => new s), this.data = e
            }
            update(t) {
                t *= this.timeScale;
                let e = this.tracks;
                for (let s = 0, a = e.length; s < a; s++) {
                    let a = e[s];
                    if (null == a) continue;
                    a.animationLast = a.nextAnimationLast, a.trackLast = a.nextTrackLast;
                    let n = t * a.timeScale;
                    if (a.delay > 0) {
                        if (a.delay -= n, a.delay > 0) continue;
                        n = -a.delay, a.delay = 0
                    }
                    let i = a.next;
                    if (null != i) {
                        let e = a.trackLast - i.delay;
                        if (e >= 0) {
                            for (i.delay = 0, i.trackTime += 0 == a.timeScale ? 0 : (e / a.timeScale + t) * i.timeScale, a.trackTime += n, this.setCurrent(s, i, !0); null != i.mixingFrom;) i.mixTime += t, i = i.mixingFrom;
                            continue
                        }
                    } else if (a.trackLast >= a.trackEnd && null == a.mixingFrom) {
                        e[s] = null, this.queue.end(a), this.disposeNext(a);
                        continue
                    }
                    if (null != a.mixingFrom && this.updateMixingFrom(a, t)) {
                        let t = a.mixingFrom;
                        for (a.mixingFrom = null, null != t && (t.mixingTo = null); null != t;) this.queue.end(t), t = t.mixingFrom
                    }
                    a.trackTime += n
                }
                this.queue.drain()
            }
            updateMixingFrom(t, e) {
                let s = t.mixingFrom;
                if (null == s) return !0;
                let a = this.updateMixingFrom(s, e);
                return s.animationLast = s.nextAnimationLast, s.trackLast = s.nextTrackLast, t.mixTime > 0 && t.mixTime >= t.mixDuration ? (0 != s.totalAlpha && 0 != t.mixDuration || (t.mixingFrom = s.mixingFrom, null != s.mixingFrom && (s.mixingFrom.mixingTo = t), t.interruptAlpha = s.interruptAlpha, this.queue.end(s)), a) : (s.trackTime += e * s.timeScale, t.mixTime += e, !1)
            }
            apply(s) {
                if (null == s) throw new Error("skeleton cannot be null.");
                this.animationsChanged && this._animationsChanged();
                let a = this.events,
                    n = this.tracks,
                    i = !1;
                for (let l = 0, o = n.length; l < o; l++) {
                    let o = n[l];
                    if (null == o || o.delay > 0) continue;
                    i = !0;
                    let h = 0 == l ? t.MixBlend.first : o.mixBlend,
                        d = o.alpha;
                    null != o.mixingFrom ? d *= this.applyMixingFrom(o, s, h) : o.trackTime >= o.trackEnd && null == o.next && (d = 0);
                    let u = o.animationLast,
                        c = o.getAnimationTime(),
                        f = o.animation.timelines.length,
                        m = o.animation.timelines;
                    if (0 == l && 1 == d || h == t.MixBlend.add)
                        for (let e = 0; e < f; e++) {
                            t.Utils.webkit602BugfixHelper(d, h);
                            var r = m[e];
                            r instanceof t.AttachmentTimeline ? this.applyAttachmentTimeline(r, s, c, h, !0) : r.apply(s, u, c, a, d, h, t.MixDirection.mixIn)
                        } else {
                            let n = o.timelineMode,
                                i = 0 == o.timelinesRotation.length;
                            i && t.Utils.setArraySize(o.timelinesRotation, f << 1, null);
                            let r = o.timelinesRotation;
                            for (let l = 0; l < f; l++) {
                                let o = m[l],
                                    f = n[l] == e.SUBSEQUENT ? h : t.MixBlend.setup;
                                o instanceof t.RotateTimeline ? this.applyRotateTimeline(o, s, c, d, f, r, l << 1, i) : o instanceof t.AttachmentTimeline ? this.applyAttachmentTimeline(o, s, c, h, !0) : (t.Utils.webkit602BugfixHelper(d, h), o.apply(s, u, c, a, d, f, t.MixDirection.mixIn))
                            }
                        }
                    this.queueEvents(o, c), a.length = 0, o.nextAnimationLast = c, o.nextTrackLast = o.trackTime
                }
                for (var l = this.unkeyedState + e.SETUP, o = s.slots, h = 0, d = s.slots.length; h < d; h++) {
                    var u = o[h];
                    if (u.attachmentState == l) {
                        var c = u.data.attachmentName;
                        u.attachment = null == c ? null : s.getAttachment(u.data.index, c)
                    }
                }
                return this.unkeyedState += 2, this.queue.drain(), i
            }
            applyMixingFrom(s, a, n) {
                let i = s.mixingFrom;
                null != i.mixingFrom && this.applyMixingFrom(i, a, n);
                let r = 0;
                0 == s.mixDuration ? (r = 1, n == t.MixBlend.first && (n = t.MixBlend.setup)) : (r = s.mixTime / s.mixDuration, r > 1 && (r = 1), n != t.MixBlend.first && (n = i.mixBlend));
                let l = r < i.eventThreshold ? this.events : null,
                    o = r < i.attachmentThreshold,
                    h = r < i.drawOrderThreshold,
                    d = i.animationLast,
                    u = i.getAnimationTime(),
                    c = i.animation.timelines.length,
                    f = i.animation.timelines,
                    m = i.alpha * s.interruptAlpha,
                    g = m * (1 - r);
                if (n == t.MixBlend.add)
                    for (let e = 0; e < c; e++) f[e].apply(a, d, u, l, g, n, t.MixDirection.mixOut);
                else {
                    let s = i.timelineMode,
                        r = i.timelineHoldMix,
                        p = 0 == i.timelinesRotation.length;
                    p && t.Utils.setArraySize(i.timelinesRotation, c << 1, null);
                    let w = i.timelinesRotation;
                    i.totalAlpha = 0;
                    for (let x = 0; x < c; x++) {
                        let c, M = f[x],
                            E = t.MixDirection.mixOut,
                            T = 0;
                        switch (s[x]) {
                            case e.SUBSEQUENT:
                                if (!h && M instanceof t.DrawOrderTimeline) continue;
                                c = n, T = g;
                                break;
                            case e.FIRST:
                                c = t.MixBlend.setup, T = g;
                                break;
                            case e.HOLD_SUBSEQUENT:
                                c = n, T = m;
                                break;
                            case e.HOLD_FIRST:
                                c = t.MixBlend.setup, T = m;
                                break;
                            default:
                                c = t.MixBlend.setup;
                                let a = r[x];
                                T = m * Math.max(0, 1 - a.mixTime / a.mixDuration)
                        }
                        i.totalAlpha += T, M instanceof t.RotateTimeline ? this.applyRotateTimeline(M, a, u, T, c, w, x << 1, p) : M instanceof t.AttachmentTimeline ? this.applyAttachmentTimeline(M, a, u, c, o) : (t.Utils.webkit602BugfixHelper(T, n), h && M instanceof t.DrawOrderTimeline && c == t.MixBlend.setup && (E = t.MixDirection.mixIn), M.apply(a, d, u, l, T, c, E))
                    }
                }
                return s.mixDuration > 0 && this.queueEvents(i, u), this.events.length = 0, i.nextAnimationLast = u, i.nextTrackLast = i.trackTime, r
            }
            applyAttachmentTimeline(s, a, n, i, r) {
                var l = a.slots[s.slotIndex];
                if (l.bone.active) {
                    var o, h = s.frames;
                    if (n < h[0]) i != t.MixBlend.setup && i != t.MixBlend.first || this.setAttachment(a, l, l.data.attachmentName, r);
                    else o = n >= h[h.length - 1] ? h.length - 1 : t.Animation.binarySearch(h, n) - 1, this.setAttachment(a, l, s.attachmentNames[o], r);
                    l.attachmentState <= this.unkeyedState && (l.attachmentState = this.unkeyedState + e.SETUP)
                }
            }
            setAttachment(t, s, a, n) {
                s.setAttachment(null == a ? null : t.getAttachment(s.data.index, a)), n && (s.attachmentState = this.unkeyedState + e.CURRENT)
            }
            applyRotateTimeline(e, s, a, n, i, r, l, o) {
                if (o && (r[l] = 0), 1 == n) return void e.apply(s, 0, a, null, 1, i, t.MixDirection.mixIn);
                let h = e,
                    d = h.frames,
                    u = s.bones[h.boneIndex];
                if (!u.active) return;
                let c = 0,
                    f = 0;
                if (a < d[0]) switch (i) {
                        case t.MixBlend.setup:
                            u.rotation = u.data.rotation;
                        default:
                            return;
                        case t.MixBlend.first:
                            c = u.rotation, f = u.data.rotation
                    } else if (c = i == t.MixBlend.setup ? u.data.rotation : u.rotation, a >= d[d.length - t.RotateTimeline.ENTRIES]) f = u.data.rotation + d[d.length + t.RotateTimeline.PREV_ROTATION];
                    else {
                        let e = t.Animation.binarySearch(d, a, t.RotateTimeline.ENTRIES),
                            s = d[e + t.RotateTimeline.PREV_ROTATION],
                            n = d[e],
                            i = h.getCurvePercent((e >> 1) - 1, 1 - (a - n) / (d[e + t.RotateTimeline.PREV_TIME] - n));
                        f = d[e + t.RotateTimeline.ROTATION] - s, f -= 360 * (16384 - (16384.499999999996 - f / 360 | 0)), f = s + f * i + u.data.rotation, f -= 360 * (16384 - (16384.499999999996 - f / 360 | 0))
                    }
                let m = 0,
                    g = f - c;
                if (g -= 360 * (16384 - (16384.499999999996 - g / 360 | 0)), 0 == g) m = r[l];
                else {
                    let e = 0,
                        s = 0;
                    o ? (e = 0, s = g) : (e = r[l], s = r[l + 1]);
                    let a = g > 0,
                        n = e >= 0;
                    t.MathUtils.signum(s) != t.MathUtils.signum(g) && Math.abs(s) <= 90 && (Math.abs(e) > 180 && (e += 360 * t.MathUtils.signum(e)), n = a), m = g + e - e % 360, n != a && (m += 360 * t.MathUtils.signum(e)), r[l] = m
                }
                r[l + 1] = g, c += m * n, u.rotation = c - 360 * (16384 - (16384.499999999996 - c / 360 | 0))
            }
            queueEvents(t, e) {
                let s = t.animationStart,
                    a = t.animationEnd,
                    n = a - s,
                    i = t.trackLast % n,
                    r = this.events,
                    l = 0,
                    o = r.length;
                for (; l < o; l++) {
                    let e = r[l];
                    if (e.time < i) break;
                    e.time > a || this.queue.event(t, e)
                }
                let h = !1;
                for (h = t.loop ? 0 == n || i > t.trackTime % n : e >= a && t.animationLast < a, h && this.queue.complete(t); l < o; l++) {
                    let e = r[l];
                    e.time < s || this.queue.event(t, r[l])
                }
            }
            clearTracks() {
                let t = this.queue.drainDisabled;
                this.queue.drainDisabled = !0;
                for (let t = 0, e = this.tracks.length; t < e; t++) this.clearTrack(t);
                this.tracks.length = 0, this.queue.drainDisabled = t, this.queue.drain()
            }
            clearTrack(t) {
                if (t >= this.tracks.length) return;
                let e = this.tracks[t];
                if (null == e) return;
                this.queue.end(e), this.disposeNext(e);
                let s = e;
                for (;;) {
                    let t = s.mixingFrom;
                    if (null == t) break;
                    this.queue.end(t), s.mixingFrom = null, s.mixingTo = null, s = t
                }
                this.tracks[e.trackIndex] = null, this.queue.drain()
            }
            setCurrent(t, e, s) {
                let a = this.expandToIndex(t);
                this.tracks[t] = e, null != a && (s && this.queue.interrupt(a), e.mixingFrom = a, a.mixingTo = e, e.mixTime = 0, null != a.mixingFrom && a.mixDuration > 0 && (e.interruptAlpha *= Math.min(1, a.mixTime / a.mixDuration)), a.timelinesRotation.length = 0), this.queue.start(e)
            }
            setAnimation(t, e, s) {
                let a = this.data.skeletonData.findAnimation(e);
                if (null == a) throw new Error("Animation not found: " + e);
                return this.setAnimationWith(t, a, s)
            }
            setAnimationWith(t, e, s) {
                if (null == e) throw new Error("animation cannot be null.");
                let a = !0,
                    n = this.expandToIndex(t);
                null != n && (-1 == n.nextTrackLast ? (this.tracks[t] = n.mixingFrom, this.queue.interrupt(n), this.queue.end(n), this.disposeNext(n), n = n.mixingFrom, a = !1) : this.disposeNext(n));
                let i = this.trackEntry(t, e, s, n);
                return this.setCurrent(t, i, a), this.queue.drain(), i
            }
            addAnimation(t, e, s, a) {
                let n = this.data.skeletonData.findAnimation(e);
                if (null == n) throw new Error("Animation not found: " + e);
                return this.addAnimationWith(t, n, s, a)
            }
            addAnimationWith(t, e, s, a) {
                if (null == e) throw new Error("animation cannot be null.");
                let n = this.expandToIndex(t);
                if (null != n)
                    for (; null != n.next;) n = n.next;
                let i = this.trackEntry(t, e, s, n);
                if (null == n) this.setCurrent(t, i, !0), this.queue.drain();
                else if (n.next = i, a <= 0) {
                    let t = n.animationEnd - n.animationStart;
                    0 != t ? (n.loop ? a += t * (1 + (n.trackTime / t | 0)) : a += Math.max(t, n.trackTime), a -= this.data.getMix(n.animation, e)) : a = n.trackTime
                }
                return i.delay = a, i
            }
            setEmptyAnimation(t, s) {
                let a = this.setAnimationWith(t, e.emptyAnimation, !1);
                return a.mixDuration = s, a.trackEnd = s, a
            }
            addEmptyAnimation(t, s, a) {
                a <= 0 && (a -= s);
                let n = this.addAnimationWith(t, e.emptyAnimation, !1, a);
                return n.mixDuration = s, n.trackEnd = s, n
            }
            setEmptyAnimations(t) {
                let e = this.queue.drainDisabled;
                this.queue.drainDisabled = !0;
                for (let e = 0, s = this.tracks.length; e < s; e++) {
                    let s = this.tracks[e];
                    null != s && this.setEmptyAnimation(s.trackIndex, t)
                }
                this.queue.drainDisabled = e, this.queue.drain()
            }
            expandToIndex(e) {
                return e < this.tracks.length ? this.tracks[e] : (t.Utils.ensureArrayCapacity(this.tracks, e + 1, null), this.tracks.length = e + 1, null)
            }
            trackEntry(e, s, a, n) {
                let i = this.trackEntryPool.obtain();
                return i.trackIndex = e, i.animation = s, i.loop = a, i.holdPrevious = !1, i.eventThreshold = 0, i.attachmentThreshold = 0, i.drawOrderThreshold = 0, i.animationStart = 0, i.animationEnd = s.duration, i.animationLast = -1, i.nextAnimationLast = -1, i.delay = 0, i.trackTime = 0, i.trackLast = -1, i.nextTrackLast = -1, i.trackEnd = Number.MAX_VALUE, i.timeScale = 1, i.alpha = 1, i.interruptAlpha = 1, i.mixTime = 0, i.mixDuration = null == n ? 0 : this.data.getMix(n.animation, s), i.mixBlend = t.MixBlend.replace, i
            }
            disposeNext(t) {
                let e = t.next;
                for (; null != e;) this.queue.dispose(e), e = e.next;
                t.next = null
            }
            _animationsChanged() {
                this.animationsChanged = !1, this.propertyIDs.clear();
                for (let e = 0, s = this.tracks.length; e < s; e++) {
                    let s = this.tracks[e];
                    if (null != s) {
                        for (; null != s.mixingFrom;) s = s.mixingFrom;
                        do {
                            null != s.mixingFrom && s.mixBlend == t.MixBlend.add || this.computeHold(s), s = s.mixingTo
                        } while (null != s)
                    }
                }
            }
            computeHold(s) {
                let a = s.mixingTo,
                    n = s.animation.timelines,
                    i = s.animation.timelines.length,
                    r = t.Utils.setArraySize(s.timelineMode, i);
                s.timelineHoldMix.length = 0;
                let l = t.Utils.setArraySize(s.timelineHoldMix, i),
                    o = this.propertyIDs;
                if (null != a && a.holdPrevious)
                    for (let t = 0; t < i; t++) r[t] = o.add(n[t].getPropertyId()) ? e.HOLD_FIRST : e.HOLD_SUBSEQUENT;
                else t: for (let h = 0; h < i; h++) {
                    let i = n[h],
                        d = i.getPropertyId();
                    if (o.add(d))
                        if (null == a || i instanceof t.AttachmentTimeline || i instanceof t.DrawOrderTimeline || i instanceof t.EventTimeline || !a.animation.hasTimeline(d)) r[h] = e.FIRST;
                        else {
                            for (let t = a.mixingTo; null != t; t = t.mixingTo)
                                if (!t.animation.hasTimeline(d)) {
                                    if (s.mixDuration > 0) {
                                        r[h] = e.HOLD_MIX, l[h] = t;
                                        continue t
                                    }
                                    break
                                }
                            r[h] = e.HOLD_FIRST
                        } else r[h] = e.SUBSEQUENT
                }
            }
            getCurrent(t) {
                return t >= this.tracks.length ? null : this.tracks[t]
            }
            addListener(t) {
                if (null == t) throw new Error("listener cannot be null.");
                this.listeners.push(t)
            }
            removeListener(t) {
                let e = this.listeners.indexOf(t);
                e >= 0 && this.listeners.splice(e, 1)
            }
            clearListeners() {
                this.listeners.length = 0
            }
            clearListenerNotifications() {
                this.queue.clear()
            }
        }
        e.emptyAnimation = new t.Animation("<empty>", [], 0), e.SUBSEQUENT = 0, e.FIRST = 1, e.HOLD_SUBSEQUENT = 2, e.HOLD_FIRST = 3, e.HOLD_MIX = 4, e.SETUP = 1, e.CURRENT = 2, t.AnimationState = e;
        class s {
            constructor() {
                this.mixBlend = t.MixBlend.replace, this.timelineMode = new Array, this.timelineHoldMix = new Array, this.timelinesRotation = new Array
            }
            reset() {
                this.next = null, this.mixingFrom = null, this.mixingTo = null, this.animation = null, this.listener = null, this.timelineMode.length = 0, this.timelineHoldMix.length = 0, this.timelinesRotation.length = 0
            }
            getAnimationTime() {
                if (this.loop) {
                    let t = this.animationEnd - this.animationStart;
                    return 0 == t ? this.animationStart : this.trackTime % t + this.animationStart
                }
                return Math.min(this.trackTime + this.animationStart, this.animationEnd)
            }
            setAnimationLast(t) {
                this.animationLast = t, this.nextAnimationLast = t
            }
            isComplete() {
                return this.trackTime >= this.animationEnd - this.animationStart
            }
            resetRotationDirections() {
                this.timelinesRotation.length = 0
            }
        }
        t.TrackEntry = s;
        class a {
            constructor(t) {
                this.objects = [], this.drainDisabled = !1, this.animState = t
            }
            start(t) {
                this.objects.push(n.start), this.objects.push(t), this.animState.animationsChanged = !0
            }
            interrupt(t) {
                this.objects.push(n.interrupt), this.objects.push(t)
            }
            end(t) {
                this.objects.push(n.end), this.objects.push(t), this.animState.animationsChanged = !0
            }
            dispose(t) {
                this.objects.push(n.dispose), this.objects.push(t)
            }
            complete(t) {
                this.objects.push(n.complete), this.objects.push(t)
            }
            event(t, e) {
                this.objects.push(n.event), this.objects.push(t), this.objects.push(e)
            }
            drain() {
                if (this.drainDisabled) return;
                this.drainDisabled = !0;
                let t = this.objects,
                    e = this.animState.listeners;
                for (let s = 0; s < t.length; s += 2) {
                    let a = t[s],
                        i = t[s + 1];
                    switch (a) {
                        case n.start:
                            null != i.listener && i.listener.start && i.listener.start(i);
                            for (let t = 0; t < e.length; t++) e[t].start && e[t].start(i);
                            break;
                        case n.interrupt:
                            null != i.listener && i.listener.interrupt && i.listener.interrupt(i);
                            for (let t = 0; t < e.length; t++) e[t].interrupt && e[t].interrupt(i);
                            break;
                        case n.end:
                            null != i.listener && i.listener.end && i.listener.end(i);
                            for (let t = 0; t < e.length; t++) e[t].end && e[t].end(i);
                        case n.dispose:
                            null != i.listener && i.listener.dispose && i.listener.dispose(i);
                            for (let t = 0; t < e.length; t++) e[t].dispose && e[t].dispose(i);
                            this.animState.trackEntryPool.free(i);
                            break;
                        case n.complete:
                            null != i.listener && i.listener.complete && i.listener.complete(i);
                            for (let t = 0; t < e.length; t++) e[t].complete && e[t].complete(i);
                            break;
                        case n.event:
                            let r = t[2 + s++];
                            null != i.listener && i.listener.event && i.listener.event(i, r);
                            for (let t = 0; t < e.length; t++) e[t].event && e[t].event(i, r)
                    }
                }
                this.clear(), this.drainDisabled = !1
            }
            clear() {
                this.objects.length = 0
            }
        }
        let n;
        t.EventQueue = a,
            function(t) {
                t[t.start = 0] = "start", t[t.interrupt = 1] = "interrupt", t[t.end = 2] = "end", t[t.dispose = 3] = "dispose", t[t.complete = 4] = "complete", t[t.event = 5] = "event"
            }(n = t.EventType || (t.EventType = {}));
        class i {
            start(t) {}
            interrupt(t) {}
            end(t) {}
            dispose(t) {}
            complete(t) {}
            event(t, e) {}
        }
        t.AnimationStateAdapter = i
    }(spine || (spine = {})),
    function(t) {
        class e {
            constructor(t) {
                if (this.animationToMixTime = {}, this.defaultMix = 0, null == t) throw new Error("skeletonData cannot be null.");
                this.skeletonData = t
            }
            setMix(t, e, s) {
                let a = this.skeletonData.findAnimation(t);
                if (null == a) throw new Error("Animation not found: " + t);
                let n = this.skeletonData.findAnimation(e);
                if (null == n) throw new Error("Animation not found: " + e);
                this.setMixWith(a, n, s)
            }
            setMixWith(t, e, s) {
                if (null == t) throw new Error("from cannot be null.");
                if (null == e) throw new Error("to cannot be null.");
                let a = t.name + "." + e.name;
                this.animationToMixTime[a] = s
            }
            getMix(t, e) {
                let s = t.name + "." + e.name,
                    a = this.animationToMixTime[s];
                return void 0 === a ? this.defaultMix : a
            }
        }
        t.AnimationStateData = e
    }(spine || (spine = {})),
    function(t) {
        class e {
            constructor(t, e = "") {
                this.assets = {}, this.errors = {}, this.toLoad = 0, this.loaded = 0, this.rawDataUris = {}, this.textureLoader = t, this.pathPrefix = e
            }
            downloadText(t, e, s) {
                let a = window.Laya.Laya ? window.Laya.Laya : Laya;
                a.loader.load([{
                    type: a.Loader.TEXT,
                    url: t
                }], a.Handler.create(this, n => {
                    n ? e(a.loader.getRes(t)) : s("download text error: ", t)
                }))
            }
            downloadBinary(t, e, s) {
                let a = window.Laya.Laya ? window.Laya.Laya : Laya;
                a.loader.load([{
                    type: a.Loader.BUFFER,
                    url: t
                }], a.Handler.create(this, n => {
                    n ? e(new Uint8Array(a.loader.getRes(t))) : s("download binary error: ", t)
                }))
            }
            setRawDataURI(t, e) {
                this.rawDataUris[this.pathPrefix + t] = e
            }
            loadBinary(t, e = null, s = null) {
                t = this.pathPrefix + t, this.toLoad++, this.downloadBinary(t, s => {
                    this.assets[t] = s, e && e(t, s), this.toLoad--, this.loaded++
                }, (e, a) => {
                    this.errors[t] = `Couldn't load binary ${t}: status ${e}, ${a}`, s && s(t, `Couldn't load binary ${t}: status ${e}, ${a}`), this.toLoad--, this.loaded++
                })
            }
            loadText(t, e = null, s = null) {
                t = this.pathPrefix + t, this.toLoad++, this.downloadText(t, s => {
                    this.assets[t] = s, e && e(t, s), this.toLoad--, this.loaded++
                }, (e, a) => {
                    this.errors[t] = `Couldn't load text ${t}: status ${e}, ${a}`, s && s(t, `Couldn't load text ${t}: status ${e}, ${a}`), this.toLoad--, this.loaded++
                })
            }
            loadTexture(t, e = null, s = null) {
                t = this.pathPrefix + t;
                this.toLoad++;
                let a = window.Laya.Laya ? window.Laya.Laya : Laya;
                a.loader.load([{
                    type: a.Loader.IMAGE,
                    url: t
                }], a.Handler.create(this, n => {
                    if (n) {
                        let s = this.textureLoader(a.loader.getRes(t));
                        this.assets[t] = s, this.toLoad--, this.loaded++, e && e(t, s)
                    } else this.errors[t] = `Couldn't load image ${t}`, this.toLoad--, this.loaded++, s && s(t, `Couldn't load image ${t}`)
                }))
            }
            loadTextureAtlas(e, s = null, a = null) {
                let n = e.lastIndexOf("/") >= 0 ? e.substring(0, e.lastIndexOf("/")) : "";
                e = this.pathPrefix + e, this.toLoad++, this.downloadText(e, i => {
                    let r = {
                            count: 0
                        },
                        l = new Array;
                    try {
                        new t.TextureAtlas(i, e => {
                            l.push("" == n ? e : n + "/" + e);
                            let s = document.createElement("img");
                            return new t.FakeTexture(s)
                        })
                    } catch (t) {
                        let s = t;
                        return this.errors[e] = `Couldn't load texture atlas ${e}: ${s.message}`, a && a(e, `Couldn't load texture atlas ${e}: ${s.message}`), this.toLoad--, void this.loaded++
                    }
                    for (let o of l) {
                        let h = !1;
                        this.loadTexture(o, (o, d) => {
                            if (r.count++, r.count == l.length)
                                if (h) this.errors[e] = `Couldn't load texture atlas page ${o}} of atlas ${e}`, a && a(e, `Couldn't load texture atlas page ${o} of atlas ${e}`), this.toLoad--, this.loaded++;
                                else try {
                                    let r = new t.TextureAtlas(i, t => this.get("" == n ? t : n + "/" + t));
                                    this.assets[e] = r, s && s(e, r), this.toLoad--, this.loaded++
                                } catch (t) {
                                    let s = t;
                                    this.errors[e] = `Couldn't load texture atlas ${e}: ${s.message}`, a && a(e, `Couldn't load texture atlas ${e}: ${s.message}`), this.toLoad--, this.loaded++
                                }
                        }, (t, s) => {
                            h = !0, r.count++, r.count == l.length && (this.errors[e] = `Couldn't load texture atlas page ${t}} of atlas ${e}`, a && a(e, `Couldn't load texture atlas page ${t} of atlas ${e}`), this.toLoad--, this.loaded++)
                        })
                    }
                }, (t, s) => {
                    this.errors[e] = `Couldn't load texture atlas ${e}: status ${t}, ${s}`, a && a(e, `Couldn't load texture atlas ${e}: status ${t}, ${s}`), this.toLoad--, this.loaded++
                })
            }
            get(t) {
                return t = this.pathPrefix + t, this.assets[t]
            }
            remove(t) {
                t = this.pathPrefix + t;
                let e = this.assets[t];
                e.dispose && e.dispose(), this.assets[t] = null
            }
            removeAll() {
                for (let t in this.assets) {
                    let e = this.assets[t];
                    e.dispose && e.dispose()
                }
                this.assets = {}
            }
            isLoadingComplete() {
                return 0 == this.toLoad
            }
            getToLoad() {
                return this.toLoad
            }
            getLoaded() {
                return this.loaded
            }
            dispose() {
                this.removeAll()
            }
            hasErrors() {
                return Object.keys(this.errors).length > 0
            }
            getErrors() {
                return this.errors
            }
        }
        t.AssetManager = e
    }(spine || (spine = {})),
    function(t) {
        class e {
            constructor(t) {
                this.atlas = t
            }
            newRegionAttachment(e, s, a) {
                let n = this.atlas.findRegion(a);
                if (null == n) throw new Error("Region not found in atlas: " + a + " (region attachment: " + s + ")");
                n.renderObject = n;
                let i = new t.RegionAttachment(s);
                return i.setRegion(n), i
            }
            newMeshAttachment(e, s, a) {
                let n = this.atlas.findRegion(a);
                if (null == n) throw new Error("Region not found in atlas: " + a + " (mesh attachment: " + s + ")");
                n.renderObject = n;
                let i = new t.MeshAttachment(s);
                return i.region = n, i
            }
            newBoundingBoxAttachment(e, s) {
                return new t.BoundingBoxAttachment(s)
            }
            newPathAttachment(e, s) {
                return new t.PathAttachment(s)
            }
            newPointAttachment(e, s) {
                return new t.PointAttachment(s)
            }
            newClippingAttachment(e, s) {
                return new t.ClippingAttachment(s)
            }
        }
        t.AtlasAttachmentLoader = e
    }(spine || (spine = {})),
    function(t) {
        let e;
        (function(t) {
            t[t.Normal = 0] = "Normal", t[t.Additive = 1] = "Additive", t[t.Multiply = 2] = "Multiply", t[t.Screen = 3] = "Screen"
        })(e = t.BlendMode || (t.BlendMode = {}))
    }(spine || (spine = {})),
    function(t) {
        class e {
            constructor(t, e, s) {
                if (this.children = new Array, this.x = 0, this.y = 0, this.rotation = 0, this.scaleX = 0, this.scaleY = 0, this.shearX = 0, this.shearY = 0, this.ax = 0, this.ay = 0, this.arotation = 0, this.ascaleX = 0, this.ascaleY = 0, this.ashearX = 0, this.ashearY = 0, this.appliedValid = !1, this.a = 0, this.b = 0, this.c = 0, this.d = 0, this.worldY = 0, this.worldX = 0, this.sorted = !1, this.active = !1, null == t) throw new Error("data cannot be null.");
                if (null == e) throw new Error("skeleton cannot be null.");
                this.data = t, this.skeleton = e, this.parent = s, this.setToSetupPose()
            }
            isActive() {
                return this.active
            }
            update() {
                this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY)
            }
            updateWorldTransform() {
                this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY)
            }
            updateWorldTransformWith(e, s, a, n, i, r, l) {
                this.ax = e, this.ay = s, this.arotation = a, this.ascaleX = n, this.ascaleY = i, this.ashearX = r, this.ashearY = l, this.appliedValid = !0;
                let o = this.parent;
                if (null == o) {
                    let o = this.skeleton,
                        h = a + 90 + l,
                        d = o.scaleX,
                        u = o.scaleY;
                    return this.a = t.MathUtils.cosDeg(a + r) * n * d, this.b = t.MathUtils.cosDeg(h) * i * d, this.c = t.MathUtils.sinDeg(a + r) * n * u, this.d = t.MathUtils.sinDeg(h) * i * u, this.worldX = e * d + o.x, void(this.worldY = s * u + o.y)
                }
                let h = o.a,
                    d = o.b,
                    u = o.c,
                    c = o.d;
                switch (this.worldX = h * e + d * s + o.worldX, this.worldY = u * e + c * s + o.worldY, this.data.transformMode) {
                    case t.TransformMode.Normal:
                        {
                            let e = a + 90 + l,
                                s = t.MathUtils.cosDeg(a + r) * n,
                                o = t.MathUtils.cosDeg(e) * i,
                                f = t.MathUtils.sinDeg(a + r) * n,
                                m = t.MathUtils.sinDeg(e) * i;
                            return this.a = h * s + d * f, this.b = h * o + d * m, this.c = u * s + c * f, void(this.d = u * o + c * m)
                        }
                    case t.TransformMode.OnlyTranslation:
                        {
                            let e = a + 90 + l;
                            this.a = t.MathUtils.cosDeg(a + r) * n, this.b = t.MathUtils.cosDeg(e) * i, this.c = t.MathUtils.sinDeg(a + r) * n, this.d = t.MathUtils.sinDeg(e) * i;
                            break
                        }
                    case t.TransformMode.NoRotationOrReflection:
                        {
                            let e = h * h + u * u,
                                s = 0;
                            e > 1e-4 ? (e = Math.abs(h * c - d * u) / e, h /= this.skeleton.scaleX, u /= this.skeleton.scaleY, d = u * e, c = h * e, s = Math.atan2(u, h) * t.MathUtils.radDeg) : (h = 0, u = 0, s = 90 - Math.atan2(c, d) * t.MathUtils.radDeg);
                            let o = a + r - s,
                                f = a + l - s + 90,
                                m = t.MathUtils.cosDeg(o) * n,
                                g = t.MathUtils.cosDeg(f) * i,
                                p = t.MathUtils.sinDeg(o) * n,
                                w = t.MathUtils.sinDeg(f) * i;
                            this.a = h * m - d * p, this.b = h * g - d * w, this.c = u * m + c * p, this.d = u * g + c * w;
                            break
                        }
                    case t.TransformMode.NoScale:
                    case t.TransformMode.NoScaleOrReflection:
                        {
                            let e = t.MathUtils.cosDeg(a),
                                s = t.MathUtils.sinDeg(a),
                                o = (h * e + d * s) / this.skeleton.scaleX,
                                f = (u * e + c * s) / this.skeleton.scaleY,
                                m = Math.sqrt(o * o + f * f);
                            m > 1e-5 && (m = 1 / m), o *= m, f *= m, m = Math.sqrt(o * o + f * f), this.data.transformMode == t.TransformMode.NoScale && h * c - d * u < 0 != (this.skeleton.scaleX < 0 != this.skeleton.scaleY < 0) && (m = -m);
                            let g = Math.PI / 2 + Math.atan2(f, o),
                                p = Math.cos(g) * m,
                                w = Math.sin(g) * m,
                                x = t.MathUtils.cosDeg(r) * n,
                                M = t.MathUtils.cosDeg(90 + l) * i,
                                E = t.MathUtils.sinDeg(r) * n,
                                T = t.MathUtils.sinDeg(90 + l) * i;
                            this.a = o * x + p * E, this.b = o * M + p * T, this.c = f * x + w * E, this.d = f * M + w * T;
                            break
                        }
                }
                this.a *= this.skeleton.scaleX, this.b *= this.skeleton.scaleX, this.c *= this.skeleton.scaleY, this.d *= this.skeleton.scaleY
            }
            setToSetupPose() {
                let t = this.data;
                this.x = t.x, this.y = t.y, this.rotation = t.rotation, this.scaleX = t.scaleX, this.scaleY = t.scaleY, this.shearX = t.shearX, this.shearY = t.shearY
            }
            getWorldRotationX() {
                return Math.atan2(this.c, this.a) * t.MathUtils.radDeg
            }
            getWorldRotationY() {
                return Math.atan2(this.d, this.b) * t.MathUtils.radDeg
            }
            getWorldScaleX() {
                return Math.sqrt(this.a * this.a + this.c * this.c)
            }
            getWorldScaleY() {
                return Math.sqrt(this.b * this.b + this.d * this.d)
            }
            updateAppliedTransform() {
                this.appliedValid = !0;
                let e = this.parent;
                if (null == e) return this.ax = this.worldX, this.ay = this.worldY, this.arotation = Math.atan2(this.c, this.a) * t.MathUtils.radDeg, this.ascaleX = Math.sqrt(this.a * this.a + this.c * this.c), this.ascaleY = Math.sqrt(this.b * this.b + this.d * this.d), this.ashearX = 0, void(this.ashearY = Math.atan2(this.a * this.b + this.c * this.d, this.a * this.d - this.b * this.c) * t.MathUtils.radDeg);
                let s = e.a,
                    a = e.b,
                    n = e.c,
                    i = e.d,
                    r = 1 / (s * i - a * n),
                    l = this.worldX - e.worldX,
                    o = this.worldY - e.worldY;
                this.ax = l * i * r - o * a * r, this.ay = o * s * r - l * n * r;
                let h = r * i,
                    d = r * s,
                    u = r * a,
                    c = r * n,
                    f = h * this.a - u * this.c,
                    m = h * this.b - u * this.d,
                    g = d * this.c - c * this.a,
                    p = d * this.d - c * this.b;
                if (this.ashearX = 0, this.ascaleX = Math.sqrt(f * f + g * g), this.ascaleX > 1e-4) {
                    let e = f * p - m * g;
                    this.ascaleY = e / this.ascaleX, this.ashearY = Math.atan2(f * m + g * p, e) * t.MathUtils.radDeg, this.arotation = Math.atan2(g, f) * t.MathUtils.radDeg
                } else this.ascaleX = 0, this.ascaleY = Math.sqrt(m * m + p * p), this.ashearY = 0, this.arotation = 90 - Math.atan2(p, m) * t.MathUtils.radDeg
            }
            worldToLocal(t) {
                let e = this.a,
                    s = this.b,
                    a = this.c,
                    n = this.d,
                    i = 1 / (e * n - s * a),
                    r = t.x - this.worldX,
                    l = t.y - this.worldY;
                return t.x = r * n * i - l * s * i, t.y = l * e * i - r * a * i, t
            }
            localToWorld(t) {
                let e = t.x,
                    s = t.y;
                return t.x = e * this.a + s * this.b + this.worldX, t.y = e * this.c + s * this.d + this.worldY, t
            }
            worldToLocalRotation(e) {
                let s = t.MathUtils.sinDeg(e),
                    a = t.MathUtils.cosDeg(e);
                return Math.atan2(this.a * s - this.c * a, this.d * a - this.b * s) * t.MathUtils.radDeg + this.rotation - this.shearX
            }
            localToWorldRotation(e) {
                e -= this.rotation - this.shearX;
                let s = t.MathUtils.sinDeg(e),
                    a = t.MathUtils.cosDeg(e);
                return Math.atan2(a * this.c + s * this.d, a * this.a + s * this.b) * t.MathUtils.radDeg
            }
            rotateWorld(e) {
                let s = this.a,
                    a = this.b,
                    n = this.c,
                    i = this.d,
                    r = t.MathUtils.cosDeg(e),
                    l = t.MathUtils.sinDeg(e);
                this.a = r * s - l * n, this.b = r * a - l * i, this.c = l * s + r * n, this.d = l * a + r * i, this.appliedValid = !1
            }
        }
        t.Bone = e
    }(spine || (spine = {})),
    function(t) {
        class e {
            constructor(e, a, n) {
                if (this.x = 0, this.y = 0, this.rotation = 0, this.scaleX = 1, this.scaleY = 1, this.shearX = 0, this.shearY = 0, this.transformMode = s.Normal, this.skinRequired = !1, this.color = new t.Color, e < 0) throw new Error("index must be >= 0.");
                if (null == a) throw new Error("name cannot be null.");
                this.index = e, this.name = a, this.parent = n
            }
        }
        let s;
        t.BoneData = e,
            function(t) {
                t[t.Normal = 0] = "Normal", t[t.OnlyTranslation = 1] = "OnlyTranslation", t[t.NoRotationOrReflection = 2] = "NoRotationOrReflection", t[t.NoScale = 3] = "NoScale", t[t.NoScaleOrReflection = 4] = "NoScaleOrReflection"
            }(s = t.TransformMode || (t.TransformMode = {}))
    }(spine || (spine = {})),
    function(t) {
        class e {
            constructor(t, e, s) {
                this.name = t, this.order = e, this.skinRequired = s
            }
        }
        t.ConstraintData = e
    }(spine || (spine = {})),
    function(t) {
        class e {
            constructor(t, e) {
                if (null == e) throw new Error("data cannot be null.");
                this.time = t, this.data = e
            }
        }
        t.Event = e
    }(spine || (spine = {})),
    function(t) {
        class e {
            constructor(t) {
                this.name = t
            }
        }
        t.EventData = e
    }(spine || (spine = {})),
    function(t) {
        class e {
            constructor(t, e) {
                if (this.bendDirection = 0, this.compress = !1, this.stretch = !1, this.mix = 1, this.softness = 0, this.active = !1, null == t) throw new Error("data cannot be null.");
                if (null == e) throw new Error("skeleton cannot be null.");
                this.data = t, this.mix = t.mix, this.softness = t.softness, this.bendDirection = t.bendDirection, this.compress = t.compress, this.stretch = t.stretch, this.bones = new Array;
                for (let s = 0; s < t.bones.length; s++) this.bones.push(e.findBone(t.bones[s].name));
                this.target = e.findBone(t.target.name)
            }
            isActive() {
                return this.active
            }
            apply() {
                this.update()
            }
            update() {
                let t = this.target,
                    e = this.bones;
                switch (e.length) {
                    case 1:
                        this.apply1(e[0], t.worldX, t.worldY, this.compress, this.stretch, this.data.uniform, this.mix);
                        break;
                    case 2:
                        this.apply2(e[0], e[1], t.worldX, t.worldY, this.bendDirection, this.stretch, this.softness, this.mix)
                }
            }
            apply1(e, s, a, n, i, r, l) {
                e.appliedValid || e.updateAppliedTransform();
                let o = e.parent,
                    h = o.a,
                    d = o.b,
                    u = o.c,
                    c = o.d,
                    f = -e.ashearX - e.arotation,
                    m = 0,
                    g = 0;
                switch (e.data.transformMode) {
                    case t.TransformMode.OnlyTranslation:
                        m = s - e.worldX, g = a - e.worldY;
                        break;
                    case t.TransformMode.NoRotationOrReflection:
                        let n = Math.abs(h * c - d * u) / (h * h + u * u),
                            i = h / e.skeleton.scaleX,
                            r = u / e.skeleton.scaleY;
                        d = -r * n * e.skeleton.scaleX, c = i * n * e.skeleton.scaleY, f += Math.atan2(r, i) * t.MathUtils.radDeg;
                    default:
                        let l = s - o.worldX,
                            p = a - o.worldY,
                            w = h * c - d * u;
                        m = (l * c - p * d) / w - e.ax, g = (p * h - l * u) / w - e.ay
                }
                f += Math.atan2(g, m) * t.MathUtils.radDeg, e.ascaleX < 0 && (f += 180), f > 180 ? f -= 360 : f < -180 && (f += 360);
                let p = e.ascaleX,
                    w = e.ascaleY;
                if (n || i) {
                    switch (e.data.transformMode) {
                        case t.TransformMode.NoScale:
                        case t.TransformMode.NoScaleOrReflection:
                            m = s - e.worldX, g = a - e.worldY
                    }
                    let o = e.data.length * p,
                        h = Math.sqrt(m * m + g * g);
                    if (n && h < o || i && h > o && o > 1e-4) {
                        let t = (h / o - 1) * l + 1;
                        p *= t, r && (w *= t)
                    }
                }
                e.updateWorldTransformWith(e.ax, e.ay, e.arotation + f * l, p, w, e.ashearX, e.ashearY)
            }
            apply2(e, s, a, n, i, r, l, o) {
                if (0 == o) return void s.updateWorldTransform();
                e.appliedValid || e.updateAppliedTransform(), s.appliedValid || s.updateAppliedTransform();
                let h = e.ax,
                    d = e.ay,
                    u = e.ascaleX,
                    c = u,
                    f = e.ascaleY,
                    m = s.ascaleX,
                    g = 0,
                    p = 0,
                    w = 0;
                u < 0 ? (u = -u, g = 180, w = -1) : (g = 0, w = 1), f < 0 && (f = -f, w = -w), m < 0 ? (m = -m, p = 180) : p = 0;
                let x = s.ax,
                    M = 0,
                    E = 0,
                    T = 0,
                    A = e.a,
                    b = e.b,
                    S = e.c,
                    y = e.d,
                    I = Math.abs(u - f) <= 1e-4;
                I ? (M = s.ay, E = A * x + b * M + e.worldX, T = S * x + y * M + e.worldY) : (M = 0, E = A * x + e.worldX, T = S * x + e.worldY);
                let R = e.parent;
                A = R.a, b = R.b, S = R.c, y = R.d;
                let C, P, V = 1 / (A * y - b * S),
                    k = E - R.worldX,
                    v = T - R.worldY,
                    F = (k * y - v * b) * V - h,
                    N = (v * A - k * S) * V - d,
                    U = Math.sqrt(F * F + N * N),
                    L = s.data.length * m;
                if (U < 1e-4) return this.apply1(e, a, n, !1, r, !1, o), void s.updateWorldTransformWith(x, M, 0, s.ascaleX, s.ascaleY, s.ashearX, s.ashearY);
                k = a - R.worldX, v = n - R.worldY;
                let Y = (k * y - v * b) * V - h,
                    X = (v * A - k * S) * V - d,
                    B = Y * Y + X * X;
                if (0 != l) {
                    l *= u * (m + 1) / 2;
                    let t = Math.sqrt(B),
                        e = t - U - L * u + l;
                    if (e > 0) {
                        let s = Math.min(1, e / (2 * l)) - 1;
                        s = (e - l * (1 - s * s)) / t, Y -= s * Y, X -= s * X, B = Y * Y + X * X
                    }
                }
                t: if (I) {
                    L *= u;
                    let t = (B - U * U - L * L) / (2 * U * L);
                    t < -1 ? t = -1 : t > 1 && (t = 1, r && (c *= (Math.sqrt(B) / (U + L) - 1) * o + 1)), P = Math.acos(t) * i, A = U + L * t, b = L * Math.sin(P), C = Math.atan2(X * A - Y * b, Y * A + X * b)
                } else {
                    A = u * L, b = f * L;
                    let e = A * A,
                        s = b * b,
                        a = Math.atan2(X, Y);
                    S = s * U * U + e * B - e * s;
                    let n = -2 * s * U,
                        r = s - e;
                    if (y = n * n - 4 * r * S, y >= 0) {
                        let t = Math.sqrt(y);
                        n < 0 && (t = -t), t = -(n + t) / 2;
                        let e = t / r,
                            s = S / t,
                            l = Math.abs(e) < Math.abs(s) ? e : s;
                        if (l * l <= B) {
                            v = Math.sqrt(B - l * l) * i, C = a - Math.atan2(v, l), P = Math.atan2(v / f, (l - U) / u);
                            break t
                        }
                    }
                    let l = t.MathUtils.PI,
                        o = U - A,
                        h = o * o,
                        d = 0,
                        c = 0,
                        m = U + A,
                        g = m * m,
                        p = 0;
                    S = -A * U / (e - s), S >= -1 && S <= 1 && (S = Math.acos(S), k = A * Math.cos(S) + U, v = b * Math.sin(S), y = k * k + v * v, y < h && (l = S, h = y, o = k, d = v), y > g && (c = S, g = y, m = k, p = v)), B <= (h + g) / 2 ? (C = a - Math.atan2(d * i, o), P = l * i) : (C = a - Math.atan2(p * i, m), P = c * i)
                }
                let O = Math.atan2(M, x) * w,
                    _ = e.arotation;
                C = (C - O) * t.MathUtils.radDeg + g - _, C > 180 ? C -= 360 : C < -180 && (C += 360), e.updateWorldTransformWith(h, d, _ + C * o, c, e.ascaleY, 0, 0), _ = s.arotation, P = ((P + O) * t.MathUtils.radDeg - s.ashearX) * w + p - _, P > 180 ? P -= 360 : P < -180 && (P += 360), s.updateWorldTransformWith(x, M, _ + P * o, s.ascaleX, s.ascaleY, s.ashearX, s.ashearY)
            }
        }
        t.IkConstraint = e
    }(spine || (spine = {})),
    function(t) {
        class e extends t.ConstraintData {
            constructor(t) {
                super(t, 0, !1), this.bones = new Array, this.bendDirection = 1, this.compress = !1, this.stretch = !1, this.uniform = !1, this.mix = 1, this.softness = 0
            }
        }
        t.IkConstraintData = e
    }(spine || (spine = {})),
    function(t) {
        class e {
            constructor(t, e) {
                if (this.position = 0, this.spacing = 0, this.rotateMix = 0, this.translateMix = 0, this.spaces = new Array, this.positions = new Array, this.world = new Array, this.curves = new Array, this.lengths = new Array, this.segments = new Array, this.active = !1, null == t) throw new Error("data cannot be null.");
                if (null == e) throw new Error("skeleton cannot be null.");
                this.data = t, this.bones = new Array;
                for (let s = 0, a = t.bones.length; s < a; s++) this.bones.push(e.findBone(t.bones[s].name));
                this.target = e.findSlot(t.target.name), this.position = t.position, this.spacing = t.spacing, this.rotateMix = t.rotateMix, this.translateMix = t.translateMix
            }
            isActive() {
                return this.active
            }
            apply() {
                this.update()
            }
            update() {
                let s = this.target.getAttachment();
                if (!(s instanceof t.PathAttachment)) return;
                let a = this.rotateMix,
                    n = this.translateMix,
                    i = n > 0,
                    r = a > 0;
                if (!i && !r) return;
                let l = this.data,
                    o = l.spacingMode == t.SpacingMode.Percent,
                    h = l.rotateMode,
                    d = h == t.RotateMode.Tangent,
                    u = h == t.RotateMode.ChainScale,
                    c = this.bones.length,
                    f = d ? c : c + 1,
                    m = this.bones,
                    g = t.Utils.setArraySize(this.spaces, f),
                    p = null,
                    w = this.spacing;
                if (u || !o) {
                    u && (p = t.Utils.setArraySize(this.lengths, c));
                    let s = l.spacingMode == t.SpacingMode.Length;
                    for (let t = 0, a = f - 1; t < a;) {
                        let a = m[t],
                            n = a.data.length;
                        if (n < e.epsilon) u && (p[t] = 0), g[++t] = 0;
                        else if (o) {
                            if (u) {
                                let e = n * a.a,
                                    s = n * a.c,
                                    i = Math.sqrt(e * e + s * s);
                                p[t] = i
                            }
                            g[++t] = w
                        } else {
                            let e = n * a.a,
                                i = n * a.c,
                                r = Math.sqrt(e * e + i * i);
                            u && (p[t] = r), g[++t] = (s ? n + w : w) * r / n
                        }
                    }
                } else
                    for (let t = 1; t < f; t++) g[t] = w;
                let x = this.computeWorldPositions(s, f, d, l.positionMode == t.PositionMode.Percent, o),
                    M = x[0],
                    E = x[1],
                    T = l.offsetRotation,
                    A = !1;
                if (0 == T) A = h == t.RotateMode.Chain;
                else {
                    A = !1;
                    let e = this.target.bone;
                    T *= e.a * e.d - e.b * e.c > 0 ? t.MathUtils.degRad : -t.MathUtils.degRad
                }
                for (let e = 0, s = 3; e < c; e++, s += 3) {
                    let i = m[e];
                    i.worldX += (M - i.worldX) * n, i.worldY += (E - i.worldY) * n;
                    let l = x[s],
                        o = x[s + 1],
                        h = l - M,
                        c = o - E;
                    if (u) {
                        let t = p[e];
                        if (0 != t) {
                            let e = (Math.sqrt(h * h + c * c) / t - 1) * a + 1;
                            i.a *= e, i.c *= e
                        }
                    }
                    if (M = l, E = o, r) {
                        let n = i.a,
                            r = i.b,
                            l = i.c,
                            o = i.d,
                            u = 0,
                            f = 0,
                            m = 0;
                        if (u = d ? x[s - 1] : 0 == g[e + 1] ? x[s + 2] : Math.atan2(c, h), u -= Math.atan2(l, n), A) {
                            f = Math.cos(u), m = Math.sin(u);
                            let t = i.data.length;
                            M += (t * (f * n - m * l) - h) * a, E += (t * (m * n + f * l) - c) * a
                        } else u += T;
                        u > t.MathUtils.PI ? u -= t.MathUtils.PI2 : u < -t.MathUtils.PI && (u += t.MathUtils.PI2), u *= a, f = Math.cos(u), m = Math.sin(u), i.a = f * n - m * l, i.b = f * r - m * o, i.c = m * n + f * l, i.d = m * r + f * o
                    }
                    i.appliedValid = !1
                }
            }
            computeWorldPositions(s, a, n, i, r) {
                let l = this.target,
                    o = this.position,
                    h = this.spaces,
                    d = t.Utils.setArraySize(this.positions, 3 * a + 2),
                    u = null,
                    c = s.closed,
                    f = s.worldVerticesLength,
                    m = f / 6,
                    g = e.NONE;
                if (!s.constantSpeed) {
                    let p = s.lengths;
                    m -= c ? 1 : 2;
                    let w = p[m];
                    if (i && (o *= w), r)
                        for (let t = 1; t < a; t++) h[t] *= w;
                    u = t.Utils.setArraySize(this.world, 8);
                    for (let t = 0, i = 0, r = 0; t < a; t++, i += 3) {
                        let a = h[t];
                        o += a;
                        let x = o;
                        if (c) x %= w, x < 0 && (x += w), r = 0;
                        else {
                            if (x < 0) {
                                g != e.BEFORE && (g = e.BEFORE, s.computeWorldVertices(l, 2, 4, u, 0, 2)), this.addBeforePosition(x, u, 0, d, i);
                                continue
                            }
                            if (x > w) {
                                g != e.AFTER && (g = e.AFTER, s.computeWorldVertices(l, f - 6, 4, u, 0, 2)), this.addAfterPosition(x - w, u, 0, d, i);
                                continue
                            }
                        }
                        for (;; r++) {
                            let t = p[r];
                            if (!(x > t)) {
                                if (0 == r) x /= t;
                                else {
                                    let e = p[r - 1];
                                    x = (x - e) / (t - e)
                                }
                                break
                            }
                        }
                        r != g && (g = r, c && r == m ? (s.computeWorldVertices(l, f - 4, 4, u, 0, 2), s.computeWorldVertices(l, 0, 4, u, 4, 2)) : s.computeWorldVertices(l, 6 * r + 2, 8, u, 0, 2)), this.addCurvePosition(x, u[0], u[1], u[2], u[3], u[4], u[5], u[6], u[7], d, i, n || t > 0 && 0 == a)
                    }
                    return d
                }
                c ? (f += 2, u = t.Utils.setArraySize(this.world, f), s.computeWorldVertices(l, 2, f - 4, u, 0, 2), s.computeWorldVertices(l, 0, 2, u, f - 4, 2), u[f - 2] = u[0], u[f - 1] = u[1]) : (m--, f -= 4, u = t.Utils.setArraySize(this.world, f), s.computeWorldVertices(l, 2, f, u, 0, 2));
                let p = t.Utils.setArraySize(this.curves, m),
                    w = 0,
                    x = u[0],
                    M = u[1],
                    E = 0,
                    T = 0,
                    A = 0,
                    b = 0,
                    S = 0,
                    y = 0,
                    I = 0,
                    R = 0,
                    C = 0,
                    P = 0,
                    V = 0,
                    k = 0,
                    v = 0,
                    F = 0;
                for (let t = 0, e = 2; t < m; t++, e += 6) E = u[e], T = u[e + 1], A = u[e + 2], b = u[e + 3], S = u[e + 4], y = u[e + 5], I = .1875 * (x - 2 * E + A), R = .1875 * (M - 2 * T + b), C = .09375 * (3 * (E - A) - x + S), P = .09375 * (3 * (T - b) - M + y), V = 2 * I + C, k = 2 * R + P, v = .75 * (E - x) + I + .16666667 * C, F = .75 * (T - M) + R + .16666667 * P, w += Math.sqrt(v * v + F * F), v += V, F += k, V += C, k += P, w += Math.sqrt(v * v + F * F), v += V, F += k, w += Math.sqrt(v * v + F * F), v += V + C, F += k + P, w += Math.sqrt(v * v + F * F), p[t] = w, x = S, M = y;
                if (o *= i ? w : w / s.lengths[m - 1], r)
                    for (let t = 1; t < a; t++) h[t] *= w;
                let N = this.segments,
                    U = 0;
                for (let t = 0, e = 0, s = 0, i = 0; t < a; t++, e += 3) {
                    let a = h[t];
                    o += a;
                    let r = o;
                    if (c) r %= w, r < 0 && (r += w), s = 0;
                    else {
                        if (r < 0) {
                            this.addBeforePosition(r, u, 0, d, e);
                            continue
                        }
                        if (r > w) {
                            this.addAfterPosition(r - w, u, f - 4, d, e);
                            continue
                        }
                    }
                    for (;; s++) {
                        let t = p[s];
                        if (!(r > t)) {
                            if (0 == s) r /= t;
                            else {
                                let e = p[s - 1];
                                r = (r - e) / (t - e)
                            }
                            break
                        }
                    }
                    if (s != g) {
                        g = s;
                        let t = 6 * s;
                        for (x = u[t], M = u[t + 1], E = u[t + 2], T = u[t + 3], A = u[t + 4], b = u[t + 5], S = u[t + 6], y = u[t + 7], I = .03 * (x - 2 * E + A), R = .03 * (M - 2 * T + b), C = .006 * (3 * (E - A) - x + S), P = .006 * (3 * (T - b) - M + y), V = 2 * I + C, k = 2 * R + P, v = .3 * (E - x) + I + .16666667 * C, F = .3 * (T - M) + R + .16666667 * P, U = Math.sqrt(v * v + F * F), N[0] = U, t = 1; t < 8; t++) v += V, F += k, V += C, k += P, U += Math.sqrt(v * v + F * F), N[t] = U;
                        v += V, F += k, U += Math.sqrt(v * v + F * F), N[8] = U, v += V + C, F += k + P, U += Math.sqrt(v * v + F * F), N[9] = U, i = 0
                    }
                    for (r *= U;; i++) {
                        let t = N[i];
                        if (!(r > t)) {
                            if (0 == i) r /= t;
                            else {
                                let e = N[i - 1];
                                r = i + (r - e) / (t - e)
                            }
                            break
                        }
                    }
                    this.addCurvePosition(.1 * r, x, M, E, T, A, b, S, y, d, e, n || t > 0 && 0 == a)
                }
                return d
            }
            addBeforePosition(t, e, s, a, n) {
                let i = e[s],
                    r = e[s + 1],
                    l = e[s + 2] - i,
                    o = e[s + 3] - r,
                    h = Math.atan2(o, l);
                a[n] = i + t * Math.cos(h), a[n + 1] = r + t * Math.sin(h), a[n + 2] = h
            }
            addAfterPosition(t, e, s, a, n) {
                let i = e[s + 2],
                    r = e[s + 3],
                    l = i - e[s],
                    o = r - e[s + 1],
                    h = Math.atan2(o, l);
                a[n] = i + t * Math.cos(h), a[n + 1] = r + t * Math.sin(h), a[n + 2] = h
            }
            addCurvePosition(t, e, s, a, n, i, r, l, o, h, d, u) {
                if (0 == t || isNaN(t)) return h[d] = e, h[d + 1] = s, void(h[d + 2] = Math.atan2(n - s, a - e));
                let c = t * t,
                    f = c * t,
                    m = 1 - t,
                    g = m * m,
                    p = g * m,
                    w = m * t,
                    x = 3 * w,
                    M = m * x,
                    E = x * t,
                    T = e * p + a * M + i * E + l * f,
                    A = s * p + n * M + r * E + o * f;
                h[d] = T, h[d + 1] = A, u && (h[d + 2] = t < .001 ? Math.atan2(n - s, a - e) : Math.atan2(A - (s * g + n * w * 2 + r * c), T - (e * g + a * w * 2 + i * c)))
            }
        }
        e.NONE = -1, e.BEFORE = -2, e.AFTER = -3, e.epsilon = 1e-5, t.PathConstraint = e
    }(spine || (spine = {})),
    function(t) {
        class e extends t.ConstraintData {
            constructor(t) {
                super(t, 0, !1), this.bones = new Array
            }
        }
        let s, a, n;
        t.PathConstraintData = e,
            function(t) {
                t[t.Fixed = 0] = "Fixed", t[t.Percent = 1] = "Percent"
            }(s = t.PositionMode || (t.PositionMode = {})),
            function(t) {
                t[t.Length = 0] = "Length", t[t.Fixed = 1] = "Fixed", t[t.Percent = 2] = "Percent"
            }(a = t.SpacingMode || (t.SpacingMode = {})),
            function(t) {
                t[t.Tangent = 0] = "Tangent", t[t.Chain = 1] = "Chain", t[t.ChainScale = 2] = "ChainScale"
            }(n = t.RotateMode || (t.RotateMode = {}))
    }(spine || (spine = {})),
    function(t) {
        class e {
            constructor(t) {
                this.toLoad = new Array, this.assets = {}, this.clientId = t
            }
            loaded() {
                let t = 0;
                for (let e in this.assets) t++;
                return t
            }
        }
        class s {
            constructor(t = "") {
                this.clientAssets = {}, this.queuedAssets = {}, this.rawAssets = {}, this.errors = {}, this.pathPrefix = t
            }
            queueAsset(t, s, a) {
                let n = this.clientAssets[t];
                return null == n && (n = new e(t), this.clientAssets[t] = n), null !== s && (n.textureLoader = s), n.toLoad.push(a), this.queuedAssets[a] !== a && (this.queuedAssets[a] = a, !0)
            }
            loadText(t, e) {
                if (e = this.pathPrefix + e, !this.queueAsset(t, null, e)) return;
                let s = new XMLHttpRequest;
                s.overrideMimeType("text/html"), s.onreadystatechange = (() => {
                    s.readyState == XMLHttpRequest.DONE && (s.status >= 200 && s.status < 300 ? this.rawAssets[e] = s.responseText : this.errors[e] = `Couldn't load text ${e}: status ${s.status}, ${s.responseText}`)
                }), s.open("GET", e, !0), s.send()
            }
            loadJson(t, e) {
                if (e = this.pathPrefix + e, !this.queueAsset(t, null, e)) return;
                let s = new XMLHttpRequest;
                s.overrideMimeType("text/html"), s.onreadystatechange = (() => {
                    s.readyState == XMLHttpRequest.DONE && (s.status >= 200 && s.status < 300 ? this.rawAssets[e] = JSON.parse(s.responseText) : this.errors[e] = `Couldn't load text ${e}: status ${s.status}, ${s.responseText}`)
                }), s.open("GET", e, !0), s.send()
            }
            loadTexture(t, e, s) {
                if (s = this.pathPrefix + s, !this.queueAsset(t, e, s)) return;
                let a = !("undefined" == typeof window || "undefined" == typeof navigator || !window.document),
                    n = !a && "undefined" != typeof importScripts;
                if (n) {
                    const t = {
                        mode: "cors"
                    };
                    fetch(s, t).then(t => (t.ok || (this.errors[s] = "Couldn't load image " + s), t.blob())).then(t => createImageBitmap(t, {
                        premultiplyAlpha: "none",
                        colorSpaceConversion: "none"
                    })).then(t => {
                        this.rawAssets[s] = t
                    })
                } else {
                    let t = new Image;
                    t.crossOrigin = "anonymous", t.onload = (e => {
                        this.rawAssets[s] = t
                    }), t.onerror = (t => {
                        this.errors[s] = `Couldn't load image ${s}`
                    }), t.src = s
                }
            }
            get(t, e) {
                e = this.pathPrefix + e;
                let s = this.clientAssets[t];
                return null == s || s.assets[e]
            }
            updateClientAssets(t) {
                let e = !("undefined" == typeof window || "undefined" == typeof navigator || !window.document),
                    s = !e && "undefined" != typeof importScripts;
                for (let e = 0; e < t.toLoad.length; e++) {
                    let a = t.toLoad[e],
                        n = t.assets[a];
                    if (null == n) {
                        let e = this.rawAssets[a];
                        if (null == e) continue;
                        s ? e instanceof ImageBitmap ? t.assets[a] = t.textureLoader(e) : t.assets[a] = e : e instanceof HTMLImageElement ? t.assets[a] = t.textureLoader(e) : t.assets[a] = e
                    }
                }
            }
            isLoadingComplete(t) {
                let e = this.clientAssets[t];
                return null == e || (this.updateClientAssets(e), e.toLoad.length == e.loaded())
            }
            dispose() {}
            hasErrors() {
                return Object.keys(this.errors).length > 0
            }
            getErrors() {
                return this.errors
            }
        }
        t.SharedAssetManager = s
    }(spine || (spine = {})),
    function(t) {
        class e {
            constructor(e) {
                if (this._updateCache = new Array, this.updateCacheReset = new Array, this.time = 0, this.scaleX = 1, this.scaleY = 1, this.x = 0, this.y = 0, null == e) throw new Error("data cannot be null.");
                this.data = e, this.bones = new Array;
                for (let s = 0; s < e.bones.length; s++) {
                    let a, n = e.bones[s];
                    if (null == n.parent) a = new t.Bone(n, this, null);
                    else {
                        let e = this.bones[n.parent.index];
                        a = new t.Bone(n, this, e), e.children.push(a)
                    }
                    this.bones.push(a)
                }
                this.slots = new Array, this.drawOrder = new Array;
                for (let s = 0; s < e.slots.length; s++) {
                    let a = e.slots[s],
                        n = this.bones[a.boneData.index],
                        i = new t.Slot(a, n);
                    this.slots.push(i), this.drawOrder.push(i)
                }
                this.ikConstraints = new Array;
                for (let s = 0; s < e.ikConstraints.length; s++) {
                    let a = e.ikConstraints[s];
                    this.ikConstraints.push(new t.IkConstraint(a, this))
                }
                this.transformConstraints = new Array;
                for (let s = 0; s < e.transformConstraints.length; s++) {
                    let a = e.transformConstraints[s];
                    this.transformConstraints.push(new t.TransformConstraint(a, this))
                }
                this.pathConstraints = new Array;
                for (let s = 0; s < e.pathConstraints.length; s++) {
                    let a = e.pathConstraints[s];
                    this.pathConstraints.push(new t.PathConstraint(a, this))
                }
                this.color = new t.Color(1, 1, 1, 1), this.updateCache()
            }
            updateCache() {
                let t = this._updateCache;
                t.length = 0, this.updateCacheReset.length = 0;
                let e = this.bones;
                for (let t = 0, s = e.length; t < s; t++) {
                    let s = e[t];
                    s.sorted = s.data.skinRequired, s.active = !s.sorted
                }
                if (null != this.skin) {
                    let t = this.skin.bones;
                    for (let e = 0, s = this.skin.bones.length; e < s; e++) {
                        let s = this.bones[t[e].index];
                        do {
                            s.sorted = !1, s.active = !0, s = s.parent
                        } while (null != s)
                    }
                }
                let s = this.ikConstraints,
                    a = this.transformConstraints,
                    n = this.pathConstraints,
                    i = s.length,
                    r = a.length,
                    l = n.length,
                    o = i + r + l;
                t: for (let t = 0; t < o; t++) {
                    for (let e = 0; e < i; e++) {
                        let a = s[e];
                        if (a.data.order == t) {
                            this.sortIkConstraint(a);
                            continue t
                        }
                    }
                    for (let e = 0; e < r; e++) {
                        let s = a[e];
                        if (s.data.order == t) {
                            this.sortTransformConstraint(s);
                            continue t
                        }
                    }
                    for (let e = 0; e < l; e++) {
                        let s = n[e];
                        if (s.data.order == t) {
                            this.sortPathConstraint(s);
                            continue t
                        }
                    }
                }
                for (let t = 0, s = e.length; t < s; t++) this.sortBone(e[t])
            }
            sortIkConstraint(e) {
                if (e.active = e.target.isActive() && (!e.data.skinRequired || null != this.skin && t.Utils.contains(this.skin.constraints, e.data, !0)), !e.active) return;
                let s = e.target;
                this.sortBone(s);
                let a = e.bones,
                    n = a[0];
                if (this.sortBone(n), a.length > 1) {
                    let t = a[a.length - 1];
                    this._updateCache.indexOf(t) > -1 || this.updateCacheReset.push(t)
                }
                this._updateCache.push(e), this.sortReset(n.children), a[a.length - 1].sorted = !0
            }
            sortPathConstraint(e) {
                if (e.active = e.target.bone.isActive() && (!e.data.skinRequired || null != this.skin && t.Utils.contains(this.skin.constraints, e.data, !0)), !e.active) return;
                let s = e.target,
                    a = s.data.index,
                    n = s.bone;
                null != this.skin && this.sortPathConstraintAttachment(this.skin, a, n), null != this.data.defaultSkin && this.data.defaultSkin != this.skin && this.sortPathConstraintAttachment(this.data.defaultSkin, a, n);
                for (let t = 0, e = this.data.skins.length; t < e; t++) this.sortPathConstraintAttachment(this.data.skins[t], a, n);
                let i = s.getAttachment();
                i instanceof t.PathAttachment && this.sortPathConstraintAttachmentWith(i, n);
                let r = e.bones,
                    l = r.length;
                for (let t = 0; t < l; t++) this.sortBone(r[t]);
                this._updateCache.push(e);
                for (let t = 0; t < l; t++) this.sortReset(r[t].children);
                for (let t = 0; t < l; t++) r[t].sorted = !0
            }
            sortTransformConstraint(e) {
                if (e.active = e.target.isActive() && (!e.data.skinRequired || null != this.skin && t.Utils.contains(this.skin.constraints, e.data, !0)), !e.active) return;
                this.sortBone(e.target);
                let s = e.bones,
                    a = s.length;
                if (e.data.local)
                    for (let t = 0; t < a; t++) {
                        let e = s[t];
                        this.sortBone(e.parent), this._updateCache.indexOf(e) > -1 || this.updateCacheReset.push(e)
                    } else
                        for (let t = 0; t < a; t++) this.sortBone(s[t]);
                this._updateCache.push(e);
                for (let t = 0; t < a; t++) this.sortReset(s[t].children);
                for (let t = 0; t < a; t++) s[t].sorted = !0
            }
            sortPathConstraintAttachment(t, e, s) {
                let a = t.attachments[e];
                if (a)
                    for (let t in a) this.sortPathConstraintAttachmentWith(a[t], s)
            }
            sortPathConstraintAttachmentWith(e, s) {
                if (!(e instanceof t.PathAttachment)) return;
                let a = e.bones;
                if (null == a) this.sortBone(s);
                else {
                    let t = this.bones,
                        e = 0;
                    for (; e < a.length;) {
                        let s = a[e++];
                        for (let n = e + s; e < n; e++) {
                            let s = a[e];
                            this.sortBone(t[s])
                        }
                    }
                }
            }
            sortBone(t) {
                if (t.sorted) return;
                let e = t.parent;
                null != e && this.sortBone(e), t.sorted = !0, this._updateCache.push(t)
            }
            sortReset(t) {
                for (let e = 0, s = t.length; e < s; e++) {
                    let s = t[e];
                    s.active && (s.sorted && this.sortReset(s.children), s.sorted = !1)
                }
            }
            updateWorldTransform() {
                let t = this.updateCacheReset;
                for (let e = 0, s = t.length; e < s; e++) {
                    let s = t[e];
                    s.ax = s.x, s.ay = s.y, s.arotation = s.rotation, s.ascaleX = s.scaleX, s.ascaleY = s.scaleY, s.ashearX = s.shearX, s.ashearY = s.shearY, s.appliedValid = !0
                }
                let e = this._updateCache;
                for (let t = 0, s = e.length; t < s; t++) e[t].update()
            }
            setToSetupPose() {
                this.setBonesToSetupPose(), this.setSlotsToSetupPose()
            }
            setBonesToSetupPose() {
                let t = this.bones;
                for (let e = 0, s = t.length; e < s; e++) t[e].setToSetupPose();
                let e = this.ikConstraints;
                for (let t = 0, s = e.length; t < s; t++) {
                    let s = e[t];
                    s.mix = s.data.mix, s.softness = s.data.softness, s.bendDirection = s.data.bendDirection, s.compress = s.data.compress, s.stretch = s.data.stretch
                }
                let s = this.transformConstraints;
                for (let t = 0, e = s.length; t < e; t++) {
                    let e = s[t],
                        a = e.data;
                    e.rotateMix = a.rotateMix, e.translateMix = a.translateMix, e.scaleMix = a.scaleMix, e.shearMix = a.shearMix
                }
                let a = this.pathConstraints;
                for (let t = 0, e = a.length; t < e; t++) {
                    let e = a[t],
                        s = e.data;
                    e.position = s.position, e.spacing = s.spacing, e.rotateMix = s.rotateMix, e.translateMix = s.translateMix
                }
            }
            setSlotsToSetupPose() {
                let e = this.slots;
                t.Utils.arrayCopy(e, 0, this.drawOrder, 0, e.length);
                for (let t = 0, s = e.length; t < s; t++) e[t].setToSetupPose()
            }
            getRootBone() {
                return 0 == this.bones.length ? null : this.bones[0]
            }
            findBone(t) {
                if (null == t) throw new Error("boneName cannot be null.");
                let e = this.bones;
                for (let s = 0, a = e.length; s < a; s++) {
                    let a = e[s];
                    if (a.data.name == t) return a
                }
                return null
            }
            findBoneIndex(t) {
                if (null == t) throw new Error("boneName cannot be null.");
                let e = this.bones;
                for (let s = 0, a = e.length; s < a; s++)
                    if (e[s].data.name == t) return s;
                return -1
            }
            findSlot(t) {
                if (null == t) throw new Error("slotName cannot be null.");
                let e = this.slots;
                for (let s = 0, a = e.length; s < a; s++) {
                    let a = e[s];
                    if (a.data.name == t) return a
                }
                return null
            }
            findSlotIndex(t) {
                if (null == t) throw new Error("slotName cannot be null.");
                let e = this.slots;
                for (let s = 0, a = e.length; s < a; s++)
                    if (e[s].data.name == t) return s;
                return -1
            }
            setSkinByName(t) {
                let e = this.data.findSkin(t);
                if (null == e) throw new Error("Skin not found: " + t);
                this.setSkin(e)
            }
            setSkin(t) {
                if (t != this.skin) {
                    if (null != t)
                        if (null != this.skin) t.attachAll(this, this.skin);
                        else {
                            let e = this.slots;
                            for (let s = 0, a = e.length; s < a; s++) {
                                let a = e[s],
                                    n = a.data.attachmentName;
                                if (null != n) {
                                    let e = t.getAttachment(s, n);
                                    null != e && a.setAttachment(e)
                                }
                            }
                        }
                    this.skin = t, this.updateCache()
                }
            }
            getAttachmentByName(t, e) {
                return this.getAttachment(this.data.findSlotIndex(t), e)
            }
            getAttachment(t, e) {
                if (null == e) throw new Error("attachmentName cannot be null.");
                if (null != this.skin) {
                    let s = this.skin.getAttachment(t, e);
                    if (null != s) return s
                }
                return null != this.data.defaultSkin ? this.data.defaultSkin.getAttachment(t, e) : null
            }
            setAttachment(t, e) {
                if (null == t) throw new Error("slotName cannot be null.");
                let s = this.slots;
                for (let a = 0, n = s.length; a < n; a++) {
                    let n = s[a];
                    if (n.data.name == t) {
                        let s = null;
                        if (null != e && (s = this.getAttachment(a, e), null == s)) throw new Error("Attachment not found: " + e + ", for slot: " + t);
                        return void n.setAttachment(s)
                    }
                }
                throw new Error("Slot not found: " + t)
            }
            findIkConstraint(t) {
                if (null == t) throw new Error("constraintName cannot be null.");
                let e = this.ikConstraints;
                for (let s = 0, a = e.length; s < a; s++) {
                    let a = e[s];
                    if (a.data.name == t) return a
                }
                return null
            }
            findTransformConstraint(t) {
                if (null == t) throw new Error("constraintName cannot be null.");
                let e = this.transformConstraints;
                for (let s = 0, a = e.length; s < a; s++) {
                    let a = e[s];
                    if (a.data.name == t) return a
                }
                return null
            }
            findPathConstraint(t) {
                if (null == t) throw new Error("constraintName cannot be null.");
                let e = this.pathConstraints;
                for (let s = 0, a = e.length; s < a; s++) {
                    let a = e[s];
                    if (a.data.name == t) return a
                }
                return null
            }
            getBounds(e, s, a = new Array(2)) {
                if (null == e) throw new Error("offset cannot be null.");
                if (null == s) throw new Error("size cannot be null.");
                let n = this.drawOrder,
                    i = Number.POSITIVE_INFINITY,
                    r = Number.POSITIVE_INFINITY,
                    l = Number.NEGATIVE_INFINITY,
                    o = Number.NEGATIVE_INFINITY;
                for (let e = 0, s = n.length; e < s; e++) {
                    let s = n[e];
                    if (!s.bone.active) continue;
                    let h = 0,
                        d = null,
                        u = s.getAttachment();
                    if (u instanceof t.RegionAttachment) h = 8, d = t.Utils.setArraySize(a, h, 0), u.computeWorldVertices(s.bone, d, 0, 2);
                    else if (u instanceof t.MeshAttachment) {
                        let e = u;
                        h = e.worldVerticesLength, d = t.Utils.setArraySize(a, h, 0), e.computeWorldVertices(s, 0, h, d, 0, 2)
                    }
                    if (null != d)
                        for (let t = 0, e = d.length; t < e; t += 2) {
                            let e = d[t],
                                s = d[t + 1];
                            i = Math.min(i, e), r = Math.min(r, s), l = Math.max(l, e), o = Math.max(o, s)
                        }
                }
                e.set(i, r), s.set(l - i, o - r)
            }
            update(t) {
                this.time += t
            }
        }
        t.Skeleton = e
    }(spine || (spine = {})),
    function(t) {
        class e {
            constructor(t) {
                this.scale = 1, this.linkedMeshes = new Array, this.attachmentLoader = t
            }
            readSkeletonData(a) {
                let n = this.scale,
                    i = new t.SkeletonData;
                i.name = "";
                let r = new s(a);
                if (i.hash = r.readString(), i.version = r.readString(), "3.8.75" == i.version) throw new Error("Unsupported skeleton data, please export with a newer version of Spine.");
                i.x = r.readFloat(), i.y = r.readFloat(), i.width = r.readFloat(), i.height = r.readFloat();
                let l = r.readBoolean();
                l && (i.fps = r.readFloat(), i.imagesPath = r.readString(), i.audioPath = r.readString());
                let o = 0;
                o = r.readInt(!0);
                for (let t = 0; t < o; t++) r.strings.push(r.readString());
                o = r.readInt(!0);
                for (let s = 0; s < o; s++) {
                    let a = r.readString(),
                        o = 0 == s ? null : i.bones[r.readInt(!0)],
                        h = new t.BoneData(s, a, o);
                    h.rotation = r.readFloat(), h.x = r.readFloat() * n, h.y = r.readFloat() * n, h.scaleX = r.readFloat(), h.scaleY = r.readFloat(), h.shearX = r.readFloat(), h.shearY = r.readFloat(), h.length = r.readFloat() * n, h.transformMode = e.TransformModeValues[r.readInt(!0)], h.skinRequired = r.readBoolean(), l && t.Color.rgba8888ToColor(h.color, r.readInt32()), i.bones.push(h)
                }
                o = r.readInt(!0);
                for (let s = 0; s < o; s++) {
                    let a = r.readString(),
                        n = i.bones[r.readInt(!0)],
                        l = new t.SlotData(s, a, n);
                    t.Color.rgba8888ToColor(l.color, r.readInt32());
                    let o = r.readInt32(); - 1 != o && t.Color.rgb888ToColor(l.darkColor = new t.Color, o), l.attachmentName = r.readStringRef(), l.blendMode = e.BlendModeValues[r.readInt(!0)], i.slots.push(l)
                }
                o = r.readInt(!0);
                for (let e, s = 0; s < o; s++) {
                    let s = new t.IkConstraintData(r.readString());
                    s.order = r.readInt(!0), s.skinRequired = r.readBoolean(), e = r.readInt(!0);
                    for (let t = 0; t < e; t++) s.bones.push(i.bones[r.readInt(!0)]);
                    s.target = i.bones[r.readInt(!0)], s.mix = r.readFloat(), s.softness = r.readFloat() * n, s.bendDirection = r.readByte(), s.compress = r.readBoolean(), s.stretch = r.readBoolean(), s.uniform = r.readBoolean(), i.ikConstraints.push(s)
                }
                o = r.readInt(!0);
                for (let e, s = 0; s < o; s++) {
                    let s = new t.TransformConstraintData(r.readString());
                    s.order = r.readInt(!0), s.skinRequired = r.readBoolean(), e = r.readInt(!0);
                    for (let t = 0; t < e; t++) s.bones.push(i.bones[r.readInt(!0)]);
                    s.target = i.bones[r.readInt(!0)], s.local = r.readBoolean(), s.relative = r.readBoolean(), s.offsetRotation = r.readFloat(), s.offsetX = r.readFloat() * n, s.offsetY = r.readFloat() * n, s.offsetScaleX = r.readFloat(), s.offsetScaleY = r.readFloat(), s.offsetShearY = r.readFloat(), s.rotateMix = r.readFloat(), s.translateMix = r.readFloat(), s.scaleMix = r.readFloat(), s.shearMix = r.readFloat(), i.transformConstraints.push(s)
                }
                o = r.readInt(!0);
                for (let s, a = 0; a < o; a++) {
                    let a = new t.PathConstraintData(r.readString());
                    a.order = r.readInt(!0), a.skinRequired = r.readBoolean(), s = r.readInt(!0);
                    for (let t = 0; t < s; t++) a.bones.push(i.bones[r.readInt(!0)]);
                    a.target = i.slots[r.readInt(!0)], a.positionMode = e.PositionModeValues[r.readInt(!0)], a.spacingMode = e.SpacingModeValues[r.readInt(!0)], a.rotateMode = e.RotateModeValues[r.readInt(!0)], a.offsetRotation = r.readFloat(), a.position = r.readFloat(), a.positionMode == t.PositionMode.Fixed && (a.position *= n), a.spacing = r.readFloat(), a.spacingMode != t.SpacingMode.Length && a.spacingMode != t.SpacingMode.Fixed || (a.spacing *= n), a.rotateMix = r.readFloat(), a.translateMix = r.readFloat(), i.pathConstraints.push(a)
                }
                let h = this.readSkin(r, i, !0, l);
                null != h && (i.defaultSkin = h, i.skins.push(h)); {
                    let e = i.skins.length;
                    for (t.Utils.setArraySize(i.skins, o = e + r.readInt(!0)); e < o; e++) i.skins[e] = this.readSkin(r, i, !1, l)
                }
                o = this.linkedMeshes.length;
                for (let t = 0; t < o; t++) {
                    let e = this.linkedMeshes[t],
                        s = null == e.skin ? i.defaultSkin : i.findSkin(e.skin);
                    if (null == s) throw new Error("Skin not found: " + e.skin);
                    let a = s.getAttachment(e.slotIndex, e.parent);
                    if (null == a) throw new Error("Parent mesh not found: " + e.parent);
                    e.mesh.deformAttachment = e.inheritDeform ? a : e.mesh, e.mesh.setParentMesh(a), e.mesh.updateUVs()
                }
                this.linkedMeshes.length = 0, o = r.readInt(!0);
                for (let e = 0; e < o; e++) {
                    let e = new t.EventData(r.readStringRef());
                    e.intValue = r.readInt(!1), e.floatValue = r.readFloat(), e.stringValue = r.readString(), e.audioPath = r.readString(), null != e.audioPath && (e.volume = r.readFloat(), e.balance = r.readFloat()), i.events.push(e)
                }
                o = r.readInt(!0);
                for (let t = 0; t < o; t++) i.animations.push(this.readAnimation(r, r.readString(), i));
                return i
            }
            readSkin(e, s, a, n) {
                let i = null,
                    r = 0;
                if (a) {
                    if (r = e.readInt(!0), 0 == r) return null;
                    i = new t.Skin("default")
                } else {
                    i = new t.Skin(e.readStringRef()), i.bones.length = e.readInt(!0);
                    for (let t = 0, a = i.bones.length; t < a; t++) i.bones[t] = s.bones[e.readInt(!0)];
                    for (let t = 0, a = e.readInt(!0); t < a; t++) i.constraints.push(s.ikConstraints[e.readInt(!0)]);
                    for (let t = 0, a = e.readInt(!0); t < a; t++) i.constraints.push(s.transformConstraints[e.readInt(!0)]);
                    for (let t = 0, a = e.readInt(!0); t < a; t++) i.constraints.push(s.pathConstraints[e.readInt(!0)]);
                    r = e.readInt(!0)
                }
                for (let t = 0; t < r; t++) {
                    let t = e.readInt(!0);
                    for (let a = 0, r = e.readInt(!0); a < r; a++) {
                        let a = e.readStringRef(),
                            r = this.readAttachment(e, s, i, t, a, n);
                        null != r && i.setAttachment(t, a, r)
                    }
                }
                return i
            }
            readAttachment(s, n, i, r, l, o) {
                let h = this.scale,
                    d = s.readStringRef();
                null == d && (d = l);
                let u = s.readByte(),
                    c = e.AttachmentTypeValues[u];
                switch (c) {
                    case t.AttachmentType.Region:
                        {
                            let e = s.readStringRef(),
                                a = s.readFloat(),
                                n = s.readFloat(),
                                r = s.readFloat(),
                                l = s.readFloat(),
                                o = s.readFloat(),
                                u = s.readFloat(),
                                c = s.readFloat(),
                                f = s.readInt32();
                            null == e && (e = d);
                            let m = this.attachmentLoader.newRegionAttachment(i, d, e);
                            return null == m ? null : (m.path = e, m.x = n * h, m.y = r * h, m.scaleX = l, m.scaleY = o, m.rotation = a, m.width = u * h, m.height = c * h, t.Color.rgba8888ToColor(m.color, f), m.updateOffset(), m)
                        }
                    case t.AttachmentType.BoundingBox:
                        {
                            let e = s.readInt(!0),
                                a = this.readVertices(s, e),
                                n = o ? s.readInt32() : 0,
                                r = this.attachmentLoader.newBoundingBoxAttachment(i, d);
                            return null == r ? null : (r.worldVerticesLength = e << 1, r.vertices = a.vertices, r.bones = a.bones, o && t.Color.rgba8888ToColor(r.color, n), r)
                        }
                    case t.AttachmentType.Mesh:
                        {
                            let e = s.readStringRef(),
                                a = s.readInt32(),
                                n = s.readInt(!0),
                                r = this.readFloatArray(s, n << 1, 1),
                                l = this.readShortArray(s),
                                u = this.readVertices(s, n),
                                c = s.readInt(!0),
                                f = null,
                                m = 0,
                                g = 0;
                            o && (f = this.readShortArray(s), m = s.readFloat(), g = s.readFloat()), null == e && (e = d);
                            let p = this.attachmentLoader.newMeshAttachment(i, d, e);
                            return null == p ? null : (p.path = e, t.Color.rgba8888ToColor(p.color, a), p.bones = u.bones, p.vertices = u.vertices, p.worldVerticesLength = n << 1, p.triangles = l, p.regionUVs = r, p.updateUVs(), p.hullLength = c << 1, o && (p.edges = f, p.width = m * h, p.height = g * h), p)
                        }
                    case t.AttachmentType.LinkedMesh:
                        {
                            let e = s.readStringRef(),
                                n = s.readInt32(),
                                l = s.readStringRef(),
                                u = s.readStringRef(),
                                c = s.readBoolean(),
                                f = 0,
                                m = 0;
                            o && (f = s.readFloat(), m = s.readFloat()), null == e && (e = d);
                            let g = this.attachmentLoader.newMeshAttachment(i, d, e);
                            return null == g ? null : (g.path = e, t.Color.rgba8888ToColor(g.color, n), o && (g.width = f * h, g.height = m * h), this.linkedMeshes.push(new a(g, l, r, u, c)), g)
                        }
                    case t.AttachmentType.Path:
                        {
                            let e = s.readBoolean(),
                                a = s.readBoolean(),
                                n = s.readInt(!0),
                                r = this.readVertices(s, n),
                                l = t.Utils.newArray(n / 3, 0);
                            for (let t = 0, e = l.length; t < e; t++) l[t] = s.readFloat() * h;
                            let u = o ? s.readInt32() : 0,
                                c = this.attachmentLoader.newPathAttachment(i, d);
                            return null == c ? null : (c.closed = e, c.constantSpeed = a, c.worldVerticesLength = n << 1, c.vertices = r.vertices, c.bones = r.bones, c.lengths = l, o && t.Color.rgba8888ToColor(c.color, u), c)
                        }
                    case t.AttachmentType.Point:
                        {
                            let e = s.readFloat(),
                                a = s.readFloat(),
                                n = s.readFloat(),
                                r = o ? s.readInt32() : 0,
                                l = this.attachmentLoader.newPointAttachment(i, d);
                            return null == l ? null : (l.x = a * h, l.y = n * h, l.rotation = e, o && t.Color.rgba8888ToColor(l.color, r), l)
                        }
                    case t.AttachmentType.Clipping:
                        {
                            let e = s.readInt(!0),
                                a = s.readInt(!0),
                                r = this.readVertices(s, a),
                                l = o ? s.readInt32() : 0,
                                h = this.attachmentLoader.newClippingAttachment(i, d);
                            return null == h ? null : (h.endSlot = n.slots[e], h.worldVerticesLength = a << 1, h.vertices = r.vertices, h.bones = r.bones, o && t.Color.rgba8888ToColor(h.color, l), h)
                        }
                }
                return null
            }
            readVertices(e, s) {
                let a = s << 1,
                    i = new n,
                    r = this.scale;
                if (!e.readBoolean()) return i.vertices = this.readFloatArray(e, a, r), i;
                let l = new Array,
                    o = new Array;
                for (let t = 0; t < s; t++) {
                    let t = e.readInt(!0);
                    o.push(t);
                    for (let s = 0; s < t; s++) o.push(e.readInt(!0)), l.push(e.readFloat() * r), l.push(e.readFloat() * r), l.push(e.readFloat())
                }
                return i.vertices = t.Utils.toFloatArray(l), i.bones = o, i
            }
            readFloatArray(t, e, s) {
                let a = new Array(e);
                if (1 == s)
                    for (let s = 0; s < e; s++) a[s] = t.readFloat();
                else
                    for (let n = 0; n < e; n++) a[n] = t.readFloat() * s;
                return a
            }
            readShortArray(t) {
                let e = t.readInt(!0),
                    s = new Array(e);
                for (let a = 0; a < e; a++) s[a] = t.readShort();
                return s
            }
            readAnimation(s, a, n) {
                let i = new Array,
                    r = this.scale,
                    l = 0,
                    o = new t.Color,
                    h = new t.Color;
                for (let a = 0, n = s.readInt(!0); a < n; a++) {
                    let a = s.readInt(!0);
                    for (let n = 0, r = s.readInt(!0); n < r; n++) {
                        let n = s.readByte(),
                            r = s.readInt(!0);
                        switch (n) {
                            case e.SLOT_ATTACHMENT:
                                {
                                    let e = new t.AttachmentTimeline(r);
                                    e.slotIndex = a;
                                    for (let t = 0; t < r; t++) e.setFrame(t, s.readFloat(), s.readStringRef());
                                    i.push(e), l = Math.max(l, e.frames[r - 1]);
                                    break
                                }
                            case e.SLOT_COLOR:
                                {
                                    let e = new t.ColorTimeline(r);
                                    e.slotIndex = a;
                                    for (let a = 0; a < r; a++) {
                                        let n = s.readFloat();
                                        t.Color.rgba8888ToColor(o, s.readInt32()), e.setFrame(a, n, o.r, o.g, o.b, o.a), a < r - 1 && this.readCurve(s, a, e)
                                    }
                                    i.push(e), l = Math.max(l, e.frames[(r - 1) * t.ColorTimeline.ENTRIES]);
                                    break
                                }
                            case e.SLOT_TWO_COLOR:
                                {
                                    let e = new t.TwoColorTimeline(r);
                                    e.slotIndex = a;
                                    for (let a = 0; a < r; a++) {
                                        let n = s.readFloat();
                                        t.Color.rgba8888ToColor(o, s.readInt32()), t.Color.rgb888ToColor(h, s.readInt32()), e.setFrame(a, n, o.r, o.g, o.b, o.a, h.r, h.g, h.b), a < r - 1 && this.readCurve(s, a, e)
                                    }
                                    i.push(e), l = Math.max(l, e.frames[(r - 1) * t.TwoColorTimeline.ENTRIES]);
                                    break
                                }
                        }
                    }
                }
                for (let a = 0, n = s.readInt(!0); a < n; a++) {
                    let a = s.readInt(!0);
                    for (let n = 0, o = s.readInt(!0); n < o; n++) {
                        let n = s.readByte(),
                            o = s.readInt(!0);
                        switch (n) {
                            case e.BONE_ROTATE:
                                {
                                    let e = new t.RotateTimeline(o);
                                    e.boneIndex = a;
                                    for (let t = 0; t < o; t++) e.setFrame(t, s.readFloat(), s.readFloat()), t < o - 1 && this.readCurve(s, t, e);
                                    i.push(e), l = Math.max(l, e.frames[(o - 1) * t.RotateTimeline.ENTRIES]);
                                    break
                                }
                            case e.BONE_TRANSLATE:
                            case e.BONE_SCALE:
                            case e.BONE_SHEAR:
                                {
                                    let h, d = 1;
                                    n == e.BONE_SCALE ? h = new t.ScaleTimeline(o) : n == e.BONE_SHEAR ? h = new t.ShearTimeline(o) : (h = new t.TranslateTimeline(o), d = r), h.boneIndex = a;
                                    for (let t = 0; t < o; t++) h.setFrame(t, s.readFloat(), s.readFloat() * d, s.readFloat() * d), t < o - 1 && this.readCurve(s, t, h);
                                    i.push(h), l = Math.max(l, h.frames[(o - 1) * t.TranslateTimeline.ENTRIES]);
                                    break
                                }
                        }
                    }
                }
                for (let e = 0, a = s.readInt(!0); e < a; e++) {
                    let e = s.readInt(!0),
                        a = s.readInt(!0),
                        n = new t.IkConstraintTimeline(a);
                    n.ikConstraintIndex = e;
                    for (let t = 0; t < a; t++) n.setFrame(t, s.readFloat(), s.readFloat(), s.readFloat() * r, s.readByte(), s.readBoolean(), s.readBoolean()), t < a - 1 && this.readCurve(s, t, n);
                    i.push(n), l = Math.max(l, n.frames[(a - 1) * t.IkConstraintTimeline.ENTRIES])
                }
                for (let e = 0, a = s.readInt(!0); e < a; e++) {
                    let e = s.readInt(!0),
                        a = s.readInt(!0),
                        n = new t.TransformConstraintTimeline(a);
                    n.transformConstraintIndex = e;
                    for (let t = 0; t < a; t++) n.setFrame(t, s.readFloat(), s.readFloat(), s.readFloat(), s.readFloat(), s.readFloat()), t < a - 1 && this.readCurve(s, t, n);
                    i.push(n), l = Math.max(l, n.frames[(a - 1) * t.TransformConstraintTimeline.ENTRIES])
                }
                for (let a = 0, o = s.readInt(!0); a < o; a++) {
                    let a = s.readInt(!0),
                        o = n.pathConstraints[a];
                    for (let n = 0, h = s.readInt(!0); n < h; n++) {
                        let n = s.readByte(),
                            h = s.readInt(!0);
                        switch (n) {
                            case e.PATH_POSITION:
                            case e.PATH_SPACING:
                                {
                                    let d, u = 1;
                                    n == e.PATH_SPACING ? (d = new t.PathConstraintSpacingTimeline(h), o.spacingMode != t.SpacingMode.Length && o.spacingMode != t.SpacingMode.Fixed || (u = r)) : (d = new t.PathConstraintPositionTimeline(h), o.positionMode == t.PositionMode.Fixed && (u = r)), d.pathConstraintIndex = a;
                                    for (let t = 0; t < h; t++) d.setFrame(t, s.readFloat(), s.readFloat() * u), t < h - 1 && this.readCurve(s, t, d);
                                    i.push(d), l = Math.max(l, d.frames[(h - 1) * t.PathConstraintPositionTimeline.ENTRIES]);
                                    break
                                }
                            case e.PATH_MIX:
                                {
                                    let e = new t.PathConstraintMixTimeline(h);
                                    e.pathConstraintIndex = a;
                                    for (let t = 0; t < h; t++) e.setFrame(t, s.readFloat(), s.readFloat(), s.readFloat()), t < h - 1 && this.readCurve(s, t, e);
                                    i.push(e), l = Math.max(l, e.frames[(h - 1) * t.PathConstraintMixTimeline.ENTRIES]);
                                    break
                                }
                        }
                    }
                }
                for (let e = 0, a = s.readInt(!0); e < a; e++) {
                    let e = n.skins[s.readInt(!0)];
                    for (let a = 0, n = s.readInt(!0); a < n; a++) {
                        let a = s.readInt(!0);
                        for (let n = 0, o = s.readInt(!0); n < o; n++) {
                            let n = e.getAttachment(a, s.readStringRef()),
                                o = null != n.bones,
                                h = n.vertices,
                                d = o ? h.length / 3 * 2 : h.length,
                                u = s.readInt(!0),
                                c = new t.DeformTimeline(u);
                            c.slotIndex = a, c.attachment = n;
                            for (let e = 0; e < u; e++) {
                                let a, n = s.readFloat(),
                                    i = s.readInt(!0);
                                if (0 == i) a = o ? t.Utils.newFloatArray(d) : h;
                                else {
                                    a = t.Utils.newFloatArray(d);
                                    let e = s.readInt(!0);
                                    if (i += e, 1 == r)
                                        for (let t = e; t < i; t++) a[t] = s.readFloat();
                                    else
                                        for (let t = e; t < i; t++) a[t] = s.readFloat() * r;
                                    if (!o)
                                        for (let t = 0, e = a.length; t < e; t++) a[t] += h[t]
                                }
                                c.setFrame(e, n, a), e < u - 1 && this.readCurve(s, e, c)
                            }
                            i.push(c), l = Math.max(l, c.frames[u - 1])
                        }
                    }
                }
                let d = s.readInt(!0);
                if (d > 0) {
                    let e = new t.DrawOrderTimeline(d),
                        a = n.slots.length;
                    for (let n = 0; n < d; n++) {
                        let i = s.readFloat(),
                            r = s.readInt(!0),
                            l = t.Utils.newArray(a, 0);
                        for (let t = a - 1; t >= 0; t--) l[t] = -1;
                        let o = t.Utils.newArray(a - r, 0),
                            h = 0,
                            d = 0;
                        for (let t = 0; t < r; t++) {
                            let t = s.readInt(!0);
                            for (; h != t;) o[d++] = h++;
                            l[h + s.readInt(!0)] = h++
                        }
                        for (; h < a;) o[d++] = h++;
                        for (let t = a - 1; t >= 0; t--) - 1 == l[t] && (l[t] = o[--d]);
                        e.setFrame(n, i, l)
                    }
                    i.push(e), l = Math.max(l, e.frames[d - 1])
                }
                let u = s.readInt(!0);
                if (u > 0) {
                    let e = new t.EventTimeline(u);
                    for (let a = 0; a < u; a++) {
                        let i = s.readFloat(),
                            r = n.events[s.readInt(!0)],
                            l = new t.Event(i, r);
                        l.intValue = s.readInt(!1), l.floatValue = s.readFloat(), l.stringValue = s.readBoolean() ? s.readString() : r.stringValue, null != l.data.audioPath && (l.volume = s.readFloat(), l.balance = s.readFloat()), e.setFrame(a, l)
                    }
                    i.push(e), l = Math.max(l, e.frames[u - 1])
                }
                return new t.Animation(a, i, l)
            }
            readCurve(t, s, a) {
                switch (t.readByte()) {
                    case e.CURVE_STEPPED:
                        a.setStepped(s);
                        break;
                    case e.CURVE_BEZIER:
                        this.setCurve(a, s, t.readFloat(), t.readFloat(), t.readFloat(), t.readFloat())
                }
            }
            setCurve(t, e, s, a, n, i) {
                t.setCurve(e, s, a, n, i)
            }
        }
        e.AttachmentTypeValues = [0, 1, 2, 3, 4, 5, 6], e.TransformModeValues = [t.TransformMode.Normal, t.TransformMode.OnlyTranslation, t.TransformMode.NoRotationOrReflection, t.TransformMode.NoScale, t.TransformMode.NoScaleOrReflection], e.PositionModeValues = [t.PositionMode.Fixed, t.PositionMode.Percent], e.SpacingModeValues = [t.SpacingMode.Length, t.SpacingMode.Fixed, t.SpacingMode.Percent], e.RotateModeValues = [t.RotateMode.Tangent, t.RotateMode.Chain, t.RotateMode.ChainScale], e.BlendModeValues = [t.BlendMode.Normal, t.BlendMode.Additive, t.BlendMode.Multiply, t.BlendMode.Screen], e.BONE_ROTATE = 0, e.BONE_TRANSLATE = 1, e.BONE_SCALE = 2, e.BONE_SHEAR = 3, e.SLOT_ATTACHMENT = 0, e.SLOT_COLOR = 1, e.SLOT_TWO_COLOR = 2, e.PATH_POSITION = 0, e.PATH_SPACING = 1, e.PATH_MIX = 2, e.CURVE_LINEAR = 0, e.CURVE_STEPPED = 1, e.CURVE_BEZIER = 2, t.SkeletonBinary = e;
        class s {
            constructor(t, e = new Array, s = 0, a = new DataView(t.buffer)) {
                this.strings = e, this.index = s, this.buffer = a
            }
            readByte() {
                return this.buffer.getInt8(this.index++)
            }
            readShort() {
                let t = this.buffer.getInt16(this.index);
                return this.index += 2, t
            }
            readInt32() {
                let t = this.buffer.getInt32(this.index);
                return this.index += 4, t
            }
            readInt(t) {
                let e = this.readByte(),
                    s = 127 & e;
                return 0 != (128 & e) && (e = this.readByte(), s |= (127 & e) << 7, 0 != (128 & e) && (e = this.readByte(), s |= (127 & e) << 14, 0 != (128 & e) && (e = this.readByte(), s |= (127 & e) << 21, 0 != (128 & e) && (e = this.readByte(), s |= (127 & e) << 28)))), t ? s : s >>> 1 ^ -(1 & s)
            }
            readStringRef() {
                let t = this.readInt(!0);
                return 0 == t ? null : this.strings[t - 1]
            }
            readString() {
                let t = this.readInt(!0);
                switch (t) {
                    case 0:
                        return null;
                    case 1:
                        return ""
                }
                t--;
                let e = "";
                for (let s = 0; s < t;) {
                    let t = this.readByte();
                    switch (t >> 4) {
                        case 12:
                        case 13:
                            e += String.fromCharCode((31 & t) << 6 | 63 & this.readByte()), s += 2;
                            break;
                        case 14:
                            e += String.fromCharCode((15 & t) << 12 | (63 & this.readByte()) << 6 | 63 & this.readByte()), s += 3;
                            break;
                        default:
                            e += String.fromCharCode(t), s++
                    }
                }
                return e
            }
            readFloat() {
                let t = this.buffer.getFloat32(this.index);
                return this.index += 4, t
            }
            readBoolean() {
                return 0 != this.readByte()
            }
        }
        class a {
            constructor(t, e, s, a, n) {
                this.mesh = t, this.skin = e, this.slotIndex = s, this.parent = a, this.inheritDeform = n
            }
        }
        class n {
            constructor(t = null, e = null) {
                this.bones = t, this.vertices = e
            }
        }
    }(spine || (spine = {})),
    function(t) {
        class e {
            constructor() {
                this.minX = 0, this.minY = 0, this.maxX = 0, this.maxY = 0, this.boundingBoxes = new Array, this.polygons = new Array, this.polygonPool = new t.Pool(() => t.Utils.newFloatArray(16))
            }
            update(e, s) {
                if (null == e) throw new Error("skeleton cannot be null.");
                let a = this.boundingBoxes,
                    n = this.polygons,
                    i = this.polygonPool,
                    r = e.slots,
                    l = r.length;
                a.length = 0, i.freeAll(n), n.length = 0;
                for (let e = 0; e < l; e++) {
                    let s = r[e];
                    if (!s.bone.active) continue;
                    let l = s.getAttachment();
                    if (l instanceof t.BoundingBoxAttachment) {
                        let e = l;
                        a.push(e);
                        let r = i.obtain();
                        r.length != e.worldVerticesLength && (r = t.Utils.newFloatArray(e.worldVerticesLength)), n.push(r), e.computeWorldVertices(s, 0, e.worldVerticesLength, r, 0, 2)
                    }
                }
                s ? this.aabbCompute() : (this.minX = Number.POSITIVE_INFINITY, this.minY = Number.POSITIVE_INFINITY, this.maxX = Number.NEGATIVE_INFINITY, this.maxY = Number.NEGATIVE_INFINITY)
            }
            aabbCompute() {
                let t = Number.POSITIVE_INFINITY,
                    e = Number.POSITIVE_INFINITY,
                    s = Number.NEGATIVE_INFINITY,
                    a = Number.NEGATIVE_INFINITY,
                    n = this.polygons;
                for (let i = 0, r = n.length; i < r; i++) {
                    let r = n[i],
                        l = r;
                    for (let n = 0, i = r.length; n < i; n += 2) {
                        let i = l[n],
                            r = l[n + 1];
                        t = Math.min(t, i), e = Math.min(e, r), s = Math.max(s, i), a = Math.max(a, r)
                    }
                }
                this.minX = t, this.minY = e, this.maxX = s, this.maxY = a
            }
            aabbContainsPoint(t, e) {
                return t >= this.minX && t <= this.maxX && e >= this.minY && e <= this.maxY
            }
            aabbIntersectsSegment(t, e, s, a) {
                let n = this.minX,
                    i = this.minY,
                    r = this.maxX,
                    l = this.maxY;
                if (t <= n && s <= n || e <= i && a <= i || t >= r && s >= r || e >= l && a >= l) return !1;
                let o = (a - e) / (s - t),
                    h = o * (n - t) + e;
                if (h > i && h < l) return !0;
                if (h = o * (r - t) + e, h > i && h < l) return !0;
                let d = (i - e) / o + t;
                return d > n && d < r || (d = (l - e) / o + t, d > n && d < r)
            }
            aabbIntersectsSkeleton(t) {
                return this.minX < t.maxX && this.maxX > t.minX && this.minY < t.maxY && this.maxY > t.minY
            }
            containsPoint(t, e) {
                let s = this.polygons;
                for (let a = 0, n = s.length; a < n; a++)
                    if (this.containsPointPolygon(s[a], t, e)) return this.boundingBoxes[a];
                return null
            }
            containsPointPolygon(t, e, s) {
                let a = t,
                    n = t.length,
                    i = n - 2,
                    r = !1;
                for (let t = 0; t < n; t += 2) {
                    let n = a[t + 1],
                        l = a[i + 1];
                    if (n < s && l >= s || l < s && n >= s) {
                        let o = a[t];
                        o + (s - n) / (l - n) * (a[i] - o) < e && (r = !r)
                    }
                    i = t
                }
                return r
            }
            intersectsSegment(t, e, s, a) {
                let n = this.polygons;
                for (let i = 0, r = n.length; i < r; i++)
                    if (this.intersectsSegmentPolygon(n[i], t, e, s, a)) return this.boundingBoxes[i];
                return null
            }
            intersectsSegmentPolygon(t, e, s, a, n) {
                let i = t,
                    r = t.length,
                    l = e - a,
                    o = s - n,
                    h = e * n - s * a,
                    d = i[r - 2],
                    u = i[r - 1];
                for (let t = 0; t < r; t += 2) {
                    let r = i[t],
                        c = i[t + 1],
                        f = d * c - u * r,
                        m = d - r,
                        g = u - c,
                        p = l * g - o * m,
                        w = (h * m - l * f) / p;
                    if ((w >= d && w <= r || w >= r && w <= d) && (w >= e && w <= a || w >= a && w <= e)) {
                        let t = (h * g - o * f) / p;
                        if ((t >= u && t <= c || t >= c && t <= u) && (t >= s && t <= n || t >= n && t <= s)) return !0
                    }
                    d = r, u = c
                }
                return !1
            }
            getPolygon(t) {
                if (null == t) throw new Error("boundingBox cannot be null.");
                let e = this.boundingBoxes.indexOf(t);
                return -1 == e ? null : this.polygons[e]
            }
            getWidth() {
                return this.maxX - this.minX
            }
            getHeight() {
                return this.maxY - this.minY
            }
        }
        t.SkeletonBounds = e
    }(spine || (spine = {})),
    function(t) {
        class e {
            constructor() {
                this.triangulator = new t.Triangulator, this.clippingPolygon = new Array, this.clipOutput = new Array, this.clippedVertices = new Array, this.clippedTriangles = new Array, this.scratch = new Array
            }
            clipStart(s, a) {
                if (null != this.clipAttachment) return 0;
                this.clipAttachment = a;
                let n = a.worldVerticesLength,
                    i = t.Utils.setArraySize(this.clippingPolygon, n);
                a.computeWorldVertices(s, 0, n, i, 0, 2);
                let r = this.clippingPolygon;
                e.makeClockwise(r);
                let l = this.clippingPolygons = this.triangulator.decompose(r, this.triangulator.triangulate(r));
                for (let t = 0, s = l.length; t < s; t++) {
                    let s = l[t];
                    e.makeClockwise(s), s.push(s[0]), s.push(s[1])
                }
                return l.length
            }
            clipEndWithSlot(t) {
                null != this.clipAttachment && this.clipAttachment.endSlot == t.data && this.clipEnd()
            }
            clipEnd() {
                null != this.clipAttachment && (this.clipAttachment = null, this.clippingPolygons = null, this.clippedVertices.length = 0, this.clippedTriangles.length = 0, this.clippingPolygon.length = 0)
            }
            isClipping() {
                return null != this.clipAttachment
            }
            clipTriangles(e, s, a, n, i, r, l, o) {
                let h = this.clipOutput,
                    d = this.clippedVertices,
                    u = this.clippedTriangles,
                    c = this.clippingPolygons,
                    f = this.clippingPolygons.length,
                    m = o ? 12 : 8,
                    g = 0;
                d.length = 0, u.length = 0;
                t: for (let s = 0; s < n; s += 3) {
                    let n = a[s] << 1,
                        p = e[n],
                        w = e[n + 1],
                        x = i[n],
                        M = i[n + 1];
                    n = a[s + 1] << 1;
                    let E = e[n],
                        T = e[n + 1],
                        A = i[n],
                        b = i[n + 1];
                    n = a[s + 2] << 1;
                    let S = e[n],
                        y = e[n + 1],
                        I = i[n],
                        R = i[n + 1];
                    for (let e = 0; e < f; e++) {
                        let s = d.length;
                        if (!this.clip(p, w, E, T, S, y, c[e], h)) {
                            let e = t.Utils.setArraySize(d, s + 3 * m);
                            e[s] = p, e[s + 1] = w, e[s + 2] = r.r, e[s + 3] = r.g, e[s + 4] = r.b, e[s + 5] = r.a, o ? (e[s + 6] = x, e[s + 7] = M, e[s + 8] = l.r, e[s + 9] = l.g, e[s + 10] = l.b, e[s + 11] = l.a, e[s + 12] = E, e[s + 13] = T, e[s + 14] = r.r, e[s + 15] = r.g, e[s + 16] = r.b, e[s + 17] = r.a, e[s + 18] = A, e[s + 19] = b, e[s + 20] = l.r, e[s + 21] = l.g, e[s + 22] = l.b, e[s + 23] = l.a, e[s + 24] = S, e[s + 25] = y, e[s + 26] = r.r, e[s + 27] = r.g, e[s + 28] = r.b, e[s + 29] = r.a, e[s + 30] = I, e[s + 31] = R, e[s + 32] = l.r, e[s + 33] = l.g, e[s + 34] = l.b, e[s + 35] = l.a) : (e[s + 6] = x, e[s + 7] = M, e[s + 8] = E, e[s + 9] = T, e[s + 10] = r.r, e[s + 11] = r.g, e[s + 12] = r.b, e[s + 13] = r.a, e[s + 14] = A, e[s + 15] = b, e[s + 16] = S, e[s + 17] = y, e[s + 18] = r.r, e[s + 19] = r.g, e[s + 20] = r.b, e[s + 21] = r.a, e[s + 22] = I, e[s + 23] = R), s = u.length;
                            let a = t.Utils.setArraySize(u, s + 3);
                            a[s] = g, a[s + 1] = g + 1, a[s + 2] = g + 2, g += 3;
                            continue t
                        } {
                            let e = h.length;
                            if (0 == e) continue;
                            let a = T - y,
                                n = S - E,
                                i = p - S,
                                c = y - w,
                                f = 1 / (a * i + n * (w - y)),
                                C = e >> 1,
                                P = this.clipOutput,
                                V = t.Utils.setArraySize(d, s + C * m);
                            for (let t = 0; t < e; t += 2) {
                                let e = P[t],
                                    h = P[t + 1];
                                V[s] = e, V[s + 1] = h, V[s + 2] = r.r, V[s + 3] = r.g, V[s + 4] = r.b, V[s + 5] = r.a;
                                let d = e - S,
                                    u = h - y,
                                    g = (a * d + n * u) * f,
                                    p = (c * d + i * u) * f,
                                    w = 1 - g - p;
                                V[s + 6] = x * g + A * p + I * w, V[s + 7] = M * g + b * p + R * w, o && (V[s + 8] = l.r, V[s + 9] = l.g, V[s + 10] = l.b, V[s + 11] = l.a), s += m
                            }
                            s = u.length;
                            let k = t.Utils.setArraySize(u, s + 3 * (C - 2));
                            C--;
                            for (let t = 1; t < C; t++) k[s] = g, k[s + 1] = g + t, k[s + 2] = g + t + 1, s += 3;
                            g += C + 1
                        }
                    }
                }
            }
            clip(t, e, s, a, n, i, r, l) {
                let o = l,
                    h = !1,
                    d = null;
                r.length % 4 >= 2 ? (d = l, l = this.scratch) : d = this.scratch, d.length = 0, d.push(t), d.push(e), d.push(s), d.push(a), d.push(n), d.push(i), d.push(t), d.push(e), l.length = 0;
                let u = r,
                    c = r.length - 4;
                for (let t = 0;; t += 2) {
                    let e = u[t],
                        s = u[t + 1],
                        a = u[t + 2],
                        n = u[t + 3],
                        i = e - a,
                        r = s - n,
                        f = d,
                        m = d.length - 2,
                        g = l.length;
                    for (let t = 0; t < m; t += 2) {
                        let o = f[t],
                            d = f[t + 1],
                            u = f[t + 2],
                            c = f[t + 3],
                            m = i * (c - n) - r * (u - a) > 0;
                        if (i * (d - n) - r * (o - a) > 0) {
                            if (m) {
                                l.push(u), l.push(c);
                                continue
                            }
                            let t = c - d,
                                i = u - o,
                                r = t * (a - e) - i * (n - s);
                            if (Math.abs(r) > 1e-6) {
                                let h = (i * (s - d) - t * (e - o)) / r;
                                l.push(e + (a - e) * h), l.push(s + (n - s) * h)
                            } else l.push(e), l.push(s)
                        } else if (m) {
                            let t = c - d,
                                i = u - o,
                                r = t * (a - e) - i * (n - s);
                            if (Math.abs(r) > 1e-6) {
                                let h = (i * (s - d) - t * (e - o)) / r;
                                l.push(e + (a - e) * h), l.push(s + (n - s) * h)
                            } else l.push(e), l.push(s);
                            l.push(u), l.push(c)
                        }
                        h = !0
                    }
                    if (g == l.length) return o.length = 0, !0;
                    if (l.push(l[0]), l.push(l[1]), t == c) break;
                    let p = l;
                    l = d, l.length = 0, d = p
                }
                if (o != l) {
                    o.length = 0;
                    for (let t = 0, e = l.length - 2; t < e; t++) o[t] = l[t]
                } else o.length = o.length - 2;
                return h
            }
            static makeClockwise(t) {
                let e = t,
                    s = t.length,
                    a = e[s - 2] * e[1] - e[0] * e[s - 1],
                    n = 0,
                    i = 0,
                    r = 0,
                    l = 0;
                for (let t = 0, o = s - 3; t < o; t += 2) n = e[t], i = e[t + 1], r = e[t + 2], l = e[t + 3], a += n * l - r * i;
                if (!(a < 0))
                    for (let t = 0, a = s - 2, n = s >> 1; t < n; t += 2) {
                        let s = e[t],
                            n = e[t + 1],
                            i = a - t;
                        e[t] = e[i], e[t + 1] = e[i + 1], e[i] = s, e[i + 1] = n
                    }
            }
        }
        t.SkeletonClipping = e
    }(spine || (spine = {})),
    function(t) {
        class e {
            constructor() {
                this.bones = new Array, this.slots = new Array, this.skins = new Array, this.events = new Array, this.animations = new Array, this.ikConstraints = new Array, this.transformConstraints = new Array, this.pathConstraints = new Array, this.fps = 0
            }
            findBone(t) {
                if (null == t) throw new Error("boneName cannot be null.");
                let e = this.bones;
                for (let s = 0, a = e.length; s < a; s++) {
                    let a = e[s];
                    if (a.name == t) return a
                }
                return null
            }
            findBoneIndex(t) {
                if (null == t) throw new Error("boneName cannot be null.");
                let e = this.bones;
                for (let s = 0, a = e.length; s < a; s++)
                    if (e[s].name == t) return s;
                return -1
            }
            findSlot(t) {
                if (null == t) throw new Error("slotName cannot be null.");
                let e = this.slots;
                for (let s = 0, a = e.length; s < a; s++) {
                    let a = e[s];
                    if (a.name == t) return a
                }
                return null
            }
            findSlotIndex(t) {
                if (null == t) throw new Error("slotName cannot be null.");
                let e = this.slots;
                for (let s = 0, a = e.length; s < a; s++)
                    if (e[s].name == t) return s;
                return -1
            }
            findSkin(t) {
                if (null == t) throw new Error("skinName cannot be null.");
                let e = this.skins;
                for (let s = 0, a = e.length; s < a; s++) {
                    let a = e[s];
                    if (a.name == t) return a
                }
                return null
            }
            findEvent(t) {
                if (null == t) throw new Error("eventDataName cannot be null.");
                let e = this.events;
                for (let s = 0, a = e.length; s < a; s++) {
                    let a = e[s];
                    if (a.name == t) return a
                }
                return null
            }
            findAnimation(t) {
                if (null == t) throw new Error("animationName cannot be null.");
                let e = this.animations;
                for (let s = 0, a = e.length; s < a; s++) {
                    let a = e[s];
                    if (a.name == t) return a
                }
                return null
            }
            findIkConstraint(t) {
                if (null == t) throw new Error("constraintName cannot be null.");
                let e = this.ikConstraints;
                for (let s = 0, a = e.length; s < a; s++) {
                    let a = e[s];
                    if (a.name == t) return a
                }
                return null
            }
            findTransformConstraint(t) {
                if (null == t) throw new Error("constraintName cannot be null.");
                let e = this.transformConstraints;
                for (let s = 0, a = e.length; s < a; s++) {
                    let a = e[s];
                    if (a.name == t) return a
                }
                return null
            }
            findPathConstraint(t) {
                if (null == t) throw new Error("constraintName cannot be null.");
                let e = this.pathConstraints;
                for (let s = 0, a = e.length; s < a; s++) {
                    let a = e[s];
                    if (a.name == t) return a
                }
                return null
            }
            findPathConstraintIndex(t) {
                if (null == t) throw new Error("pathConstraintName cannot be null.");
                let e = this.pathConstraints;
                for (let s = 0, a = e.length; s < a; s++)
                    if (e[s].name == t) return s;
                return -1
            }
        }
        t.SkeletonData = e
    }(spine || (spine = {})),
    function(t) {
        class e {
            constructor(t) {
                this.scale = 1, this.linkedMeshes = new Array, this.attachmentLoader = t
            }
            readSkeletonData(s) {
                let a = this.scale,
                    n = new t.SkeletonData,
                    i = "string" == typeof s ? JSON.parse(s) : s,
                    r = i.skeleton;
                if (null != r) {
                    if (n.hash = r.hash, n.version = r.spine, "3.8.75" == n.version) throw new Error("Unsupported skeleton data, please export with a newer version of Spine.");
                    n.x = r.x, n.y = r.y, n.width = r.width, n.height = r.height, n.fps = r.fps, n.imagesPath = r.images
                }
                if (i.bones)
                    for (let s = 0; s < i.bones.length; s++) {
                        let r = i.bones[s],
                            l = null,
                            o = this.getValue(r, "parent", null);
                        if (null != o && (l = n.findBone(o), null == l)) throw new Error("Parent bone not found: " + o);
                        let h = new t.BoneData(n.bones.length, r.name, l);
                        h.length = this.getValue(r, "length", 0) * a, h.x = this.getValue(r, "x", 0) * a, h.y = this.getValue(r, "y", 0) * a, h.rotation = this.getValue(r, "rotation", 0), h.scaleX = this.getValue(r, "scaleX", 1), h.scaleY = this.getValue(r, "scaleY", 1), h.shearX = this.getValue(r, "shearX", 0), h.shearY = this.getValue(r, "shearY", 0), h.transformMode = e.transformModeFromString(this.getValue(r, "transform", "normal")), h.skinRequired = this.getValue(r, "skin", !1), n.bones.push(h)
                    }
                if (i.slots)
                    for (let s = 0; s < i.slots.length; s++) {
                        let a = i.slots[s],
                            r = a.name,
                            l = a.bone,
                            o = n.findBone(l);
                        if (null == o) throw new Error("Slot bone not found: " + l);
                        let h = new t.SlotData(n.slots.length, r, o),
                            d = this.getValue(a, "color", null);
                        null != d && h.color.setFromString(d);
                        let u = this.getValue(a, "dark", null);
                        null != u && (h.darkColor = new t.Color(1, 1, 1, 1), h.darkColor.setFromString(u)), h.attachmentName = this.getValue(a, "attachment", null), h.blendMode = e.blendModeFromString(this.getValue(a, "blend", "normal")), n.slots.push(h)
                    }
                if (i.ik)
                    for (let e = 0; e < i.ik.length; e++) {
                        let s = i.ik[e],
                            r = new t.IkConstraintData(s.name);
                        r.order = this.getValue(s, "order", 0), r.skinRequired = this.getValue(s, "skin", !1);
                        for (let t = 0; t < s.bones.length; t++) {
                            let e = s.bones[t],
                                a = n.findBone(e);
                            if (null == a) throw new Error("IK bone not found: " + e);
                            r.bones.push(a)
                        }
                        let l = s.target;
                        if (r.target = n.findBone(l), null == r.target) throw new Error("IK target bone not found: " + l);
                        r.mix = this.getValue(s, "mix", 1), r.softness = this.getValue(s, "softness", 0) * a, r.bendDirection = this.getValue(s, "bendPositive", !0) ? 1 : -1, r.compress = this.getValue(s, "compress", !1), r.stretch = this.getValue(s, "stretch", !1), r.uniform = this.getValue(s, "uniform", !1), n.ikConstraints.push(r)
                    }
                if (i.transform)
                    for (let e = 0; e < i.transform.length; e++) {
                        let s = i.transform[e],
                            r = new t.TransformConstraintData(s.name);
                        r.order = this.getValue(s, "order", 0), r.skinRequired = this.getValue(s, "skin", !1);
                        for (let t = 0; t < s.bones.length; t++) {
                            let e = s.bones[t],
                                a = n.findBone(e);
                            if (null == a) throw new Error("Transform constraint bone not found: " + e);
                            r.bones.push(a)
                        }
                        let l = s.target;
                        if (r.target = n.findBone(l), null == r.target) throw new Error("Transform constraint target bone not found: " + l);
                        r.local = this.getValue(s, "local", !1), r.relative = this.getValue(s, "relative", !1), r.offsetRotation = this.getValue(s, "rotation", 0), r.offsetX = this.getValue(s, "x", 0) * a, r.offsetY = this.getValue(s, "y", 0) * a, r.offsetScaleX = this.getValue(s, "scaleX", 0), r.offsetScaleY = this.getValue(s, "scaleY", 0), r.offsetShearY = this.getValue(s, "shearY", 0), r.rotateMix = this.getValue(s, "rotateMix", 1), r.translateMix = this.getValue(s, "translateMix", 1), r.scaleMix = this.getValue(s, "scaleMix", 1), r.shearMix = this.getValue(s, "shearMix", 1), n.transformConstraints.push(r)
                    }
                if (i.path)
                    for (let s = 0; s < i.path.length; s++) {
                        let r = i.path[s],
                            l = new t.PathConstraintData(r.name);
                        l.order = this.getValue(r, "order", 0),
                            l.skinRequired = this.getValue(r, "skin", !1);
                        for (let t = 0; t < r.bones.length; t++) {
                            let e = r.bones[t],
                                s = n.findBone(e);
                            if (null == s) throw new Error("Transform constraint bone not found: " + e);
                            l.bones.push(s)
                        }
                        let o = r.target;
                        if (l.target = n.findSlot(o), null == l.target) throw new Error("Path target slot not found: " + o);
                        l.positionMode = e.positionModeFromString(this.getValue(r, "positionMode", "percent")), l.spacingMode = e.spacingModeFromString(this.getValue(r, "spacingMode", "length")), l.rotateMode = e.rotateModeFromString(this.getValue(r, "rotateMode", "tangent")), l.offsetRotation = this.getValue(r, "rotation", 0), l.position = this.getValue(r, "position", 0), l.positionMode == t.PositionMode.Fixed && (l.position *= a), l.spacing = this.getValue(r, "spacing", 0), l.spacingMode != t.SpacingMode.Length && l.spacingMode != t.SpacingMode.Fixed || (l.spacing *= a), l.rotateMix = this.getValue(r, "rotateMix", 1), l.translateMix = this.getValue(r, "translateMix", 1), n.pathConstraints.push(l)
                    }
                if (i.skins)
                    for (let e = 0; e < i.skins.length; e++) {
                        let s = i.skins[e],
                            a = new t.Skin(s.name);
                        if (s.bones)
                            for (let t = 0; t < s.bones.length; t++) {
                                let i = n.findBone(s.bones[t]);
                                if (null == i) throw new Error("Skin bone not found: " + s.bones[e]);
                                a.bones.push(i)
                            }
                        if (s.ik)
                            for (let t = 0; t < s.ik.length; t++) {
                                let i = n.findIkConstraint(s.ik[t]);
                                if (null == i) throw new Error("Skin IK constraint not found: " + s.ik[e]);
                                a.constraints.push(i)
                            }
                        if (s.transform)
                            for (let t = 0; t < s.transform.length; t++) {
                                let i = n.findTransformConstraint(s.transform[t]);
                                if (null == i) throw new Error("Skin transform constraint not found: " + s.transform[e]);
                                a.constraints.push(i)
                            }
                        if (s.path)
                            for (let t = 0; t < s.path.length; t++) {
                                let i = n.findPathConstraint(s.path[t]);
                                if (null == i) throw new Error("Skin path constraint not found: " + s.path[e]);
                                a.constraints.push(i)
                            }
                        for (let t in s.attachments) {
                            let e = n.findSlot(t);
                            if (null == e) throw new Error("Slot not found: " + t);
                            let i = s.attachments[t];
                            for (let t in i) {
                                let s = this.readAttachment(i[t], a, e.index, t, n);
                                null != s && a.setAttachment(e.index, t, s)
                            }
                        }
                        n.skins.push(a), "default" == a.name && (n.defaultSkin = a)
                    }
                for (let t = 0, e = this.linkedMeshes.length; t < e; t++) {
                    let e = this.linkedMeshes[t],
                        s = null == e.skin ? n.defaultSkin : n.findSkin(e.skin);
                    if (null == s) throw new Error("Skin not found: " + e.skin);
                    let a = s.getAttachment(e.slotIndex, e.parent);
                    if (null == a) throw new Error("Parent mesh not found: " + e.parent);
                    e.mesh.deformAttachment = e.inheritDeform ? a : e.mesh, e.mesh.setParentMesh(a), e.mesh.updateUVs()
                }
                if (this.linkedMeshes.length = 0, i.events)
                    for (let e in i.events) {
                        let s = i.events[e],
                            a = new t.EventData(e);
                        a.intValue = this.getValue(s, "int", 0), a.floatValue = this.getValue(s, "float", 0), a.stringValue = this.getValue(s, "string", ""), a.audioPath = this.getValue(s, "audio", null), null != a.audioPath && (a.volume = this.getValue(s, "volume", 1), a.balance = this.getValue(s, "balance", 0)), n.events.push(a)
                    }
                if (i.animations)
                    for (let t in i.animations) {
                        let e = i.animations[t];
                        this.readAnimation(e, t, n)
                    }
                return n
            }
            readAttachment(e, a, n, i, r) {
                let l = this.scale;
                i = this.getValue(e, "name", i);
                let o = this.getValue(e, "type", "region");
                switch (o) {
                    case "region":
                        {
                            let t = this.getValue(e, "path", i),
                                s = this.attachmentLoader.newRegionAttachment(a, i, t);
                            if (null == s) return null;
                            s.path = t, s.x = this.getValue(e, "x", 0) * l, s.y = this.getValue(e, "y", 0) * l, s.scaleX = this.getValue(e, "scaleX", 1), s.scaleY = this.getValue(e, "scaleY", 1), s.rotation = this.getValue(e, "rotation", 0), s.width = e.width * l, s.height = e.height * l;
                            let n = this.getValue(e, "color", null);
                            return null != n && s.color.setFromString(n), s.updateOffset(), s
                        }
                    case "boundingbox":
                        {
                            let t = this.attachmentLoader.newBoundingBoxAttachment(a, i);
                            if (null == t) return null;
                            this.readVertices(e, t, e.vertexCount << 1);
                            let s = this.getValue(e, "color", null);
                            return null != s && t.color.setFromString(s), t
                        }
                    case "mesh":
                    case "linkedmesh":
                        {
                            let t = this.getValue(e, "path", i),
                                r = this.attachmentLoader.newMeshAttachment(a, i, t);
                            if (null == r) return null;
                            r.path = t;
                            let o = this.getValue(e, "color", null);
                            null != o && r.color.setFromString(o), r.width = this.getValue(e, "width", 0) * l, r.height = this.getValue(e, "height", 0) * l;
                            let h = this.getValue(e, "parent", null);
                            if (null != h) return this.linkedMeshes.push(new s(r, this.getValue(e, "skin", null), n, h, this.getValue(e, "deform", !0))), r;
                            let d = e.uvs;
                            return this.readVertices(e, r, d.length), r.triangles = e.triangles, r.regionUVs = d, r.updateUVs(), r.edges = this.getValue(e, "edges", null), r.hullLength = 2 * this.getValue(e, "hull", 0), r
                        }
                    case "path":
                        {
                            let s = this.attachmentLoader.newPathAttachment(a, i);
                            if (null == s) return null;
                            s.closed = this.getValue(e, "closed", !1), s.constantSpeed = this.getValue(e, "constantSpeed", !0);
                            let n = e.vertexCount;
                            this.readVertices(e, s, n << 1);
                            let r = t.Utils.newArray(n / 3, 0);
                            for (let t = 0; t < e.lengths.length; t++) r[t] = e.lengths[t] * l;
                            s.lengths = r;
                            let o = this.getValue(e, "color", null);
                            return null != o && s.color.setFromString(o), s
                        }
                    case "point":
                        {
                            let t = this.attachmentLoader.newPointAttachment(a, i);
                            if (null == t) return null;
                            t.x = this.getValue(e, "x", 0) * l, t.y = this.getValue(e, "y", 0) * l, t.rotation = this.getValue(e, "rotation", 0);
                            let s = this.getValue(e, "color", null);
                            return null != s && t.color.setFromString(s), t
                        }
                    case "clipping":
                        {
                            let t = this.attachmentLoader.newClippingAttachment(a, i);
                            if (null == t) return null;
                            let s = this.getValue(e, "end", null);
                            if (null != s) {
                                let e = r.findSlot(s);
                                if (null == e) throw new Error("Clipping end slot not found: " + s);
                                t.endSlot = e
                            }
                            let n = e.vertexCount;
                            this.readVertices(e, t, n << 1);
                            let l = this.getValue(e, "color", null);
                            return null != l && t.color.setFromString(l), t
                        }
                }
                return null
            }
            readVertices(e, s, a) {
                let n = this.scale;
                s.worldVerticesLength = a;
                let i = e.vertices;
                if (a == i.length) {
                    let e = t.Utils.toFloatArray(i);
                    if (1 != n)
                        for (let t = 0, s = i.length; t < s; t++) e[t] *= n;
                    return void(s.vertices = e)
                }
                let r = new Array,
                    l = new Array;
                for (let t = 0, e = i.length; t < e;) {
                    let e = i[t++];
                    l.push(e);
                    for (let s = t + 4 * e; t < s; t += 4) l.push(i[t]), r.push(i[t + 1] * n), r.push(i[t + 2] * n), r.push(i[t + 3])
                }
                s.bones = l, s.vertices = t.Utils.toFloatArray(r)
            }
            readAnimation(e, s, a) {
                let n = this.scale,
                    i = new Array,
                    r = 0;
                if (e.slots)
                    for (let s in e.slots) {
                        let n = e.slots[s],
                            l = a.findSlotIndex(s);
                        if (-1 == l) throw new Error("Slot not found: " + s);
                        for (let e in n) {
                            let a = n[e];
                            if ("attachment" == e) {
                                let e = new t.AttachmentTimeline(a.length);
                                e.slotIndex = l;
                                let s = 0;
                                for (let t = 0; t < a.length; t++) {
                                    let n = a[t];
                                    e.setFrame(s++, this.getValue(n, "time", 0), n.name)
                                }
                                i.push(e), r = Math.max(r, e.frames[e.getFrameCount() - 1])
                            } else if ("color" == e) {
                                let e = new t.ColorTimeline(a.length);
                                e.slotIndex = l;
                                let s = 0;
                                for (let n = 0; n < a.length; n++) {
                                    let i = a[n],
                                        r = new t.Color;
                                    r.setFromString(i.color), e.setFrame(s, this.getValue(i, "time", 0), r.r, r.g, r.b, r.a), this.readCurve(i, e, s), s++
                                }
                                i.push(e), r = Math.max(r, e.frames[(e.getFrameCount() - 1) * t.ColorTimeline.ENTRIES])
                            } else {
                                if ("twoColor" != e) throw new Error("Invalid timeline type for a slot: " + e + " (" + s + ")"); {
                                    let e = new t.TwoColorTimeline(a.length);
                                    e.slotIndex = l;
                                    let s = 0;
                                    for (let n = 0; n < a.length; n++) {
                                        let i = a[n],
                                            r = new t.Color,
                                            l = new t.Color;
                                        r.setFromString(i.light), l.setFromString(i.dark), e.setFrame(s, this.getValue(i, "time", 0), r.r, r.g, r.b, r.a, l.r, l.g, l.b), this.readCurve(i, e, s), s++
                                    }
                                    i.push(e), r = Math.max(r, e.frames[(e.getFrameCount() - 1) * t.TwoColorTimeline.ENTRIES])
                                }
                            }
                        }
                    }
                if (e.bones)
                    for (let s in e.bones) {
                        let l = e.bones[s],
                            o = a.findBoneIndex(s);
                        if (-1 == o) throw new Error("Bone not found: " + s);
                        for (let e in l) {
                            let a = l[e];
                            if ("rotate" === e) {
                                let e = new t.RotateTimeline(a.length);
                                e.boneIndex = o;
                                let s = 0;
                                for (let t = 0; t < a.length; t++) {
                                    let n = a[t];
                                    e.setFrame(s, this.getValue(n, "time", 0), this.getValue(n, "angle", 0)), this.readCurve(n, e, s), s++
                                }
                                i.push(e), r = Math.max(r, e.frames[(e.getFrameCount() - 1) * t.RotateTimeline.ENTRIES])
                            } else {
                                if ("translate" !== e && "scale" !== e && "shear" !== e) throw new Error("Invalid timeline type for a bone: " + e + " (" + s + ")"); {
                                    let s = null,
                                        l = 1,
                                        h = 0;
                                    "scale" === e ? (s = new t.ScaleTimeline(a.length), h = 1) : "shear" === e ? s = new t.ShearTimeline(a.length) : (s = new t.TranslateTimeline(a.length), l = n), s.boneIndex = o;
                                    let d = 0;
                                    for (let t = 0; t < a.length; t++) {
                                        let e = a[t],
                                            n = this.getValue(e, "x", h),
                                            i = this.getValue(e, "y", h);
                                        s.setFrame(d, this.getValue(e, "time", 0), n * l, i * l), this.readCurve(e, s, d), d++
                                    }
                                    i.push(s), r = Math.max(r, s.frames[(s.getFrameCount() - 1) * t.TranslateTimeline.ENTRIES])
                                }
                            }
                        }
                    }
                if (e.ik)
                    for (let s in e.ik) {
                        let l = e.ik[s],
                            o = a.findIkConstraint(s),
                            h = new t.IkConstraintTimeline(l.length);
                        h.ikConstraintIndex = a.ikConstraints.indexOf(o);
                        let d = 0;
                        for (let t = 0; t < l.length; t++) {
                            let e = l[t];
                            h.setFrame(d, this.getValue(e, "time", 0), this.getValue(e, "mix", 1), this.getValue(e, "softness", 0) * n, this.getValue(e, "bendPositive", !0) ? 1 : -1, this.getValue(e, "compress", !1), this.getValue(e, "stretch", !1)), this.readCurve(e, h, d), d++
                        }
                        i.push(h), r = Math.max(r, h.frames[(h.getFrameCount() - 1) * t.IkConstraintTimeline.ENTRIES])
                    }
                if (e.transform)
                    for (let s in e.transform) {
                        let n = e.transform[s],
                            l = a.findTransformConstraint(s),
                            o = new t.TransformConstraintTimeline(n.length);
                        o.transformConstraintIndex = a.transformConstraints.indexOf(l);
                        let h = 0;
                        for (let t = 0; t < n.length; t++) {
                            let e = n[t];
                            o.setFrame(h, this.getValue(e, "time", 0), this.getValue(e, "rotateMix", 1), this.getValue(e, "translateMix", 1), this.getValue(e, "scaleMix", 1), this.getValue(e, "shearMix", 1)), this.readCurve(e, o, h), h++
                        }
                        i.push(o), r = Math.max(r, o.frames[(o.getFrameCount() - 1) * t.TransformConstraintTimeline.ENTRIES])
                    }
                if (e.path)
                    for (let s in e.path) {
                        let l = e.path[s],
                            o = a.findPathConstraintIndex(s);
                        if (-1 == o) throw new Error("Path constraint not found: " + s);
                        let h = a.pathConstraints[o];
                        for (let e in l) {
                            let s = l[e];
                            if ("position" === e || "spacing" === e) {
                                let a = null,
                                    l = 1;
                                "spacing" === e ? (a = new t.PathConstraintSpacingTimeline(s.length), h.spacingMode != t.SpacingMode.Length && h.spacingMode != t.SpacingMode.Fixed || (l = n)) : (a = new t.PathConstraintPositionTimeline(s.length), h.positionMode == t.PositionMode.Fixed && (l = n)), a.pathConstraintIndex = o;
                                let d = 0;
                                for (let t = 0; t < s.length; t++) {
                                    let n = s[t];
                                    a.setFrame(d, this.getValue(n, "time", 0), this.getValue(n, e, 0) * l), this.readCurve(n, a, d), d++
                                }
                                i.push(a), r = Math.max(r, a.frames[(a.getFrameCount() - 1) * t.PathConstraintPositionTimeline.ENTRIES])
                            } else if ("mix" === e) {
                                let e = new t.PathConstraintMixTimeline(s.length);
                                e.pathConstraintIndex = o;
                                let a = 0;
                                for (let t = 0; t < s.length; t++) {
                                    let n = s[t];
                                    e.setFrame(a, this.getValue(n, "time", 0), this.getValue(n, "rotateMix", 1), this.getValue(n, "translateMix", 1)), this.readCurve(n, e, a), a++
                                }
                                i.push(e), r = Math.max(r, e.frames[(e.getFrameCount() - 1) * t.PathConstraintMixTimeline.ENTRIES])
                            }
                        }
                    }
                if (e.deform)
                    for (let s in e.deform) {
                        let l = e.deform[s],
                            o = a.findSkin(s);
                        if (null == o) throw new Error("Skin not found: " + s);
                        for (let e in l) {
                            let s = l[e],
                                h = a.findSlotIndex(e);
                            if (-1 == h) throw new Error("Slot not found: " + s.name);
                            for (let e in s) {
                                let a = s[e],
                                    l = o.getAttachment(h, e);
                                if (null == l) throw new Error("Deform attachment not found: " + a.name);
                                let d = null != l.bones,
                                    u = l.vertices,
                                    c = d ? u.length / 3 * 2 : u.length,
                                    f = new t.DeformTimeline(a.length);
                                f.slotIndex = h, f.attachment = l;
                                let m = 0;
                                for (let e = 0; e < a.length; e++) {
                                    let s, i = a[e],
                                        r = this.getValue(i, "vertices", null);
                                    if (null == r) s = d ? t.Utils.newFloatArray(c) : u;
                                    else {
                                        s = t.Utils.newFloatArray(c);
                                        let e = this.getValue(i, "offset", 0);
                                        if (t.Utils.arrayCopy(r, 0, s, e, r.length), 1 != n)
                                            for (let t = e, a = t + r.length; t < a; t++) s[t] *= n;
                                        if (!d)
                                            for (let t = 0; t < c; t++) s[t] += u[t]
                                    }
                                    f.setFrame(m, this.getValue(i, "time", 0), s), this.readCurve(i, f, m), m++
                                }
                                i.push(f), r = Math.max(r, f.frames[f.getFrameCount() - 1])
                            }
                        }
                    }
                let l = e.drawOrder;
                if (null == l && (l = e.draworder), null != l) {
                    let e = new t.DrawOrderTimeline(l.length),
                        s = a.slots.length,
                        n = 0;
                    for (let i = 0; i < l.length; i++) {
                        let r = l[i],
                            o = null,
                            h = this.getValue(r, "offsets", null);
                        if (null != h) {
                            o = t.Utils.newArray(s, -1);
                            let e = t.Utils.newArray(s - h.length, 0),
                                n = 0,
                                i = 0;
                            for (let t = 0; t < h.length; t++) {
                                let s = h[t],
                                    r = a.findSlotIndex(s.slot);
                                if (-1 == r) throw new Error("Slot not found: " + s.slot);
                                for (; n != r;) e[i++] = n++;
                                o[n + s.offset] = n++
                            }
                            for (; n < s;) e[i++] = n++;
                            for (let t = s - 1; t >= 0; t--) - 1 == o[t] && (o[t] = e[--i])
                        }
                        e.setFrame(n++, this.getValue(r, "time", 0), o)
                    }
                    i.push(e), r = Math.max(r, e.frames[e.getFrameCount() - 1])
                }
                if (e.events) {
                    let s = new t.EventTimeline(e.events.length),
                        n = 0;
                    for (let i = 0; i < e.events.length; i++) {
                        let r = e.events[i],
                            l = a.findEvent(r.name);
                        if (null == l) throw new Error("Event not found: " + r.name);
                        let o = new t.Event(t.Utils.toSinglePrecision(this.getValue(r, "time", 0)), l);
                        o.intValue = this.getValue(r, "int", l.intValue), o.floatValue = this.getValue(r, "float", l.floatValue), o.stringValue = this.getValue(r, "string", l.stringValue), null != o.data.audioPath && (o.volume = this.getValue(r, "volume", 1), o.balance = this.getValue(r, "balance", 0)), s.setFrame(n++, o)
                    }
                    i.push(s), r = Math.max(r, s.frames[s.getFrameCount() - 1])
                }
                if (isNaN(r)) throw new Error("Error while parsing animation, duration is NaN");
                a.animations.push(new t.Animation(s, i, r))
            }
            readCurve(t, e, s) {
                if (t.hasOwnProperty("curve"))
                    if ("stepped" == t.curve) e.setStepped(s);
                    else {
                        let a = t.curve;
                        e.setCurve(s, a, this.getValue(t, "c2", 0), this.getValue(t, "c3", 1), this.getValue(t, "c4", 1))
                    }
            }
            getValue(t, e, s) {
                return void 0 !== t[e] ? t[e] : s
            }
            static blendModeFromString(e) {
                if (e = e.toLowerCase(), "normal" == e) return t.BlendMode.Normal;
                if ("additive" == e) return t.BlendMode.Additive;
                if ("multiply" == e) return t.BlendMode.Multiply;
                if ("screen" == e) return t.BlendMode.Screen;
                throw new Error(`Unknown blend mode: ${e}`)
            }
            static positionModeFromString(e) {
                if (e = e.toLowerCase(), "fixed" == e) return t.PositionMode.Fixed;
                if ("percent" == e) return t.PositionMode.Percent;
                throw new Error(`Unknown position mode: ${e}`)
            }
            static spacingModeFromString(e) {
                if (e = e.toLowerCase(), "length" == e) return t.SpacingMode.Length;
                if ("fixed" == e) return t.SpacingMode.Fixed;
                if ("percent" == e) return t.SpacingMode.Percent;
                throw new Error(`Unknown position mode: ${e}`)
            }
            static rotateModeFromString(e) {
                if (e = e.toLowerCase(), "tangent" == e) return t.RotateMode.Tangent;
                if ("chain" == e) return t.RotateMode.Chain;
                if ("chainscale" == e) return t.RotateMode.ChainScale;
                throw new Error(`Unknown rotate mode: ${e}`)
            }
            static transformModeFromString(e) {
                if (e = e.toLowerCase(), "normal" == e) return t.TransformMode.Normal;
                if ("onlytranslation" == e) return t.TransformMode.OnlyTranslation;
                if ("norotationorreflection" == e) return t.TransformMode.NoRotationOrReflection;
                if ("noscale" == e) return t.TransformMode.NoScale;
                if ("noscaleorreflection" == e) return t.TransformMode.NoScaleOrReflection;
                throw new Error(`Unknown transform mode: ${e}`)
            }
        }
        t.SkeletonJson = e;
        class s {
            constructor(t, e, s, a, n) {
                this.mesh = t, this.skin = e, this.slotIndex = s, this.parent = a, this.inheritDeform = n
            }
        }
    }(spine || (spine = {})),
    function(t) {
        class e {
            constructor(t, e, s) {
                this.slotIndex = t, this.name = e, this.attachment = s
            }
        }
        t.SkinEntry = e;
        class s {
            constructor(t) {
                if (this.attachments = new Array, this.bones = Array(), this.constraints = new Array, null == t) throw new Error("name cannot be null.");
                this.name = t
            }
            setAttachment(t, e, s) {
                if (null == s) throw new Error("attachment cannot be null.");
                let a = this.attachments;
                t >= a.length && (a.length = t + 1), a[t] || (a[t] = {}), a[t][e] = s
            }
            addSkin(t) {
                for (let e = 0; e < t.bones.length; e++) {
                    let s = t.bones[e],
                        a = !1;
                    for (let t = 0; t < this.bones.length; t++)
                        if (this.bones[t] == s) {
                            a = !0;
                            break
                        }
                    a || this.bones.push(s)
                }
                for (let e = 0; e < t.constraints.length; e++) {
                    let s = t.constraints[e],
                        a = !1;
                    for (let t = 0; t < this.constraints.length; t++)
                        if (this.constraints[t] == s) {
                            a = !0;
                            break
                        }
                    a || this.constraints.push(s)
                }
                let e = t.getAttachments();
                for (let t = 0; t < e.length; t++) {
                    var s = e[t];
                    this.setAttachment(s.slotIndex, s.name, s.attachment)
                }
            }
            copySkin(e) {
                for (let t = 0; t < e.bones.length; t++) {
                    let s = e.bones[t],
                        a = !1;
                    for (let t = 0; t < this.bones.length; t++)
                        if (this.bones[t] == s) {
                            a = !0;
                            break
                        }
                    a || this.bones.push(s)
                }
                for (let t = 0; t < e.constraints.length; t++) {
                    let s = e.constraints[t],
                        a = !1;
                    for (let t = 0; t < this.constraints.length; t++)
                        if (this.constraints[t] == s) {
                            a = !0;
                            break
                        }
                    a || this.constraints.push(s)
                }
                let s = e.getAttachments();
                for (let e = 0; e < s.length; e++) {
                    var a = s[e];
                    null != a.attachment && (a.attachment instanceof t.MeshAttachment ? (a.attachment = a.attachment.newLinkedMesh(), this.setAttachment(a.slotIndex, a.name, a.attachment)) : (a.attachment = a.attachment.copy(), this.setAttachment(a.slotIndex, a.name, a.attachment)))
                }
            }
            getAttachment(t, e) {
                let s = this.attachments[t];
                return s ? s[e] : null
            }
            removeAttachment(t, e) {
                let s = this.attachments[t];
                s && (s[e] = null)
            }
            getAttachments() {
                let t = new Array;
                for (var s = 0; s < this.attachments.length; s++) {
                    let a = this.attachments[s];
                    if (a)
                        for (let n in a) {
                            let i = a[n];
                            i && t.push(new e(s, n, i))
                        }
                }
                return t
            }
            getAttachmentsForSlot(t, s) {
                let a = this.attachments[t];
                if (a)
                    for (let n in a) {
                        let i = a[n];
                        i && s.push(new e(t, n, i))
                    }
            }
            clear() {
                this.attachments.length = 0, this.bones.length = 0, this.constraints.length = 0
            }
            attachAll(t, e) {
                let s = 0;
                for (let a = 0; a < t.slots.length; a++) {
                    let n = t.slots[a],
                        i = n.getAttachment();
                    if (i && s < e.attachments.length) {
                        let t = e.attachments[s];
                        for (let e in t) {
                            let a = t[e];
                            if (i == a) {
                                let t = this.getAttachment(s, e);
                                null != t && n.setAttachment(t);
                                break
                            }
                        }
                    }
                    s++
                }
            }
        }
        t.Skin = s
    }(spine || (spine = {})),
    function(t) {
        class e {
            constructor(e, s) {
                if (this.deform = new Array, null == e) throw new Error("data cannot be null.");
                if (null == s) throw new Error("bone cannot be null.");
                this.data = e, this.bone = s, this.color = new t.Color, this.darkColor = null == e.darkColor ? null : new t.Color, this.setToSetupPose()
            }
            getSkeleton() {
                return this.bone.skeleton
            }
            getAttachment() {
                return this.attachment
            }
            setAttachment(t) {
                this.attachment != t && (this.attachment = t, this.attachmentTime = this.bone.skeleton.time, this.deform.length = 0)
            }
            setAttachmentTime(t) {
                this.attachmentTime = this.bone.skeleton.time - t
            }
            getAttachmentTime() {
                return this.bone.skeleton.time - this.attachmentTime
            }
            setToSetupPose() {
                this.color.setFromColor(this.data.color), null != this.darkColor && this.darkColor.setFromColor(this.data.darkColor), null == this.data.attachmentName ? this.attachment = null : (this.attachment = null, this.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName)))
            }
        }
        t.Slot = e
    }(spine || (spine = {})),
    function(t) {
        class e {
            constructor(e, s, a) {
                if (this.color = new t.Color(1, 1, 1, 1), e < 0) throw new Error("index must be >= 0.");
                if (null == s) throw new Error("name cannot be null.");
                if (null == a) throw new Error("boneData cannot be null.");
                this.index = e, this.name = s, this.boneData = a
            }
        }
        t.SlotData = e
    }(spine || (spine = {})),
    function(t) {
        class e {
            constructor(t) {
                this._image = t
            }
            getImage() {
                return this._image
            }
            static filterFromString(t) {
                switch (t.toLowerCase()) {
                    case "nearest":
                        return s.Nearest;
                    case "linear":
                        return s.Linear;
                    case "mipmap":
                        return s.MipMap;
                    case "mipmapnearestnearest":
                        return s.MipMapNearestNearest;
                    case "mipmaplinearnearest":
                        return s.MipMapLinearNearest;
                    case "mipmapnearestlinear":
                        return s.MipMapNearestLinear;
                    case "mipmaplinearlinear":
                        return s.MipMapLinearLinear;
                    default:
                        throw new Error(`Unknown texture filter ${t}`)
                }
            }
            static wrapFromString(t) {
                switch (t.toLowerCase()) {
                    case "mirroredtepeat":
                        return a.MirroredRepeat;
                    case "clamptoedge":
                        return a.ClampToEdge;
                    case "repeat":
                        return a.Repeat;
                    default:
                        throw new Error(`Unknown texture wrap ${t}`)
                }
            }
        }
        let s, a;
        t.Texture = e,
            function(t) {
                t[t.Nearest = 9728] = "Nearest", t[t.Linear = 9729] = "Linear", t[t.MipMap = 9987] = "MipMap", t[t.MipMapNearestNearest = 9984] = "MipMapNearestNearest", t[t.MipMapLinearNearest = 9985] = "MipMapLinearNearest", t[t.MipMapNearestLinear = 9986] = "MipMapNearestLinear", t[t.MipMapLinearLinear = 9987] = "MipMapLinearLinear"
            }(s = t.TextureFilter || (t.TextureFilter = {})),
            function(t) {
                t[t.MirroredRepeat = 33648] = "MirroredRepeat", t[t.ClampToEdge = 33071] = "ClampToEdge", t[t.Repeat = 10497] = "Repeat"
            }(a = t.TextureWrap || (t.TextureWrap = {}));
        class n {
            constructor() {
                this.u = 0, this.v = 0, this.u2 = 0, this.v2 = 0, this.width = 0, this.height = 0, this.rotate = !1, this.offsetX = 0, this.offsetY = 0, this.originalWidth = 0, this.originalHeight = 0
            }
        }
        t.TextureRegion = n;
        class i extends e {
            setFilters(t, e) {}
            setWraps(t, e) {}
            dispose() {}
        }
        t.FakeTexture = i
    }(spine || (spine = {})),
    function(t) {
        class e {
            constructor(t, e) {
                this.pages = new Array, this.regions = new Array, this.load(t, e)
            }
            load(e, i) {
                if (null == i) throw new Error("textureLoader cannot be null.");
                let r = new s(e),
                    l = new Array(4),
                    o = null;
                for (;;) {
                    let e = r.readLine();
                    if (null == e) break;
                    if (e = e.trim(), 0 == e.length) o = null;
                    else if (o) {
                        let t = new n;
                        t.name = e, t.page = o;
                        let s = r.readValue();
                        "true" == s.toLocaleLowerCase() ? t.degrees = 90 : "false" == s.toLocaleLowerCase() ? t.degrees = 0 : t.degrees = parseFloat(s), t.rotate = 90 == t.degrees, r.readTuple(l);
                        let a = parseInt(l[0]),
                            i = parseInt(l[1]);
                        r.readTuple(l);
                        let h = parseInt(l[0]),
                            d = parseInt(l[1]);
                        t.u = a / o.width, t.v = i / o.height, t.rotate ? (t.u2 = (a + d) / o.width, t.v2 = (i + h) / o.height) : (t.u2 = (a + h) / o.width, t.v2 = (i + d) / o.height), t.x = a, t.y = i, t.width = Math.abs(h), t.height = Math.abs(d), 4 == r.readTuple(l) && 4 == r.readTuple(l) && r.readTuple(l), t.originalWidth = parseInt(l[0]), t.originalHeight = parseInt(l[1]), r.readTuple(l), t.offsetX = parseInt(l[0]), t.offsetY = parseInt(l[1]), t.index = parseInt(r.readValue()), t.texture = o.texture, this.regions.push(t)
                    } else {
                        o = new a, o.name = e, 2 == r.readTuple(l) && (o.width = parseInt(l[0]), o.height = parseInt(l[1]), r.readTuple(l)), r.readTuple(l), o.minFilter = t.Texture.filterFromString(l[0]), o.magFilter = t.Texture.filterFromString(l[1]);
                        let s = r.readValue();
                        o.uWrap = t.TextureWrap.ClampToEdge, o.vWrap = t.TextureWrap.ClampToEdge, "x" == s ? o.uWrap = t.TextureWrap.Repeat : "y" == s ? o.vWrap = t.TextureWrap.Repeat : "xy" == s && (o.uWrap = o.vWrap = t.TextureWrap.Repeat), o.texture = i(e), o.texture.setFilters(o.minFilter, o.magFilter), o.texture.setWraps(o.uWrap, o.vWrap), o.width = o.texture.getImage().width, o.height = o.texture.getImage().height, this.pages.push(o)
                    }
                }
            }
            findRegion(t) {
                for (let e = 0; e < this.regions.length; e++)
                    if (this.regions[e].name == t) return this.regions[e];
                return null
            }
            dispose() {
                for (let t = 0; t < this.pages.length; t++) this.pages[t].texture.dispose()
            }
        }
        t.TextureAtlas = e;
        class s {
            constructor(t) {
                this.index = 0, this.lines = t.split(/\r\n|\r|\n/)
            }
            readLine() {
                return this.index >= this.lines.length ? null : this.lines[this.index++]
            }
            readValue() {
                let t = this.readLine(),
                    e = t.indexOf(":");
                if (-1 == e) throw new Error("Invalid line: " + t);
                return t.substring(e + 1).trim()
            }
            readTuple(t) {
                let e = this.readLine(),
                    s = e.indexOf(":");
                if (-1 == s) throw new Error("Invalid line: " + e);
                let a = 0,
                    n = s + 1;
                for (; a < 3; a++) {
                    let s = e.indexOf(",", n);
                    if (-1 == s) break;
                    t[a] = e.substr(n, s - n).trim(), n = s + 1
                }
                return t[a] = e.substring(n).trim(), a + 1
            }
        }
        class a {}
        t.TextureAtlasPage = a;
        class n extends t.TextureRegion {}
        t.TextureAtlasRegion = n
    }(spine || (spine = {})),
    function(t) {
        class e {
            constructor(e, s) {
                if (this.rotateMix = 0, this.translateMix = 0, this.scaleMix = 0, this.shearMix = 0, this.temp = new t.Vector2, this.active = !1, null == e) throw new Error("data cannot be null.");
                if (null == s) throw new Error("skeleton cannot be null.");
                this.data = e, this.rotateMix = e.rotateMix, this.translateMix = e.translateMix, this.scaleMix = e.scaleMix, this.shearMix = e.shearMix, this.bones = new Array;
                for (let t = 0; t < e.bones.length; t++) this.bones.push(s.findBone(e.bones[t].name));
                this.target = s.findBone(e.target.name)
            }
            isActive() {
                return this.active
            }
            apply() {
                this.update()
            }
            update() {
                this.data.local ? this.data.relative ? this.applyRelativeLocal() : this.applyAbsoluteLocal() : this.data.relative ? this.applyRelativeWorld() : this.applyAbsoluteWorld()
            }
            applyAbsoluteWorld() {
                let e = this.rotateMix,
                    s = this.translateMix,
                    a = this.scaleMix,
                    n = this.shearMix,
                    i = this.target,
                    r = i.a,
                    l = i.b,
                    o = i.c,
                    h = i.d,
                    d = r * h - l * o > 0 ? t.MathUtils.degRad : -t.MathUtils.degRad,
                    u = this.data.offsetRotation * d,
                    c = this.data.offsetShearY * d,
                    f = this.bones;
                for (let d = 0, m = f.length; d < m; d++) {
                    let m = f[d],
                        g = !1;
                    if (0 != e) {
                        let s = m.a,
                            a = m.b,
                            n = m.c,
                            i = m.d,
                            l = Math.atan2(o, r) - Math.atan2(n, s) + u;
                        l > t.MathUtils.PI ? l -= t.MathUtils.PI2 : l < -t.MathUtils.PI && (l += t.MathUtils.PI2), l *= e;
                        let h = Math.cos(l),
                            d = Math.sin(l);
                        m.a = h * s - d * n, m.b = h * a - d * i, m.c = d * s + h * n, m.d = d * a + h * i, g = !0
                    }
                    if (0 != s) {
                        let t = this.temp;
                        i.localToWorld(t.set(this.data.offsetX, this.data.offsetY)), m.worldX += (t.x - m.worldX) * s, m.worldY += (t.y - m.worldY) * s, g = !0
                    }
                    if (a > 0) {
                        let t = Math.sqrt(m.a * m.a + m.c * m.c),
                            e = Math.sqrt(r * r + o * o);
                        t > 1e-5 && (t = (t + (e - t + this.data.offsetScaleX) * a) / t), m.a *= t, m.c *= t, t = Math.sqrt(m.b * m.b + m.d * m.d), e = Math.sqrt(l * l + h * h), t > 1e-5 && (t = (t + (e - t + this.data.offsetScaleY) * a) / t), m.b *= t, m.d *= t, g = !0
                    }
                    if (n > 0) {
                        let e = m.b,
                            s = m.d,
                            a = Math.atan2(s, e),
                            i = Math.atan2(h, l) - Math.atan2(o, r) - (a - Math.atan2(m.c, m.a));
                        i > t.MathUtils.PI ? i -= t.MathUtils.PI2 : i < -t.MathUtils.PI && (i += t.MathUtils.PI2), i = a + (i + c) * n;
                        let d = Math.sqrt(e * e + s * s);
                        m.b = Math.cos(i) * d, m.d = Math.sin(i) * d, g = !0
                    }
                    g && (m.appliedValid = !1)
                }
            }
            applyRelativeWorld() {
                let e = this.rotateMix,
                    s = this.translateMix,
                    a = this.scaleMix,
                    n = this.shearMix,
                    i = this.target,
                    r = i.a,
                    l = i.b,
                    o = i.c,
                    h = i.d,
                    d = r * h - l * o > 0 ? t.MathUtils.degRad : -t.MathUtils.degRad,
                    u = this.data.offsetRotation * d,
                    c = this.data.offsetShearY * d,
                    f = this.bones;
                for (let d = 0, m = f.length; d < m; d++) {
                    let m = f[d],
                        g = !1;
                    if (0 != e) {
                        let s = m.a,
                            a = m.b,
                            n = m.c,
                            i = m.d,
                            l = Math.atan2(o, r) + u;
                        l > t.MathUtils.PI ? l -= t.MathUtils.PI2 : l < -t.MathUtils.PI && (l += t.MathUtils.PI2), l *= e;
                        let h = Math.cos(l),
                            d = Math.sin(l);
                        m.a = h * s - d * n, m.b = h * a - d * i, m.c = d * s + h * n, m.d = d * a + h * i, g = !0
                    }
                    if (0 != s) {
                        let t = this.temp;
                        i.localToWorld(t.set(this.data.offsetX, this.data.offsetY)), m.worldX += t.x * s, m.worldY += t.y * s, g = !0
                    }
                    if (a > 0) {
                        let t = (Math.sqrt(r * r + o * o) - 1 + this.data.offsetScaleX) * a + 1;
                        m.a *= t, m.c *= t, t = (Math.sqrt(l * l + h * h) - 1 + this.data.offsetScaleY) * a + 1, m.b *= t, m.d *= t, g = !0
                    }
                    if (n > 0) {
                        let e = Math.atan2(h, l) - Math.atan2(o, r);
                        e > t.MathUtils.PI ? e -= t.MathUtils.PI2 : e < -t.MathUtils.PI && (e += t.MathUtils.PI2);
                        let s = m.b,
                            a = m.d;
                        e = Math.atan2(a, s) + (e - t.MathUtils.PI / 2 + c) * n;
                        let i = Math.sqrt(s * s + a * a);
                        m.b = Math.cos(e) * i, m.d = Math.sin(e) * i, g = !0
                    }
                    g && (m.appliedValid = !1)
                }
            }
            applyAbsoluteLocal() {
                let t = this.rotateMix,
                    e = this.translateMix,
                    s = this.scaleMix,
                    a = this.shearMix,
                    n = this.target;
                n.appliedValid || n.updateAppliedTransform();
                let i = this.bones;
                for (let r = 0, l = i.length; r < l; r++) {
                    let l = i[r];
                    l.appliedValid || l.updateAppliedTransform();
                    let o = l.arotation;
                    if (0 != t) {
                        let e = n.arotation - o + this.data.offsetRotation;
                        e -= 360 * (16384 - (16384.499999999996 - e / 360 | 0)), o += e * t
                    }
                    let h = l.ax,
                        d = l.ay;
                    0 != e && (h += (n.ax - h + this.data.offsetX) * e, d += (n.ay - d + this.data.offsetY) * e);
                    let u = l.ascaleX,
                        c = l.ascaleY;
                    0 != s && (u > 1e-5 && (u = (u + (n.ascaleX - u + this.data.offsetScaleX) * s) / u), c > 1e-5 && (c = (c + (n.ascaleY - c + this.data.offsetScaleY) * s) / c));
                    let f = l.ashearY;
                    if (0 != a) {
                        let t = n.ashearY - f + this.data.offsetShearY;
                        t -= 360 * (16384 - (16384.499999999996 - t / 360 | 0)), l.shearY += t * a
                    }
                    l.updateWorldTransformWith(h, d, o, u, c, l.ashearX, f)
                }
            }
            applyRelativeLocal() {
                let t = this.rotateMix,
                    e = this.translateMix,
                    s = this.scaleMix,
                    a = this.shearMix,
                    n = this.target;
                n.appliedValid || n.updateAppliedTransform();
                let i = this.bones;
                for (let r = 0, l = i.length; r < l; r++) {
                    let l = i[r];
                    l.appliedValid || l.updateAppliedTransform();
                    let o = l.arotation;
                    0 != t && (o += (n.arotation + this.data.offsetRotation) * t);
                    let h = l.ax,
                        d = l.ay;
                    0 != e && (h += (n.ax + this.data.offsetX) * e, d += (n.ay + this.data.offsetY) * e);
                    let u = l.ascaleX,
                        c = l.ascaleY;
                    0 != s && (u > 1e-5 && (u *= (n.ascaleX - 1 + this.data.offsetScaleX) * s + 1), c > 1e-5 && (c *= (n.ascaleY - 1 + this.data.offsetScaleY) * s + 1));
                    let f = l.ashearY;
                    0 != a && (f += (n.ashearY + this.data.offsetShearY) * a), l.updateWorldTransformWith(h, d, o, u, c, l.ashearX, f)
                }
            }
        }
        t.TransformConstraint = e
    }(spine || (spine = {})),
    function(t) {
        class e extends t.ConstraintData {
            constructor(t) {
                super(t, 0, !1), this.bones = new Array, this.rotateMix = 0, this.translateMix = 0, this.scaleMix = 0, this.shearMix = 0, this.offsetRotation = 0, this.offsetX = 0, this.offsetY = 0, this.offsetScaleX = 0, this.offsetScaleY = 0, this.offsetShearY = 0, this.relative = !1, this.local = !1
            }
        }
        t.TransformConstraintData = e
    }(spine || (spine = {})),
    function(t) {
        class e {
            constructor() {
                this.convexPolygons = new Array, this.convexPolygonsIndices = new Array, this.indicesArray = new Array, this.isConcaveArray = new Array, this.triangles = new Array, this.polygonPool = new t.Pool(() => new Array), this.polygonIndicesPool = new t.Pool(() => new Array)
            }
            triangulate(t) {
                let s = t,
                    a = t.length >> 1,
                    n = this.indicesArray;
                n.length = 0;
                for (let t = 0; t < a; t++) n[t] = t;
                let i = this.isConcaveArray;
                i.length = 0;
                for (let t = 0, r = a; t < r; ++t) i[t] = e.isConcave(t, a, s, n);
                let r = this.triangles;
                for (r.length = 0; a > 3;) {
                    let t = a - 1,
                        l = 0,
                        o = 1;
                    for (;;) {
                        t: if (!i[l]) {
                            let r = n[t] << 1,
                                h = n[l] << 1,
                                d = n[o] << 1,
                                u = s[r],
                                c = s[r + 1],
                                f = s[h],
                                m = s[h + 1],
                                g = s[d],
                                p = s[d + 1];
                            for (let r = (o + 1) % a; r != t; r = (r + 1) % a) {
                                if (!i[r]) continue;
                                let t = n[r] << 1,
                                    a = s[t],
                                    l = s[t + 1];
                                if (e.positiveArea(g, p, u, c, a, l) && e.positiveArea(u, c, f, m, a, l) && e.positiveArea(f, m, g, p, a, l)) break t
                            }
                            break
                        }if (0 == o) {
                            do {
                                if (!i[l]) break;
                                l--
                            } while (l > 0);
                            break
                        }
                        t = l,
                        l = o,
                        o = (o + 1) % a
                    }
                    r.push(n[(a + l - 1) % a]), r.push(n[l]), r.push(n[(l + 1) % a]), n.splice(l, 1), i.splice(l, 1), a--;
                    let h = (a + l - 1) % a,
                        d = l == a ? 0 : l;
                    i[h] = e.isConcave(h, a, s, n), i[d] = e.isConcave(d, a, s, n)
                }
                return 3 == a && (r.push(n[2]), r.push(n[0]), r.push(n[1])), r
            }
            decompose(t, s) {
                let a = t,
                    n = this.convexPolygons;
                this.polygonPool.freeAll(n), n.length = 0;
                let i = this.convexPolygonsIndices;
                this.polygonIndicesPool.freeAll(i), i.length = 0;
                let r = this.polygonIndicesPool.obtain();
                r.length = 0;
                let l = this.polygonPool.obtain();
                l.length = 0;
                let o = -1,
                    h = 0;
                for (let t = 0, d = s.length; t < d; t += 3) {
                    let d = s[t] << 1,
                        u = s[t + 1] << 1,
                        c = s[t + 2] << 1,
                        f = a[d],
                        m = a[d + 1],
                        g = a[u],
                        p = a[u + 1],
                        w = a[c],
                        x = a[c + 1],
                        M = !1;
                    if (o == d) {
                        let t = l.length - 4,
                            s = e.winding(l[t], l[t + 1], l[t + 2], l[t + 3], w, x),
                            a = e.winding(w, x, l[0], l[1], l[2], l[3]);
                        s == h && a == h && (l.push(w), l.push(x), r.push(c), M = !0)
                    }
                    M || (l.length > 0 ? (n.push(l), i.push(r)) : (this.polygonPool.free(l), this.polygonIndicesPool.free(r)), l = this.polygonPool.obtain(), l.length = 0, l.push(f), l.push(m), l.push(g), l.push(p), l.push(w), l.push(x), r = this.polygonIndicesPool.obtain(), r.length = 0, r.push(d), r.push(u), r.push(c), h = e.winding(f, m, g, p, w, x), o = d)
                }
                l.length > 0 && (n.push(l), i.push(r));
                for (let t = 0, s = n.length; t < s; t++) {
                    if (r = i[t], 0 == r.length) continue;
                    let a = r[0],
                        o = r[r.length - 1];
                    l = n[t];
                    let h = l.length - 4,
                        d = l[h],
                        u = l[h + 1],
                        c = l[h + 2],
                        f = l[h + 3],
                        m = l[0],
                        g = l[1],
                        p = l[2],
                        w = l[3],
                        x = e.winding(d, u, c, f, m, g);
                    for (let h = 0; h < s; h++) {
                        if (h == t) continue;
                        let s = i[h];
                        if (3 != s.length) continue;
                        let M = s[0],
                            E = s[1],
                            T = s[2],
                            A = n[h],
                            b = A[A.length - 2],
                            S = A[A.length - 1];
                        if (M != a || E != o) continue;
                        let y = e.winding(d, u, c, f, b, S),
                            I = e.winding(b, S, m, g, p, w);
                        y == x && I == x && (A.length = 0, s.length = 0, l.push(b), l.push(S), r.push(T), d = c, u = f, c = b, f = S, h = 0)
                    }
                }
                for (let t = n.length - 1; t >= 0; t--) l = n[t], 0 == l.length && (n.splice(t, 1), this.polygonPool.free(l), r = i[t], i.splice(t, 1), this.polygonIndicesPool.free(r));
                return n
            }
            static isConcave(t, e, s, a) {
                let n = a[(e + t - 1) % e] << 1,
                    i = a[t] << 1,
                    r = a[(t + 1) % e] << 1;
                return !this.positiveArea(s[n], s[n + 1], s[i], s[i + 1], s[r], s[r + 1])
            }
            static positiveArea(t, e, s, a, n, i) {
                return t * (i - a) + s * (e - i) + n * (a - e) >= 0
            }
            static winding(t, e, s, a, n, i) {
                let r = s - t,
                    l = a - e;
                return n * l - i * r + r * e - t * l >= 0 ? 1 : -1
            }
        }
        t.Triangulator = e
    }(spine || (spine = {})),
    function(t) {
        class e {
            constructor() {
                this.array = new Array
            }
            add(t) {
                let e = this.contains(t);
                return this.array[0 | t] = 0 | t, !e
            }
            contains(t) {
                return null != this.array[0 | t]
            }
            remove(t) {
                this.array[0 | t] = void 0
            }
            clear() {
                this.array.length = 0
            }
        }
        t.IntSet = e;
        class s {
            constructor(t = 0, e = 0, s = 0, a = 0) {
                this.r = t, this.g = e, this.b = s, this.a = a
            }
            set(t, e, s, a) {
                return this.r = t, this.g = e, this.b = s, this.a = a, this.clamp(), this
            }
            setFromColor(t) {
                return this.r = t.r, this.g = t.g, this.b = t.b, this.a = t.a, this
            }
            setFromString(t) {
                return t = "#" == t.charAt(0) ? t.substr(1) : t, this.r = parseInt(t.substr(0, 2), 16) / 255, this.g = parseInt(t.substr(2, 2), 16) / 255, this.b = parseInt(t.substr(4, 2), 16) / 255, this.a = (8 != t.length ? 255 : parseInt(t.substr(6, 2), 16)) / 255, this
            }
            add(t, e, s, a) {
                return this.r += t, this.g += e, this.b += s, this.a += a, this.clamp(), this
            }
            clamp() {
                return this.r < 0 ? this.r = 0 : this.r > 1 && (this.r = 1), this.g < 0 ? this.g = 0 : this.g > 1 && (this.g = 1), this.b < 0 ? this.b = 0 : this.b > 1 && (this.b = 1), this.a < 0 ? this.a = 0 : this.a > 1 && (this.a = 1), this
            }
            static rgba8888ToColor(t, e) {
                t.r = ((4278190080 & e) >>> 24) / 255, t.g = ((16711680 & e) >>> 16) / 255, t.b = ((65280 & e) >>> 8) / 255, t.a = (255 & e) / 255
            }
            static rgb888ToColor(t, e) {
                t.r = ((16711680 & e) >>> 16) / 255, t.g = ((65280 & e) >>> 8) / 255, t.b = (255 & e) / 255
            }
        }
        s.WHITE = new s(1, 1, 1, 1), s.RED = new s(1, 0, 0, 1), s.GREEN = new s(0, 1, 0, 1), s.BLUE = new s(0, 0, 1, 1), s.MAGENTA = new s(1, 0, 1, 1), t.Color = s;
        class a {
            static clamp(t, e, s) {
                return t < e ? e : t > s ? s : t
            }
            static cosDeg(t) {
                return Math.cos(t * a.degRad)
            }
            static sinDeg(t) {
                return Math.sin(t * a.degRad)
            }
            static signum(t) {
                return t > 0 ? 1 : t < 0 ? -1 : 0
            }
            static toInt(t) {
                return t > 0 ? Math.floor(t) : Math.ceil(t)
            }
            static cbrt(t) {
                let e = Math.pow(Math.abs(t), 1 / 3);
                return t < 0 ? -e : e
            }
            static randomTriangular(t, e) {
                return a.randomTriangularWith(t, e, .5 * (t + e))
            }
            static randomTriangularWith(t, e, s) {
                let a = Math.random(),
                    n = e - t;
                return a <= (s - t) / n ? t + Math.sqrt(a * n * (s - t)) : e - Math.sqrt((1 - a) * n * (e - s))
            }
        }
        a.PI = 3.1415927, a.PI2 = 2 * a.PI, a.radiansToDegrees = 180 / a.PI, a.radDeg = a.radiansToDegrees, a.degreesToRadians = a.PI / 180, a.degRad = a.degreesToRadians, t.MathUtils = a;
        class n {
            apply(t, e, s) {
                return t + (e - t) * this.applyInternal(s)
            }
        }
        t.Interpolation = n;
        class i extends n {
            constructor(t) {
                super(), this.power = 2, this.power = t
            }
            applyInternal(t) {
                return t <= .5 ? Math.pow(2 * t, this.power) / 2 : Math.pow(2 * (t - 1), this.power) / (this.power % 2 == 0 ? -2 : 2) + 1
            }
        }
        t.Pow = i;
        class r extends i {
            constructor(t) {
                super(t)
            }
            applyInternal(t) {
                return Math.pow(t - 1, this.power) * (this.power % 2 == 0 ? -1 : 1) + 1
            }
        }
        t.PowOut = r;
        class l {
            static arrayCopy(t, e, s, a, n) {
                for (let i = e, r = a; i < e + n; i++, r++) s[r] = t[i]
            }
            static setArraySize(t, e, s = 0) {
                let a = t.length;
                if (a == e) return t;
                if (t.length = e, a < e)
                    for (let n = a; n < e; n++) t[n] = s;
                return t
            }
            static ensureArrayCapacity(t, e, s = 0) {
                return t.length >= e ? t : l.setArraySize(t, e, s)
            }
            static newArray(t, e) {
                let s = new Array(t);
                for (let a = 0; a < t; a++) s[a] = e;
                return s
            }
            static newFloatArray(t) {
                if (l.SUPPORTS_TYPED_ARRAYS) return new Float32Array(t); {
                    let e = new Array(t);
                    for (let t = 0; t < e.length; t++) e[t] = 0;
                    return e
                }
            }
            static newShortArray(t) {
                if (l.SUPPORTS_TYPED_ARRAYS) return new Int16Array(t); {
                    let e = new Array(t);
                    for (let t = 0; t < e.length; t++) e[t] = 0;
                    return e
                }
            }
            static toFloatArray(t) {
                return l.SUPPORTS_TYPED_ARRAYS ? new Float32Array(t) : t
            }
            static toSinglePrecision(t) {
                return l.SUPPORTS_TYPED_ARRAYS ? Math.fround(t) : t
            }
            static webkit602BugfixHelper(t, e) {}
            static contains(t, e, s = !0) {
                for (var a = 0; a < t.length; a++)
                    if (t[a] == e) return !0;
                return !1
            }
        }
        l.SUPPORTS_TYPED_ARRAYS = "undefined" != typeof Float32Array, t.Utils = l;
        class o {
            static logBones(t) {
                for (let e = 0; e < t.bones.length; e++) {
                    let s = t.bones[e];
                    console.log(s.data.name + ", " + s.a + ", " + s.b + ", " + s.c + ", " + s.d + ", " + s.worldX + ", " + s.worldY)
                }
            }
        }
        t.DebugUtils = o;
        class h {
            constructor(t) {
                this.items = new Array, this.instantiator = t
            }
            obtain() {
                return this.items.length > 0 ? this.items.pop() : this.instantiator()
            }
            free(t) {
                t.reset && t.reset(), this.items.push(t)
            }
            freeAll(t) {
                for (let e = 0; e < t.length; e++) this.free(t[e])
            }
            clear() {
                this.items.length = 0
            }
        }
        t.Pool = h;
        class d {
            constructor(t = 0, e = 0) {
                this.x = t, this.y = e
            }
            set(t, e) {
                return this.x = t, this.y = e, this
            }
            length() {
                let t = this.x,
                    e = this.y;
                return Math.sqrt(t * t + e * e)
            }
            normalize() {
                let t = this.length();
                return 0 != t && (this.x /= t, this.y /= t), this
            }
        }
        t.Vector2 = d;
        class u {
            constructor() {
                this.maxDelta = .064, this.framesPerSecond = 0, this.delta = 0, this.totalTime = 0, this.lastTime = Date.now() / 1e3, this.frameCount = 0, this.frameTime = 0
            }
            update() {
                let t = Date.now() / 1e3;
                this.delta = t - this.lastTime, this.delta = this.delta * u.sSpeed, this.frameTime += this.delta, this.totalTime += this.delta, this.delta > this.maxDelta && (this.delta = this.maxDelta), this.lastTime = t, this.frameCount++, this.frameTime > 1 && (this.framesPerSecond = this.frameCount / this.frameTime, this.frameTime = 0, this.frameCount = 0)
            }
        }
        u.sSpeed = 1, t.TimeKeeper = u;
        class c {
            constructor(t = 32) {
                this.addedValues = 0, this.lastValue = 0, this.mean = 0, this.dirty = !0, this.values = new Array(t)
            }
            hasEnoughData() {
                return this.addedValues >= this.values.length
            }
            addValue(t) {
                this.addedValues < this.values.length && this.addedValues++, this.values[this.lastValue++] = t, this.lastValue > this.values.length - 1 && (this.lastValue = 0), this.dirty = !0
            }
            getMean() {
                if (this.hasEnoughData()) {
                    if (this.dirty) {
                        let t = 0;
                        for (let e = 0; e < this.values.length; e++) t += this.values[e];
                        this.mean = t / this.values.length, this.dirty = !1
                    }
                    return this.mean
                }
                return 0
            }
        }
        t.WindowedMean = c
    }(spine || (spine = {})), Math.fround || (Math.fround = function(t) {
            return function(e) {
                return t[0] = e, t[0]
            }
        }(new Float32Array(1))),
        function(t) {
            class e {
                constructor(t) {
                    if (null == t) throw new Error("name cannot be null.");
                    this.name = t
                }
            }
            t.Attachment = e;
            class s extends e {
                constructor(t) {
                    super(t), this.id = (65535 & s.nextID++) << 11, this.worldVerticesLength = 0, this.deformAttachment = this
                }
                computeWorldVertices(t, e, s, a, n, i) {
                    s = n + (s >> 1) * i;
                    let r = t.bone.skeleton,
                        l = t.deform,
                        o = this.vertices,
                        h = this.bones;
                    if (null == h) {
                        l.length > 0 && (o = l);
                        let r = t.bone,
                            h = r.worldX,
                            d = r.worldY,
                            u = r.a,
                            c = r.b,
                            f = r.c,
                            m = r.d;
                        for (let t = e, r = n; r < s; t += 2, r += i) {
                            let e = o[t],
                                s = o[t + 1];
                            a[r] = e * u + s * c + h, a[r + 1] = e * f + s * m + d
                        }
                        return
                    }
                    let d = 0,
                        u = 0;
                    for (let t = 0; t < e; t += 2) {
                        let t = h[d];
                        d += t + 1, u += t
                    }
                    let c = r.bones;
                    if (0 == l.length)
                        for (let t = n, e = 3 * u; t < s; t += i) {
                            let s = 0,
                                n = 0,
                                i = h[d++];
                            for (i += d; d < i; d++, e += 3) {
                                let t = c[h[d]],
                                    a = o[e],
                                    i = o[e + 1],
                                    r = o[e + 2];
                                s += (a * t.a + i * t.b + t.worldX) * r, n += (a * t.c + i * t.d + t.worldY) * r
                            }
                            a[t] = s, a[t + 1] = n
                        } else {
                            let t = l;
                            for (let e = n, r = 3 * u, l = u << 1; e < s; e += i) {
                                let s = 0,
                                    n = 0,
                                    i = h[d++];
                                for (i += d; d < i; d++, r += 3, l += 2) {
                                    let e = c[h[d]],
                                        a = o[r] + t[l],
                                        i = o[r + 1] + t[l + 1],
                                        u = o[r + 2];
                                    s += (a * e.a + i * e.b + e.worldX) * u, n += (a * e.c + i * e.d + e.worldY) * u
                                }
                                a[e] = s, a[e + 1] = n
                            }
                        }
                }
                copyTo(e) {
                    null != this.bones ? (e.bones = new Array(this.bones.length), t.Utils.arrayCopy(this.bones, 0, e.bones, 0, this.bones.length)) : e.bones = null, null != this.vertices ? (e.vertices = t.Utils.newFloatArray(this.vertices.length), t.Utils.arrayCopy(this.vertices, 0, e.vertices, 0, this.vertices.length)) : e.vertices = null, e.worldVerticesLength = this.worldVerticesLength, e.deformAttachment = this.deformAttachment
                }
            }
            s.nextID = 0, t.VertexAttachment = s
        }(spine || (spine = {})),
        function(t) {
            let e;
            (function(t) {
                t[t.Region = 0] = "Region", t[t.BoundingBox = 1] = "BoundingBox", t[t.Mesh = 2] = "Mesh", t[t.LinkedMesh = 3] = "LinkedMesh", t[t.Path = 4] = "Path", t[t.Point = 5] = "Point", t[t.Clipping = 6] = "Clipping"
            })(e = t.AttachmentType || (t.AttachmentType = {}))
        }(spine || (spine = {})),
        function(t) {
            class e extends t.VertexAttachment {
                constructor(e) {
                    super(e), this.color = new t.Color(1, 1, 1, 1)
                }
                copy() {
                    let t = new e(this.name);
                    return this.copyTo(t), t.color.setFromColor(this.color), t
                }
            }
            t.BoundingBoxAttachment = e
        }(spine || (spine = {})),
        function(t) {
            class e extends t.VertexAttachment {
                constructor(e) {
                    super(e), this.color = new t.Color(.2275, .2275, .8078, 1)
                }
                copy() {
                    let t = new e(this.name);
                    return this.copyTo(t), t.endSlot = this.endSlot, t.color.setFromColor(this.color), t
                }
            }
            t.ClippingAttachment = e
        }(spine || (spine = {})),
        function(t) {
            class e extends t.VertexAttachment {
                constructor(e) {
                    super(e), this.color = new t.Color(1, 1, 1, 1), this.tempColor = new t.Color(0, 0, 0, 0)
                }
                updateUVs() {
                    let e = this.regionUVs;
                    null != this.uvs && this.uvs.length == e.length || (this.uvs = t.Utils.newFloatArray(e.length));
                    let s = this.uvs,
                        a = this.uvs.length,
                        n = this.region.u,
                        i = this.region.v,
                        r = 0,
                        l = 0;
                    if (this.region instanceof t.TextureAtlasRegion) {
                        let t = this.region,
                            o = t.texture.getImage().width,
                            h = t.texture.getImage().height;
                        switch (t.degrees) {
                            case 90:
                                n -= (t.originalHeight - t.offsetY - t.height) / o, i -= (t.originalWidth - t.offsetX - t.width) / h, r = t.originalHeight / o, l = t.originalWidth / h;
                                for (let t = 0; t < a; t += 2) s[t] = n + e[t + 1] * r, s[t + 1] = i + (1 - e[t]) * l;
                                return;
                            case 180:
                                n -= (t.originalWidth - t.offsetX - t.width) / o, i -= t.offsetY / h, r = t.originalWidth / o, l = t.originalHeight / h;
                                for (let t = 0; t < a; t += 2) s[t] = n + (1 - e[t]) * r, s[t + 1] = i + (1 - e[t + 1]) * l;
                                return;
                            case 270:
                                n -= t.offsetY / o, i -= t.offsetX / h, r = t.originalHeight / o, l = t.originalWidth / h;
                                for (let t = 0; t < a; t += 2) s[t] = n + (1 - e[t + 1]) * r, s[t + 1] = i + e[t] * l;
                                return
                        }
                        n -= t.offsetX / o, i -= (t.originalHeight - t.offsetY - t.height) / h, r = t.originalWidth / o, l = t.originalHeight / h
                    } else null == this.region ? (n = i = 0, r = l = 1) : (r = this.region.u2 - n, l = this.region.v2 - i);
                    for (let t = 0; t < a; t += 2) s[t] = n + e[t] * r, s[t + 1] = i + e[t + 1] * l
                }
                getParentMesh() {
                    return this.parentMesh
                }
                setParentMesh(t) {
                    this.parentMesh = t, null != t && (this.bones = t.bones, this.vertices = t.vertices, this.worldVerticesLength = t.worldVerticesLength, this.regionUVs = t.regionUVs, this.triangles = t.triangles, this.hullLength = t.hullLength, this.worldVerticesLength = t.worldVerticesLength)
                }
                copy() {
                    if (null != this.parentMesh) return this.newLinkedMesh();
                    let s = new e(this.name);
                    return s.region = this.region, s.path = this.path, s.color.setFromColor(this.color), this.copyTo(s), s.regionUVs = new Array(this.regionUVs.length), t.Utils.arrayCopy(this.regionUVs, 0, s.regionUVs, 0, this.regionUVs.length), s.uvs = new Array(this.uvs.length), t.Utils.arrayCopy(this.uvs, 0, s.uvs, 0, this.uvs.length), s.triangles = new Array(this.triangles.length), t.Utils.arrayCopy(this.triangles, 0, s.triangles, 0, this.triangles.length), s.hullLength = this.hullLength, null != this.edges && (s.edges = new Array(this.edges.length), t.Utils.arrayCopy(this.edges, 0, s.edges, 0, this.edges.length)), s.width = this.width, s.height = this.height, s
                }
                newLinkedMesh() {
                    let t = new e(this.name);
                    return t.region = this.region, t.path = this.path, t.color.setFromColor(this.color), t.deformAttachment = this.deformAttachment, t.setParentMesh(null != this.parentMesh ? this.parentMesh : this), t.updateUVs(), t
                }
            }
            t.MeshAttachment = e
        }(spine || (spine = {})),
        function(t) {
            class e extends t.VertexAttachment {
                constructor(e) {
                    super(e), this.closed = !1, this.constantSpeed = !1, this.color = new t.Color(1, 1, 1, 1)
                }
                copy() {
                    let s = new e(this.name);
                    return this.copyTo(s), s.lengths = new Array(this.lengths.length), t.Utils.arrayCopy(this.lengths, 0, s.lengths, 0, this.lengths.length), s.closed = closed, s.constantSpeed = this.constantSpeed, s.color.setFromColor(this.color), s
                }
            }
            t.PathAttachment = e
        }(spine || (spine = {})),
        function(t) {
            class e extends t.VertexAttachment {
                constructor(e) {
                    super(e), this.color = new t.Color(.38, .94, 0, 1)
                }
                computeWorldPosition(t, e) {
                    return e.x = this.x * t.a + this.y * t.b + t.worldX, e.y = this.x * t.c + this.y * t.d + t.worldY, e
                }
                computeWorldRotation(e) {
                    let s = t.MathUtils.cosDeg(this.rotation),
                        a = t.MathUtils.sinDeg(this.rotation),
                        n = s * e.a + a * e.b,
                        i = s * e.c + a * e.d;
                    return Math.atan2(i, n) * t.MathUtils.radDeg
                }
                copy() {
                    let t = new e(this.name);
                    return t.x = this.x, t.y = this.y, t.rotation = this.rotation, t.color.setFromColor(this.color), t
                }
            }
            t.PointAttachment = e
        }(spine || (spine = {})),
        function(t) {
            class e extends t.Attachment {
                constructor(e) {
                    super(e), this.x = 0, this.y = 0, this.scaleX = 1, this.scaleY = 1, this.rotation = 0, this.width = 0, this.height = 0, this.color = new t.Color(1, 1, 1, 1), this.offset = t.Utils.newFloatArray(8), this.uvs = t.Utils.newFloatArray(8), this.tempColor = new t.Color(1, 1, 1, 1)
                }
                updateOffset() {
                    let t = this.width / this.region.originalWidth * this.scaleX,
                        s = this.height / this.region.originalHeight * this.scaleY,
                        a = -this.width / 2 * this.scaleX + this.region.offsetX * t,
                        n = -this.height / 2 * this.scaleY + this.region.offsetY * s,
                        i = a + this.region.width * t,
                        r = n + this.region.height * s,
                        l = this.rotation * Math.PI / 180,
                        o = Math.cos(l),
                        h = Math.sin(l),
                        d = a * o + this.x,
                        u = a * h,
                        c = n * o + this.y,
                        f = n * h,
                        m = i * o + this.x,
                        g = i * h,
                        p = r * o + this.y,
                        w = r * h,
                        x = this.offset;
                    x[e.OX1] = d - f, x[e.OY1] = c + u, x[e.OX2] = d - w, x[e.OY2] = p + u, x[e.OX3] = m - w, x[e.OY3] = p + g, x[e.OX4] = m - f, x[e.OY4] = c + g
                }
                setRegion(t) {
                    this.region = t;
                    let e = this.uvs;
                    t.rotate ? (e[2] = t.u, e[3] = t.v2, e[4] = t.u, e[5] = t.v, e[6] = t.u2, e[7] = t.v, e[0] = t.u2, e[1] = t.v2) : (e[0] = t.u, e[1] = t.v2, e[2] = t.u, e[3] = t.v, e[4] = t.u2, e[5] = t.v, e[6] = t.u2, e[7] = t.v2)
                }
                computeWorldVertices(t, s, a, n) {
                    let i = this.offset,
                        r = t.worldX,
                        l = t.worldY,
                        o = t.a,
                        h = t.b,
                        d = t.c,
                        u = t.d,
                        c = 0,
                        f = 0;
                    c = i[e.OX1], f = i[e.OY1], s[a] = c * o + f * h + r, s[a + 1] = c * d + f * u + l, a += n, c = i[e.OX2], f = i[e.OY2], s[a] = c * o + f * h + r, s[a + 1] = c * d + f * u + l, a += n, c = i[e.OX3], f = i[e.OY3], s[a] = c * o + f * h + r, s[a + 1] = c * d + f * u + l, a += n, c = i[e.OX4], f = i[e.OY4], s[a] = c * o + f * h + r, s[a + 1] = c * d + f * u + l
                }
                copy() {
                    let s = new e(this.name);
                    return s.region = this.region, s.rendererObject = this.rendererObject, s.path = this.path, s.x = this.x, s.y = this.y, s.scaleX = this.scaleX, s.scaleY = this.scaleY, s.rotation = this.rotation, s.width = this.width, s.height = this.height, t.Utils.arrayCopy(this.uvs, 0, s.uvs, 0, 8), t.Utils.arrayCopy(this.offset, 0, s.offset, 0, 8), s.color.setFromColor(this.color), s
                }
            }
            e.OX1 = 0, e.OY1 = 1, e.OX2 = 2, e.OY2 = 3, e.OX3 = 4, e.OY3 = 5, e.OX4 = 6, e.OY4 = 7, e.X1 = 0, e.Y1 = 1, e.C1R = 2, e.C1G = 3, e.C1B = 4, e.C1A = 5, e.U1 = 6, e.V1 = 7, e.X2 = 8, e.Y2 = 9, e.C2R = 10, e.C2G = 11, e.C2B = 12, e.C2A = 13, e.U2 = 14, e.V2 = 15, e.X3 = 16, e.Y3 = 17, e.C3R = 18, e.C3G = 19, e.C3B = 20, e.C3A = 21, e.U3 = 22, e.V3 = 23, e.X4 = 24, e.Y4 = 25, e.C4R = 26, e.C4G = 27, e.C4B = 28, e.C4A = 29, e.U4 = 30, e.V4 = 31, t.RegionAttachment = e
        }(spine || (spine = {})),
        function(t) {
            class e {
                constructor(t, e) {
                    this.jitterX = 0, this.jitterY = 0, this.jitterX = t, this.jitterY = e
                }
                begin(t) {}
                transform(e, s, a, n) {
                    e.x += t.MathUtils.randomTriangular(-this.jitterX, this.jitterY), e.y += t.MathUtils.randomTriangular(-this.jitterX, this.jitterY)
                }
                end() {}
            }
            t.JitterEffect = e
        }(spine || (spine = {})),
        function(t) {
            class e {
                constructor(t) {
                    this.centerX = 0, this.centerY = 0, this.radius = 0, this.angle = 0, this.worldX = 0, this.worldY = 0, this.radius = t
                }
                begin(t) {
                    this.worldX = t.x + this.centerX, this.worldY = t.y + this.centerY
                }
                transform(s, a, n, i) {
                    let r = this.angle * t.MathUtils.degreesToRadians,
                        l = s.x - this.worldX,
                        o = s.y - this.worldY,
                        h = Math.sqrt(l * l + o * o);
                    if (h < this.radius) {
                        let t = e.interpolation.apply(0, r, (this.radius - h) / this.radius),
                            a = Math.cos(t),
                            n = Math.sin(t);
                        s.x = a * l - n * o + this.worldX, s.y = n * l + a * o + this.worldY
                    }
                }
                end() {}
            }
            e.interpolation = new t.PowOut(2), t.SwirlEffect = e
        }(spine || (spine = {})), window.spine = spine;
});
var global = (function() {
    return this
})();
if (!global && typeof GameGlobal !== 'undefined') global = GameGlobal;
var pluginInfoMap = {};;
global.requirePlugin = global.requirePlugin || function(path) {
    var position = path.indexOf('/');
    var alias = '';
    var pagePath = '';
    if (position !== -1) {
        alias = path.substr(0, position);
        pagePath = path.substr(position + 1, path.length);
    } else {
        alias = path;
    }
    if (pluginInfoMap.hasOwnProperty(alias)) {
        var realPath = '';
        if (pagePath.length === 0) {
            realPath = '__plugin__/' + pluginInfoMap[alias].appid;
            return require(realPath);
        } else {
            realPath = '__plugin__/' + pluginInfoMap[alias].appid + '/' + pagePath;
            return require(realPath);
        }
    } else {
        console.error('not found alias: ', alias);
        throw new Error('Plugin ' + alias + ' is not defined.')
    }
};
define("libs/game.js", function(require, module, exports) {

});
require("libs/game.js");